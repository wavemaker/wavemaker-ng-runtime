{"version":3,"file":"pagination.utils.js","sourceRoot":"./","sources":["src/util/variable/pagination.utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { jmespath } from '@metrichor/jmespath';\n\n// declare const _: any;\nimport _ from 'lodash';\n\nexport class PaginationUtils {\n    /**\n     * Modifies the query values with the pagination info which is retrieved from the previous API response.\n     * @param variable withholds variable information \n     * @param operationInfo has metadata of the variable \n     * @param paginationInfo has metadata of the variable pagination data\n     * @returns {void} This method does not return anything\n     */\n    static setPaginationQueryParams(variable, operationInfo, paginationInfo) {\n        operationInfo.parameters.forEach(element => {\n            // pagination input information varies based on the type\n            let inputParam;\n            if (paginationInfo.type === 'offset' || paginationInfo.input.offset) {\n                inputParam = 'offset';\n            } else {\n                inputParam = 'page';\n            }\n            // modifies query values based on the pagination of variable\n            // compare parameter name with the input parameter's starting naming key (ex: channelcontext in channelcontext.pagination)\n            if (element.name === paginationInfo.input[inputParam].split('.')[0]) {\n                element.sampleValue = variable.pagination['page'];\n            } else if (element.name === paginationInfo.input.size.split('.')[0]) {\n                element.sampleValue = variable.pagination['size'];\n            }\n        });\n    }\n\n    /**\n     * Sets pagination on the variable based on the response of the triggered api call.\n     * @param variable withholds variable information \n     * @param response has data of the api call's response\n     * @param options has info of the api's query params\n     * @returns {void} This method does not return anything\n     */\n    static setVariablePagination(variable, response, options) {\n        if (!variable.pagination) {\n            variable.pagination = {\n                empty: false\n            };\n        }\n        variable.pagination['size'] = response.size;\n        variable.pagination['page'] =  response.page || 0;\n        variable.pagination['totalElements'] = response.totalElements;\n        variable.pagination['numberOfElements'] = variable.pagination['size'];\n        variable.pagination['number'] =  options['page'] ? options['page'] - 1 : 0;\n        \n        /**\n         * Deduce totalPages from totalElements by size.\n         * If the total elements are evenly split among the pages, assign the same to totalPages\n         * Else assign totalPages + 1\n         */\n        variable.pagination['totalPages'] =  variable.pagination['totalElements'] / variable.pagination['size'];\n        if (variable.pagination['totalElements'] % variable.pagination['size'] === 0) {\n            variable.pagination['totalPages'] = parseInt(variable.pagination['totalPages']);\n        } else {\n            variable.pagination['totalPages'] = parseInt(variable.pagination['totalPages']) + 1;\n        }\n\n        // If pagination type is cursor, fill next & prev\n        if (response.next) {\n            variable.pagination['next'] = response.next;\n            variable.pagination['prev'] = response.prev;\n            variable.pagination['last'] = response.next ? false : true;\n            variable.pagination['first'] = response.prev ? false : true;\n        } else {\n            variable.pagination['first'] = variable.pagination['page'] <= 1 ? true : false;\n            // calculate last based on current page index against total pages\n            variable.pagination['last'] = response.hasMoreItems === '' ? !(variable.pagination['page'] < variable.pagination['totalPages']) : !response.hasMoreItems;\n        }\n    }\n\n    /**\n     * Resolves the expression given in pagination metadata's output\n     * @param item has value of each key which is inside output pagination metadata\n     * @param response has data of the api call's response\n     * @param resHeaders has data of the api call's response headers\n     * @param res holds the information of pagination which has to be stored on the variable\n     * @param key has key name against which data has to be stored in pagination \n     * @returns {void} This method does not return anything\n     */\n    static setPaginationItems(item, response, res, key, resHeaders) {\n        // if the item has body, resolve the expression against the response\n        if (_.startsWith(item, '$body')) {\n            const bodyKey = item.replace('$body.', '');\n            try {\n                res[key] = jmespath.search(response, bodyKey);\n            } catch {\n                console.warn(`${item} expression needs to be corrected as per JMES guidelines`);\n            }\n        } else if (_.startsWith(item, '$header')) { // if the item has header, resolve the expression against the response headers \n            const headerKey = item.replace('$header.', '');\n            const headers =  (<any>Object).fromEntries(resHeaders.headers);\n            const headerParams = headerKey.split('.');\n            try {\n                res[key] = jmespath.search(headers, headerParams[0].toLowerCase());\n            } catch {\n                console.warn(`${item} expression needs to be corrected as per JMES guidelines`);\n            }\n            if (res[key]?.length) { \n                let headerVal = res[key].join();\n                if (headerParams.length === 1) { \n                    /**\n                     * If the headerParams has only 1 key (which is not an object) name assing headerVal to the res[key]\n                     */\n                    res[key] = headerVal;\n                } else { \n                    /**\n                     * If the headerParams has more than 1 key (an object), parse the stringified headerVal which is an object\n                     * Resolve the expression against headerVal object amd assign it to res[key]\n                     */\n                    let keyName = headerParams.slice(1).join('.');\n                    const headerResp = JSON.parse(headerVal);\n                    const specialChar = /[!@#$%^&*()+\\=\\[\\]{};':\"\\\\|,<>\\/?]+/;\n                    if (specialChar.test(keyName)) {\n                        // If key name has expression (ex: comparission expression) \n                        // add root key name to keyName for JMES to resolve the expression\n                        keyName = 'headerResp.' + keyName;\n                    }\n                    try {\n                        res[key] = jmespath.search(headerResp, keyName);\n                    } catch {\n                        console.warn(`${item} expression needs to be corrected as per JMES guidelines`);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Return the pagination information of the service based on its existence on swagger or on the variable\n     * @param variable withholds variable information \n     * @param operationInfo has metadata of the variable \n     * @returns {object} This method return pagination metadata\n     */\n    static getPaginationInfo(operationInfo, variable) {\n        if (operationInfo?.paginationInfo) {\n            return operationInfo.paginationInfo;\n        } else {\n            return variable._paginationConfig;\n        }\n    }\n\n    /**\n     * Set query params with the pagination info, if pagination metadata is present in query params\n     * @param variable withholds variable information \n     * @param operationInfo has metadata of the variable \n     * @param options has info of the api's query params\n     * @returns {void} This method does not return anything\n     */\n    static checkPaginationAtQuery(operationInfo, variable, options) {        \n        const paginationInfo = this.getPaginationInfo(operationInfo, variable);\n        // If page is not first, pagination is present on the variable and paginationInfo's input meta has size set pagination in query params\n        const hasPagination = options && options['page'] && paginationInfo?.input.size && variable.pagination;    \n        if (!hasPagination) {\n            return;\n        }\n\n        let inputParam;\n        // if pagination type is offset, asssign inputParam to offset else page\n        if (paginationInfo.type === 'offset' || paginationInfo.input.offset) {\n            inputParam = 'offset';\n        } else {\n            inputParam = 'page';\n        }\n        const paramName = paginationInfo.input[inputParam].split('.')[0]; \n        const paramObj = _.find(operationInfo.parameters, function(obj) { return obj.name === paramName });   \n        // check if the variable has query params and they are not empty\n        if (!_.isEmpty(variable.dataBinding) && paramObj && paramObj.parameterType === 'query') {\n            /**\n             * For pagination type other than offset, assign page which is recieved from options\n             * For offset type, calculate page from size and options[page]\n             */\n            if (!paginationInfo.output?.page && paginationInfo.type !== 'offset') {\n                variable.pagination['page'] = options['page'];\n            } else {\n                variable.pagination['page'] = this.getOffsetInfo(variable, options);\n            }\n            this.setPaginationQueryParams(variable, operationInfo, paginationInfo);  \n        }\n    }\n\n    /**\n     * Deduces the offset information from the size and page params\n     * @param variable withholds variable information \n     * @param options has info of the api's query params\n     * @returns {object} Returns the next offset number\n     */\n    static getOffsetInfo(variable, options) {\n        return variable.pagination['size'] * (options['page'] ? (options['page'] - 1) : 1);\n    }\n\n    /**\n     * Sets Pagination data on the request information\n     * @param variable withholds variable information \n     * @param operationInfo has metadata of the variable \n     * @param options has info of the api's query params\n     * @param paginationInfo has pagination information of the variable\n     * @param headers has request headers\n     * @param requestBody has request body\n     * @param url has request url\n     * @returns {object} Returns the request object which has pagination info\n     */\n    static setPaginationAtReq(paginationInfo, operationInfo, variable, headers, requestBody, url, options) {\n        let reqObj = {};\n        let inputParam;\n        let resObj = {};\n        // pagination input information varies based on the type\n        if (paginationInfo.type === 'offset' || paginationInfo.input.offset) {\n            inputParam = 'offset';\n        } else {\n            inputParam = 'page';\n        }\n        const paramName = paginationInfo.input[inputParam].split('.')[0]; \n        // check if paramName is present in parameters of operation info \n        const paramObj = _.find(operationInfo.parameters, function(obj) { return obj.name === paramName }); \n        // set page/offset and size from pagination if matched parameter's type is header  \n        if (paramObj?.parameterType === 'header') {\n            _.set(reqObj, paginationInfo.input[inputParam], variable.pagination['page']);\n            _.set(reqObj, paginationInfo.input.size, variable.pagination['size']);\n            headers[paramName] = JSON.stringify(reqObj[paramName]);\n            resObj['headers'] = headers;\n        } else if (paramObj?.parameterType === 'body') { \n            // set page/offset and size from pagination if matched parameter's type is body \n            // assign bodyVal to updated pagination info object\n            const bodyVal = JSON.parse(paramObj.sampleValue);\n            const bodyParam = paginationInfo.input[inputParam].split('.')[1]\n            if (bodyVal && bodyVal[bodyParam]) {\n                const inputBodyParam = paginationInfo.input[inputParam].split('.').splice(1).join('.');               \n                if (inputParam !== 'offset') { \n                    _.set(reqObj, inputBodyParam, variable.pagination['page']);\n                } else {\n                    _.set(reqObj, inputBodyParam, this.getOffsetInfo(variable, options));\n                }\n                _.set(reqObj, paginationInfo.input.size.split('.').splice(1).join('.'), variable.pagination['size']);\n                bodyVal[bodyParam] =  reqObj[bodyParam];\n                requestBody = JSON.stringify(bodyVal);\n                resObj['requestBody'] = requestBody;\n            }\n        } else if (variable.pagination.next && paramObj) {\n            /**\n             * For cursor type pagination, if pagination info is present in the path \n             * Based on whether user clicks on the next or prev button modify the url \n             */\n            \n            if (paramObj.parameterType === 'path') {\n                const urlParams = operationInfo.relativePath.split('/'),\n                paramConfig = '{' + paramObj.name + '}',\n                paramIndex = urlParams.indexOf(paramConfig);\n                let invokeUrl;\n                if (variable.pagination.isNext) {\n                    invokeUrl = variable.pagination.next.split('/');\n                } else {\n                    invokeUrl = variable.pagination.prev.split('/');\n                }\n\n                let urlPathParmas;\n                let urlPath;\n                if (operationInfo.directPath) { // For direct path, as url has hostname, derivate pathname using URL object\n                    urlPath = new URL(url);\n                    urlPathParmas = urlPath.pathname.split('/');\n                    urlPathParmas[paramIndex] = invokeUrl[paramIndex];\n                    urlPath.pathname = urlPathParmas.join('/');\n                    url = urlPath.href;\n                    resObj['url'] = url;\n                } else { // Else modify the url with index as +1 (following proxy pattern)\n                    urlPathParmas = url.split('/');\n                    urlPathParmas[paramIndex + 1] = invokeUrl[paramIndex];\n                    url = urlPathParmas.join('/');\n                    resObj['url'] = url;\n                }\n\n            } else if (paramObj.parameterType === 'query') {\n            /**\n             * For cursor type pagination, if pagination info is present in the query \n             * Based on whether user clicks on the next or prev button modify the url's query params\n             */\n                const urlParams = url.split('?');\n                let invokeUrl;\n                if (variable.pagination.isNext) {\n                    invokeUrl = variable.pagination.next.split('?');\n                } else {\n                    invokeUrl = variable.pagination.prev.split('?');\n                }\n                urlParams[1] = invokeUrl[1];\n                url = urlParams.join('?');\n                resObj['url'] = url;\n            }\n        }\n        return resObj;   \n    }\n\n    /**\n     * Sets the pagination info recieved from api's response in the res object\n     * @param operationInfo has metadata of the variable\n     * @param res holds the information of pagination which has to be stored on the variable\n     * @param paramName has key name against which data has to be stored in pagination\n     * @param variable withholds variable information \n     * @returns {void} This method does not return anything\n     */\n    static setParameterVal(paramName, res, operationInfo, variable) {\n        const paginationInfo = this.getPaginationInfo(operationInfo, variable);\n        const param = paginationInfo.input[paramName].split('.')[0]; \n        const sizeObj = _.find(operationInfo.parameters, function(obj) { return obj.name === param });\n        res[paramName] = _.result(sizeObj, 'sampleValue');\n    }\n\n    /**\n     * Creates res object from the response recieved from the api triggered\n     * @param variable withholds variable information \n     * @param operationInfo has metadata of the variable\n     * @param paginationInfo has metadata of the variable's pagination\n     * @param response has data of the api call's response\n     * @param options has info of the api's query params\n     * @param resHeaders has data of the api call's response headers\n     * @returns {object} An object which holds the information of pagination which has to be stored on the variable\n     */\n    static generatePaginationRes(operationInfo, paginationInfo, response, resHeaders, options, variable) {\n        let res = {};\n        const resOutput = paginationInfo.output;\n        // If pagination type is not cursor, create the following metadata \n        if (!resOutput?.next) {\n            /**\n             * If size is present in the pagination's output metadata deduce size from api's response\n             * Else deduce size from the pagination's input metadata size key\n             */\n            if (resOutput?.size) {\n                this.setPaginationItems(resOutput.size, response, res, 'size', resHeaders);\n            } else { \n                this.setParameterVal('size', res, operationInfo, variable);\n            }\n            /**\n             * If page is present in the pagination's output metadata deduce page from api's response\n             * Else deduce page from the pagination's input metadata page key\n             */\n            if (resOutput?.page) {\n                this.setPaginationItems(resOutput.page, response, res, 'page', resHeaders);\n            } else if (paginationInfo.type !== 'offset') {\n                this.setParameterVal('page', res, operationInfo, variable);\n            }\n            /**\n             * If totalElements has $minValue in it, set totalElements as $minValue\n             * If the rendered elements are greater than $minValue, set totalElements as Number of elements rendered + 1\n             \n                * If totalElements is present in the pagination's output metadata deduce totalElements from api's response\n                \n                * If Pagination type is offset, deduce totalElements from size and options[page] else deduce from size and res[page]\n                */\n            if (_.startsWith(resOutput?.totalElements, '$minValue')) {\n                const totalEl = resOutput.totalElements.replace('$minValue=', '');\n                const pageParam = res['page'] ? res['page'] : options['page']\n                const elRendered = res['size'] * pageParam;\n                if (!variable.pagination || variable.pagination['totalElements'] > elRendered) {\n                    res['totalElements'] = parseInt(totalEl);\n                } else {\n                    res['totalElements'] = elRendered + 1;\n                }\n            } else if (resOutput?.totalElements) {\n                this.setPaginationItems(resOutput.totalElements, response, res, 'totalElements', resHeaders);\n            } else {\n                if (paginationInfo.type === 'offset' || paginationInfo.input.offset) {\n                    res['totalElements'] = (res['size'] * (options['page'] ? options['page'] : 1)) + 1;\n                } else {\n                    res['totalElements'] = (res['size'] * res['page']) + 1;\n                }\n            }\n            /**\n             * If hasMoreItems is present in the pagination's output metadata deduce hasMoreItems from api's response\n             * Else assign it as empty which will be calculated at pagination object generation\n             */\n            if (resOutput?.hasMoreItems) {\n                this.setPaginationItems(resOutput.hasMoreItems, response, res, 'hasMoreItems', resHeaders);\n            } else {\n                res['hasMoreItems'] = '';\n            }\n        } else if (resOutput) { // For cursor type pagination set next and prev keys in res object\n            this.setPaginationItems(resOutput.next, response, res, 'next', resHeaders);\n            this.setPaginationItems(resOutput.prev, response, res, 'prev', resHeaders);\n        }\n        return res;\n    }\n}"]}