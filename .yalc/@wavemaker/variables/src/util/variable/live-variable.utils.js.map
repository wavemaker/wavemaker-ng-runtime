{"version":3,"file":"live-variable.utils.js","sourceRoot":"./","sources":["src/util/variable/live-variable.utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { hasCordova, getClonedObject, isDateTimeType, isDefined, replace, triggerFn, isNumberType } from \"../../util/utils\";\nimport { $rootScope, DB_CONSTANTS, SWAGGER_CONSTANTS } from '../../constants/variables.constants';\nimport { getEvaluatedOrderBy, formatDate } from './variables.utils';\n\ndeclare const _, moment;\n\nexport class LiveVariableUtils {\n\n    static isCompositeKey(primaryKey) {\n        return !primaryKey || (primaryKey && (!primaryKey.length || primaryKey.length > 1));\n    }\n\n    static isNoPrimaryKey(primaryKey) {\n        return (!primaryKey || (primaryKey && !primaryKey.length));\n    }\n\n    // Generate the URL based on the primary keys and their values\n    static getCompositeIDURL(primaryKeysData) {\n        let compositeId = '';\n        //  Loop over the 'compositeKeysData' and construct the 'compositeId'.\n        _.forEach(primaryKeysData, (paramValue, paramName) => {\n            compositeId += paramName + '=' + encodeURIComponent(paramValue) + '&';\n        });\n        compositeId = compositeId.slice(0, -1);\n        return compositeId;\n    }\n\n\n    // Check if table has blob column\n    static hasBlob(variable) {\n        return _.find(_.get(variable, ['propertiesMap', 'columns']), {'type': 'blob'});\n    }\n\n    static getPrimaryKey(variable) {\n        if (!variable.propertiesMap) {\n            return [];\n        }\n\n        if (variable.propertiesMap.primaryFields) {\n            return variable.propertiesMap.primaryFields;\n        }\n        /*Old projects do not have primary fields. Get primary key from the columns*/\n        const primaryKey = [];\n        /*Loop through the propertiesMap and get the primary key column.*/\n        _.forEach(variable.propertiesMap.columns, (index, column) => {\n            if (column.isPrimaryKey) {\n                if (column.isRelated && (!_.includes(column.relatedFieldName, primaryKey))) {\n                    primaryKey.push(column.relatedFieldName);\n                } else if (!_.includes(column.fieldName, primaryKey)) {\n                    primaryKey.push(column.fieldName);\n                }\n            }\n        });\n        return primaryKey;\n    }\n\n    //  Construct the URL for blob columns and set it in the data, so that widgets can use this\n    static processBlobColumns(responseData, variable) {\n        if (!responseData) {\n            return;\n        }\n        const blobCols = _.map(_.filter(variable.propertiesMap.columns, {'type': 'blob'}), 'fieldName'),\n            deployedUrl = _.trim($rootScope.project.deployedUrl);\n        let href = '',\n            primaryKeys;\n\n        if (_.isEmpty(blobCols)) {\n            return;\n        }\n\n        if (hasCordova()) {\n            href += _.endsWith(deployedUrl, '/') ? deployedUrl : deployedUrl + '/';\n        }\n        href += ((variable._prefabName !== '' && variable._prefabName !== undefined) ? 'prefabs/' + variable._prefabName : 'services') + '/' + variable.liveSource + '/' + variable.type + '/';\n        primaryKeys = variable.propertiesMap.primaryFields || variable.propertiesMap.primaryKeys;\n        _.forEach(responseData, data => {\n            if (data) {\n                _.forEach(blobCols, col => {\n                    const compositeKeysData = {};\n                    if (data[col] === null || !_.isEmpty(_.trim(data[col]))) {\n                        return;\n                    }\n                    if (LiveVariableUtils.isCompositeKey(primaryKeys)) {\n                        primaryKeys.forEach(key => {\n                            compositeKeysData[key] = data[key];\n                        });\n                        data[col] = href + 'composite-id/content/' + col + '?' + LiveVariableUtils.getCompositeIDURL(compositeKeysData);\n                    } else {\n                        data[col] = href + data[_.join(primaryKeys)] + '/content/' + col;\n                    }\n                });\n            }\n        });\n    }\n\n    static getHibernateOrSqlType(variable, fieldName, type, entityName?: string) {\n        const columns = variable.propertiesMap.columns;\n        let column,\n            relatedCols,\n            relatedCol,\n            columnParts;\n        if (_.includes(fieldName, '.')) {\n            columnParts = fieldName.split('.');\n            if (columnParts.length > 2) {\n                return undefined;\n            }\n            column = _.find(columns, col => {\n                return col.fieldName === columnParts[0];\n            });\n            relatedCols = column && column.columns;\n            relatedCol = _.find(relatedCols, col => {\n                return col.fieldName === columnParts[1];\n            });\n            return relatedCol && relatedCol[type];\n        }\n        column = _.find(columns, col => {\n            return col.fieldName === fieldName || col.relatedColumnName === fieldName;\n        });\n        if (!column && entityName) {\n            const entity = _.find(columns, col => col.relatedEntityName === entityName);\n            column = _.find(entity.columns, col => {\n                return col.fieldName === fieldName || col.relatedColumnName === fieldName;\n            });\n        }\n        return column && column[type];\n    }\n\n    /*Function to get the sqlType of the specified field.*/\n    static getSqlType(variable, fieldName, entityName?: string) {\n        return LiveVariableUtils.getHibernateOrSqlType(variable, fieldName, 'type', entityName);\n    }\n\n    /*Function to check if the specified field has a one-to-many relation or not.*/\n    static isRelatedFieldMany(variable, fieldName) {\n        const columns = variable.propertiesMap.columns,\n            columnsCount = columns.length;\n        let index,\n            column;\n        /*Loop through the columns of the liveVariable*/\n        for (index = 0; index < columnsCount; index += 1) {\n            column = columns[index];\n            /*If the specified field is found in the columns of the variable,\n            * then it has a many-to-one relation.*/\n            if (column.fieldName === fieldName) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    static isStringType(type) {\n        return _.includes(['text', 'string'], _.toLower(type));\n    }\n\n    static getSQLFieldType(variable, options) {\n        if (_.includes(['timestamp', 'datetime', 'date'], options.type)) {\n            return options.type;\n        }\n        return LiveVariableUtils.getSqlType(variable, options.fieldName) || options.type;\n    }\n\n    static getAttributeName(variable, fieldName) {\n        let attrName = fieldName;\n        variable.propertiesMap.columns.forEach(column => {\n            if (column.fieldName === fieldName && column.isRelated) {\n                attrName = column.relatedFieldName;\n            }\n        });\n        return attrName;\n    }\n\n    static getFilterCondition(filterCondition) {\n        if (_.includes(DB_CONSTANTS.DATABASE_RANGE_MATCH_MODES, filterCondition)) {\n            return filterCondition;\n        }\n        return DB_CONSTANTS.DATABASE_MATCH_MODES['exact'];\n    }\n\n    static getFilterOption(variable, fieldOptions, options) {\n        let attributeName,\n            fieldValue = fieldOptions.value,\n            filterOption,\n            filterCondition;\n\n        const matchModes = DB_CONSTANTS.DATABASE_MATCH_MODES,\n            fieldName = fieldOptions.fieldName,\n            fieldRequired = fieldOptions.required || false,\n            fieldType = LiveVariableUtils.getSQLFieldType(variable, fieldOptions);\n\n        filterCondition = matchModes[fieldOptions.matchMode] || matchModes[fieldOptions.filterCondition] || fieldOptions.filterCondition;\n\n        fieldOptions.type = fieldType;\n        /* if the field value is an object(complex type), loop over each field inside and push only first level fields */\n        if (_.isObject(fieldValue) && !_.isArray(fieldValue)) {\n            const firstLevelValues = [];\n            _.forEach(fieldValue, (subFieldValue, subFieldName) => {\n                if (subFieldValue && !_.isObject(subFieldValue)) {\n                    firstLevelValues.push(fieldName + '.' + subFieldName + '=' + subFieldValue);\n                }\n            });\n            return firstLevelValues;\n        }\n\n        if (_.includes(DB_CONSTANTS.DATABASE_EMPTY_MATCH_MODES, filterCondition)) {\n            attributeName = LiveVariableUtils.getAttributeName(variable, fieldName);\n            // For non string types empty match modes are not supported, so convert them to null match modes.\n            if (fieldType && !LiveVariableUtils.isStringType(fieldType)) {\n                filterCondition = DB_CONSTANTS.DATABASE_NULL_EMPTY_MATCH[filterCondition];\n            }\n            filterOption = {\n                'attributeName': attributeName,\n                'attributeValue': '',\n                'attributeType': _.toUpper(fieldType),\n                'filterCondition': filterCondition,\n                'required': fieldRequired\n            };\n            if (options.searchWithQuery) {\n                filterOption.isVariableFilter = fieldOptions.isVariableFilter;\n            }\n            return filterOption;\n        }\n\n        if (isDefined(fieldValue) && fieldValue !== null && fieldValue !== '') {\n            /*Based on the sqlType of the field, format the value & set the filter condition.*/\n            if (fieldType) {\n                switch (fieldType) {\n                    case 'integer':\n                        fieldValue = _.isArray(fieldValue) ? _.reduce(fieldValue, (result, value) => {\n                            value = parseInt(value, 10);\n                            if (!_.isNaN(value)) {\n                                result.push(value);\n                            }\n                            return result;\n                        }, []) : parseInt(fieldValue, 10);\n                        filterCondition = filterCondition ? LiveVariableUtils.getFilterCondition(filterCondition) : matchModes['exact'];\n                        break;\n                    case 'date':\n                    case 'datetime':\n                    case 'timestamp':\n                        // ToDo - variable seperation\n                        fieldValue = formatDate(fieldValue, fieldType);\n                        filterCondition = filterCondition ? LiveVariableUtils.getFilterCondition(filterCondition) : matchModes['exact'];\n                        break;\n                    case 'text':\n                    case 'string':\n                        if (_.isArray(fieldValue)) {\n                            filterCondition = _.includes([matchModes['in'], matchModes['notin']], filterCondition) ? filterCondition : matchModes['exact'];\n                        } else {\n                            filterCondition = filterCondition || matchModes['anywhereignorecase'];\n                        }\n                        break;\n                    default:\n                        filterCondition = filterCondition ? LiveVariableUtils.getFilterCondition(filterCondition) : matchModes['exact'];\n                        break;\n                }\n            } else {\n                filterCondition = _.isString(fieldValue) ? matchModes['anywhereignorecase'] : matchModes['exact'];\n            }\n            attributeName = LiveVariableUtils.getAttributeName(variable, fieldName);\n            filterOption = {\n                'attributeName': attributeName,\n                'attributeValue': fieldValue,\n                'attributeType': _.toUpper(fieldType),\n                'filterCondition': filterCondition,\n                'required': fieldRequired\n            };\n            if (options.searchWithQuery) {\n                filterOption.isVariableFilter = fieldOptions.isVariableFilter;\n            }\n            return filterOption;\n        }\n    }\n\n    static getFilterOptions(variable, filterFields, options) {\n        let filterOptions = [];\n        _.each(filterFields, (fieldOptions) => {\n            const filterOption = LiveVariableUtils.getFilterOption(variable, fieldOptions, options);\n            if (!_.isNil(filterOption)) {\n                if (_.isArray(filterOption)) {\n                    filterOptions = filterOptions.concat(filterOption);\n                } else {\n                    filterOptions.push(filterOption);\n                }\n            }\n        });\n        return filterOptions;\n    }\n\n    // Wrap the field name and value in lower() in ignore case scenario\n    // TODO: Change the function name to represent the added functionality of identifiers for datetime, timestamp and float types. Previously only lower was warapped.\n    static wrapInLowerCase(value, options, ignoreCase, isField?) {\n        const type = _.toLower(options.attributeType);\n        // If ignore case is true and type is string/ text and match mode is string type, wrap in lower()\n        if (ignoreCase && (!type || LiveVariableUtils.isStringType(type)) && _.includes(DB_CONSTANTS.DATABASE_STRING_MODES, options.filterCondition)) {\n            return 'lower(' + value + ')';\n        }\n        return value;\n    }\n\n    static encodeAndAddQuotes(value, type, skipEncode) {\n        let encodedValue = skipEncode ? value : encodeURIComponent(value);\n        type = _.toLower(type);\n        encodedValue = _.replace(encodedValue, /'/g, '\\'\\'');\n        // For number types, don't wrap the value in quotes\n        if ((isNumberType(type) && type !== 'float')) {\n            return encodedValue;\n        }\n        return '\\'' + encodedValue + '\\'';\n    }\n\n    static getParamValue(value, options, ignoreCase, skipEncode) {\n        let param;\n        const filterCondition = options.filterCondition,\n            dbModes = DB_CONSTANTS.DATABASE_MATCH_MODES,\n            type = options.attributeType;\n        if (_.includes(DB_CONSTANTS.DATABASE_EMPTY_MATCH_MODES, filterCondition)) {\n            // For empty matchmodes, no value is required\n            return '';\n        }\n        switch (filterCondition) {\n            case dbModes.startignorecase:\n            case dbModes.start:\n                param = LiveVariableUtils.encodeAndAddQuotes(value + '%', type, skipEncode);\n                param = LiveVariableUtils.wrapInLowerCase(param, options, ignoreCase);\n                break;\n            case dbModes.endignorecase:\n            case dbModes.end:\n                param = LiveVariableUtils.encodeAndAddQuotes('%' + value, type, skipEncode);\n                param = LiveVariableUtils.wrapInLowerCase(param, options, ignoreCase);\n                break;\n            case dbModes.nowhereignorecase:\n            case dbModes.nowhere:\n            case dbModes.anywhereignorecase:\n            case dbModes.anywhere:\n                param = LiveVariableUtils.encodeAndAddQuotes('%' + value + '%', type, skipEncode);\n                param = LiveVariableUtils.wrapInLowerCase(param, options, ignoreCase);\n                break;\n            case dbModes.between:\n                param = _.join(_.map(value, val => {\n                    return LiveVariableUtils.wrapInLowerCase(LiveVariableUtils.encodeAndAddQuotes(val, type, skipEncode), options, ignoreCase);\n                }), ' and ');\n                break;\n            case dbModes.in:\n            case dbModes.notin:\n                param = _.join(_.map(value, val => {\n                    return LiveVariableUtils.wrapInLowerCase(LiveVariableUtils.encodeAndAddQuotes(val, type, skipEncode), options, ignoreCase);\n                }), ', ');\n                param = '(' + param + ')';\n                break;\n            /*case dbModes.exactignorecase:\n            case dbModes.exact:\n            case dbModes.notequals:\n            The above three cases will be handled by default*/\n            default:\n                param = LiveVariableUtils.encodeAndAddQuotes(value, type, skipEncode);\n                param = LiveVariableUtils.wrapInLowerCase(param, options, ignoreCase);\n                break;\n        }\n        return isDefined(param) ? param : '';\n    }\n\n    static getSearchQuery(filterOptions, operator, ignoreCase, skipEncode?) {\n        let query;\n        const params = [];\n        _.forEach(filterOptions, fieldValue => {\n            const value = fieldValue.attributeValue,\n                dbModes = DB_CONSTANTS.DATABASE_MATCH_MODES,\n                isValArray = _.isArray(value);\n            let fieldName = fieldValue.attributeName,\n                filterCondition = fieldValue.filterCondition,\n                matchModeExpr,\n                paramValue;\n            // If value is an empty array, do not generate the query\n            // If values is NaN and number type, do not generate query for this field\n            if ((isValArray && _.isEmpty(value)) || (!isValArray && isNaN(value) && (isNumberType(fieldValue.attributeType))) || (!isValArray && (isNaN(value) && !moment(value).isValid() && isDateTimeType(_.toLower(fieldValue.attributeType))))) {\n                return;\n            }\n            if (isValArray) {\n                // If array is value and mode is between, pass between. Else pass as in query\n                filterCondition = filterCondition === dbModes.between || filterCondition === dbModes.notin ? filterCondition : dbModes.in;\n                fieldValue.filterCondition = filterCondition;\n            }\n            matchModeExpr = DB_CONSTANTS.DATABASE_MATCH_MODES_WITH_QUERY[filterCondition];\n            paramValue = LiveVariableUtils.getParamValue(value, fieldValue, ignoreCase, skipEncode);\n            fieldName = LiveVariableUtils.wrapInLowerCase(fieldName, fieldValue, ignoreCase);\n            params.push(replace(matchModeExpr, [fieldName, paramValue]));\n        });\n        query = _.join(params, operator); // empty space added intentionally around OR\n        return query;\n    }\n\n    /**\n     * creating the proper values from the actual object like for between,in matchModes value has to be an array like [1,2]\n     * @param rules recursive filterexpressions object\n     * @param variable variable object\n     * @param options options\n     */\n    static processFilterFields(rules, variable, options) {\n        _.remove(rules, rule => {\n            return rule && (_.isString(rule.value) && rule.value.indexOf('bind:') === 0 || (rule.matchMode === 'between' ? (_.isString(rule.secondvalue) && rule.secondvalue.indexOf('bind:') === 0) : false));\n        });\n\n        _.forEach(rules, (rule, index) => {\n            if (rule) {\n                if (rule.rules) {\n                    LiveVariableUtils.processFilterFields(rule.rules, variable, options);\n                } else {\n                    if (!_.isNull(rule.target)) {\n                        const value = rule.matchMode.toLowerCase() === DB_CONSTANTS.DATABASE_MATCH_MODES.between.toLowerCase()\n                            ? (_.isArray(rule.value) ? rule.value : [rule.value, rule.secondvalue])\n                            : (rule.matchMode.toLowerCase() === DB_CONSTANTS.DATABASE_MATCH_MODES.in.toLowerCase() || rule.matchMode.toLowerCase() === DB_CONSTANTS.DATABASE_MATCH_MODES.notin.toLowerCase()\n                                ? (_.isArray(rule.value) ? rule.value : (rule.value ? rule.value.split(',').map(val => val.trim()) : ''))\n                                : rule.value);\n                        rules[index] = LiveVariableUtils.getFilterOption(variable, {\n                            'fieldName': rule.target,\n                            'type': rule.type,\n                            'value': value,\n                            'required': rule.required,\n                            'filterCondition': rule.matchMode || options.matchMode || variable.matchMode\n                        }, options);\n                    }\n                }\n            }\n        });\n    }\n\n    static getSearchField(fieldValue, ignoreCase, skipEncode) {\n        let fieldName = fieldValue.attributeName;\n        let matchModeExpr;\n        let paramValue;\n        let filterCondition = fieldValue.filterCondition;\n\n        const value = fieldValue.attributeValue;\n        const isValArray = _.isArray(value);\n        const dbModes = DB_CONSTANTS.DATABASE_MATCH_MODES;\n\n        // If value is an empty array, do not generate the query\n        // If values is NaN and number type, do not generate query for this field\n        if ((isValArray && _.isEmpty(value)) ||\n            (isValArray && _.some(value, val => (_.isNull(val) || _.isNaN(val) || val === ''))) ||\n            (!isValArray && (isNaN(value) && (isNumberType(fieldValue.attributeType)))) ||\n            (!isValArray && (isNaN(value) && !moment(value).isValid() && isDateTimeType(_.toLower(fieldValue.attributeType))))) {\n            return;\n        }\n        if (isValArray) {\n            // If array is value and mode is between, pass between. Else pass as in query\n            filterCondition = filterCondition === dbModes.between || filterCondition === dbModes.notin ? filterCondition : dbModes.in;\n            fieldValue.filterCondition = filterCondition;\n        }\n        matchModeExpr = DB_CONSTANTS.DATABASE_MATCH_MODES_WITH_QUERY[filterCondition];\n        paramValue = LiveVariableUtils.getParamValue(value, fieldValue, ignoreCase, skipEncode);\n        fieldName = LiveVariableUtils.wrapInLowerCase(fieldName, fieldValue, ignoreCase);\n        return replace(matchModeExpr, [fieldName, paramValue]);\n    }\n\n    /**\n     * this is used to identify whether to use ignorecase at each criteria level and not use the variable\n     * level isIgnoreCase flag and apply it to all the rules.\n     * Instead of adding an extra param to the criteria object, we have added few other matchmodes for string types like\n     * anywhere with anywhereignorecase, start with startignorecase, end with endignorecase, exact with exactignorecase,\n     * So while creating the criteria itseld user can choose whether to use ignore case or not for a particular column while querying\n     * @param matchMode\n     * @param ignoreCase\n     * @returns {*} boolean\n     */\n    static getIgnoreCase(matchMode, ignoreCase) {\n        const matchModes = DB_CONSTANTS.DATABASE_MATCH_MODES;\n        if (_.indexOf([matchModes['anywhere'], matchModes['nowhere'], matchModes['start'], matchModes['end'], matchModes['exact']], matchMode) !== -1) {\n            return false;\n        }\n        if (_.indexOf([matchModes['anywhereignorecase'], matchModes['nowhereignorecase'], matchModes['startignorecase'], matchModes['endignorecase'], matchModes['exactignorecase']], matchMode) !== -1) {\n            return true;\n        }\n        return ignoreCase;\n    }\n\n    static generateSearchQuery(rules, condition, ignoreCase, skipEncode) {\n        const params = [];\n        _.forEach(rules, rule => {\n            if (rule) {\n                if (rule.rules) {\n                    const query = LiveVariableUtils.generateSearchQuery(rule.rules, rule.condition, ignoreCase, skipEncode);\n                    if (query !== '') {\n                        params.push('(' + query + ')');\n                    }\n                } else {\n                    const searchField = LiveVariableUtils.getSearchField(rule, LiveVariableUtils.getIgnoreCase(rule.filterCondition, ignoreCase), skipEncode);\n                    if (!_.isNil(searchField)) {\n                        params.push(searchField);\n                    }\n                }\n            }\n        });\n        return _.join(params, ' ' + condition + ' ');\n    }\n\n    static prepareTableOptionsForFilterExps(variable, options, clonedFields) {\n        if (!isDefined(options.searchWithQuery)) {\n            options.searchWithQuery = true; // Using query api instead of  search api\n        }\n\n        const filterOptions = [];\n        const matchModes = DB_CONSTANTS.DATABASE_MATCH_MODES;\n        let orderByFields,\n            orderByOptions,\n            query;\n        let clonedObj = clonedFields || getClonedObject(variable.filterExpressions);\n\n        // if filterexpression from live filter is present use it to query\n        if (options.filterExpr && !_.isEmpty(options.filterExpr)) {\n            clonedObj = options.filterExpr;\n        }\n        // merge live filter runtime values\n        let filterRules: any = {};\n        if (!_.isEmpty(options.filterFields)) {\n            let operator = '';\n            for (const field in options.filterFields) {\n                operator = options.filterFields[field]['logicalOp'] || '';\n                break;\n            }\n            filterRules = {'condition': options.logicalOp || operator || 'AND', 'rules': []};\n            _.forEach(options.filterFields, (filterObj, filterName) => {\n                const filterCondition = matchModes[filterObj.matchMode] || matchModes[filterObj.filterCondition] || filterObj.filterCondition;\n                if (_.includes(DB_CONSTANTS.DATABASE_EMPTY_MATCH_MODES, filterCondition) ||\n                    (!_.isNil(filterObj.value) && filterObj.value !== '')) {\n                    const type = filterObj.type || LiveVariableUtils.getSqlType(variable, filterName, options.entityName);\n                    const ruleObj = {\n                        'target': filterName,\n                        'type': type,\n                        'matchMode': filterObj.matchMode || (LiveVariableUtils.isStringType(type) ? 'startignorecase' : 'exact'),\n                        'value': filterObj.value,\n                        'required': filterObj.required || false\n                    };\n                    filterRules.rules.push(ruleObj);\n                }\n            });\n        }\n        if (!_.isEmpty(clonedObj)) {\n            if (!_.isNil(filterRules.rules) && filterRules.rules.length) {\n                // combine both the rules using 'AND'\n                const tempRules = {'condition': 'AND', 'rules': []};\n                tempRules.rules.push(getClonedObject(clonedObj));\n                tempRules.rules.push(filterRules);\n                clonedObj = tempRules;\n            }\n        } else {\n            clonedObj = filterRules;\n        }\n\n        LiveVariableUtils.processFilterFields(clonedObj.rules, variable, options);\n        query = LiveVariableUtils.generateSearchQuery(clonedObj.rules, clonedObj.condition, variable.ignoreCase, options.skipEncode);\n\n        orderByFields = getEvaluatedOrderBy(variable.orderBy, options.orderBy);\n        orderByOptions = orderByFields ? 'sort=' + orderByFields : '';\n\n        return {\n            'filter' : filterOptions,\n            'sort'   : orderByOptions,\n            'query'  : query\n        };\n    }\n\n    static prepareTableOptions(variable, options, clonedFields?) {\n        if (variable.operation === 'read') {\n            return LiveVariableUtils.prepareTableOptionsForFilterExps(variable, options, clonedFields);\n        }\n        if (!isDefined(options.searchWithQuery)) {\n            options.searchWithQuery = true; //  Using query api instead of  search api\n        }\n        const filterFields = [];\n        let filterOptions = [],\n            orderByFields,\n            orderByOptions,\n            query,\n            optionsQuery;\n        clonedFields = clonedFields || variable.filterFields;\n        // get the filter fields from the variable\n        _.forEach(clonedFields, (value, key) => {\n            if (_.isObject(value) && (!options.filterFields || !options.filterFields[key] || options.filterFields[key].logicalOp === 'AND')) {\n                value.fieldName = key;\n                if (LiveVariableUtils.isStringType(LiveVariableUtils.getSQLFieldType(variable, value))) {\n                    value.filterCondition = DB_CONSTANTS.DATABASE_MATCH_MODES[value.matchMode || variable.matchMode];\n                }\n                value.isVariableFilter = true;\n                filterFields.push(value);\n            }\n        });\n        // get the filter fields from the options\n        _.forEach(options.filterFields, (value, key) => {\n            value.fieldName = key;\n            value.filterCondition = DB_CONSTANTS.DATABASE_MATCH_MODES[value.matchMode || options.matchMode || variable.matchMode];\n            filterFields.push(value);\n        });\n        if (variable.operation === 'read' || options.operation === 'read') {\n            filterOptions = LiveVariableUtils.getFilterOptions(variable, filterFields, options);\n        }\n        /*if searchWithQuery is true, then convert the input params into query string. For example if firstName and lastName\n         should be sent as params then query string will be q='firstName containing 'someValue' OR lastName containing 'someValue''\n         */\n        if (options.searchWithQuery && filterOptions.length) {\n            // Generate query for variable filter fields. This has AND logical operator\n            query = LiveVariableUtils.getSearchQuery(_.filter(filterOptions, {'isVariableFilter': true}), ' AND ', variable.ignoreCase, options.skipEncode);\n            // Generate query for option filter fields. This has default logical operator as OR\n            optionsQuery = LiveVariableUtils.getSearchQuery(_.filter(filterOptions, {'isVariableFilter': undefined}), ' ' + (options.logicalOp || 'AND') + ' ', variable.ignoreCase, options.skipEncode);\n            if (optionsQuery) {\n                // If both variable and option query are present, merge them with AND\n                query = query ? (query + ' AND ( ' + optionsQuery + ' )') : optionsQuery;\n            }\n        }\n        orderByFields = getEvaluatedOrderBy(variable.orderBy, options.orderBy);\n        orderByOptions = orderByFields ? 'sort=' + orderByFields : '';\n\n        return {\n            'filter': filterOptions,\n            'sort': orderByOptions,\n            'query': query\n        };\n    }\n\n    /* Function to check if specified field is of type date*/\n    static getFieldType(fieldName, variable, relatedField?) {\n        let fieldType,\n            columns,\n            result;\n        if (variable.propertiesMap) {\n            columns = variable.propertiesMap.columns || [];\n            result = _.find(columns, obj => {\n                return obj.fieldName === fieldName;\n            });\n            // if related field name passed, get its type from columns inside the current field\n            if (relatedField && result) {\n                result = _.find(result.columns, obj => {\n                    return obj.fieldName === relatedField;\n                });\n            }\n            fieldType = result && result.type;\n        }\n        return fieldType;\n    }\n\n    // Prepare formData for blob columns\n    static prepareFormData(variableDetails, rowObject) {\n        const formData: any = new FormData();\n        formData.rowData = _.clone(rowObject);\n        _.forEach(rowObject, (colValue, colName) => {\n            if (LiveVariableUtils.getFieldType(colName, variableDetails) === 'blob') {\n                if (_.isObject(colValue)) {\n                    if (_.isArray(colValue)) {\n                        _.forEach(colValue, fileObject => {\n                            formData.append(colName, fileObject, fileObject.name);\n                        });\n                    } else {\n                        formData.append(colName, colValue, colValue.name);\n                    }\n                }\n                rowObject[colName] = colValue !== null ? '' : null;\n            }\n        });\n        formData.append(SWAGGER_CONSTANTS.WM_DATA_JSON, new Blob([JSON.stringify(rowObject)], {\n            type: 'application/json'\n        }));\n        return formData;\n    }\n\n    static traverseFilterExpressions(filterExpressions, traverseCallbackFn) {\n        if (filterExpressions && filterExpressions.rules) {\n            _.forEach(filterExpressions.rules, (filExpObj, i) => {\n                if (filExpObj.rules) {\n                    LiveVariableUtils.traverseFilterExpressions(filExpObj, traverseCallbackFn);\n                } else {\n                    return triggerFn(traverseCallbackFn, filterExpressions, filExpObj);\n                }\n            });\n        }\n    }\n\n    /**\n     * Traverses recursively the filterExpressions object and if there is any required field present with no value,\n     * then we will return without proceeding further. Its upto the developer to provide the mandatory value,\n     * if he wants to assign it in teh onbefore<delete/insert/update>function then make that field in\n     * the filter query section as optional\n     * @param filterExpressions - recursive rule Object\n     * @returns {Object} object or boolean. Object if everything gets validated or else just boolean indicating failure in the validations\n     */\n    static getFilterExprFields(filterExpressions) {\n        let isRequiredFieldAbsent = false;\n        const traverseCallbackFn = (parentFilExpObj, filExpObj) => {\n            if (filExpObj\n                && filExpObj.required\n                && ((_.indexOf(['null', 'isnotnull', 'empty', 'isnotempty', 'nullorempty'], filExpObj.matchMode) === -1) && filExpObj.value === '')) {\n                isRequiredFieldAbsent = true;\n                return false;\n            }\n        };\n        LiveVariableUtils.traverseFilterExpressions(filterExpressions, traverseCallbackFn);\n        return isRequiredFieldAbsent ? !isRequiredFieldAbsent : filterExpressions;\n    }\n\n    /**\n     *\n     * @param variable\n     * @param options\n     * @returns {function(*=): *} returns a function which should be called for the where clause.\n     * This return function can take a function as argument. This argument function can modify the filter fields\n     * before generating where clause.\n     */\n    static getWhereClauseGenerator(variable, options, updatedFilterFields?: any) {\n        return (modifier, skipEncode?: boolean) => {\n            const clonedFields = LiveVariableUtils.getFilterExprFields(getClonedObject(updatedFilterFields || variable.filterExpressions));\n            // this flag skips the encoding of the query\n            if (isDefined(skipEncode)) {\n                options.skipEncode = skipEncode;\n            }\n            if (modifier) {\n                // handling the scenario where variable can also have filterFields\n                if (options.filterFields) {\n                    modifier(clonedFields, options);\n                } else {\n                    modifier(clonedFields);\n                }\n            }\n            return LiveVariableUtils.prepareTableOptions(variable, options, clonedFields).query;\n        };\n    }\n}\n\n"]}