var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
(function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === 'object' && typeof module === 'object')
        module.exports = factory();
    else if (typeof define === 'function' && define.amd)
        define([], factory);
    else if (typeof exports === 'object')
        exports["wm_common_variables"] = factory();
    else
        root["wm_common_variables"] = factory();
})(window, function () {
    return /******/ (function () {
        /******/ var __webpack_modules__ = ({
            /***/ "./node_modules/@metrichor/jmespath/dist/jmespath.esm.js": 
            /*!***************************************************************!*\
              !*** ./node_modules/@metrichor/jmespath/dist/jmespath.esm.js ***!
              \***************************************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                var _e, _f;
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "TYPE_ANY": function () { return ( /* binding */TYPE_ANY); },
                    /* harmony export */ "TYPE_ARRAY": function () { return ( /* binding */TYPE_ARRAY); },
                    /* harmony export */ "TYPE_ARRAY_NUMBER": function () { return ( /* binding */TYPE_ARRAY_NUMBER); },
                    /* harmony export */ "TYPE_ARRAY_STRING": function () { return ( /* binding */TYPE_ARRAY_STRING); },
                    /* harmony export */ "TYPE_BOOLEAN": function () { return ( /* binding */TYPE_BOOLEAN); },
                    /* harmony export */ "TYPE_EXPREF": function () { return ( /* binding */TYPE_EXPREF); },
                    /* harmony export */ "TYPE_NULL": function () { return ( /* binding */TYPE_NULL); },
                    /* harmony export */ "TYPE_NUMBER": function () { return ( /* binding */TYPE_NUMBER); },
                    /* harmony export */ "TYPE_OBJECT": function () { return ( /* binding */TYPE_OBJECT); },
                    /* harmony export */ "TYPE_STRING": function () { return ( /* binding */TYPE_STRING); },
                    /* harmony export */ "TreeInterpreter": function () { return ( /* binding */TreeInterpreter); },
                    /* harmony export */ "compile": function () { return ( /* binding */compile); },
                    /* harmony export */ "default": function () { return (__WEBPACK_DEFAULT_EXPORT__); },
                    /* harmony export */ "jmespath": function () { return ( /* binding */jmespath); },
                    /* harmony export */ "registerFunction": function () { return ( /* binding */registerFunction); },
                    /* harmony export */ "search": function () { return ( /* binding */search); },
                    /* harmony export */ "tokenize": function () { return ( /* binding */tokenize); }
                    /* harmony export */ 
                });
                var isObject = function (obj) {
                    return obj !== null && Object.prototype.toString.call(obj) === '[object Object]';
                };
                var strictDeepEqual = function (first, second) {
                    if (first === second) {
                        return true;
                    }
                    if (typeof first !== typeof second) {
                        return false;
                    }
                    if (Array.isArray(first) && Array.isArray(second)) {
                        if (first.length !== second.length) {
                            return false;
                        }
                        for (var i = 0; i < first.length; i += 1) {
                            if (!strictDeepEqual(first[i], second[i])) {
                                return false;
                            }
                        }
                        return true;
                    }
                    if (isObject(first) && isObject(second)) {
                        var firstEntries = Object.entries(first);
                        var secondKeys = new Set(Object.keys(second));
                        if (firstEntries.length !== secondKeys.size) {
                            return false;
                        }
                        for (var _e = 0, firstEntries_1 = firstEntries; _e < firstEntries_1.length; _e++) {
                            var _f = firstEntries_1[_e], key = _f[0], value = _f[1];
                            if (!strictDeepEqual(value, second[key])) {
                                return false;
                            }
                            secondKeys.delete(key);
                        }
                        return secondKeys.size === 0;
                    }
                    return false;
                };
                var isFalse = function (obj) {
                    if (obj === '' || obj === false || obj === null || obj === undefined) {
                        return true;
                    }
                    if (Array.isArray(obj) && obj.length === 0) {
                        return true;
                    }
                    if (isObject(obj)) {
                        for (var key in obj) {
                            if (obj.hasOwnProperty(key)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    return false;
                };
                var isAlpha = function (ch) {
                    // tslint:disable-next-line: strict-comparisons
                    return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '_';
                };
                var isNum = function (ch) {
                    // tslint:disable-next-line: strict-comparisons
                    return (ch >= '0' && ch <= '9') || ch === '-';
                };
                var isAlphaNum = function (ch) {
                    // tslint:disable-next-line: strict-comparisons
                    return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch === '_';
                };
                var Token;
                (function (Token) {
                    Token["TOK_EOF"] = "EOF";
                    Token["TOK_UNQUOTEDIDENTIFIER"] = "UnquotedIdentifier";
                    Token["TOK_QUOTEDIDENTIFIER"] = "QuotedIdentifier";
                    Token["TOK_RBRACKET"] = "Rbracket";
                    Token["TOK_RPAREN"] = "Rparen";
                    Token["TOK_COMMA"] = "Comma";
                    Token["TOK_COLON"] = "Colon";
                    Token["TOK_RBRACE"] = "Rbrace";
                    Token["TOK_NUMBER"] = "Number";
                    Token["TOK_CURRENT"] = "Current";
                    Token["TOK_ROOT"] = "Root";
                    Token["TOK_EXPREF"] = "Expref";
                    Token["TOK_PIPE"] = "Pipe";
                    Token["TOK_OR"] = "Or";
                    Token["TOK_AND"] = "And";
                    Token["TOK_EQ"] = "EQ";
                    Token["TOK_GT"] = "GT";
                    Token["TOK_LT"] = "LT";
                    Token["TOK_GTE"] = "GTE";
                    Token["TOK_LTE"] = "LTE";
                    Token["TOK_NE"] = "NE";
                    Token["TOK_FLATTEN"] = "Flatten";
                    Token["TOK_STAR"] = "Star";
                    Token["TOK_FILTER"] = "Filter";
                    Token["TOK_DOT"] = "Dot";
                    Token["TOK_NOT"] = "Not";
                    Token["TOK_LBRACE"] = "Lbrace";
                    Token["TOK_LBRACKET"] = "Lbracket";
                    Token["TOK_LPAREN"] = "Lparen";
                    Token["TOK_LITERAL"] = "Literal";
                })(Token || (Token = {}));
                var basicTokens = (_e = {
                        '(': Token.TOK_LPAREN,
                        ')': Token.TOK_RPAREN,
                        '*': Token.TOK_STAR,
                        ',': Token.TOK_COMMA,
                        '.': Token.TOK_DOT,
                        ':': Token.TOK_COLON,
                        '@': Token.TOK_CURRENT
                    },
                    _e['$'] = Token.TOK_ROOT,
                    _e[']'] = Token.TOK_RBRACKET,
                    _e['{'] = Token.TOK_LBRACE,
                    _e['}'] = Token.TOK_RBRACE,
                    _e);
                var operatorStartToken = {
                    '!': true,
                    '<': true,
                    '=': true,
                    '>': true,
                };
                var skipChars = {
                    '\t': true,
                    '\n': true,
                    '\r': true,
                    ' ': true,
                };
                var StreamLexer = /** @class */ (function () {
                    function StreamLexer() {
                        this._current = 0;
                    }
                    StreamLexer.prototype.tokenize = function (stream) {
                        var tokens = [];
                        this._current = 0;
                        var start;
                        var identifier;
                        var token;
                        while (this._current < stream.length) {
                            if (isAlpha(stream[this._current])) {
                                start = this._current;
                                identifier = this.consumeUnquotedIdentifier(stream);
                                tokens.push({
                                    start: start,
                                    type: Token.TOK_UNQUOTEDIDENTIFIER,
                                    value: identifier,
                                });
                            }
                            else if (basicTokens[stream[this._current]] !== undefined) {
                                tokens.push({
                                    start: this._current,
                                    type: basicTokens[stream[this._current]],
                                    value: stream[this._current],
                                });
                                this._current += 1;
                            }
                            else if (isNum(stream[this._current])) {
                                token = this.consumeNumber(stream);
                                tokens.push(token);
                            }
                            else if (stream[this._current] === '[') {
                                token = this.consumeLBracket(stream);
                                tokens.push(token);
                            }
                            else if (stream[this._current] === '"') {
                                start = this._current;
                                identifier = this.consumeQuotedIdentifier(stream);
                                tokens.push({
                                    start: start,
                                    type: Token.TOK_QUOTEDIDENTIFIER,
                                    value: identifier,
                                });
                            }
                            else if (stream[this._current] === "'") {
                                start = this._current;
                                identifier = this.consumeRawStringLiteral(stream);
                                tokens.push({
                                    start: start,
                                    type: Token.TOK_LITERAL,
                                    value: identifier,
                                });
                            }
                            else if (stream[this._current] === '`') {
                                start = this._current;
                                var literal = this.consumeLiteral(stream);
                                tokens.push({
                                    start: start,
                                    type: Token.TOK_LITERAL,
                                    value: literal,
                                });
                            }
                            else if (operatorStartToken[stream[this._current]] !== undefined) {
                                token = this.consumeOperator(stream);
                                token && tokens.push(token);
                            }
                            else if (skipChars[stream[this._current]] !== undefined) {
                                this._current += 1;
                            }
                            else if (stream[this._current] === '&') {
                                start = this._current;
                                this._current += 1;
                                if (stream[this._current] === '&') {
                                    this._current += 1;
                                    tokens.push({ start: start, type: Token.TOK_AND, value: '&&' });
                                }
                                else {
                                    tokens.push({ start: start, type: Token.TOK_EXPREF, value: '&' });
                                }
                            }
                            else if (stream[this._current] === '|') {
                                start = this._current;
                                this._current += 1;
                                if (stream[this._current] === '|') {
                                    this._current += 1;
                                    tokens.push({ start: start, type: Token.TOK_OR, value: '||' });
                                }
                                else {
                                    tokens.push({ start: start, type: Token.TOK_PIPE, value: '|' });
                                }
                            }
                            else {
                                var error = new Error("Unknown character: " + stream[this._current]);
                                error.name = 'LexerError';
                                throw error;
                            }
                        }
                        return tokens;
                    };
                    StreamLexer.prototype.consumeUnquotedIdentifier = function (stream) {
                        var start = this._current;
                        this._current += 1;
                        while (this._current < stream.length && isAlphaNum(stream[this._current])) {
                            this._current += 1;
                        }
                        return stream.slice(start, this._current);
                    };
                    StreamLexer.prototype.consumeQuotedIdentifier = function (stream) {
                        var start = this._current;
                        this._current += 1;
                        var maxLength = stream.length;
                        while (stream[this._current] !== '"' && this._current < maxLength) {
                            var current = this._current;
                            if (stream[current] === '\\' && (stream[current + 1] === '\\' || stream[current + 1] === '"')) {
                                current += 2;
                            }
                            else {
                                current += 1;
                            }
                            this._current = current;
                        }
                        this._current += 1;
                        return JSON.parse(stream.slice(start, this._current));
                    };
                    StreamLexer.prototype.consumeRawStringLiteral = function (stream) {
                        var start = this._current;
                        this._current += 1;
                        var maxLength = stream.length;
                        while (stream[this._current] !== "'" && this._current < maxLength) {
                            var current = this._current;
                            if (stream[current] === '\\' && (stream[current + 1] === '\\' || stream[current + 1] === "'")) {
                                current += 2;
                            }
                            else {
                                current += 1;
                            }
                            this._current = current;
                        }
                        this._current += 1;
                        var literal = stream.slice(start + 1, this._current - 1);
                        return literal.replace("\\'", "'");
                    };
                    StreamLexer.prototype.consumeNumber = function (stream) {
                        var start = this._current;
                        this._current += 1;
                        var maxLength = stream.length;
                        while (isNum(stream[this._current]) && this._current < maxLength) {
                            this._current += 1;
                        }
                        var value = parseInt(stream.slice(start, this._current), 10);
                        return { start: start, value: value, type: Token.TOK_NUMBER };
                    };
                    StreamLexer.prototype.consumeLBracket = function (stream) {
                        var start = this._current;
                        this._current += 1;
                        if (stream[this._current] === '?') {
                            this._current += 1;
                            return { start: start, type: Token.TOK_FILTER, value: '[?' };
                        }
                        if (stream[this._current] === ']') {
                            this._current += 1;
                            return { start: start, type: Token.TOK_FLATTEN, value: '[]' };
                        }
                        return { start: start, type: Token.TOK_LBRACKET, value: '[' };
                    };
                    StreamLexer.prototype.consumeOperator = function (stream) {
                        var start = this._current;
                        var startingChar = stream[start];
                        this._current += 1;
                        if (startingChar === '!') {
                            if (stream[this._current] === '=') {
                                this._current += 1;
                                return { start: start, type: Token.TOK_NE, value: '!=' };
                            }
                            return { start: start, type: Token.TOK_NOT, value: '!' };
                        }
                        if (startingChar === '<') {
                            if (stream[this._current] === '=') {
                                this._current += 1;
                                return { start: start, type: Token.TOK_LTE, value: '<=' };
                            }
                            return { start: start, type: Token.TOK_LT, value: '<' };
                        }
                        if (startingChar === '>') {
                            if (stream[this._current] === '=') {
                                this._current += 1;
                                return { start: start, type: Token.TOK_GTE, value: '>=' };
                            }
                            return { start: start, type: Token.TOK_GT, value: '>' };
                        }
                        if (startingChar === '=' && stream[this._current] === '=') {
                            this._current += 1;
                            return { start: start, type: Token.TOK_EQ, value: '==' };
                        }
                    };
                    StreamLexer.prototype.consumeLiteral = function (stream) {
                        this._current += 1;
                        var start = this._current;
                        var maxLength = stream.length;
                        while (stream[this._current] !== '`' && this._current < maxLength) {
                            var current = this._current;
                            if (stream[current] === '\\' && (stream[current + 1] === '\\' || stream[current + 1] === '`')) {
                                current += 2;
                            }
                            else {
                                current += 1;
                            }
                            this._current = current;
                        }
                        var literalString = stream.slice(start, this._current).trimLeft();
                        literalString = literalString.replace('\\`', '`');
                        var literal = this.looksLikeJSON(literalString)
                            ? JSON.parse(literalString)
                            : JSON.parse("\"" + literalString + "\"");
                        this._current += 1;
                        return literal;
                    };
                    StreamLexer.prototype.looksLikeJSON = function (literalString) {
                        var startingChars = '[{"';
                        var jsonLiterals = ['true', 'false', 'null'];
                        var numberLooking = '-0123456789';
                        if (literalString === '') {
                            return false;
                        }
                        if (startingChars.includes(literalString[0])) {
                            return true;
                        }
                        if (jsonLiterals.includes(literalString)) {
                            return true;
                        }
                        if (numberLooking.includes(literalString[0])) {
                            try {
                                JSON.parse(literalString);
                                return true;
                            }
                            catch (ex) {
                                return false;
                            }
                        }
                        return false;
                    };
                    return StreamLexer;
                }());
                var Lexer = new StreamLexer();
                var bindingPower = (_f = {},
                    _f[Token.TOK_EOF] = 0,
                    _f[Token.TOK_UNQUOTEDIDENTIFIER] = 0,
                    _f[Token.TOK_QUOTEDIDENTIFIER] = 0,
                    _f[Token.TOK_RBRACKET] = 0,
                    _f[Token.TOK_RPAREN] = 0,
                    _f[Token.TOK_COMMA] = 0,
                    _f[Token.TOK_RBRACE] = 0,
                    _f[Token.TOK_NUMBER] = 0,
                    _f[Token.TOK_CURRENT] = 0,
                    _f[Token.TOK_EXPREF] = 0,
                    _f[Token.TOK_ROOT] = 0,
                    _f[Token.TOK_PIPE] = 1,
                    _f[Token.TOK_OR] = 2,
                    _f[Token.TOK_AND] = 3,
                    _f[Token.TOK_EQ] = 5,
                    _f[Token.TOK_GT] = 5,
                    _f[Token.TOK_LT] = 5,
                    _f[Token.TOK_GTE] = 5,
                    _f[Token.TOK_LTE] = 5,
                    _f[Token.TOK_NE] = 5,
                    _f[Token.TOK_FLATTEN] = 9,
                    _f[Token.TOK_STAR] = 20,
                    _f[Token.TOK_FILTER] = 21,
                    _f[Token.TOK_DOT] = 40,
                    _f[Token.TOK_NOT] = 45,
                    _f[Token.TOK_LBRACE] = 50,
                    _f[Token.TOK_LBRACKET] = 55,
                    _f[Token.TOK_LPAREN] = 60,
                    _f);
                var TokenParser = /** @class */ (function () {
                    function TokenParser() {
                        this.index = 0;
                        this.tokens = [];
                    }
                    TokenParser.prototype.parse = function (expression) {
                        this.loadTokens(expression);
                        this.index = 0;
                        var ast = this.expression(0);
                        if (this.lookahead(0) !== Token.TOK_EOF) {
                            var token = this.lookaheadToken(0);
                            this.errorToken(token, "Unexpected token type: " + token.type + ", value: " + token.value);
                        }
                        return ast;
                    };
                    TokenParser.prototype.loadTokens = function (expression) {
                        this.tokens = __spreadArray(__spreadArray([], Lexer.tokenize(expression)), [{ type: Token.TOK_EOF, value: '', start: expression.length }]);
                    };
                    TokenParser.prototype.expression = function (rbp) {
                        var leftToken = this.lookaheadToken(0);
                        this.advance();
                        var left = this.nud(leftToken);
                        var currentTokenType = this.lookahead(0);
                        while (rbp < bindingPower[currentTokenType]) {
                            this.advance();
                            left = this.led(currentTokenType, left);
                            currentTokenType = this.lookahead(0);
                        }
                        return left;
                    };
                    TokenParser.prototype.lookahead = function (offset) {
                        return this.tokens[this.index + offset].type;
                    };
                    TokenParser.prototype.lookaheadToken = function (offset) {
                        return this.tokens[this.index + offset];
                    };
                    TokenParser.prototype.advance = function () {
                        this.index += 1;
                    };
                    TokenParser.prototype.nud = function (token) {
                        var left;
                        var right;
                        var expression;
                        switch (token.type) {
                            case Token.TOK_LITERAL:
                                return { type: 'Literal', value: token.value };
                            case Token.TOK_UNQUOTEDIDENTIFIER:
                                return { type: 'Field', name: token.value };
                            case Token.TOK_QUOTEDIDENTIFIER:
                                var node = { type: 'Field', name: token.value };
                                if (this.lookahead(0) === Token.TOK_LPAREN) {
                                    throw new Error('Quoted identifier not allowed for function names.');
                                }
                                else {
                                    return node;
                                }
                            case Token.TOK_NOT:
                                right = this.expression(bindingPower.Not);
                                return { type: 'NotExpression', children: [right] };
                            case Token.TOK_STAR:
                                left = { type: 'Identity' };
                                right =
                                    (this.lookahead(0) === Token.TOK_RBRACKET && { type: 'Identity' }) ||
                                        this.parseProjectionRHS(bindingPower.Star);
                                return { type: 'ValueProjection', children: [left, right] };
                            case Token.TOK_FILTER:
                                return this.led(token.type, { type: 'Identity' });
                            case Token.TOK_LBRACE:
                                return this.parseMultiselectHash();
                            case Token.TOK_FLATTEN:
                                left = { type: Token.TOK_FLATTEN, children: [{ type: 'Identity' }] };
                                right = this.parseProjectionRHS(bindingPower.Flatten);
                                return { type: 'Projection', children: [left, right] };
                            case Token.TOK_LBRACKET:
                                if (this.lookahead(0) === Token.TOK_NUMBER || this.lookahead(0) === Token.TOK_COLON) {
                                    right = this.parseIndexExpression();
                                    return this.projectIfSlice({ type: 'Identity' }, right);
                                }
                                if (this.lookahead(0) === Token.TOK_STAR && this.lookahead(1) === Token.TOK_RBRACKET) {
                                    this.advance();
                                    this.advance();
                                    right = this.parseProjectionRHS(bindingPower.Star);
                                    return {
                                        children: [{ type: 'Identity' }, right],
                                        type: 'Projection',
                                    };
                                }
                                return this.parseMultiselectList();
                            case Token.TOK_CURRENT:
                                return { type: Token.TOK_CURRENT };
                            case Token.TOK_ROOT:
                                return { type: Token.TOK_ROOT };
                            case Token.TOK_EXPREF:
                                expression = this.expression(bindingPower.Expref);
                                return { type: 'ExpressionReference', children: [expression] };
                            case Token.TOK_LPAREN:
                                var args = [];
                                while (this.lookahead(0) !== Token.TOK_RPAREN) {
                                    if (this.lookahead(0) === Token.TOK_CURRENT) {
                                        expression = { type: Token.TOK_CURRENT };
                                        this.advance();
                                    }
                                    else {
                                        expression = this.expression(0);
                                    }
                                    args.push(expression);
                                }
                                this.match(Token.TOK_RPAREN);
                                return args[0];
                            default:
                                this.errorToken(token);
                        }
                    };
                    TokenParser.prototype.led = function (tokenName, left) {
                        var right;
                        switch (tokenName) {
                            case Token.TOK_DOT:
                                var rbp = bindingPower.Dot;
                                if (this.lookahead(0) !== Token.TOK_STAR) {
                                    right = this.parseDotRHS(rbp);
                                    return { type: 'Subexpression', children: [left, right] };
                                }
                                this.advance();
                                right = this.parseProjectionRHS(rbp);
                                return { type: 'ValueProjection', children: [left, right] };
                            case Token.TOK_PIPE:
                                right = this.expression(bindingPower.Pipe);
                                return { type: Token.TOK_PIPE, children: [left, right] };
                            case Token.TOK_OR:
                                right = this.expression(bindingPower.Or);
                                return { type: 'OrExpression', children: [left, right] };
                            case Token.TOK_AND:
                                right = this.expression(bindingPower.And);
                                return { type: 'AndExpression', children: [left, right] };
                            case Token.TOK_LPAREN:
                                var name_1 = left.name;
                                var args = [];
                                var expression = void 0;
                                while (this.lookahead(0) !== Token.TOK_RPAREN) {
                                    if (this.lookahead(0) === Token.TOK_CURRENT) {
                                        expression = { type: Token.TOK_CURRENT };
                                        this.advance();
                                    }
                                    else {
                                        expression = this.expression(0);
                                    }
                                    if (this.lookahead(0) === Token.TOK_COMMA) {
                                        this.match(Token.TOK_COMMA);
                                    }
                                    args.push(expression);
                                }
                                this.match(Token.TOK_RPAREN);
                                var node = { name: name_1, type: 'Function', children: args };
                                return node;
                            case Token.TOK_FILTER:
                                var condition = this.expression(0);
                                this.match(Token.TOK_RBRACKET);
                                right =
                                    (this.lookahead(0) === Token.TOK_FLATTEN && { type: 'Identity' }) ||
                                        this.parseProjectionRHS(bindingPower.Filter);
                                return { type: 'FilterProjection', children: [left, right, condition] };
                            case Token.TOK_FLATTEN:
                                var leftNode = { type: Token.TOK_FLATTEN, children: [left] };
                                var rightNode = this.parseProjectionRHS(bindingPower.Flatten);
                                return { type: 'Projection', children: [leftNode, rightNode] };
                            case Token.TOK_EQ:
                            case Token.TOK_NE:
                            case Token.TOK_GT:
                            case Token.TOK_GTE:
                            case Token.TOK_LT:
                            case Token.TOK_LTE:
                                return this.parseComparator(left, tokenName);
                            case Token.TOK_LBRACKET:
                                var token = this.lookaheadToken(0);
                                if (token.type === Token.TOK_NUMBER || token.type === Token.TOK_COLON) {
                                    right = this.parseIndexExpression();
                                    return this.projectIfSlice(left, right);
                                }
                                this.match(Token.TOK_STAR);
                                this.match(Token.TOK_RBRACKET);
                                right = this.parseProjectionRHS(bindingPower.Star);
                                return { type: 'Projection', children: [left, right] };
                            default:
                                return this.errorToken(this.lookaheadToken(0));
                        }
                    };
                    TokenParser.prototype.match = function (tokenType) {
                        if (this.lookahead(0) === tokenType) {
                            this.advance();
                            return;
                        }
                        else {
                            var token = this.lookaheadToken(0);
                            this.errorToken(token, "Expected " + tokenType + ", got: " + token.type);
                        }
                    };
                    TokenParser.prototype.errorToken = function (token, message) {
                        if (message === void 0) { message = ''; }
                        var error = new Error(message || "Invalid token (" + token.type + "): \"" + token.value + "\"");
                        error.name = 'ParserError';
                        throw error;
                    };
                    TokenParser.prototype.parseIndexExpression = function () {
                        if (this.lookahead(0) === Token.TOK_COLON || this.lookahead(1) === Token.TOK_COLON) {
                            return this.parseSliceExpression();
                        }
                        var node = {
                            type: 'Index',
                            value: this.lookaheadToken(0).value,
                        };
                        this.advance();
                        this.match(Token.TOK_RBRACKET);
                        return node;
                    };
                    TokenParser.prototype.projectIfSlice = function (left, right) {
                        var indexExpr = { type: 'IndexExpression', children: [left, right] };
                        if (right.type === 'Slice') {
                            return {
                                children: [indexExpr, this.parseProjectionRHS(bindingPower.Star)],
                                type: 'Projection',
                            };
                        }
                        return indexExpr;
                    };
                    TokenParser.prototype.parseSliceExpression = function () {
                        var parts = [null, null, null];
                        var index = 0;
                        var currentTokenType = this.lookahead(0);
                        while (currentTokenType !== Token.TOK_RBRACKET && index < 3) {
                            if (currentTokenType === Token.TOK_COLON) {
                                index += 1;
                                this.advance();
                            }
                            else if (currentTokenType === Token.TOK_NUMBER) {
                                parts[index] = this.lookaheadToken(0).value;
                                this.advance();
                            }
                            else {
                                var token = this.lookaheadToken(0);
                                this.errorToken(token, "Syntax error, unexpected token: " + token.value + "(" + token.type + ")");
                            }
                            currentTokenType = this.lookahead(0);
                        }
                        this.match(Token.TOK_RBRACKET);
                        return {
                            children: parts,
                            type: 'Slice',
                        };
                    };
                    TokenParser.prototype.parseComparator = function (left, comparator) {
                        var right = this.expression(bindingPower[comparator]);
                        return { type: 'Comparator', name: comparator, children: [left, right] };
                    };
                    TokenParser.prototype.parseDotRHS = function (rbp) {
                        var lookahead = this.lookahead(0);
                        var exprTokens = [Token.TOK_UNQUOTEDIDENTIFIER, Token.TOK_QUOTEDIDENTIFIER, Token.TOK_STAR];
                        if (exprTokens.includes(lookahead)) {
                            return this.expression(rbp);
                        }
                        if (lookahead === Token.TOK_LBRACKET) {
                            this.match(Token.TOK_LBRACKET);
                            return this.parseMultiselectList();
                        }
                        if (lookahead === Token.TOK_LBRACE) {
                            this.match(Token.TOK_LBRACE);
                            return this.parseMultiselectHash();
                        }
                        var token = this.lookaheadToken(0);
                        this.errorToken(token, "Syntax error, unexpected token: " + token.value + "(" + token.type + ")");
                    };
                    TokenParser.prototype.parseProjectionRHS = function (rbp) {
                        if (bindingPower[this.lookahead(0)] < 10) {
                            return { type: 'Identity' };
                        }
                        if (this.lookahead(0) === Token.TOK_LBRACKET) {
                            return this.expression(rbp);
                        }
                        if (this.lookahead(0) === Token.TOK_FILTER) {
                            return this.expression(rbp);
                        }
                        if (this.lookahead(0) === Token.TOK_DOT) {
                            this.match(Token.TOK_DOT);
                            return this.parseDotRHS(rbp);
                        }
                        var token = this.lookaheadToken(0);
                        this.errorToken(token, "Syntax error, unexpected token: " + token.value + "(" + token.type + ")");
                    };
                    TokenParser.prototype.parseMultiselectList = function () {
                        var expressions = [];
                        while (this.lookahead(0) !== Token.TOK_RBRACKET) {
                            var expression = this.expression(0);
                            expressions.push(expression);
                            if (this.lookahead(0) === Token.TOK_COMMA) {
                                this.match(Token.TOK_COMMA);
                                if (this.lookahead(0) === Token.TOK_RBRACKET) {
                                    throw new Error('Unexpected token Rbracket');
                                }
                            }
                        }
                        this.match(Token.TOK_RBRACKET);
                        return { type: 'MultiSelectList', children: expressions };
                    };
                    TokenParser.prototype.parseMultiselectHash = function () {
                        var pairs = [];
                        var identifierTypes = [Token.TOK_UNQUOTEDIDENTIFIER, Token.TOK_QUOTEDIDENTIFIER];
                        var keyToken;
                        var keyName;
                        var value;
                        // tslint:disable-next-line: prettier
                        for (;;) {
                            keyToken = this.lookaheadToken(0);
                            if (!identifierTypes.includes(keyToken.type)) {
                                throw new Error("Expecting an identifier token, got: " + keyToken.type);
                            }
                            keyName = keyToken.value;
                            this.advance();
                            this.match(Token.TOK_COLON);
                            value = this.expression(0);
                            pairs.push({ value: value, type: 'KeyValuePair', name: keyName });
                            if (this.lookahead(0) === Token.TOK_COMMA) {
                                this.match(Token.TOK_COMMA);
                            }
                            else if (this.lookahead(0) === Token.TOK_RBRACE) {
                                this.match(Token.TOK_RBRACE);
                                break;
                            }
                        }
                        return { type: 'MultiSelectHash', children: pairs };
                    };
                    return TokenParser;
                }());
                var Parser = new TokenParser();
                var InputArgument;
                (function (InputArgument) {
                    InputArgument[InputArgument["TYPE_NUMBER"] = 0] = "TYPE_NUMBER";
                    InputArgument[InputArgument["TYPE_ANY"] = 1] = "TYPE_ANY";
                    InputArgument[InputArgument["TYPE_STRING"] = 2] = "TYPE_STRING";
                    InputArgument[InputArgument["TYPE_ARRAY"] = 3] = "TYPE_ARRAY";
                    InputArgument[InputArgument["TYPE_OBJECT"] = 4] = "TYPE_OBJECT";
                    InputArgument[InputArgument["TYPE_BOOLEAN"] = 5] = "TYPE_BOOLEAN";
                    InputArgument[InputArgument["TYPE_EXPREF"] = 6] = "TYPE_EXPREF";
                    InputArgument[InputArgument["TYPE_NULL"] = 7] = "TYPE_NULL";
                    InputArgument[InputArgument["TYPE_ARRAY_NUMBER"] = 8] = "TYPE_ARRAY_NUMBER";
                    InputArgument[InputArgument["TYPE_ARRAY_STRING"] = 9] = "TYPE_ARRAY_STRING";
                })(InputArgument || (InputArgument = {}));
                var Runtime = /** @class */ (function () {
                    function Runtime(interpreter) {
                        var _e;
                        var _this_1 = this;
                        this.TYPE_NAME_TABLE = (_e = {},
                            _e[InputArgument.TYPE_NUMBER] = 'number',
                            _e[InputArgument.TYPE_ANY] = 'any',
                            _e[InputArgument.TYPE_STRING] = 'string',
                            _e[InputArgument.TYPE_ARRAY] = 'array',
                            _e[InputArgument.TYPE_OBJECT] = 'object',
                            _e[InputArgument.TYPE_BOOLEAN] = 'boolean',
                            _e[InputArgument.TYPE_EXPREF] = 'expression',
                            _e[InputArgument.TYPE_NULL] = 'null',
                            _e[InputArgument.TYPE_ARRAY_NUMBER] = 'Array<number>',
                            _e[InputArgument.TYPE_ARRAY_STRING] = 'Array<string>',
                            _e);
                        this.functionAbs = function (_e) {
                            var inputValue = _e[0];
                            return Math.abs(inputValue);
                        };
                        this.functionAvg = function (_e) {
                            var inputArray = _e[0];
                            var sum = 0;
                            for (var i = 0; i < inputArray.length; i += 1) {
                                sum += inputArray[i];
                            }
                            return sum / inputArray.length;
                        };
                        this.functionCeil = function (_e) {
                            var inputValue = _e[0];
                            return Math.ceil(inputValue);
                        };
                        this.functionContains = function (resolvedArgs) {
                            var searchable = resolvedArgs[0], searchValue = resolvedArgs[1];
                            return searchable.includes(searchValue);
                        };
                        this.functionEndsWith = function (resolvedArgs) {
                            var searchStr = resolvedArgs[0], suffix = resolvedArgs[1];
                            return searchStr.includes(suffix, searchStr.length - suffix.length);
                        };
                        this.functionFloor = function (_e) {
                            var inputValue = _e[0];
                            return Math.floor(inputValue);
                        };
                        this.functionJoin = function (resolvedArgs) {
                            var joinChar = resolvedArgs[0], listJoin = resolvedArgs[1];
                            return listJoin.join(joinChar);
                        };
                        this.functionKeys = function (_e) {
                            var inputObject = _e[0];
                            return Object.keys(inputObject);
                        };
                        this.functionLength = function (_e) {
                            var inputValue = _e[0];
                            if (!isObject(inputValue)) {
                                return inputValue.length;
                            }
                            return Object.keys(inputValue).length;
                        };
                        this.functionMap = function (resolvedArgs) {
                            if (!_this_1._interpreter) {
                                return [];
                            }
                            var mapped = [];
                            var interpreter = _this_1._interpreter;
                            var exprefNode = resolvedArgs[0];
                            var elements = resolvedArgs[1];
                            for (var i = 0; i < elements.length; i += 1) {
                                mapped.push(interpreter.visit(exprefNode, elements[i]));
                            }
                            return mapped;
                        };
                        this.functionMax = function (_e) {
                            var inputValue = _e[0];
                            if (!inputValue.length) {
                                return null;
                            }
                            var typeName = _this_1.getTypeName(inputValue[0]);
                            if (typeName === InputArgument.TYPE_NUMBER) {
                                return Math.max.apply(Math, inputValue);
                            }
                            var elements = inputValue;
                            var maxElement = elements[0];
                            for (var i = 1; i < elements.length; i += 1) {
                                if (maxElement.localeCompare(elements[i]) < 0) {
                                    maxElement = elements[i];
                                }
                            }
                            return maxElement;
                        };
                        this.functionMaxBy = function (resolvedArgs) {
                            var exprefNode = resolvedArgs[1];
                            var resolvedArray = resolvedArgs[0];
                            var keyFunction = _this_1.createKeyFunction(exprefNode, [InputArgument.TYPE_NUMBER, InputArgument.TYPE_STRING]);
                            var maxNumber = -Infinity;
                            var maxRecord;
                            var current;
                            for (var i = 0; i < resolvedArray.length; i += 1) {
                                current = keyFunction && keyFunction(resolvedArray[i]);
                                if (current !== undefined && current > maxNumber) {
                                    maxNumber = current;
                                    maxRecord = resolvedArray[i];
                                }
                            }
                            return maxRecord;
                        };
                        this.functionMerge = function (resolvedArgs) {
                            var merged = {};
                            for (var i = 0; i < resolvedArgs.length; i += 1) {
                                var current = resolvedArgs[i];
                                merged = Object.assign(merged, current);
                                // for (const key in current) {
                                //   merged[key] = current[key];
                                // }
                            }
                            return merged;
                        };
                        this.functionMin = function (_e) {
                            var inputValue = _e[0];
                            if (!inputValue.length) {
                                return null;
                            }
                            var typeName = _this_1.getTypeName(inputValue[0]);
                            if (typeName === InputArgument.TYPE_NUMBER) {
                                return Math.min.apply(Math, inputValue);
                            }
                            var elements = inputValue;
                            var minElement = elements[0];
                            for (var i = 1; i < elements.length; i += 1) {
                                if (elements[i].localeCompare(minElement) < 0) {
                                    minElement = elements[i];
                                }
                            }
                            return minElement;
                        };
                        this.functionMinBy = function (resolvedArgs) {
                            var exprefNode = resolvedArgs[1];
                            var resolvedArray = resolvedArgs[0];
                            var keyFunction = _this_1.createKeyFunction(exprefNode, [InputArgument.TYPE_NUMBER, InputArgument.TYPE_STRING]);
                            var minNumber = Infinity;
                            var minRecord;
                            var current;
                            for (var i = 0; i < resolvedArray.length; i += 1) {
                                current = keyFunction && keyFunction(resolvedArray[i]);
                                if (current !== undefined && current < minNumber) {
                                    minNumber = current;
                                    minRecord = resolvedArray[i];
                                }
                            }
                            return minRecord;
                        };
                        this.functionNotNull = function (resolvedArgs) {
                            for (var i = 0; i < resolvedArgs.length; i += 1) {
                                if (_this_1.getTypeName(resolvedArgs[i]) !== InputArgument.TYPE_NULL) {
                                    return resolvedArgs[i];
                                }
                            }
                            return null;
                        };
                        this.functionReverse = function (_e) {
                            var inputValue = _e[0];
                            var typeName = _this_1.getTypeName(inputValue);
                            if (typeName === InputArgument.TYPE_STRING) {
                                var originalStr = inputValue;
                                var reversedStr = '';
                                for (var i = originalStr.length - 1; i >= 0; i -= 1) {
                                    reversedStr += originalStr[i];
                                }
                                return reversedStr;
                            }
                            var reversedArray = inputValue.slice(0);
                            reversedArray.reverse();
                            return reversedArray;
                        };
                        this.functionSort = function (_e) {
                            var inputValue = _e[0];
                            return __spreadArray([], inputValue).sort();
                        };
                        this.functionSortBy = function (resolvedArgs) {
                            if (!_this_1._interpreter) {
                                return [];
                            }
                            var sortedArray = resolvedArgs[0].slice(0);
                            if (sortedArray.length === 0) {
                                return sortedArray;
                            }
                            var interpreter = _this_1._interpreter;
                            var exprefNode = resolvedArgs[1];
                            var requiredType = _this_1.getTypeName(interpreter.visit(exprefNode, sortedArray[0]));
                            if (requiredType !== undefined && ![InputArgument.TYPE_NUMBER, InputArgument.TYPE_STRING].includes(requiredType)) {
                                throw new Error("TypeError: unexpected type (" + _this_1.TYPE_NAME_TABLE[requiredType] + ")");
                            }
                            var decorated = [];
                            for (var i = 0; i < sortedArray.length; i += 1) {
                                decorated.push([i, sortedArray[i]]);
                            }
                            decorated.sort(function (a, b) {
                                var exprA = interpreter.visit(exprefNode, a[1]);
                                var exprB = interpreter.visit(exprefNode, b[1]);
                                if (_this_1.getTypeName(exprA) !== requiredType) {
                                    throw new Error("TypeError: expected (" + _this_1.TYPE_NAME_TABLE[requiredType] + "), received " + _this_1.TYPE_NAME_TABLE[_this_1.getTypeName(exprA)]);
                                }
                                else if (_this_1.getTypeName(exprB) !== requiredType) {
                                    throw new Error("TypeError: expected (" + _this_1.TYPE_NAME_TABLE[requiredType] + "), received " + _this_1.TYPE_NAME_TABLE[_this_1.getTypeName(exprB)]);
                                }
                                if (exprA > exprB) {
                                    return 1;
                                }
                                return exprA < exprB ? -1 : a[0] - b[0];
                            });
                            for (var j = 0; j < decorated.length; j += 1) {
                                sortedArray[j] = decorated[j][1];
                            }
                            return sortedArray;
                        };
                        this.functionStartsWith = function (_e) {
                            var searchable = _e[0], searchStr = _e[1];
                            return searchable.startsWith(searchStr);
                        };
                        this.functionSum = function (_e) {
                            var inputValue = _e[0];
                            return inputValue.reduce(function (x, y) { return x + y; }, 0);
                        };
                        this.functionToArray = function (_e) {
                            var inputValue = _e[0];
                            if (_this_1.getTypeName(inputValue) === InputArgument.TYPE_ARRAY) {
                                return inputValue;
                            }
                            return [inputValue];
                        };
                        this.functionToNumber = function (_e) {
                            var inputValue = _e[0];
                            var typeName = _this_1.getTypeName(inputValue);
                            var convertedValue;
                            if (typeName === InputArgument.TYPE_NUMBER) {
                                return inputValue;
                            }
                            if (typeName === InputArgument.TYPE_STRING) {
                                convertedValue = +inputValue;
                                if (!isNaN(convertedValue)) {
                                    return convertedValue;
                                }
                            }
                            return null;
                        };
                        this.functionToString = function (_e) {
                            var inputValue = _e[0];
                            if (_this_1.getTypeName(inputValue) === InputArgument.TYPE_STRING) {
                                return inputValue;
                            }
                            return JSON.stringify(inputValue);
                        };
                        this.functionType = function (_e) {
                            var inputValue = _e[0];
                            switch (_this_1.getTypeName(inputValue)) {
                                case InputArgument.TYPE_NUMBER:
                                    return 'number';
                                case InputArgument.TYPE_STRING:
                                    return 'string';
                                case InputArgument.TYPE_ARRAY:
                                    return 'array';
                                case InputArgument.TYPE_OBJECT:
                                    return 'object';
                                case InputArgument.TYPE_BOOLEAN:
                                    return 'boolean';
                                case InputArgument.TYPE_EXPREF:
                                    return 'expref';
                                case InputArgument.TYPE_NULL:
                                    return 'null';
                                default:
                                    return;
                            }
                        };
                        this.functionValues = function (_e) {
                            var inputObject = _e[0];
                            return Object.values(inputObject);
                        };
                        this.functionTable = {
                            abs: {
                                _func: this.functionAbs,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_NUMBER],
                                    },
                                ],
                            },
                            avg: {
                                _func: this.functionAvg,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_ARRAY_NUMBER],
                                    },
                                ],
                            },
                            ceil: {
                                _func: this.functionCeil,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_NUMBER],
                                    },
                                ],
                            },
                            contains: {
                                _func: this.functionContains,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_STRING, InputArgument.TYPE_ARRAY],
                                    },
                                    {
                                        types: [InputArgument.TYPE_ANY],
                                    },
                                ],
                            },
                            ends_with: {
                                _func: this.functionEndsWith,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_STRING],
                                    },
                                    {
                                        types: [InputArgument.TYPE_STRING],
                                    },
                                ],
                            },
                            floor: {
                                _func: this.functionFloor,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_NUMBER],
                                    },
                                ],
                            },
                            join: {
                                _func: this.functionJoin,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_STRING],
                                    },
                                    {
                                        types: [InputArgument.TYPE_ARRAY_STRING],
                                    },
                                ],
                            },
                            keys: {
                                _func: this.functionKeys,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_OBJECT],
                                    },
                                ],
                            },
                            length: {
                                _func: this.functionLength,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_STRING, InputArgument.TYPE_ARRAY, InputArgument.TYPE_OBJECT],
                                    },
                                ],
                            },
                            map: {
                                _func: this.functionMap,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_EXPREF],
                                    },
                                    {
                                        types: [InputArgument.TYPE_ARRAY],
                                    },
                                ],
                            },
                            max: {
                                _func: this.functionMax,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_ARRAY_NUMBER, InputArgument.TYPE_ARRAY_STRING],
                                    },
                                ],
                            },
                            max_by: {
                                _func: this.functionMaxBy,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_ARRAY],
                                    },
                                    {
                                        types: [InputArgument.TYPE_EXPREF],
                                    },
                                ],
                            },
                            merge: {
                                _func: this.functionMerge,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_OBJECT],
                                        variadic: true,
                                    },
                                ],
                            },
                            min: {
                                _func: this.functionMin,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_ARRAY_NUMBER, InputArgument.TYPE_ARRAY_STRING],
                                    },
                                ],
                            },
                            min_by: {
                                _func: this.functionMinBy,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_ARRAY],
                                    },
                                    {
                                        types: [InputArgument.TYPE_EXPREF],
                                    },
                                ],
                            },
                            not_null: {
                                _func: this.functionNotNull,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_ANY],
                                        variadic: true,
                                    },
                                ],
                            },
                            reverse: {
                                _func: this.functionReverse,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_STRING, InputArgument.TYPE_ARRAY],
                                    },
                                ],
                            },
                            sort: {
                                _func: this.functionSort,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_ARRAY_STRING, InputArgument.TYPE_ARRAY_NUMBER],
                                    },
                                ],
                            },
                            sort_by: {
                                _func: this.functionSortBy,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_ARRAY],
                                    },
                                    {
                                        types: [InputArgument.TYPE_EXPREF],
                                    },
                                ],
                            },
                            starts_with: {
                                _func: this.functionStartsWith,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_STRING],
                                    },
                                    {
                                        types: [InputArgument.TYPE_STRING],
                                    },
                                ],
                            },
                            sum: {
                                _func: this.functionSum,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_ARRAY_NUMBER],
                                    },
                                ],
                            },
                            to_array: {
                                _func: this.functionToArray,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_ANY],
                                    },
                                ],
                            },
                            to_number: {
                                _func: this.functionToNumber,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_ANY],
                                    },
                                ],
                            },
                            to_string: {
                                _func: this.functionToString,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_ANY],
                                    },
                                ],
                            },
                            type: {
                                _func: this.functionType,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_ANY],
                                    },
                                ],
                            },
                            values: {
                                _func: this.functionValues,
                                _signature: [
                                    {
                                        types: [InputArgument.TYPE_OBJECT],
                                    },
                                ],
                            },
                        };
                        this._interpreter = interpreter;
                    }
                    Runtime.prototype.registerFunction = function (name, customFunction, signature) {
                        if (name in this.functionTable) {
                            throw new Error("Function already defined: " + name + "()");
                        }
                        this.functionTable[name] = {
                            _func: customFunction.bind(this),
                            _signature: signature,
                        };
                    };
                    Runtime.prototype.callFunction = function (name, resolvedArgs) {
                        var functionEntry = this.functionTable[name];
                        if (functionEntry === undefined) {
                            throw new Error("Unknown function: " + name + "()");
                        }
                        this.validateArgs(name, resolvedArgs, functionEntry._signature);
                        return functionEntry._func.call(this, resolvedArgs);
                    };
                    Runtime.prototype.validateInputSignatures = function (name, signature) {
                        for (var i = 0; i < signature.length; i += 1) {
                            if ('variadic' in signature[i] && i !== signature.length - 1) {
                                throw new Error("ArgumentError: " + name + "() 'variadic' argument " + (i + 1) + " must occur last");
                            }
                        }
                    };
                    Runtime.prototype.validateArgs = function (name, args, signature) {
                        var _this_1 = this;
                        var _a, _b;
                        var pluralized;
                        this.validateInputSignatures(name, signature);
                        var numberOfRequiredArgs = signature.filter(function (argSignature) { var _a; return (_a = !argSignature.optional) !== null && _a !== void 0 ? _a : false; }).length;
                        var lastArgIsVariadic = (_b = (_a = signature[signature.length - 1]) === null || _a === void 0 ? void 0 : _a.variadic) !== null && _b !== void 0 ? _b : false;
                        var tooFewArgs = args.length < numberOfRequiredArgs;
                        var tooManyArgs = args.length > signature.length;
                        var tooFewModifier = tooFewArgs && ((!lastArgIsVariadic && numberOfRequiredArgs > 1) || lastArgIsVariadic) ? 'at least ' : '';
                        if ((lastArgIsVariadic && tooFewArgs) || (!lastArgIsVariadic && (tooFewArgs || tooManyArgs))) {
                            pluralized = signature.length > 1;
                            throw new Error("ArgumentError: " + name + "() takes " + tooFewModifier + numberOfRequiredArgs + " argument" + ((pluralized && 's') || '') + " but received " + args.length);
                        }
                        var currentSpec;
                        var actualType;
                        var typeMatched;
                        for (var i = 0; i < signature.length; i += 1) {
                            typeMatched = false;
                            currentSpec = signature[i].types;
                            actualType = this.getTypeName(args[i]);
                            var j = void 0;
                            for (j = 0; j < currentSpec.length; j += 1) {
                                if (actualType !== undefined && this.typeMatches(actualType, currentSpec[j], args[i])) {
                                    typeMatched = true;
                                    break;
                                }
                            }
                            if (!typeMatched && actualType !== undefined) {
                                var expected = currentSpec
                                    .map(function (typeIdentifier) {
                                    return _this_1.TYPE_NAME_TABLE[typeIdentifier];
                                })
                                    .join(' | ');
                                throw new Error("TypeError: " + name + "() expected argument " + (i + 1) + " to be type (" + expected + ") but received type " + this.TYPE_NAME_TABLE[actualType] + " instead.");
                            }
                        }
                    };
                    Runtime.prototype.typeMatches = function (actual, expected, argValue) {
                        if (expected === InputArgument.TYPE_ANY) {
                            return true;
                        }
                        if (expected === InputArgument.TYPE_ARRAY_STRING ||
                            expected === InputArgument.TYPE_ARRAY_NUMBER ||
                            expected === InputArgument.TYPE_ARRAY) {
                            if (expected === InputArgument.TYPE_ARRAY) {
                                return actual === InputArgument.TYPE_ARRAY;
                            }
                            if (actual === InputArgument.TYPE_ARRAY) {
                                var subtype = void 0;
                                if (expected === InputArgument.TYPE_ARRAY_NUMBER) {
                                    subtype = InputArgument.TYPE_NUMBER;
                                }
                                else if (expected === InputArgument.TYPE_ARRAY_STRING) {
                                    subtype = InputArgument.TYPE_STRING;
                                }
                                for (var i = 0; i < argValue.length; i += 1) {
                                    var typeName = this.getTypeName(argValue[i]);
                                    if (typeName !== undefined && subtype !== undefined && !this.typeMatches(typeName, subtype, argValue[i])) {
                                        return false;
                                    }
                                }
                                return true;
                            }
                        }
                        else {
                            return actual === expected;
                        }
                        return false;
                    };
                    Runtime.prototype.getTypeName = function (obj) {
                        switch (Object.prototype.toString.call(obj)) {
                            case '[object String]':
                                return InputArgument.TYPE_STRING;
                            case '[object Number]':
                                return InputArgument.TYPE_NUMBER;
                            case '[object Array]':
                                return InputArgument.TYPE_ARRAY;
                            case '[object Boolean]':
                                return InputArgument.TYPE_BOOLEAN;
                            case '[object Null]':
                                return InputArgument.TYPE_NULL;
                            case '[object Object]':
                                if (obj.jmespathType === Token.TOK_EXPREF) {
                                    return InputArgument.TYPE_EXPREF;
                                }
                                return InputArgument.TYPE_OBJECT;
                            default:
                                return;
                        }
                    };
                    Runtime.prototype.createKeyFunction = function (exprefNode, allowedTypes) {
                        var _this_1 = this;
                        if (!this._interpreter) {
                            return;
                        }
                        var interpreter = this._interpreter;
                        var keyFunc = function (x) {
                            var current = interpreter.visit(exprefNode, x);
                            if (!allowedTypes.includes(_this_1.getTypeName(current))) {
                                var msg = "TypeError: expected one of (" + allowedTypes
                                    .map(function (t) { return _this_1.TYPE_NAME_TABLE[t]; })
                                    .join(' | ') + "), received " + _this_1.TYPE_NAME_TABLE[_this_1.getTypeName(current)];
                                throw new Error(msg);
                            }
                            return current;
                        };
                        return keyFunc;
                    };
                    return Runtime;
                }());
                var TreeInterpreter$1 = /** @class */ (function () {
                    function TreeInterpreter$1() {
                        this._rootValue = null;
                        this.runtime = new Runtime(this);
                    }
                    TreeInterpreter$1.prototype.search = function (node, value) {
                        this._rootValue = value;
                        return this.visit(node, value);
                    };
                    TreeInterpreter$1.prototype.visit = function (node, value) {
                        var matched;
                        var current;
                        var result;
                        var first;
                        var second;
                        var field;
                        var left;
                        var right;
                        var collected;
                        var i;
                        var base;
                        switch (node.type) {
                            case 'Field':
                                if (value === null) {
                                    return null;
                                }
                                if (isObject(value)) {
                                    field = value[node.name];
                                    if (field === undefined) {
                                        return null;
                                    }
                                    return field;
                                }
                                return null;
                            case 'Subexpression':
                                result = this.visit(node.children[0], value);
                                for (i = 1; i < node.children.length; i += 1) {
                                    result = this.visit(node.children[1], result);
                                    if (result === null) {
                                        return null;
                                    }
                                }
                                return result;
                            case 'IndexExpression':
                                left = this.visit(node.children[0], value);
                                right = this.visit(node.children[1], left);
                                return right;
                            case 'Index':
                                if (!Array.isArray(value)) {
                                    return null;
                                }
                                var index = node.value;
                                if (index < 0) {
                                    index = value.length + index;
                                }
                                result = value[index];
                                if (result === undefined) {
                                    result = null;
                                }
                                return result;
                            case 'Slice':
                                if (!Array.isArray(value)) {
                                    return null;
                                }
                                var sliceParams = __spreadArray([], node.children);
                                var computed = this.computeSliceParams(value.length, sliceParams);
                                var start = computed[0], stop_1 = computed[1], step = computed[2];
                                result = [];
                                if (step > 0) {
                                    for (i = start; i < stop_1; i += step) {
                                        result.push(value[i]);
                                    }
                                }
                                else {
                                    for (i = start; i > stop_1; i += step) {
                                        result.push(value[i]);
                                    }
                                }
                                return result;
                            case 'Projection':
                                base = this.visit(node.children[0], value);
                                if (!Array.isArray(base)) {
                                    return null;
                                }
                                collected = [];
                                for (i = 0; i < base.length; i += 1) {
                                    current = this.visit(node.children[1], base[i]);
                                    if (current !== null) {
                                        collected.push(current);
                                    }
                                }
                                return collected;
                            case 'ValueProjection':
                                base = this.visit(node.children[0], value);
                                if (!isObject(base)) {
                                    return null;
                                }
                                collected = [];
                                var values = Object.values(base);
                                for (i = 0; i < values.length; i += 1) {
                                    current = this.visit(node.children[1], values[i]);
                                    if (current !== null) {
                                        collected.push(current);
                                    }
                                }
                                return collected;
                            case 'FilterProjection':
                                base = this.visit(node.children[0], value);
                                if (!Array.isArray(base)) {
                                    return null;
                                }
                                var filtered = [];
                                var finalResults = [];
                                for (i = 0; i < base.length; i += 1) {
                                    matched = this.visit(node.children[2], base[i]);
                                    if (!isFalse(matched)) {
                                        filtered.push(base[i]);
                                    }
                                }
                                for (var j = 0; j < filtered.length; j += 1) {
                                    current = this.visit(node.children[1], filtered[j]);
                                    if (current !== null) {
                                        finalResults.push(current);
                                    }
                                }
                                return finalResults;
                            case 'Comparator':
                                first = this.visit(node.children[0], value);
                                second = this.visit(node.children[1], value);
                                switch (node.name) {
                                    case Token.TOK_EQ:
                                        result = strictDeepEqual(first, second);
                                        break;
                                    case Token.TOK_NE:
                                        result = !strictDeepEqual(first, second);
                                        break;
                                    case Token.TOK_GT:
                                        result = first > second;
                                        break;
                                    case Token.TOK_GTE:
                                        result = first >= second;
                                        break;
                                    case Token.TOK_LT:
                                        result = first < second;
                                        break;
                                    case Token.TOK_LTE:
                                        result = first <= second;
                                        break;
                                    default:
                                        throw new Error("Unknown comparator: " + node.name);
                                }
                                return result;
                            case Token.TOK_FLATTEN:
                                var original = this.visit(node.children[0], value);
                                if (!Array.isArray(original)) {
                                    return null;
                                }
                                var merged = [];
                                for (i = 0; i < original.length; i += 1) {
                                    current = original[i];
                                    if (Array.isArray(current)) {
                                        merged = __spreadArray(__spreadArray([], merged), current);
                                    }
                                    else {
                                        merged.push(current);
                                    }
                                }
                                return merged;
                            case 'Identity':
                                return value;
                            case 'MultiSelectList':
                                if (value === null) {
                                    return null;
                                }
                                collected = [];
                                for (i = 0; i < node.children.length; i += 1) {
                                    collected.push(this.visit(node.children[i], value));
                                }
                                return collected;
                            case 'MultiSelectHash':
                                if (value === null) {
                                    return null;
                                }
                                collected = {};
                                var child = void 0;
                                for (i = 0; i < node.children.length; i += 1) {
                                    child = node.children[i];
                                    collected[child.name] = this.visit(child.value, value);
                                }
                                return collected;
                            case 'OrExpression':
                                matched = this.visit(node.children[0], value);
                                if (isFalse(matched)) {
                                    matched = this.visit(node.children[1], value);
                                }
                                return matched;
                            case 'AndExpression':
                                first = this.visit(node.children[0], value);
                                if (isFalse(first)) {
                                    return first;
                                }
                                return this.visit(node.children[1], value);
                            case 'NotExpression':
                                first = this.visit(node.children[0], value);
                                return isFalse(first);
                            case 'Literal':
                                return node.value;
                            case Token.TOK_PIPE:
                                left = this.visit(node.children[0], value);
                                return this.visit(node.children[1], left);
                            case Token.TOK_CURRENT:
                                return value;
                            case Token.TOK_ROOT:
                                return this._rootValue;
                            case 'Function':
                                var resolvedArgs = [];
                                for (var j = 0; j < node.children.length; j += 1) {
                                    resolvedArgs.push(this.visit(node.children[j], value));
                                }
                                return this.runtime.callFunction(node.name, resolvedArgs);
                            case 'ExpressionReference':
                                var refNode = node.children[0];
                                refNode.jmespathType = Token.TOK_EXPREF;
                                return refNode;
                            default:
                                throw new Error("Unknown node type: " + node.type);
                        }
                    };
                    TreeInterpreter$1.prototype.computeSliceParams = function (arrayLength, sliceParams) {
                        var start = sliceParams[0], stop = sliceParams[1], step = sliceParams[2];
                        if (step === null) {
                            step = 1;
                        }
                        else if (step === 0) {
                            var error = new Error('Invalid slice, step cannot be 0');
                            error.name = 'RuntimeError';
                            throw error;
                        }
                        var stepValueNegative = step < 0 ? true : false;
                        start = start === null ? (stepValueNegative ? arrayLength - 1 : 0) : this.capSliceRange(arrayLength, start, step);
                        stop = stop === null ? (stepValueNegative ? -1 : arrayLength) : this.capSliceRange(arrayLength, stop, step);
                        return [start, stop, step];
                    };
                    TreeInterpreter$1.prototype.capSliceRange = function (arrayLength, actualValue, step) {
                        var nextActualValue = actualValue;
                        if (nextActualValue < 0) {
                            nextActualValue += arrayLength;
                            if (nextActualValue < 0) {
                                nextActualValue = step < 0 ? -1 : 0;
                            }
                        }
                        else if (nextActualValue >= arrayLength) {
                            nextActualValue = step < 0 ? arrayLength - 1 : arrayLength;
                        }
                        return nextActualValue;
                    };
                    return TreeInterpreter$1;
                }());
                var TreeInterpreterInstance = new TreeInterpreter$1();
                var TYPE_ANY = InputArgument.TYPE_ANY;
                var TYPE_ARRAY = InputArgument.TYPE_ARRAY;
                var TYPE_ARRAY_NUMBER = InputArgument.TYPE_ARRAY_NUMBER;
                var TYPE_ARRAY_STRING = InputArgument.TYPE_ARRAY_STRING;
                var TYPE_BOOLEAN = InputArgument.TYPE_BOOLEAN;
                var TYPE_EXPREF = InputArgument.TYPE_EXPREF;
                var TYPE_NULL = InputArgument.TYPE_NULL;
                var TYPE_NUMBER = InputArgument.TYPE_NUMBER;
                var TYPE_OBJECT = InputArgument.TYPE_OBJECT;
                var TYPE_STRING = InputArgument.TYPE_STRING;
                function compile(expression) {
                    var nodeTree = Parser.parse(expression);
                    return nodeTree;
                }
                function tokenize(expression) {
                    return Lexer.tokenize(expression);
                }
                var registerFunction = function (functionName, customFunction, signature) {
                    TreeInterpreterInstance.runtime.registerFunction(functionName, customFunction, signature);
                };
                function search(data, expression) {
                    var nodeTree = Parser.parse(expression);
                    return TreeInterpreterInstance.search(nodeTree, data);
                }
                var TreeInterpreter = TreeInterpreterInstance;
                var jmespath = {
                    compile: compile,
                    registerFunction: registerFunction,
                    search: search,
                    tokenize: tokenize,
                    TreeInterpreter: TreeInterpreter,
                    TYPE_ANY: TYPE_ANY,
                    TYPE_ARRAY_NUMBER: TYPE_ARRAY_NUMBER,
                    TYPE_ARRAY_STRING: TYPE_ARRAY_STRING,
                    TYPE_ARRAY: TYPE_ARRAY,
                    TYPE_BOOLEAN: TYPE_BOOLEAN,
                    TYPE_EXPREF: TYPE_EXPREF,
                    TYPE_NULL: TYPE_NULL,
                    TYPE_NUMBER: TYPE_NUMBER,
                    TYPE_OBJECT: TYPE_OBJECT,
                    TYPE_STRING: TYPE_STRING,
                };
                /* harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = (jmespath);
                /***/ 
            }),
            /***/ "./node_modules/he/he.js": 
            /*!*******************************!*\
              !*** ./node_modules/he/he.js ***!
              \*******************************/
            /***/ (function (module, exports, __webpack_require__) {
                /* module decorator */ module = __webpack_require__.nmd(module);
                var __WEBPACK_AMD_DEFINE_RESULT__; /*! https://mths.be/he v1.2.0 by @mathias | MIT license */
                ;
                (function (root) {
                    // Detect free variables `exports`.
                    var freeExports = true && exports;
                    // Detect free variable `module`.
                    var freeModule = true && module &&
                        module.exports == freeExports && module;
                    // Detect free variable `global`, from Node.js or Browserified code,
                    // and use it as `root`.
                    var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;
                    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
                        root = freeGlobal;
                    }
                    /*--------------------------------------------------------------------------*/
                    // All astral symbols.
                    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
                    // All ASCII symbols (not just printable ASCII) except those listed in the
                    // first column of the overrides table.
                    // https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides
                    var regexAsciiWhitelist = /[\x01-\x7F]/g;
                    // All BMP symbols that are not ASCII newlines, printable ASCII symbols, or
                    // code points listed in the first column of the overrides table on
                    // https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides.
                    var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
                    var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
                    var encodeMap = { '\xAD': 'shy', '\u200C': 'zwnj', '\u200D': 'zwj', '\u200E': 'lrm', '\u2063': 'ic', '\u2062': 'it', '\u2061': 'af', '\u200F': 'rlm', '\u200B': 'ZeroWidthSpace', '\u2060': 'NoBreak', '\u0311': 'DownBreve', '\u20DB': 'tdot', '\u20DC': 'DotDot', '\t': 'Tab', '\n': 'NewLine', '\u2008': 'puncsp', '\u205F': 'MediumSpace', '\u2009': 'thinsp', '\u200A': 'hairsp', '\u2004': 'emsp13', '\u2002': 'ensp', '\u2005': 'emsp14', '\u2003': 'emsp', '\u2007': 'numsp', '\xA0': 'nbsp', '\u205F\u200A': 'ThickSpace', '\u203E': 'oline', '_': 'lowbar', '\u2010': 'dash', '\u2013': 'ndash', '\u2014': 'mdash', '\u2015': 'horbar', ',': 'comma', ';': 'semi', '\u204F': 'bsemi', ':': 'colon', '\u2A74': 'Colone', '!': 'excl', '\xA1': 'iexcl', '?': 'quest', '\xBF': 'iquest', '.': 'period', '\u2025': 'nldr', '\u2026': 'mldr', '\xB7': 'middot', '\'': 'apos', '\u2018': 'lsquo', '\u2019': 'rsquo', '\u201A': 'sbquo', '\u2039': 'lsaquo', '\u203A': 'rsaquo', '"': 'quot', '\u201C': 'ldquo', '\u201D': 'rdquo', '\u201E': 'bdquo', '\xAB': 'laquo', '\xBB': 'raquo', '(': 'lpar', ')': 'rpar', '[': 'lsqb', ']': 'rsqb', '{': 'lcub', '}': 'rcub', '\u2308': 'lceil', '\u2309': 'rceil', '\u230A': 'lfloor', '\u230B': 'rfloor', '\u2985': 'lopar', '\u2986': 'ropar', '\u298B': 'lbrke', '\u298C': 'rbrke', '\u298D': 'lbrkslu', '\u298E': 'rbrksld', '\u298F': 'lbrksld', '\u2990': 'rbrkslu', '\u2991': 'langd', '\u2992': 'rangd', '\u2993': 'lparlt', '\u2994': 'rpargt', '\u2995': 'gtlPar', '\u2996': 'ltrPar', '\u27E6': 'lobrk', '\u27E7': 'robrk', '\u27E8': 'lang', '\u27E9': 'rang', '\u27EA': 'Lang', '\u27EB': 'Rang', '\u27EC': 'loang', '\u27ED': 'roang', '\u2772': 'lbbrk', '\u2773': 'rbbrk', '\u2016': 'Vert', '\xA7': 'sect', '\xB6': 'para', '@': 'commat', '*': 'ast', '/': 'sol', 'undefined': null, '&': 'amp', '#': 'num', '%': 'percnt', '\u2030': 'permil', '\u2031': 'pertenk', '\u2020': 'dagger', '\u2021': 'Dagger', '\u2022': 'bull', '\u2043': 'hybull', '\u2032': 'prime', '\u2033': 'Prime', '\u2034': 'tprime', '\u2057': 'qprime', '\u2035': 'bprime', '\u2041': 'caret', '`': 'grave', '\xB4': 'acute', '\u02DC': 'tilde', '^': 'Hat', '\xAF': 'macr', '\u02D8': 'breve', '\u02D9': 'dot', '\xA8': 'die', '\u02DA': 'ring', '\u02DD': 'dblac', '\xB8': 'cedil', '\u02DB': 'ogon', '\u02C6': 'circ', '\u02C7': 'caron', '\xB0': 'deg', '\xA9': 'copy', '\xAE': 'reg', '\u2117': 'copysr', '\u2118': 'wp', '\u211E': 'rx', '\u2127': 'mho', '\u2129': 'iiota', '\u2190': 'larr', '\u219A': 'nlarr', '\u2192': 'rarr', '\u219B': 'nrarr', '\u2191': 'uarr', '\u2193': 'darr', '\u2194': 'harr', '\u21AE': 'nharr', '\u2195': 'varr', '\u2196': 'nwarr', '\u2197': 'nearr', '\u2198': 'searr', '\u2199': 'swarr', '\u219D': 'rarrw', '\u219D\u0338': 'nrarrw', '\u219E': 'Larr', '\u219F': 'Uarr', '\u21A0': 'Rarr', '\u21A1': 'Darr', '\u21A2': 'larrtl', '\u21A3': 'rarrtl', '\u21A4': 'mapstoleft', '\u21A5': 'mapstoup', '\u21A6': 'map', '\u21A7': 'mapstodown', '\u21A9': 'larrhk', '\u21AA': 'rarrhk', '\u21AB': 'larrlp', '\u21AC': 'rarrlp', '\u21AD': 'harrw', '\u21B0': 'lsh', '\u21B1': 'rsh', '\u21B2': 'ldsh', '\u21B3': 'rdsh', '\u21B5': 'crarr', '\u21B6': 'cularr', '\u21B7': 'curarr', '\u21BA': 'olarr', '\u21BB': 'orarr', '\u21BC': 'lharu', '\u21BD': 'lhard', '\u21BE': 'uharr', '\u21BF': 'uharl', '\u21C0': 'rharu', '\u21C1': 'rhard', '\u21C2': 'dharr', '\u21C3': 'dharl', '\u21C4': 'rlarr', '\u21C5': 'udarr', '\u21C6': 'lrarr', '\u21C7': 'llarr', '\u21C8': 'uuarr', '\u21C9': 'rrarr', '\u21CA': 'ddarr', '\u21CB': 'lrhar', '\u21CC': 'rlhar', '\u21D0': 'lArr', '\u21CD': 'nlArr', '\u21D1': 'uArr', '\u21D2': 'rArr', '\u21CF': 'nrArr', '\u21D3': 'dArr', '\u21D4': 'iff', '\u21CE': 'nhArr', '\u21D5': 'vArr', '\u21D6': 'nwArr', '\u21D7': 'neArr', '\u21D8': 'seArr', '\u21D9': 'swArr', '\u21DA': 'lAarr', '\u21DB': 'rAarr', '\u21DD': 'zigrarr', '\u21E4': 'larrb', '\u21E5': 'rarrb', '\u21F5': 'duarr', '\u21FD': 'loarr', '\u21FE': 'roarr', '\u21FF': 'hoarr', '\u2200': 'forall', '\u2201': 'comp', '\u2202': 'part', '\u2202\u0338': 'npart', '\u2203': 'exist', '\u2204': 'nexist', '\u2205': 'empty', '\u2207': 'Del', '\u2208': 'in', '\u2209': 'notin', '\u220B': 'ni', '\u220C': 'notni', '\u03F6': 'bepsi', '\u220F': 'prod', '\u2210': 'coprod', '\u2211': 'sum', '+': 'plus', '\xB1': 'pm', '\xF7': 'div', '\xD7': 'times', '<': 'lt', '\u226E': 'nlt', '<\u20D2': 'nvlt', '=': 'equals', '\u2260': 'ne', '=\u20E5': 'bne', '\u2A75': 'Equal', '>': 'gt', '\u226F': 'ngt', '>\u20D2': 'nvgt', '\xAC': 'not', '|': 'vert', '\xA6': 'brvbar', '\u2212': 'minus', '\u2213': 'mp', '\u2214': 'plusdo', '\u2044': 'frasl', '\u2216': 'setmn', '\u2217': 'lowast', '\u2218': 'compfn', '\u221A': 'Sqrt', '\u221D': 'prop', '\u221E': 'infin', '\u221F': 'angrt', '\u2220': 'ang', '\u2220\u20D2': 'nang', '\u2221': 'angmsd', '\u2222': 'angsph', '\u2223': 'mid', '\u2224': 'nmid', '\u2225': 'par', '\u2226': 'npar', '\u2227': 'and', '\u2228': 'or', '\u2229': 'cap', '\u2229\uFE00': 'caps', '\u222A': 'cup', '\u222A\uFE00': 'cups', '\u222B': 'int', '\u222C': 'Int', '\u222D': 'tint', '\u2A0C': 'qint', '\u222E': 'oint', '\u222F': 'Conint', '\u2230': 'Cconint', '\u2231': 'cwint', '\u2232': 'cwconint', '\u2233': 'awconint', '\u2234': 'there4', '\u2235': 'becaus', '\u2236': 'ratio', '\u2237': 'Colon', '\u2238': 'minusd', '\u223A': 'mDDot', '\u223B': 'homtht', '\u223C': 'sim', '\u2241': 'nsim', '\u223C\u20D2': 'nvsim', '\u223D': 'bsim', '\u223D\u0331': 'race', '\u223E': 'ac', '\u223E\u0333': 'acE', '\u223F': 'acd', '\u2240': 'wr', '\u2242': 'esim', '\u2242\u0338': 'nesim', '\u2243': 'sime', '\u2244': 'nsime', '\u2245': 'cong', '\u2247': 'ncong', '\u2246': 'simne', '\u2248': 'ap', '\u2249': 'nap', '\u224A': 'ape', '\u224B': 'apid', '\u224B\u0338': 'napid', '\u224C': 'bcong', '\u224D': 'CupCap', '\u226D': 'NotCupCap', '\u224D\u20D2': 'nvap', '\u224E': 'bump', '\u224E\u0338': 'nbump', '\u224F': 'bumpe', '\u224F\u0338': 'nbumpe', '\u2250': 'doteq', '\u2250\u0338': 'nedot', '\u2251': 'eDot', '\u2252': 'efDot', '\u2253': 'erDot', '\u2254': 'colone', '\u2255': 'ecolon', '\u2256': 'ecir', '\u2257': 'cire', '\u2259': 'wedgeq', '\u225A': 'veeeq', '\u225C': 'trie', '\u225F': 'equest', '\u2261': 'equiv', '\u2262': 'nequiv', '\u2261\u20E5': 'bnequiv', '\u2264': 'le', '\u2270': 'nle', '\u2264\u20D2': 'nvle', '\u2265': 'ge', '\u2271': 'nge', '\u2265\u20D2': 'nvge', '\u2266': 'lE', '\u2266\u0338': 'nlE', '\u2267': 'gE', '\u2267\u0338': 'ngE', '\u2268\uFE00': 'lvnE', '\u2268': 'lnE', '\u2269': 'gnE', '\u2269\uFE00': 'gvnE', '\u226A': 'll', '\u226A\u0338': 'nLtv', '\u226A\u20D2': 'nLt', '\u226B': 'gg', '\u226B\u0338': 'nGtv', '\u226B\u20D2': 'nGt', '\u226C': 'twixt', '\u2272': 'lsim', '\u2274': 'nlsim', '\u2273': 'gsim', '\u2275': 'ngsim', '\u2276': 'lg', '\u2278': 'ntlg', '\u2277': 'gl', '\u2279': 'ntgl', '\u227A': 'pr', '\u2280': 'npr', '\u227B': 'sc', '\u2281': 'nsc', '\u227C': 'prcue', '\u22E0': 'nprcue', '\u227D': 'sccue', '\u22E1': 'nsccue', '\u227E': 'prsim', '\u227F': 'scsim', '\u227F\u0338': 'NotSucceedsTilde', '\u2282': 'sub', '\u2284': 'nsub', '\u2282\u20D2': 'vnsub', '\u2283': 'sup', '\u2285': 'nsup', '\u2283\u20D2': 'vnsup', '\u2286': 'sube', '\u2288': 'nsube', '\u2287': 'supe', '\u2289': 'nsupe', '\u228A\uFE00': 'vsubne', '\u228A': 'subne', '\u228B\uFE00': 'vsupne', '\u228B': 'supne', '\u228D': 'cupdot', '\u228E': 'uplus', '\u228F': 'sqsub', '\u228F\u0338': 'NotSquareSubset', '\u2290': 'sqsup', '\u2290\u0338': 'NotSquareSuperset', '\u2291': 'sqsube', '\u22E2': 'nsqsube', '\u2292': 'sqsupe', '\u22E3': 'nsqsupe', '\u2293': 'sqcap', '\u2293\uFE00': 'sqcaps', '\u2294': 'sqcup', '\u2294\uFE00': 'sqcups', '\u2295': 'oplus', '\u2296': 'ominus', '\u2297': 'otimes', '\u2298': 'osol', '\u2299': 'odot', '\u229A': 'ocir', '\u229B': 'oast', '\u229D': 'odash', '\u229E': 'plusb', '\u229F': 'minusb', '\u22A0': 'timesb', '\u22A1': 'sdotb', '\u22A2': 'vdash', '\u22AC': 'nvdash', '\u22A3': 'dashv', '\u22A4': 'top', '\u22A5': 'bot', '\u22A7': 'models', '\u22A8': 'vDash', '\u22AD': 'nvDash', '\u22A9': 'Vdash', '\u22AE': 'nVdash', '\u22AA': 'Vvdash', '\u22AB': 'VDash', '\u22AF': 'nVDash', '\u22B0': 'prurel', '\u22B2': 'vltri', '\u22EA': 'nltri', '\u22B3': 'vrtri', '\u22EB': 'nrtri', '\u22B4': 'ltrie', '\u22EC': 'nltrie', '\u22B4\u20D2': 'nvltrie', '\u22B5': 'rtrie', '\u22ED': 'nrtrie', '\u22B5\u20D2': 'nvrtrie', '\u22B6': 'origof', '\u22B7': 'imof', '\u22B8': 'mumap', '\u22B9': 'hercon', '\u22BA': 'intcal', '\u22BB': 'veebar', '\u22BD': 'barvee', '\u22BE': 'angrtvb', '\u22BF': 'lrtri', '\u22C0': 'Wedge', '\u22C1': 'Vee', '\u22C2': 'xcap', '\u22C3': 'xcup', '\u22C4': 'diam', '\u22C5': 'sdot', '\u22C6': 'Star', '\u22C7': 'divonx', '\u22C8': 'bowtie', '\u22C9': 'ltimes', '\u22CA': 'rtimes', '\u22CB': 'lthree', '\u22CC': 'rthree', '\u22CD': 'bsime', '\u22CE': 'cuvee', '\u22CF': 'cuwed', '\u22D0': 'Sub', '\u22D1': 'Sup', '\u22D2': 'Cap', '\u22D3': 'Cup', '\u22D4': 'fork', '\u22D5': 'epar', '\u22D6': 'ltdot', '\u22D7': 'gtdot', '\u22D8': 'Ll', '\u22D8\u0338': 'nLl', '\u22D9': 'Gg', '\u22D9\u0338': 'nGg', '\u22DA\uFE00': 'lesg', '\u22DA': 'leg', '\u22DB': 'gel', '\u22DB\uFE00': 'gesl', '\u22DE': 'cuepr', '\u22DF': 'cuesc', '\u22E6': 'lnsim', '\u22E7': 'gnsim', '\u22E8': 'prnsim', '\u22E9': 'scnsim', '\u22EE': 'vellip', '\u22EF': 'ctdot', '\u22F0': 'utdot', '\u22F1': 'dtdot', '\u22F2': 'disin', '\u22F3': 'isinsv', '\u22F4': 'isins', '\u22F5': 'isindot', '\u22F5\u0338': 'notindot', '\u22F6': 'notinvc', '\u22F7': 'notinvb', '\u22F9': 'isinE', '\u22F9\u0338': 'notinE', '\u22FA': 'nisd', '\u22FB': 'xnis', '\u22FC': 'nis', '\u22FD': 'notnivc', '\u22FE': 'notnivb', '\u2305': 'barwed', '\u2306': 'Barwed', '\u230C': 'drcrop', '\u230D': 'dlcrop', '\u230E': 'urcrop', '\u230F': 'ulcrop', '\u2310': 'bnot', '\u2312': 'profline', '\u2313': 'profsurf', '\u2315': 'telrec', '\u2316': 'target', '\u231C': 'ulcorn', '\u231D': 'urcorn', '\u231E': 'dlcorn', '\u231F': 'drcorn', '\u2322': 'frown', '\u2323': 'smile', '\u232D': 'cylcty', '\u232E': 'profalar', '\u2336': 'topbot', '\u233D': 'ovbar', '\u233F': 'solbar', '\u237C': 'angzarr', '\u23B0': 'lmoust', '\u23B1': 'rmoust', '\u23B4': 'tbrk', '\u23B5': 'bbrk', '\u23B6': 'bbrktbrk', '\u23DC': 'OverParenthesis', '\u23DD': 'UnderParenthesis', '\u23DE': 'OverBrace', '\u23DF': 'UnderBrace', '\u23E2': 'trpezium', '\u23E7': 'elinters', '\u2423': 'blank', '\u2500': 'boxh', '\u2502': 'boxv', '\u250C': 'boxdr', '\u2510': 'boxdl', '\u2514': 'boxur', '\u2518': 'boxul', '\u251C': 'boxvr', '\u2524': 'boxvl', '\u252C': 'boxhd', '\u2534': 'boxhu', '\u253C': 'boxvh', '\u2550': 'boxH', '\u2551': 'boxV', '\u2552': 'boxdR', '\u2553': 'boxDr', '\u2554': 'boxDR', '\u2555': 'boxdL', '\u2556': 'boxDl', '\u2557': 'boxDL', '\u2558': 'boxuR', '\u2559': 'boxUr', '\u255A': 'boxUR', '\u255B': 'boxuL', '\u255C': 'boxUl', '\u255D': 'boxUL', '\u255E': 'boxvR', '\u255F': 'boxVr', '\u2560': 'boxVR', '\u2561': 'boxvL', '\u2562': 'boxVl', '\u2563': 'boxVL', '\u2564': 'boxHd', '\u2565': 'boxhD', '\u2566': 'boxHD', '\u2567': 'boxHu', '\u2568': 'boxhU', '\u2569': 'boxHU', '\u256A': 'boxvH', '\u256B': 'boxVh', '\u256C': 'boxVH', '\u2580': 'uhblk', '\u2584': 'lhblk', '\u2588': 'block', '\u2591': 'blk14', '\u2592': 'blk12', '\u2593': 'blk34', '\u25A1': 'squ', '\u25AA': 'squf', '\u25AB': 'EmptyVerySmallSquare', '\u25AD': 'rect', '\u25AE': 'marker', '\u25B1': 'fltns', '\u25B3': 'xutri', '\u25B4': 'utrif', '\u25B5': 'utri', '\u25B8': 'rtrif', '\u25B9': 'rtri', '\u25BD': 'xdtri', '\u25BE': 'dtrif', '\u25BF': 'dtri', '\u25C2': 'ltrif', '\u25C3': 'ltri', '\u25CA': 'loz', '\u25CB': 'cir', '\u25EC': 'tridot', '\u25EF': 'xcirc', '\u25F8': 'ultri', '\u25F9': 'urtri', '\u25FA': 'lltri', '\u25FB': 'EmptySmallSquare', '\u25FC': 'FilledSmallSquare', '\u2605': 'starf', '\u2606': 'star', '\u260E': 'phone', '\u2640': 'female', '\u2642': 'male', '\u2660': 'spades', '\u2663': 'clubs', '\u2665': 'hearts', '\u2666': 'diams', '\u266A': 'sung', '\u2713': 'check', '\u2717': 'cross', '\u2720': 'malt', '\u2736': 'sext', '\u2758': 'VerticalSeparator', '\u27C8': 'bsolhsub', '\u27C9': 'suphsol', '\u27F5': 'xlarr', '\u27F6': 'xrarr', '\u27F7': 'xharr', '\u27F8': 'xlArr', '\u27F9': 'xrArr', '\u27FA': 'xhArr', '\u27FC': 'xmap', '\u27FF': 'dzigrarr', '\u2902': 'nvlArr', '\u2903': 'nvrArr', '\u2904': 'nvHarr', '\u2905': 'Map', '\u290C': 'lbarr', '\u290D': 'rbarr', '\u290E': 'lBarr', '\u290F': 'rBarr', '\u2910': 'RBarr', '\u2911': 'DDotrahd', '\u2912': 'UpArrowBar', '\u2913': 'DownArrowBar', '\u2916': 'Rarrtl', '\u2919': 'latail', '\u291A': 'ratail', '\u291B': 'lAtail', '\u291C': 'rAtail', '\u291D': 'larrfs', '\u291E': 'rarrfs', '\u291F': 'larrbfs', '\u2920': 'rarrbfs', '\u2923': 'nwarhk', '\u2924': 'nearhk', '\u2925': 'searhk', '\u2926': 'swarhk', '\u2927': 'nwnear', '\u2928': 'toea', '\u2929': 'tosa', '\u292A': 'swnwar', '\u2933': 'rarrc', '\u2933\u0338': 'nrarrc', '\u2935': 'cudarrr', '\u2936': 'ldca', '\u2937': 'rdca', '\u2938': 'cudarrl', '\u2939': 'larrpl', '\u293C': 'curarrm', '\u293D': 'cularrp', '\u2945': 'rarrpl', '\u2948': 'harrcir', '\u2949': 'Uarrocir', '\u294A': 'lurdshar', '\u294B': 'ldrushar', '\u294E': 'LeftRightVector', '\u294F': 'RightUpDownVector', '\u2950': 'DownLeftRightVector', '\u2951': 'LeftUpDownVector', '\u2952': 'LeftVectorBar', '\u2953': 'RightVectorBar', '\u2954': 'RightUpVectorBar', '\u2955': 'RightDownVectorBar', '\u2956': 'DownLeftVectorBar', '\u2957': 'DownRightVectorBar', '\u2958': 'LeftUpVectorBar', '\u2959': 'LeftDownVectorBar', '\u295A': 'LeftTeeVector', '\u295B': 'RightTeeVector', '\u295C': 'RightUpTeeVector', '\u295D': 'RightDownTeeVector', '\u295E': 'DownLeftTeeVector', '\u295F': 'DownRightTeeVector', '\u2960': 'LeftUpTeeVector', '\u2961': 'LeftDownTeeVector', '\u2962': 'lHar', '\u2963': 'uHar', '\u2964': 'rHar', '\u2965': 'dHar', '\u2966': 'luruhar', '\u2967': 'ldrdhar', '\u2968': 'ruluhar', '\u2969': 'rdldhar', '\u296A': 'lharul', '\u296B': 'llhard', '\u296C': 'rharul', '\u296D': 'lrhard', '\u296E': 'udhar', '\u296F': 'duhar', '\u2970': 'RoundImplies', '\u2971': 'erarr', '\u2972': 'simrarr', '\u2973': 'larrsim', '\u2974': 'rarrsim', '\u2975': 'rarrap', '\u2976': 'ltlarr', '\u2978': 'gtrarr', '\u2979': 'subrarr', '\u297B': 'suplarr', '\u297C': 'lfisht', '\u297D': 'rfisht', '\u297E': 'ufisht', '\u297F': 'dfisht', '\u299A': 'vzigzag', '\u299C': 'vangrt', '\u299D': 'angrtvbd', '\u29A4': 'ange', '\u29A5': 'range', '\u29A6': 'dwangle', '\u29A7': 'uwangle', '\u29A8': 'angmsdaa', '\u29A9': 'angmsdab', '\u29AA': 'angmsdac', '\u29AB': 'angmsdad', '\u29AC': 'angmsdae', '\u29AD': 'angmsdaf', '\u29AE': 'angmsdag', '\u29AF': 'angmsdah', '\u29B0': 'bemptyv', '\u29B1': 'demptyv', '\u29B2': 'cemptyv', '\u29B3': 'raemptyv', '\u29B4': 'laemptyv', '\u29B5': 'ohbar', '\u29B6': 'omid', '\u29B7': 'opar', '\u29B9': 'operp', '\u29BB': 'olcross', '\u29BC': 'odsold', '\u29BE': 'olcir', '\u29BF': 'ofcir', '\u29C0': 'olt', '\u29C1': 'ogt', '\u29C2': 'cirscir', '\u29C3': 'cirE', '\u29C4': 'solb', '\u29C5': 'bsolb', '\u29C9': 'boxbox', '\u29CD': 'trisb', '\u29CE': 'rtriltri', '\u29CF': 'LeftTriangleBar', '\u29CF\u0338': 'NotLeftTriangleBar', '\u29D0': 'RightTriangleBar', '\u29D0\u0338': 'NotRightTriangleBar', '\u29DC': 'iinfin', '\u29DD': 'infintie', '\u29DE': 'nvinfin', '\u29E3': 'eparsl', '\u29E4': 'smeparsl', '\u29E5': 'eqvparsl', '\u29EB': 'lozf', '\u29F4': 'RuleDelayed', '\u29F6': 'dsol', '\u2A00': 'xodot', '\u2A01': 'xoplus', '\u2A02': 'xotime', '\u2A04': 'xuplus', '\u2A06': 'xsqcup', '\u2A0D': 'fpartint', '\u2A10': 'cirfnint', '\u2A11': 'awint', '\u2A12': 'rppolint', '\u2A13': 'scpolint', '\u2A14': 'npolint', '\u2A15': 'pointint', '\u2A16': 'quatint', '\u2A17': 'intlarhk', '\u2A22': 'pluscir', '\u2A23': 'plusacir', '\u2A24': 'simplus', '\u2A25': 'plusdu', '\u2A26': 'plussim', '\u2A27': 'plustwo', '\u2A29': 'mcomma', '\u2A2A': 'minusdu', '\u2A2D': 'loplus', '\u2A2E': 'roplus', '\u2A2F': 'Cross', '\u2A30': 'timesd', '\u2A31': 'timesbar', '\u2A33': 'smashp', '\u2A34': 'lotimes', '\u2A35': 'rotimes', '\u2A36': 'otimesas', '\u2A37': 'Otimes', '\u2A38': 'odiv', '\u2A39': 'triplus', '\u2A3A': 'triminus', '\u2A3B': 'tritime', '\u2A3C': 'iprod', '\u2A3F': 'amalg', '\u2A40': 'capdot', '\u2A42': 'ncup', '\u2A43': 'ncap', '\u2A44': 'capand', '\u2A45': 'cupor', '\u2A46': 'cupcap', '\u2A47': 'capcup', '\u2A48': 'cupbrcap', '\u2A49': 'capbrcup', '\u2A4A': 'cupcup', '\u2A4B': 'capcap', '\u2A4C': 'ccups', '\u2A4D': 'ccaps', '\u2A50': 'ccupssm', '\u2A53': 'And', '\u2A54': 'Or', '\u2A55': 'andand', '\u2A56': 'oror', '\u2A57': 'orslope', '\u2A58': 'andslope', '\u2A5A': 'andv', '\u2A5B': 'orv', '\u2A5C': 'andd', '\u2A5D': 'ord', '\u2A5F': 'wedbar', '\u2A66': 'sdote', '\u2A6A': 'simdot', '\u2A6D': 'congdot', '\u2A6D\u0338': 'ncongdot', '\u2A6E': 'easter', '\u2A6F': 'apacir', '\u2A70': 'apE', '\u2A70\u0338': 'napE', '\u2A71': 'eplus', '\u2A72': 'pluse', '\u2A73': 'Esim', '\u2A77': 'eDDot', '\u2A78': 'equivDD', '\u2A79': 'ltcir', '\u2A7A': 'gtcir', '\u2A7B': 'ltquest', '\u2A7C': 'gtquest', '\u2A7D': 'les', '\u2A7D\u0338': 'nles', '\u2A7E': 'ges', '\u2A7E\u0338': 'nges', '\u2A7F': 'lesdot', '\u2A80': 'gesdot', '\u2A81': 'lesdoto', '\u2A82': 'gesdoto', '\u2A83': 'lesdotor', '\u2A84': 'gesdotol', '\u2A85': 'lap', '\u2A86': 'gap', '\u2A87': 'lne', '\u2A88': 'gne', '\u2A89': 'lnap', '\u2A8A': 'gnap', '\u2A8B': 'lEg', '\u2A8C': 'gEl', '\u2A8D': 'lsime', '\u2A8E': 'gsime', '\u2A8F': 'lsimg', '\u2A90': 'gsiml', '\u2A91': 'lgE', '\u2A92': 'glE', '\u2A93': 'lesges', '\u2A94': 'gesles', '\u2A95': 'els', '\u2A96': 'egs', '\u2A97': 'elsdot', '\u2A98': 'egsdot', '\u2A99': 'el', '\u2A9A': 'eg', '\u2A9D': 'siml', '\u2A9E': 'simg', '\u2A9F': 'simlE', '\u2AA0': 'simgE', '\u2AA1': 'LessLess', '\u2AA1\u0338': 'NotNestedLessLess', '\u2AA2': 'GreaterGreater', '\u2AA2\u0338': 'NotNestedGreaterGreater', '\u2AA4': 'glj', '\u2AA5': 'gla', '\u2AA6': 'ltcc', '\u2AA7': 'gtcc', '\u2AA8': 'lescc', '\u2AA9': 'gescc', '\u2AAA': 'smt', '\u2AAB': 'lat', '\u2AAC': 'smte', '\u2AAC\uFE00': 'smtes', '\u2AAD': 'late', '\u2AAD\uFE00': 'lates', '\u2AAE': 'bumpE', '\u2AAF': 'pre', '\u2AAF\u0338': 'npre', '\u2AB0': 'sce', '\u2AB0\u0338': 'nsce', '\u2AB3': 'prE', '\u2AB4': 'scE', '\u2AB5': 'prnE', '\u2AB6': 'scnE', '\u2AB7': 'prap', '\u2AB8': 'scap', '\u2AB9': 'prnap', '\u2ABA': 'scnap', '\u2ABB': 'Pr', '\u2ABC': 'Sc', '\u2ABD': 'subdot', '\u2ABE': 'supdot', '\u2ABF': 'subplus', '\u2AC0': 'supplus', '\u2AC1': 'submult', '\u2AC2': 'supmult', '\u2AC3': 'subedot', '\u2AC4': 'supedot', '\u2AC5': 'subE', '\u2AC5\u0338': 'nsubE', '\u2AC6': 'supE', '\u2AC6\u0338': 'nsupE', '\u2AC7': 'subsim', '\u2AC8': 'supsim', '\u2ACB\uFE00': 'vsubnE', '\u2ACB': 'subnE', '\u2ACC\uFE00': 'vsupnE', '\u2ACC': 'supnE', '\u2ACF': 'csub', '\u2AD0': 'csup', '\u2AD1': 'csube', '\u2AD2': 'csupe', '\u2AD3': 'subsup', '\u2AD4': 'supsub', '\u2AD5': 'subsub', '\u2AD6': 'supsup', '\u2AD7': 'suphsub', '\u2AD8': 'supdsub', '\u2AD9': 'forkv', '\u2ADA': 'topfork', '\u2ADB': 'mlcp', '\u2AE4': 'Dashv', '\u2AE6': 'Vdashl', '\u2AE7': 'Barv', '\u2AE8': 'vBar', '\u2AE9': 'vBarv', '\u2AEB': 'Vbar', '\u2AEC': 'Not', '\u2AED': 'bNot', '\u2AEE': 'rnmid', '\u2AEF': 'cirmid', '\u2AF0': 'midcir', '\u2AF1': 'topcir', '\u2AF2': 'nhpar', '\u2AF3': 'parsim', '\u2AFD': 'parsl', '\u2AFD\u20E5': 'nparsl', '\u266D': 'flat', '\u266E': 'natur', '\u266F': 'sharp', '\xA4': 'curren', '\xA2': 'cent', '$': 'dollar', '\xA3': 'pound', '\xA5': 'yen', '\u20AC': 'euro', '\xB9': 'sup1', '\xBD': 'half', '\u2153': 'frac13', '\xBC': 'frac14', '\u2155': 'frac15', '\u2159': 'frac16', '\u215B': 'frac18', '\xB2': 'sup2', '\u2154': 'frac23', '\u2156': 'frac25', '\xB3': 'sup3', '\xBE': 'frac34', '\u2157': 'frac35', '\u215C': 'frac38', '\u2158': 'frac45', '\u215A': 'frac56', '\u215D': 'frac58', '\u215E': 'frac78', '\uD835\uDCB6': 'ascr', '\uD835\uDD52': 'aopf', '\uD835\uDD1E': 'afr', '\uD835\uDD38': 'Aopf', '\uD835\uDD04': 'Afr', '\uD835\uDC9C': 'Ascr', '\xAA': 'ordf', '\xE1': 'aacute', '\xC1': 'Aacute', '\xE0': 'agrave', '\xC0': 'Agrave', '\u0103': 'abreve', '\u0102': 'Abreve', '\xE2': 'acirc', '\xC2': 'Acirc', '\xE5': 'aring', '\xC5': 'angst', '\xE4': 'auml', '\xC4': 'Auml', '\xE3': 'atilde', '\xC3': 'Atilde', '\u0105': 'aogon', '\u0104': 'Aogon', '\u0101': 'amacr', '\u0100': 'Amacr', '\xE6': 'aelig', '\xC6': 'AElig', '\uD835\uDCB7': 'bscr', '\uD835\uDD53': 'bopf', '\uD835\uDD1F': 'bfr', '\uD835\uDD39': 'Bopf', '\u212C': 'Bscr', '\uD835\uDD05': 'Bfr', '\uD835\uDD20': 'cfr', '\uD835\uDCB8': 'cscr', '\uD835\uDD54': 'copf', '\u212D': 'Cfr', '\uD835\uDC9E': 'Cscr', '\u2102': 'Copf', '\u0107': 'cacute', '\u0106': 'Cacute', '\u0109': 'ccirc', '\u0108': 'Ccirc', '\u010D': 'ccaron', '\u010C': 'Ccaron', '\u010B': 'cdot', '\u010A': 'Cdot', '\xE7': 'ccedil', '\xC7': 'Ccedil', '\u2105': 'incare', '\uD835\uDD21': 'dfr', '\u2146': 'dd', '\uD835\uDD55': 'dopf', '\uD835\uDCB9': 'dscr', '\uD835\uDC9F': 'Dscr', '\uD835\uDD07': 'Dfr', '\u2145': 'DD', '\uD835\uDD3B': 'Dopf', '\u010F': 'dcaron', '\u010E': 'Dcaron', '\u0111': 'dstrok', '\u0110': 'Dstrok', '\xF0': 'eth', '\xD0': 'ETH', '\u2147': 'ee', '\u212F': 'escr', '\uD835\uDD22': 'efr', '\uD835\uDD56': 'eopf', '\u2130': 'Escr', '\uD835\uDD08': 'Efr', '\uD835\uDD3C': 'Eopf', '\xE9': 'eacute', '\xC9': 'Eacute', '\xE8': 'egrave', '\xC8': 'Egrave', '\xEA': 'ecirc', '\xCA': 'Ecirc', '\u011B': 'ecaron', '\u011A': 'Ecaron', '\xEB': 'euml', '\xCB': 'Euml', '\u0117': 'edot', '\u0116': 'Edot', '\u0119': 'eogon', '\u0118': 'Eogon', '\u0113': 'emacr', '\u0112': 'Emacr', '\uD835\uDD23': 'ffr', '\uD835\uDD57': 'fopf', '\uD835\uDCBB': 'fscr', '\uD835\uDD09': 'Ffr', '\uD835\uDD3D': 'Fopf', '\u2131': 'Fscr', '\uFB00': 'fflig', '\uFB03': 'ffilig', '\uFB04': 'ffllig', '\uFB01': 'filig', 'fj': 'fjlig', '\uFB02': 'fllig', '\u0192': 'fnof', '\u210A': 'gscr', '\uD835\uDD58': 'gopf', '\uD835\uDD24': 'gfr', '\uD835\uDCA2': 'Gscr', '\uD835\uDD3E': 'Gopf', '\uD835\uDD0A': 'Gfr', '\u01F5': 'gacute', '\u011F': 'gbreve', '\u011E': 'Gbreve', '\u011D': 'gcirc', '\u011C': 'Gcirc', '\u0121': 'gdot', '\u0120': 'Gdot', '\u0122': 'Gcedil', '\uD835\uDD25': 'hfr', '\u210E': 'planckh', '\uD835\uDCBD': 'hscr', '\uD835\uDD59': 'hopf', '\u210B': 'Hscr', '\u210C': 'Hfr', '\u210D': 'Hopf', '\u0125': 'hcirc', '\u0124': 'Hcirc', '\u210F': 'hbar', '\u0127': 'hstrok', '\u0126': 'Hstrok', '\uD835\uDD5A': 'iopf', '\uD835\uDD26': 'ifr', '\uD835\uDCBE': 'iscr', '\u2148': 'ii', '\uD835\uDD40': 'Iopf', '\u2110': 'Iscr', '\u2111': 'Im', '\xED': 'iacute', '\xCD': 'Iacute', '\xEC': 'igrave', '\xCC': 'Igrave', '\xEE': 'icirc', '\xCE': 'Icirc', '\xEF': 'iuml', '\xCF': 'Iuml', '\u0129': 'itilde', '\u0128': 'Itilde', '\u0130': 'Idot', '\u012F': 'iogon', '\u012E': 'Iogon', '\u012B': 'imacr', '\u012A': 'Imacr', '\u0133': 'ijlig', '\u0132': 'IJlig', '\u0131': 'imath', '\uD835\uDCBF': 'jscr', '\uD835\uDD5B': 'jopf', '\uD835\uDD27': 'jfr', '\uD835\uDCA5': 'Jscr', '\uD835\uDD0D': 'Jfr', '\uD835\uDD41': 'Jopf', '\u0135': 'jcirc', '\u0134': 'Jcirc', '\u0237': 'jmath', '\uD835\uDD5C': 'kopf', '\uD835\uDCC0': 'kscr', '\uD835\uDD28': 'kfr', '\uD835\uDCA6': 'Kscr', '\uD835\uDD42': 'Kopf', '\uD835\uDD0E': 'Kfr', '\u0137': 'kcedil', '\u0136': 'Kcedil', '\uD835\uDD29': 'lfr', '\uD835\uDCC1': 'lscr', '\u2113': 'ell', '\uD835\uDD5D': 'lopf', '\u2112': 'Lscr', '\uD835\uDD0F': 'Lfr', '\uD835\uDD43': 'Lopf', '\u013A': 'lacute', '\u0139': 'Lacute', '\u013E': 'lcaron', '\u013D': 'Lcaron', '\u013C': 'lcedil', '\u013B': 'Lcedil', '\u0142': 'lstrok', '\u0141': 'Lstrok', '\u0140': 'lmidot', '\u013F': 'Lmidot', '\uD835\uDD2A': 'mfr', '\uD835\uDD5E': 'mopf', '\uD835\uDCC2': 'mscr', '\uD835\uDD10': 'Mfr', '\uD835\uDD44': 'Mopf', '\u2133': 'Mscr', '\uD835\uDD2B': 'nfr', '\uD835\uDD5F': 'nopf', '\uD835\uDCC3': 'nscr', '\u2115': 'Nopf', '\uD835\uDCA9': 'Nscr', '\uD835\uDD11': 'Nfr', '\u0144': 'nacute', '\u0143': 'Nacute', '\u0148': 'ncaron', '\u0147': 'Ncaron', '\xF1': 'ntilde', '\xD1': 'Ntilde', '\u0146': 'ncedil', '\u0145': 'Ncedil', '\u2116': 'numero', '\u014B': 'eng', '\u014A': 'ENG', '\uD835\uDD60': 'oopf', '\uD835\uDD2C': 'ofr', '\u2134': 'oscr', '\uD835\uDCAA': 'Oscr', '\uD835\uDD12': 'Ofr', '\uD835\uDD46': 'Oopf', '\xBA': 'ordm', '\xF3': 'oacute', '\xD3': 'Oacute', '\xF2': 'ograve', '\xD2': 'Ograve', '\xF4': 'ocirc', '\xD4': 'Ocirc', '\xF6': 'ouml', '\xD6': 'Ouml', '\u0151': 'odblac', '\u0150': 'Odblac', '\xF5': 'otilde', '\xD5': 'Otilde', '\xF8': 'oslash', '\xD8': 'Oslash', '\u014D': 'omacr', '\u014C': 'Omacr', '\u0153': 'oelig', '\u0152': 'OElig', '\uD835\uDD2D': 'pfr', '\uD835\uDCC5': 'pscr', '\uD835\uDD61': 'popf', '\u2119': 'Popf', '\uD835\uDD13': 'Pfr', '\uD835\uDCAB': 'Pscr', '\uD835\uDD62': 'qopf', '\uD835\uDD2E': 'qfr', '\uD835\uDCC6': 'qscr', '\uD835\uDCAC': 'Qscr', '\uD835\uDD14': 'Qfr', '\u211A': 'Qopf', '\u0138': 'kgreen', '\uD835\uDD2F': 'rfr', '\uD835\uDD63': 'ropf', '\uD835\uDCC7': 'rscr', '\u211B': 'Rscr', '\u211C': 'Re', '\u211D': 'Ropf', '\u0155': 'racute', '\u0154': 'Racute', '\u0159': 'rcaron', '\u0158': 'Rcaron', '\u0157': 'rcedil', '\u0156': 'Rcedil', '\uD835\uDD64': 'sopf', '\uD835\uDCC8': 'sscr', '\uD835\uDD30': 'sfr', '\uD835\uDD4A': 'Sopf', '\uD835\uDD16': 'Sfr', '\uD835\uDCAE': 'Sscr', '\u24C8': 'oS', '\u015B': 'sacute', '\u015A': 'Sacute', '\u015D': 'scirc', '\u015C': 'Scirc', '\u0161': 'scaron', '\u0160': 'Scaron', '\u015F': 'scedil', '\u015E': 'Scedil', '\xDF': 'szlig', '\uD835\uDD31': 'tfr', '\uD835\uDCC9': 'tscr', '\uD835\uDD65': 'topf', '\uD835\uDCAF': 'Tscr', '\uD835\uDD17': 'Tfr', '\uD835\uDD4B': 'Topf', '\u0165': 'tcaron', '\u0164': 'Tcaron', '\u0163': 'tcedil', '\u0162': 'Tcedil', '\u2122': 'trade', '\u0167': 'tstrok', '\u0166': 'Tstrok', '\uD835\uDCCA': 'uscr', '\uD835\uDD66': 'uopf', '\uD835\uDD32': 'ufr', '\uD835\uDD4C': 'Uopf', '\uD835\uDD18': 'Ufr', '\uD835\uDCB0': 'Uscr', '\xFA': 'uacute', '\xDA': 'Uacute', '\xF9': 'ugrave', '\xD9': 'Ugrave', '\u016D': 'ubreve', '\u016C': 'Ubreve', '\xFB': 'ucirc', '\xDB': 'Ucirc', '\u016F': 'uring', '\u016E': 'Uring', '\xFC': 'uuml', '\xDC': 'Uuml', '\u0171': 'udblac', '\u0170': 'Udblac', '\u0169': 'utilde', '\u0168': 'Utilde', '\u0173': 'uogon', '\u0172': 'Uogon', '\u016B': 'umacr', '\u016A': 'Umacr', '\uD835\uDD33': 'vfr', '\uD835\uDD67': 'vopf', '\uD835\uDCCB': 'vscr', '\uD835\uDD19': 'Vfr', '\uD835\uDD4D': 'Vopf', '\uD835\uDCB1': 'Vscr', '\uD835\uDD68': 'wopf', '\uD835\uDCCC': 'wscr', '\uD835\uDD34': 'wfr', '\uD835\uDCB2': 'Wscr', '\uD835\uDD4E': 'Wopf', '\uD835\uDD1A': 'Wfr', '\u0175': 'wcirc', '\u0174': 'Wcirc', '\uD835\uDD35': 'xfr', '\uD835\uDCCD': 'xscr', '\uD835\uDD69': 'xopf', '\uD835\uDD4F': 'Xopf', '\uD835\uDD1B': 'Xfr', '\uD835\uDCB3': 'Xscr', '\uD835\uDD36': 'yfr', '\uD835\uDCCE': 'yscr', '\uD835\uDD6A': 'yopf', '\uD835\uDCB4': 'Yscr', '\uD835\uDD1C': 'Yfr', '\uD835\uDD50': 'Yopf', '\xFD': 'yacute', '\xDD': 'Yacute', '\u0177': 'ycirc', '\u0176': 'Ycirc', '\xFF': 'yuml', '\u0178': 'Yuml', '\uD835\uDCCF': 'zscr', '\uD835\uDD37': 'zfr', '\uD835\uDD6B': 'zopf', '\u2128': 'Zfr', '\u2124': 'Zopf', '\uD835\uDCB5': 'Zscr', '\u017A': 'zacute', '\u0179': 'Zacute', '\u017E': 'zcaron', '\u017D': 'Zcaron', '\u017C': 'zdot', '\u017B': 'Zdot', '\u01B5': 'imped', '\xFE': 'thorn', '\xDE': 'THORN', '\u0149': 'napos', '\u03B1': 'alpha', '\u0391': 'Alpha', '\u03B2': 'beta', '\u0392': 'Beta', '\u03B3': 'gamma', '\u0393': 'Gamma', '\u03B4': 'delta', '\u0394': 'Delta', '\u03B5': 'epsi', '\u03F5': 'epsiv', '\u0395': 'Epsilon', '\u03DD': 'gammad', '\u03DC': 'Gammad', '\u03B6': 'zeta', '\u0396': 'Zeta', '\u03B7': 'eta', '\u0397': 'Eta', '\u03B8': 'theta', '\u03D1': 'thetav', '\u0398': 'Theta', '\u03B9': 'iota', '\u0399': 'Iota', '\u03BA': 'kappa', '\u03F0': 'kappav', '\u039A': 'Kappa', '\u03BB': 'lambda', '\u039B': 'Lambda', '\u03BC': 'mu', '\xB5': 'micro', '\u039C': 'Mu', '\u03BD': 'nu', '\u039D': 'Nu', '\u03BE': 'xi', '\u039E': 'Xi', '\u03BF': 'omicron', '\u039F': 'Omicron', '\u03C0': 'pi', '\u03D6': 'piv', '\u03A0': 'Pi', '\u03C1': 'rho', '\u03F1': 'rhov', '\u03A1': 'Rho', '\u03C3': 'sigma', '\u03A3': 'Sigma', '\u03C2': 'sigmaf', '\u03C4': 'tau', '\u03A4': 'Tau', '\u03C5': 'upsi', '\u03A5': 'Upsilon', '\u03D2': 'Upsi', '\u03C6': 'phi', '\u03D5': 'phiv', '\u03A6': 'Phi', '\u03C7': 'chi', '\u03A7': 'Chi', '\u03C8': 'psi', '\u03A8': 'Psi', '\u03C9': 'omega', '\u03A9': 'ohm', '\u0430': 'acy', '\u0410': 'Acy', '\u0431': 'bcy', '\u0411': 'Bcy', '\u0432': 'vcy', '\u0412': 'Vcy', '\u0433': 'gcy', '\u0413': 'Gcy', '\u0453': 'gjcy', '\u0403': 'GJcy', '\u0434': 'dcy', '\u0414': 'Dcy', '\u0452': 'djcy', '\u0402': 'DJcy', '\u0435': 'iecy', '\u0415': 'IEcy', '\u0451': 'iocy', '\u0401': 'IOcy', '\u0454': 'jukcy', '\u0404': 'Jukcy', '\u0436': 'zhcy', '\u0416': 'ZHcy', '\u0437': 'zcy', '\u0417': 'Zcy', '\u0455': 'dscy', '\u0405': 'DScy', '\u0438': 'icy', '\u0418': 'Icy', '\u0456': 'iukcy', '\u0406': 'Iukcy', '\u0457': 'yicy', '\u0407': 'YIcy', '\u0439': 'jcy', '\u0419': 'Jcy', '\u0458': 'jsercy', '\u0408': 'Jsercy', '\u043A': 'kcy', '\u041A': 'Kcy', '\u045C': 'kjcy', '\u040C': 'KJcy', '\u043B': 'lcy', '\u041B': 'Lcy', '\u0459': 'ljcy', '\u0409': 'LJcy', '\u043C': 'mcy', '\u041C': 'Mcy', '\u043D': 'ncy', '\u041D': 'Ncy', '\u045A': 'njcy', '\u040A': 'NJcy', '\u043E': 'ocy', '\u041E': 'Ocy', '\u043F': 'pcy', '\u041F': 'Pcy', '\u0440': 'rcy', '\u0420': 'Rcy', '\u0441': 'scy', '\u0421': 'Scy', '\u0442': 'tcy', '\u0422': 'Tcy', '\u045B': 'tshcy', '\u040B': 'TSHcy', '\u0443': 'ucy', '\u0423': 'Ucy', '\u045E': 'ubrcy', '\u040E': 'Ubrcy', '\u0444': 'fcy', '\u0424': 'Fcy', '\u0445': 'khcy', '\u0425': 'KHcy', '\u0446': 'tscy', '\u0426': 'TScy', '\u0447': 'chcy', '\u0427': 'CHcy', '\u045F': 'dzcy', '\u040F': 'DZcy', '\u0448': 'shcy', '\u0428': 'SHcy', '\u0449': 'shchcy', '\u0429': 'SHCHcy', '\u044A': 'hardcy', '\u042A': 'HARDcy', '\u044B': 'ycy', '\u042B': 'Ycy', '\u044C': 'softcy', '\u042C': 'SOFTcy', '\u044D': 'ecy', '\u042D': 'Ecy', '\u044E': 'yucy', '\u042E': 'YUcy', '\u044F': 'yacy', '\u042F': 'YAcy', '\u2135': 'aleph', '\u2136': 'beth', '\u2137': 'gimel', '\u2138': 'daleth' };
                    var regexEscape = /["&'<>`]/g;
                    var escapeMap = {
                        '"': '&quot;',
                        '&': '&amp;',
                        '\'': '&#x27;',
                        '<': '&lt;',
                        // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
                        // following is not strictly necessary unless its part of a tag or an
                        // unquoted attribute value. Were only escaping it to support those
                        // situations, and for XML support.
                        '>': '&gt;',
                        // In Internet Explorer  8, the backtick character can be used
                        // to break out of (un)quoted attribute values or HTML comments.
                        // See http://html5sec.org/#102, http://html5sec.org/#108, and
                        // http://html5sec.org/#133.
                        '`': '&#x60;'
                    };
                    var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
                    var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
                    var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
                    var decodeMap = { 'aacute': '\xE1', 'Aacute': '\xC1', 'abreve': '\u0103', 'Abreve': '\u0102', 'ac': '\u223E', 'acd': '\u223F', 'acE': '\u223E\u0333', 'acirc': '\xE2', 'Acirc': '\xC2', 'acute': '\xB4', 'acy': '\u0430', 'Acy': '\u0410', 'aelig': '\xE6', 'AElig': '\xC6', 'af': '\u2061', 'afr': '\uD835\uDD1E', 'Afr': '\uD835\uDD04', 'agrave': '\xE0', 'Agrave': '\xC0', 'alefsym': '\u2135', 'aleph': '\u2135', 'alpha': '\u03B1', 'Alpha': '\u0391', 'amacr': '\u0101', 'Amacr': '\u0100', 'amalg': '\u2A3F', 'amp': '&', 'AMP': '&', 'and': '\u2227', 'And': '\u2A53', 'andand': '\u2A55', 'andd': '\u2A5C', 'andslope': '\u2A58', 'andv': '\u2A5A', 'ang': '\u2220', 'ange': '\u29A4', 'angle': '\u2220', 'angmsd': '\u2221', 'angmsdaa': '\u29A8', 'angmsdab': '\u29A9', 'angmsdac': '\u29AA', 'angmsdad': '\u29AB', 'angmsdae': '\u29AC', 'angmsdaf': '\u29AD', 'angmsdag': '\u29AE', 'angmsdah': '\u29AF', 'angrt': '\u221F', 'angrtvb': '\u22BE', 'angrtvbd': '\u299D', 'angsph': '\u2222', 'angst': '\xC5', 'angzarr': '\u237C', 'aogon': '\u0105', 'Aogon': '\u0104', 'aopf': '\uD835\uDD52', 'Aopf': '\uD835\uDD38', 'ap': '\u2248', 'apacir': '\u2A6F', 'ape': '\u224A', 'apE': '\u2A70', 'apid': '\u224B', 'apos': '\'', 'ApplyFunction': '\u2061', 'approx': '\u2248', 'approxeq': '\u224A', 'aring': '\xE5', 'Aring': '\xC5', 'ascr': '\uD835\uDCB6', 'Ascr': '\uD835\uDC9C', 'Assign': '\u2254', 'ast': '*', 'asymp': '\u2248', 'asympeq': '\u224D', 'atilde': '\xE3', 'Atilde': '\xC3', 'auml': '\xE4', 'Auml': '\xC4', 'awconint': '\u2233', 'awint': '\u2A11', 'backcong': '\u224C', 'backepsilon': '\u03F6', 'backprime': '\u2035', 'backsim': '\u223D', 'backsimeq': '\u22CD', 'Backslash': '\u2216', 'Barv': '\u2AE7', 'barvee': '\u22BD', 'barwed': '\u2305', 'Barwed': '\u2306', 'barwedge': '\u2305', 'bbrk': '\u23B5', 'bbrktbrk': '\u23B6', 'bcong': '\u224C', 'bcy': '\u0431', 'Bcy': '\u0411', 'bdquo': '\u201E', 'becaus': '\u2235', 'because': '\u2235', 'Because': '\u2235', 'bemptyv': '\u29B0', 'bepsi': '\u03F6', 'bernou': '\u212C', 'Bernoullis': '\u212C', 'beta': '\u03B2', 'Beta': '\u0392', 'beth': '\u2136', 'between': '\u226C', 'bfr': '\uD835\uDD1F', 'Bfr': '\uD835\uDD05', 'bigcap': '\u22C2', 'bigcirc': '\u25EF', 'bigcup': '\u22C3', 'bigodot': '\u2A00', 'bigoplus': '\u2A01', 'bigotimes': '\u2A02', 'bigsqcup': '\u2A06', 'bigstar': '\u2605', 'bigtriangledown': '\u25BD', 'bigtriangleup': '\u25B3', 'biguplus': '\u2A04', 'bigvee': '\u22C1', 'bigwedge': '\u22C0', 'bkarow': '\u290D', 'blacklozenge': '\u29EB', 'blacksquare': '\u25AA', 'blacktriangle': '\u25B4', 'blacktriangledown': '\u25BE', 'blacktriangleleft': '\u25C2', 'blacktriangleright': '\u25B8', 'blank': '\u2423', 'blk12': '\u2592', 'blk14': '\u2591', 'blk34': '\u2593', 'block': '\u2588', 'bne': '=\u20E5', 'bnequiv': '\u2261\u20E5', 'bnot': '\u2310', 'bNot': '\u2AED', 'bopf': '\uD835\uDD53', 'Bopf': '\uD835\uDD39', 'bot': '\u22A5', 'bottom': '\u22A5', 'bowtie': '\u22C8', 'boxbox': '\u29C9', 'boxdl': '\u2510', 'boxdL': '\u2555', 'boxDl': '\u2556', 'boxDL': '\u2557', 'boxdr': '\u250C', 'boxdR': '\u2552', 'boxDr': '\u2553', 'boxDR': '\u2554', 'boxh': '\u2500', 'boxH': '\u2550', 'boxhd': '\u252C', 'boxhD': '\u2565', 'boxHd': '\u2564', 'boxHD': '\u2566', 'boxhu': '\u2534', 'boxhU': '\u2568', 'boxHu': '\u2567', 'boxHU': '\u2569', 'boxminus': '\u229F', 'boxplus': '\u229E', 'boxtimes': '\u22A0', 'boxul': '\u2518', 'boxuL': '\u255B', 'boxUl': '\u255C', 'boxUL': '\u255D', 'boxur': '\u2514', 'boxuR': '\u2558', 'boxUr': '\u2559', 'boxUR': '\u255A', 'boxv': '\u2502', 'boxV': '\u2551', 'boxvh': '\u253C', 'boxvH': '\u256A', 'boxVh': '\u256B', 'boxVH': '\u256C', 'boxvl': '\u2524', 'boxvL': '\u2561', 'boxVl': '\u2562', 'boxVL': '\u2563', 'boxvr': '\u251C', 'boxvR': '\u255E', 'boxVr': '\u255F', 'boxVR': '\u2560', 'bprime': '\u2035', 'breve': '\u02D8', 'Breve': '\u02D8', 'brvbar': '\xA6', 'bscr': '\uD835\uDCB7', 'Bscr': '\u212C', 'bsemi': '\u204F', 'bsim': '\u223D', 'bsime': '\u22CD', 'bsol': '\\', 'bsolb': '\u29C5', 'bsolhsub': '\u27C8', 'bull': '\u2022', 'bullet': '\u2022', 'bump': '\u224E', 'bumpe': '\u224F', 'bumpE': '\u2AAE', 'bumpeq': '\u224F', 'Bumpeq': '\u224E', 'cacute': '\u0107', 'Cacute': '\u0106', 'cap': '\u2229', 'Cap': '\u22D2', 'capand': '\u2A44', 'capbrcup': '\u2A49', 'capcap': '\u2A4B', 'capcup': '\u2A47', 'capdot': '\u2A40', 'CapitalDifferentialD': '\u2145', 'caps': '\u2229\uFE00', 'caret': '\u2041', 'caron': '\u02C7', 'Cayleys': '\u212D', 'ccaps': '\u2A4D', 'ccaron': '\u010D', 'Ccaron': '\u010C', 'ccedil': '\xE7', 'Ccedil': '\xC7', 'ccirc': '\u0109', 'Ccirc': '\u0108', 'Cconint': '\u2230', 'ccups': '\u2A4C', 'ccupssm': '\u2A50', 'cdot': '\u010B', 'Cdot': '\u010A', 'cedil': '\xB8', 'Cedilla': '\xB8', 'cemptyv': '\u29B2', 'cent': '\xA2', 'centerdot': '\xB7', 'CenterDot': '\xB7', 'cfr': '\uD835\uDD20', 'Cfr': '\u212D', 'chcy': '\u0447', 'CHcy': '\u0427', 'check': '\u2713', 'checkmark': '\u2713', 'chi': '\u03C7', 'Chi': '\u03A7', 'cir': '\u25CB', 'circ': '\u02C6', 'circeq': '\u2257', 'circlearrowleft': '\u21BA', 'circlearrowright': '\u21BB', 'circledast': '\u229B', 'circledcirc': '\u229A', 'circleddash': '\u229D', 'CircleDot': '\u2299', 'circledR': '\xAE', 'circledS': '\u24C8', 'CircleMinus': '\u2296', 'CirclePlus': '\u2295', 'CircleTimes': '\u2297', 'cire': '\u2257', 'cirE': '\u29C3', 'cirfnint': '\u2A10', 'cirmid': '\u2AEF', 'cirscir': '\u29C2', 'ClockwiseContourIntegral': '\u2232', 'CloseCurlyDoubleQuote': '\u201D', 'CloseCurlyQuote': '\u2019', 'clubs': '\u2663', 'clubsuit': '\u2663', 'colon': ':', 'Colon': '\u2237', 'colone': '\u2254', 'Colone': '\u2A74', 'coloneq': '\u2254', 'comma': ',', 'commat': '@', 'comp': '\u2201', 'compfn': '\u2218', 'complement': '\u2201', 'complexes': '\u2102', 'cong': '\u2245', 'congdot': '\u2A6D', 'Congruent': '\u2261', 'conint': '\u222E', 'Conint': '\u222F', 'ContourIntegral': '\u222E', 'copf': '\uD835\uDD54', 'Copf': '\u2102', 'coprod': '\u2210', 'Coproduct': '\u2210', 'copy': '\xA9', 'COPY': '\xA9', 'copysr': '\u2117', 'CounterClockwiseContourIntegral': '\u2233', 'crarr': '\u21B5', 'cross': '\u2717', 'Cross': '\u2A2F', 'cscr': '\uD835\uDCB8', 'Cscr': '\uD835\uDC9E', 'csub': '\u2ACF', 'csube': '\u2AD1', 'csup': '\u2AD0', 'csupe': '\u2AD2', 'ctdot': '\u22EF', 'cudarrl': '\u2938', 'cudarrr': '\u2935', 'cuepr': '\u22DE', 'cuesc': '\u22DF', 'cularr': '\u21B6', 'cularrp': '\u293D', 'cup': '\u222A', 'Cup': '\u22D3', 'cupbrcap': '\u2A48', 'cupcap': '\u2A46', 'CupCap': '\u224D', 'cupcup': '\u2A4A', 'cupdot': '\u228D', 'cupor': '\u2A45', 'cups': '\u222A\uFE00', 'curarr': '\u21B7', 'curarrm': '\u293C', 'curlyeqprec': '\u22DE', 'curlyeqsucc': '\u22DF', 'curlyvee': '\u22CE', 'curlywedge': '\u22CF', 'curren': '\xA4', 'curvearrowleft': '\u21B6', 'curvearrowright': '\u21B7', 'cuvee': '\u22CE', 'cuwed': '\u22CF', 'cwconint': '\u2232', 'cwint': '\u2231', 'cylcty': '\u232D', 'dagger': '\u2020', 'Dagger': '\u2021', 'daleth': '\u2138', 'darr': '\u2193', 'dArr': '\u21D3', 'Darr': '\u21A1', 'dash': '\u2010', 'dashv': '\u22A3', 'Dashv': '\u2AE4', 'dbkarow': '\u290F', 'dblac': '\u02DD', 'dcaron': '\u010F', 'Dcaron': '\u010E', 'dcy': '\u0434', 'Dcy': '\u0414', 'dd': '\u2146', 'DD': '\u2145', 'ddagger': '\u2021', 'ddarr': '\u21CA', 'DDotrahd': '\u2911', 'ddotseq': '\u2A77', 'deg': '\xB0', 'Del': '\u2207', 'delta': '\u03B4', 'Delta': '\u0394', 'demptyv': '\u29B1', 'dfisht': '\u297F', 'dfr': '\uD835\uDD21', 'Dfr': '\uD835\uDD07', 'dHar': '\u2965', 'dharl': '\u21C3', 'dharr': '\u21C2', 'DiacriticalAcute': '\xB4', 'DiacriticalDot': '\u02D9', 'DiacriticalDoubleAcute': '\u02DD', 'DiacriticalGrave': '`', 'DiacriticalTilde': '\u02DC', 'diam': '\u22C4', 'diamond': '\u22C4', 'Diamond': '\u22C4', 'diamondsuit': '\u2666', 'diams': '\u2666', 'die': '\xA8', 'DifferentialD': '\u2146', 'digamma': '\u03DD', 'disin': '\u22F2', 'div': '\xF7', 'divide': '\xF7', 'divideontimes': '\u22C7', 'divonx': '\u22C7', 'djcy': '\u0452', 'DJcy': '\u0402', 'dlcorn': '\u231E', 'dlcrop': '\u230D', 'dollar': '$', 'dopf': '\uD835\uDD55', 'Dopf': '\uD835\uDD3B', 'dot': '\u02D9', 'Dot': '\xA8', 'DotDot': '\u20DC', 'doteq': '\u2250', 'doteqdot': '\u2251', 'DotEqual': '\u2250', 'dotminus': '\u2238', 'dotplus': '\u2214', 'dotsquare': '\u22A1', 'doublebarwedge': '\u2306', 'DoubleContourIntegral': '\u222F', 'DoubleDot': '\xA8', 'DoubleDownArrow': '\u21D3', 'DoubleLeftArrow': '\u21D0', 'DoubleLeftRightArrow': '\u21D4', 'DoubleLeftTee': '\u2AE4', 'DoubleLongLeftArrow': '\u27F8', 'DoubleLongLeftRightArrow': '\u27FA', 'DoubleLongRightArrow': '\u27F9', 'DoubleRightArrow': '\u21D2', 'DoubleRightTee': '\u22A8', 'DoubleUpArrow': '\u21D1', 'DoubleUpDownArrow': '\u21D5', 'DoubleVerticalBar': '\u2225', 'downarrow': '\u2193', 'Downarrow': '\u21D3', 'DownArrow': '\u2193', 'DownArrowBar': '\u2913', 'DownArrowUpArrow': '\u21F5', 'DownBreve': '\u0311', 'downdownarrows': '\u21CA', 'downharpoonleft': '\u21C3', 'downharpoonright': '\u21C2', 'DownLeftRightVector': '\u2950', 'DownLeftTeeVector': '\u295E', 'DownLeftVector': '\u21BD', 'DownLeftVectorBar': '\u2956', 'DownRightTeeVector': '\u295F', 'DownRightVector': '\u21C1', 'DownRightVectorBar': '\u2957', 'DownTee': '\u22A4', 'DownTeeArrow': '\u21A7', 'drbkarow': '\u2910', 'drcorn': '\u231F', 'drcrop': '\u230C', 'dscr': '\uD835\uDCB9', 'Dscr': '\uD835\uDC9F', 'dscy': '\u0455', 'DScy': '\u0405', 'dsol': '\u29F6', 'dstrok': '\u0111', 'Dstrok': '\u0110', 'dtdot': '\u22F1', 'dtri': '\u25BF', 'dtrif': '\u25BE', 'duarr': '\u21F5', 'duhar': '\u296F', 'dwangle': '\u29A6', 'dzcy': '\u045F', 'DZcy': '\u040F', 'dzigrarr': '\u27FF', 'eacute': '\xE9', 'Eacute': '\xC9', 'easter': '\u2A6E', 'ecaron': '\u011B', 'Ecaron': '\u011A', 'ecir': '\u2256', 'ecirc': '\xEA', 'Ecirc': '\xCA', 'ecolon': '\u2255', 'ecy': '\u044D', 'Ecy': '\u042D', 'eDDot': '\u2A77', 'edot': '\u0117', 'eDot': '\u2251', 'Edot': '\u0116', 'ee': '\u2147', 'efDot': '\u2252', 'efr': '\uD835\uDD22', 'Efr': '\uD835\uDD08', 'eg': '\u2A9A', 'egrave': '\xE8', 'Egrave': '\xC8', 'egs': '\u2A96', 'egsdot': '\u2A98', 'el': '\u2A99', 'Element': '\u2208', 'elinters': '\u23E7', 'ell': '\u2113', 'els': '\u2A95', 'elsdot': '\u2A97', 'emacr': '\u0113', 'Emacr': '\u0112', 'empty': '\u2205', 'emptyset': '\u2205', 'EmptySmallSquare': '\u25FB', 'emptyv': '\u2205', 'EmptyVerySmallSquare': '\u25AB', 'emsp': '\u2003', 'emsp13': '\u2004', 'emsp14': '\u2005', 'eng': '\u014B', 'ENG': '\u014A', 'ensp': '\u2002', 'eogon': '\u0119', 'Eogon': '\u0118', 'eopf': '\uD835\uDD56', 'Eopf': '\uD835\uDD3C', 'epar': '\u22D5', 'eparsl': '\u29E3', 'eplus': '\u2A71', 'epsi': '\u03B5', 'epsilon': '\u03B5', 'Epsilon': '\u0395', 'epsiv': '\u03F5', 'eqcirc': '\u2256', 'eqcolon': '\u2255', 'eqsim': '\u2242', 'eqslantgtr': '\u2A96', 'eqslantless': '\u2A95', 'Equal': '\u2A75', 'equals': '=', 'EqualTilde': '\u2242', 'equest': '\u225F', 'Equilibrium': '\u21CC', 'equiv': '\u2261', 'equivDD': '\u2A78', 'eqvparsl': '\u29E5', 'erarr': '\u2971', 'erDot': '\u2253', 'escr': '\u212F', 'Escr': '\u2130', 'esdot': '\u2250', 'esim': '\u2242', 'Esim': '\u2A73', 'eta': '\u03B7', 'Eta': '\u0397', 'eth': '\xF0', 'ETH': '\xD0', 'euml': '\xEB', 'Euml': '\xCB', 'euro': '\u20AC', 'excl': '!', 'exist': '\u2203', 'Exists': '\u2203', 'expectation': '\u2130', 'exponentiale': '\u2147', 'ExponentialE': '\u2147', 'fallingdotseq': '\u2252', 'fcy': '\u0444', 'Fcy': '\u0424', 'female': '\u2640', 'ffilig': '\uFB03', 'fflig': '\uFB00', 'ffllig': '\uFB04', 'ffr': '\uD835\uDD23', 'Ffr': '\uD835\uDD09', 'filig': '\uFB01', 'FilledSmallSquare': '\u25FC', 'FilledVerySmallSquare': '\u25AA', 'fjlig': 'fj', 'flat': '\u266D', 'fllig': '\uFB02', 'fltns': '\u25B1', 'fnof': '\u0192', 'fopf': '\uD835\uDD57', 'Fopf': '\uD835\uDD3D', 'forall': '\u2200', 'ForAll': '\u2200', 'fork': '\u22D4', 'forkv': '\u2AD9', 'Fouriertrf': '\u2131', 'fpartint': '\u2A0D', 'frac12': '\xBD', 'frac13': '\u2153', 'frac14': '\xBC', 'frac15': '\u2155', 'frac16': '\u2159', 'frac18': '\u215B', 'frac23': '\u2154', 'frac25': '\u2156', 'frac34': '\xBE', 'frac35': '\u2157', 'frac38': '\u215C', 'frac45': '\u2158', 'frac56': '\u215A', 'frac58': '\u215D', 'frac78': '\u215E', 'frasl': '\u2044', 'frown': '\u2322', 'fscr': '\uD835\uDCBB', 'Fscr': '\u2131', 'gacute': '\u01F5', 'gamma': '\u03B3', 'Gamma': '\u0393', 'gammad': '\u03DD', 'Gammad': '\u03DC', 'gap': '\u2A86', 'gbreve': '\u011F', 'Gbreve': '\u011E', 'Gcedil': '\u0122', 'gcirc': '\u011D', 'Gcirc': '\u011C', 'gcy': '\u0433', 'Gcy': '\u0413', 'gdot': '\u0121', 'Gdot': '\u0120', 'ge': '\u2265', 'gE': '\u2267', 'gel': '\u22DB', 'gEl': '\u2A8C', 'geq': '\u2265', 'geqq': '\u2267', 'geqslant': '\u2A7E', 'ges': '\u2A7E', 'gescc': '\u2AA9', 'gesdot': '\u2A80', 'gesdoto': '\u2A82', 'gesdotol': '\u2A84', 'gesl': '\u22DB\uFE00', 'gesles': '\u2A94', 'gfr': '\uD835\uDD24', 'Gfr': '\uD835\uDD0A', 'gg': '\u226B', 'Gg': '\u22D9', 'ggg': '\u22D9', 'gimel': '\u2137', 'gjcy': '\u0453', 'GJcy': '\u0403', 'gl': '\u2277', 'gla': '\u2AA5', 'glE': '\u2A92', 'glj': '\u2AA4', 'gnap': '\u2A8A', 'gnapprox': '\u2A8A', 'gne': '\u2A88', 'gnE': '\u2269', 'gneq': '\u2A88', 'gneqq': '\u2269', 'gnsim': '\u22E7', 'gopf': '\uD835\uDD58', 'Gopf': '\uD835\uDD3E', 'grave': '`', 'GreaterEqual': '\u2265', 'GreaterEqualLess': '\u22DB', 'GreaterFullEqual': '\u2267', 'GreaterGreater': '\u2AA2', 'GreaterLess': '\u2277', 'GreaterSlantEqual': '\u2A7E', 'GreaterTilde': '\u2273', 'gscr': '\u210A', 'Gscr': '\uD835\uDCA2', 'gsim': '\u2273', 'gsime': '\u2A8E', 'gsiml': '\u2A90', 'gt': '>', 'Gt': '\u226B', 'GT': '>', 'gtcc': '\u2AA7', 'gtcir': '\u2A7A', 'gtdot': '\u22D7', 'gtlPar': '\u2995', 'gtquest': '\u2A7C', 'gtrapprox': '\u2A86', 'gtrarr': '\u2978', 'gtrdot': '\u22D7', 'gtreqless': '\u22DB', 'gtreqqless': '\u2A8C', 'gtrless': '\u2277', 'gtrsim': '\u2273', 'gvertneqq': '\u2269\uFE00', 'gvnE': '\u2269\uFE00', 'Hacek': '\u02C7', 'hairsp': '\u200A', 'half': '\xBD', 'hamilt': '\u210B', 'hardcy': '\u044A', 'HARDcy': '\u042A', 'harr': '\u2194', 'hArr': '\u21D4', 'harrcir': '\u2948', 'harrw': '\u21AD', 'Hat': '^', 'hbar': '\u210F', 'hcirc': '\u0125', 'Hcirc': '\u0124', 'hearts': '\u2665', 'heartsuit': '\u2665', 'hellip': '\u2026', 'hercon': '\u22B9', 'hfr': '\uD835\uDD25', 'Hfr': '\u210C', 'HilbertSpace': '\u210B', 'hksearow': '\u2925', 'hkswarow': '\u2926', 'hoarr': '\u21FF', 'homtht': '\u223B', 'hookleftarrow': '\u21A9', 'hookrightarrow': '\u21AA', 'hopf': '\uD835\uDD59', 'Hopf': '\u210D', 'horbar': '\u2015', 'HorizontalLine': '\u2500', 'hscr': '\uD835\uDCBD', 'Hscr': '\u210B', 'hslash': '\u210F', 'hstrok': '\u0127', 'Hstrok': '\u0126', 'HumpDownHump': '\u224E', 'HumpEqual': '\u224F', 'hybull': '\u2043', 'hyphen': '\u2010', 'iacute': '\xED', 'Iacute': '\xCD', 'ic': '\u2063', 'icirc': '\xEE', 'Icirc': '\xCE', 'icy': '\u0438', 'Icy': '\u0418', 'Idot': '\u0130', 'iecy': '\u0435', 'IEcy': '\u0415', 'iexcl': '\xA1', 'iff': '\u21D4', 'ifr': '\uD835\uDD26', 'Ifr': '\u2111', 'igrave': '\xEC', 'Igrave': '\xCC', 'ii': '\u2148', 'iiiint': '\u2A0C', 'iiint': '\u222D', 'iinfin': '\u29DC', 'iiota': '\u2129', 'ijlig': '\u0133', 'IJlig': '\u0132', 'Im': '\u2111', 'imacr': '\u012B', 'Imacr': '\u012A', 'image': '\u2111', 'ImaginaryI': '\u2148', 'imagline': '\u2110', 'imagpart': '\u2111', 'imath': '\u0131', 'imof': '\u22B7', 'imped': '\u01B5', 'Implies': '\u21D2', 'in': '\u2208', 'incare': '\u2105', 'infin': '\u221E', 'infintie': '\u29DD', 'inodot': '\u0131', 'int': '\u222B', 'Int': '\u222C', 'intcal': '\u22BA', 'integers': '\u2124', 'Integral': '\u222B', 'intercal': '\u22BA', 'Intersection': '\u22C2', 'intlarhk': '\u2A17', 'intprod': '\u2A3C', 'InvisibleComma': '\u2063', 'InvisibleTimes': '\u2062', 'iocy': '\u0451', 'IOcy': '\u0401', 'iogon': '\u012F', 'Iogon': '\u012E', 'iopf': '\uD835\uDD5A', 'Iopf': '\uD835\uDD40', 'iota': '\u03B9', 'Iota': '\u0399', 'iprod': '\u2A3C', 'iquest': '\xBF', 'iscr': '\uD835\uDCBE', 'Iscr': '\u2110', 'isin': '\u2208', 'isindot': '\u22F5', 'isinE': '\u22F9', 'isins': '\u22F4', 'isinsv': '\u22F3', 'isinv': '\u2208', 'it': '\u2062', 'itilde': '\u0129', 'Itilde': '\u0128', 'iukcy': '\u0456', 'Iukcy': '\u0406', 'iuml': '\xEF', 'Iuml': '\xCF', 'jcirc': '\u0135', 'Jcirc': '\u0134', 'jcy': '\u0439', 'Jcy': '\u0419', 'jfr': '\uD835\uDD27', 'Jfr': '\uD835\uDD0D', 'jmath': '\u0237', 'jopf': '\uD835\uDD5B', 'Jopf': '\uD835\uDD41', 'jscr': '\uD835\uDCBF', 'Jscr': '\uD835\uDCA5', 'jsercy': '\u0458', 'Jsercy': '\u0408', 'jukcy': '\u0454', 'Jukcy': '\u0404', 'kappa': '\u03BA', 'Kappa': '\u039A', 'kappav': '\u03F0', 'kcedil': '\u0137', 'Kcedil': '\u0136', 'kcy': '\u043A', 'Kcy': '\u041A', 'kfr': '\uD835\uDD28', 'Kfr': '\uD835\uDD0E', 'kgreen': '\u0138', 'khcy': '\u0445', 'KHcy': '\u0425', 'kjcy': '\u045C', 'KJcy': '\u040C', 'kopf': '\uD835\uDD5C', 'Kopf': '\uD835\uDD42', 'kscr': '\uD835\uDCC0', 'Kscr': '\uD835\uDCA6', 'lAarr': '\u21DA', 'lacute': '\u013A', 'Lacute': '\u0139', 'laemptyv': '\u29B4', 'lagran': '\u2112', 'lambda': '\u03BB', 'Lambda': '\u039B', 'lang': '\u27E8', 'Lang': '\u27EA', 'langd': '\u2991', 'langle': '\u27E8', 'lap': '\u2A85', 'Laplacetrf': '\u2112', 'laquo': '\xAB', 'larr': '\u2190', 'lArr': '\u21D0', 'Larr': '\u219E', 'larrb': '\u21E4', 'larrbfs': '\u291F', 'larrfs': '\u291D', 'larrhk': '\u21A9', 'larrlp': '\u21AB', 'larrpl': '\u2939', 'larrsim': '\u2973', 'larrtl': '\u21A2', 'lat': '\u2AAB', 'latail': '\u2919', 'lAtail': '\u291B', 'late': '\u2AAD', 'lates': '\u2AAD\uFE00', 'lbarr': '\u290C', 'lBarr': '\u290E', 'lbbrk': '\u2772', 'lbrace': '{', 'lbrack': '[', 'lbrke': '\u298B', 'lbrksld': '\u298F', 'lbrkslu': '\u298D', 'lcaron': '\u013E', 'Lcaron': '\u013D', 'lcedil': '\u013C', 'Lcedil': '\u013B', 'lceil': '\u2308', 'lcub': '{', 'lcy': '\u043B', 'Lcy': '\u041B', 'ldca': '\u2936', 'ldquo': '\u201C', 'ldquor': '\u201E', 'ldrdhar': '\u2967', 'ldrushar': '\u294B', 'ldsh': '\u21B2', 'le': '\u2264', 'lE': '\u2266', 'LeftAngleBracket': '\u27E8', 'leftarrow': '\u2190', 'Leftarrow': '\u21D0', 'LeftArrow': '\u2190', 'LeftArrowBar': '\u21E4', 'LeftArrowRightArrow': '\u21C6', 'leftarrowtail': '\u21A2', 'LeftCeiling': '\u2308', 'LeftDoubleBracket': '\u27E6', 'LeftDownTeeVector': '\u2961', 'LeftDownVector': '\u21C3', 'LeftDownVectorBar': '\u2959', 'LeftFloor': '\u230A', 'leftharpoondown': '\u21BD', 'leftharpoonup': '\u21BC', 'leftleftarrows': '\u21C7', 'leftrightarrow': '\u2194', 'Leftrightarrow': '\u21D4', 'LeftRightArrow': '\u2194', 'leftrightarrows': '\u21C6', 'leftrightharpoons': '\u21CB', 'leftrightsquigarrow': '\u21AD', 'LeftRightVector': '\u294E', 'LeftTee': '\u22A3', 'LeftTeeArrow': '\u21A4', 'LeftTeeVector': '\u295A', 'leftthreetimes': '\u22CB', 'LeftTriangle': '\u22B2', 'LeftTriangleBar': '\u29CF', 'LeftTriangleEqual': '\u22B4', 'LeftUpDownVector': '\u2951', 'LeftUpTeeVector': '\u2960', 'LeftUpVector': '\u21BF', 'LeftUpVectorBar': '\u2958', 'LeftVector': '\u21BC', 'LeftVectorBar': '\u2952', 'leg': '\u22DA', 'lEg': '\u2A8B', 'leq': '\u2264', 'leqq': '\u2266', 'leqslant': '\u2A7D', 'les': '\u2A7D', 'lescc': '\u2AA8', 'lesdot': '\u2A7F', 'lesdoto': '\u2A81', 'lesdotor': '\u2A83', 'lesg': '\u22DA\uFE00', 'lesges': '\u2A93', 'lessapprox': '\u2A85', 'lessdot': '\u22D6', 'lesseqgtr': '\u22DA', 'lesseqqgtr': '\u2A8B', 'LessEqualGreater': '\u22DA', 'LessFullEqual': '\u2266', 'LessGreater': '\u2276', 'lessgtr': '\u2276', 'LessLess': '\u2AA1', 'lesssim': '\u2272', 'LessSlantEqual': '\u2A7D', 'LessTilde': '\u2272', 'lfisht': '\u297C', 'lfloor': '\u230A', 'lfr': '\uD835\uDD29', 'Lfr': '\uD835\uDD0F', 'lg': '\u2276', 'lgE': '\u2A91', 'lHar': '\u2962', 'lhard': '\u21BD', 'lharu': '\u21BC', 'lharul': '\u296A', 'lhblk': '\u2584', 'ljcy': '\u0459', 'LJcy': '\u0409', 'll': '\u226A', 'Ll': '\u22D8', 'llarr': '\u21C7', 'llcorner': '\u231E', 'Lleftarrow': '\u21DA', 'llhard': '\u296B', 'lltri': '\u25FA', 'lmidot': '\u0140', 'Lmidot': '\u013F', 'lmoust': '\u23B0', 'lmoustache': '\u23B0', 'lnap': '\u2A89', 'lnapprox': '\u2A89', 'lne': '\u2A87', 'lnE': '\u2268', 'lneq': '\u2A87', 'lneqq': '\u2268', 'lnsim': '\u22E6', 'loang': '\u27EC', 'loarr': '\u21FD', 'lobrk': '\u27E6', 'longleftarrow': '\u27F5', 'Longleftarrow': '\u27F8', 'LongLeftArrow': '\u27F5', 'longleftrightarrow': '\u27F7', 'Longleftrightarrow': '\u27FA', 'LongLeftRightArrow': '\u27F7', 'longmapsto': '\u27FC', 'longrightarrow': '\u27F6', 'Longrightarrow': '\u27F9', 'LongRightArrow': '\u27F6', 'looparrowleft': '\u21AB', 'looparrowright': '\u21AC', 'lopar': '\u2985', 'lopf': '\uD835\uDD5D', 'Lopf': '\uD835\uDD43', 'loplus': '\u2A2D', 'lotimes': '\u2A34', 'lowast': '\u2217', 'lowbar': '_', 'LowerLeftArrow': '\u2199', 'LowerRightArrow': '\u2198', 'loz': '\u25CA', 'lozenge': '\u25CA', 'lozf': '\u29EB', 'lpar': '(', 'lparlt': '\u2993', 'lrarr': '\u21C6', 'lrcorner': '\u231F', 'lrhar': '\u21CB', 'lrhard': '\u296D', 'lrm': '\u200E', 'lrtri': '\u22BF', 'lsaquo': '\u2039', 'lscr': '\uD835\uDCC1', 'Lscr': '\u2112', 'lsh': '\u21B0', 'Lsh': '\u21B0', 'lsim': '\u2272', 'lsime': '\u2A8D', 'lsimg': '\u2A8F', 'lsqb': '[', 'lsquo': '\u2018', 'lsquor': '\u201A', 'lstrok': '\u0142', 'Lstrok': '\u0141', 'lt': '<', 'Lt': '\u226A', 'LT': '<', 'ltcc': '\u2AA6', 'ltcir': '\u2A79', 'ltdot': '\u22D6', 'lthree': '\u22CB', 'ltimes': '\u22C9', 'ltlarr': '\u2976', 'ltquest': '\u2A7B', 'ltri': '\u25C3', 'ltrie': '\u22B4', 'ltrif': '\u25C2', 'ltrPar': '\u2996', 'lurdshar': '\u294A', 'luruhar': '\u2966', 'lvertneqq': '\u2268\uFE00', 'lvnE': '\u2268\uFE00', 'macr': '\xAF', 'male': '\u2642', 'malt': '\u2720', 'maltese': '\u2720', 'map': '\u21A6', 'Map': '\u2905', 'mapsto': '\u21A6', 'mapstodown': '\u21A7', 'mapstoleft': '\u21A4', 'mapstoup': '\u21A5', 'marker': '\u25AE', 'mcomma': '\u2A29', 'mcy': '\u043C', 'Mcy': '\u041C', 'mdash': '\u2014', 'mDDot': '\u223A', 'measuredangle': '\u2221', 'MediumSpace': '\u205F', 'Mellintrf': '\u2133', 'mfr': '\uD835\uDD2A', 'Mfr': '\uD835\uDD10', 'mho': '\u2127', 'micro': '\xB5', 'mid': '\u2223', 'midast': '*', 'midcir': '\u2AF0', 'middot': '\xB7', 'minus': '\u2212', 'minusb': '\u229F', 'minusd': '\u2238', 'minusdu': '\u2A2A', 'MinusPlus': '\u2213', 'mlcp': '\u2ADB', 'mldr': '\u2026', 'mnplus': '\u2213', 'models': '\u22A7', 'mopf': '\uD835\uDD5E', 'Mopf': '\uD835\uDD44', 'mp': '\u2213', 'mscr': '\uD835\uDCC2', 'Mscr': '\u2133', 'mstpos': '\u223E', 'mu': '\u03BC', 'Mu': '\u039C', 'multimap': '\u22B8', 'mumap': '\u22B8', 'nabla': '\u2207', 'nacute': '\u0144', 'Nacute': '\u0143', 'nang': '\u2220\u20D2', 'nap': '\u2249', 'napE': '\u2A70\u0338', 'napid': '\u224B\u0338', 'napos': '\u0149', 'napprox': '\u2249', 'natur': '\u266E', 'natural': '\u266E', 'naturals': '\u2115', 'nbsp': '\xA0', 'nbump': '\u224E\u0338', 'nbumpe': '\u224F\u0338', 'ncap': '\u2A43', 'ncaron': '\u0148', 'Ncaron': '\u0147', 'ncedil': '\u0146', 'Ncedil': '\u0145', 'ncong': '\u2247', 'ncongdot': '\u2A6D\u0338', 'ncup': '\u2A42', 'ncy': '\u043D', 'Ncy': '\u041D', 'ndash': '\u2013', 'ne': '\u2260', 'nearhk': '\u2924', 'nearr': '\u2197', 'neArr': '\u21D7', 'nearrow': '\u2197', 'nedot': '\u2250\u0338', 'NegativeMediumSpace': '\u200B', 'NegativeThickSpace': '\u200B', 'NegativeThinSpace': '\u200B', 'NegativeVeryThinSpace': '\u200B', 'nequiv': '\u2262', 'nesear': '\u2928', 'nesim': '\u2242\u0338', 'NestedGreaterGreater': '\u226B', 'NestedLessLess': '\u226A', 'NewLine': '\n', 'nexist': '\u2204', 'nexists': '\u2204', 'nfr': '\uD835\uDD2B', 'Nfr': '\uD835\uDD11', 'nge': '\u2271', 'ngE': '\u2267\u0338', 'ngeq': '\u2271', 'ngeqq': '\u2267\u0338', 'ngeqslant': '\u2A7E\u0338', 'nges': '\u2A7E\u0338', 'nGg': '\u22D9\u0338', 'ngsim': '\u2275', 'ngt': '\u226F', 'nGt': '\u226B\u20D2', 'ngtr': '\u226F', 'nGtv': '\u226B\u0338', 'nharr': '\u21AE', 'nhArr': '\u21CE', 'nhpar': '\u2AF2', 'ni': '\u220B', 'nis': '\u22FC', 'nisd': '\u22FA', 'niv': '\u220B', 'njcy': '\u045A', 'NJcy': '\u040A', 'nlarr': '\u219A', 'nlArr': '\u21CD', 'nldr': '\u2025', 'nle': '\u2270', 'nlE': '\u2266\u0338', 'nleftarrow': '\u219A', 'nLeftarrow': '\u21CD', 'nleftrightarrow': '\u21AE', 'nLeftrightarrow': '\u21CE', 'nleq': '\u2270', 'nleqq': '\u2266\u0338', 'nleqslant': '\u2A7D\u0338', 'nles': '\u2A7D\u0338', 'nless': '\u226E', 'nLl': '\u22D8\u0338', 'nlsim': '\u2274', 'nlt': '\u226E', 'nLt': '\u226A\u20D2', 'nltri': '\u22EA', 'nltrie': '\u22EC', 'nLtv': '\u226A\u0338', 'nmid': '\u2224', 'NoBreak': '\u2060', 'NonBreakingSpace': '\xA0', 'nopf': '\uD835\uDD5F', 'Nopf': '\u2115', 'not': '\xAC', 'Not': '\u2AEC', 'NotCongruent': '\u2262', 'NotCupCap': '\u226D', 'NotDoubleVerticalBar': '\u2226', 'NotElement': '\u2209', 'NotEqual': '\u2260', 'NotEqualTilde': '\u2242\u0338', 'NotExists': '\u2204', 'NotGreater': '\u226F', 'NotGreaterEqual': '\u2271', 'NotGreaterFullEqual': '\u2267\u0338', 'NotGreaterGreater': '\u226B\u0338', 'NotGreaterLess': '\u2279', 'NotGreaterSlantEqual': '\u2A7E\u0338', 'NotGreaterTilde': '\u2275', 'NotHumpDownHump': '\u224E\u0338', 'NotHumpEqual': '\u224F\u0338', 'notin': '\u2209', 'notindot': '\u22F5\u0338', 'notinE': '\u22F9\u0338', 'notinva': '\u2209', 'notinvb': '\u22F7', 'notinvc': '\u22F6', 'NotLeftTriangle': '\u22EA', 'NotLeftTriangleBar': '\u29CF\u0338', 'NotLeftTriangleEqual': '\u22EC', 'NotLess': '\u226E', 'NotLessEqual': '\u2270', 'NotLessGreater': '\u2278', 'NotLessLess': '\u226A\u0338', 'NotLessSlantEqual': '\u2A7D\u0338', 'NotLessTilde': '\u2274', 'NotNestedGreaterGreater': '\u2AA2\u0338', 'NotNestedLessLess': '\u2AA1\u0338', 'notni': '\u220C', 'notniva': '\u220C', 'notnivb': '\u22FE', 'notnivc': '\u22FD', 'NotPrecedes': '\u2280', 'NotPrecedesEqual': '\u2AAF\u0338', 'NotPrecedesSlantEqual': '\u22E0', 'NotReverseElement': '\u220C', 'NotRightTriangle': '\u22EB', 'NotRightTriangleBar': '\u29D0\u0338', 'NotRightTriangleEqual': '\u22ED', 'NotSquareSubset': '\u228F\u0338', 'NotSquareSubsetEqual': '\u22E2', 'NotSquareSuperset': '\u2290\u0338', 'NotSquareSupersetEqual': '\u22E3', 'NotSubset': '\u2282\u20D2', 'NotSubsetEqual': '\u2288', 'NotSucceeds': '\u2281', 'NotSucceedsEqual': '\u2AB0\u0338', 'NotSucceedsSlantEqual': '\u22E1', 'NotSucceedsTilde': '\u227F\u0338', 'NotSuperset': '\u2283\u20D2', 'NotSupersetEqual': '\u2289', 'NotTilde': '\u2241', 'NotTildeEqual': '\u2244', 'NotTildeFullEqual': '\u2247', 'NotTildeTilde': '\u2249', 'NotVerticalBar': '\u2224', 'npar': '\u2226', 'nparallel': '\u2226', 'nparsl': '\u2AFD\u20E5', 'npart': '\u2202\u0338', 'npolint': '\u2A14', 'npr': '\u2280', 'nprcue': '\u22E0', 'npre': '\u2AAF\u0338', 'nprec': '\u2280', 'npreceq': '\u2AAF\u0338', 'nrarr': '\u219B', 'nrArr': '\u21CF', 'nrarrc': '\u2933\u0338', 'nrarrw': '\u219D\u0338', 'nrightarrow': '\u219B', 'nRightarrow': '\u21CF', 'nrtri': '\u22EB', 'nrtrie': '\u22ED', 'nsc': '\u2281', 'nsccue': '\u22E1', 'nsce': '\u2AB0\u0338', 'nscr': '\uD835\uDCC3', 'Nscr': '\uD835\uDCA9', 'nshortmid': '\u2224', 'nshortparallel': '\u2226', 'nsim': '\u2241', 'nsime': '\u2244', 'nsimeq': '\u2244', 'nsmid': '\u2224', 'nspar': '\u2226', 'nsqsube': '\u22E2', 'nsqsupe': '\u22E3', 'nsub': '\u2284', 'nsube': '\u2288', 'nsubE': '\u2AC5\u0338', 'nsubset': '\u2282\u20D2', 'nsubseteq': '\u2288', 'nsubseteqq': '\u2AC5\u0338', 'nsucc': '\u2281', 'nsucceq': '\u2AB0\u0338', 'nsup': '\u2285', 'nsupe': '\u2289', 'nsupE': '\u2AC6\u0338', 'nsupset': '\u2283\u20D2', 'nsupseteq': '\u2289', 'nsupseteqq': '\u2AC6\u0338', 'ntgl': '\u2279', 'ntilde': '\xF1', 'Ntilde': '\xD1', 'ntlg': '\u2278', 'ntriangleleft': '\u22EA', 'ntrianglelefteq': '\u22EC', 'ntriangleright': '\u22EB', 'ntrianglerighteq': '\u22ED', 'nu': '\u03BD', 'Nu': '\u039D', 'num': '#', 'numero': '\u2116', 'numsp': '\u2007', 'nvap': '\u224D\u20D2', 'nvdash': '\u22AC', 'nvDash': '\u22AD', 'nVdash': '\u22AE', 'nVDash': '\u22AF', 'nvge': '\u2265\u20D2', 'nvgt': '>\u20D2', 'nvHarr': '\u2904', 'nvinfin': '\u29DE', 'nvlArr': '\u2902', 'nvle': '\u2264\u20D2', 'nvlt': '<\u20D2', 'nvltrie': '\u22B4\u20D2', 'nvrArr': '\u2903', 'nvrtrie': '\u22B5\u20D2', 'nvsim': '\u223C\u20D2', 'nwarhk': '\u2923', 'nwarr': '\u2196', 'nwArr': '\u21D6', 'nwarrow': '\u2196', 'nwnear': '\u2927', 'oacute': '\xF3', 'Oacute': '\xD3', 'oast': '\u229B', 'ocir': '\u229A', 'ocirc': '\xF4', 'Ocirc': '\xD4', 'ocy': '\u043E', 'Ocy': '\u041E', 'odash': '\u229D', 'odblac': '\u0151', 'Odblac': '\u0150', 'odiv': '\u2A38', 'odot': '\u2299', 'odsold': '\u29BC', 'oelig': '\u0153', 'OElig': '\u0152', 'ofcir': '\u29BF', 'ofr': '\uD835\uDD2C', 'Ofr': '\uD835\uDD12', 'ogon': '\u02DB', 'ograve': '\xF2', 'Ograve': '\xD2', 'ogt': '\u29C1', 'ohbar': '\u29B5', 'ohm': '\u03A9', 'oint': '\u222E', 'olarr': '\u21BA', 'olcir': '\u29BE', 'olcross': '\u29BB', 'oline': '\u203E', 'olt': '\u29C0', 'omacr': '\u014D', 'Omacr': '\u014C', 'omega': '\u03C9', 'Omega': '\u03A9', 'omicron': '\u03BF', 'Omicron': '\u039F', 'omid': '\u29B6', 'ominus': '\u2296', 'oopf': '\uD835\uDD60', 'Oopf': '\uD835\uDD46', 'opar': '\u29B7', 'OpenCurlyDoubleQuote': '\u201C', 'OpenCurlyQuote': '\u2018', 'operp': '\u29B9', 'oplus': '\u2295', 'or': '\u2228', 'Or': '\u2A54', 'orarr': '\u21BB', 'ord': '\u2A5D', 'order': '\u2134', 'orderof': '\u2134', 'ordf': '\xAA', 'ordm': '\xBA', 'origof': '\u22B6', 'oror': '\u2A56', 'orslope': '\u2A57', 'orv': '\u2A5B', 'oS': '\u24C8', 'oscr': '\u2134', 'Oscr': '\uD835\uDCAA', 'oslash': '\xF8', 'Oslash': '\xD8', 'osol': '\u2298', 'otilde': '\xF5', 'Otilde': '\xD5', 'otimes': '\u2297', 'Otimes': '\u2A37', 'otimesas': '\u2A36', 'ouml': '\xF6', 'Ouml': '\xD6', 'ovbar': '\u233D', 'OverBar': '\u203E', 'OverBrace': '\u23DE', 'OverBracket': '\u23B4', 'OverParenthesis': '\u23DC', 'par': '\u2225', 'para': '\xB6', 'parallel': '\u2225', 'parsim': '\u2AF3', 'parsl': '\u2AFD', 'part': '\u2202', 'PartialD': '\u2202', 'pcy': '\u043F', 'Pcy': '\u041F', 'percnt': '%', 'period': '.', 'permil': '\u2030', 'perp': '\u22A5', 'pertenk': '\u2031', 'pfr': '\uD835\uDD2D', 'Pfr': '\uD835\uDD13', 'phi': '\u03C6', 'Phi': '\u03A6', 'phiv': '\u03D5', 'phmmat': '\u2133', 'phone': '\u260E', 'pi': '\u03C0', 'Pi': '\u03A0', 'pitchfork': '\u22D4', 'piv': '\u03D6', 'planck': '\u210F', 'planckh': '\u210E', 'plankv': '\u210F', 'plus': '+', 'plusacir': '\u2A23', 'plusb': '\u229E', 'pluscir': '\u2A22', 'plusdo': '\u2214', 'plusdu': '\u2A25', 'pluse': '\u2A72', 'PlusMinus': '\xB1', 'plusmn': '\xB1', 'plussim': '\u2A26', 'plustwo': '\u2A27', 'pm': '\xB1', 'Poincareplane': '\u210C', 'pointint': '\u2A15', 'popf': '\uD835\uDD61', 'Popf': '\u2119', 'pound': '\xA3', 'pr': '\u227A', 'Pr': '\u2ABB', 'prap': '\u2AB7', 'prcue': '\u227C', 'pre': '\u2AAF', 'prE': '\u2AB3', 'prec': '\u227A', 'precapprox': '\u2AB7', 'preccurlyeq': '\u227C', 'Precedes': '\u227A', 'PrecedesEqual': '\u2AAF', 'PrecedesSlantEqual': '\u227C', 'PrecedesTilde': '\u227E', 'preceq': '\u2AAF', 'precnapprox': '\u2AB9', 'precneqq': '\u2AB5', 'precnsim': '\u22E8', 'precsim': '\u227E', 'prime': '\u2032', 'Prime': '\u2033', 'primes': '\u2119', 'prnap': '\u2AB9', 'prnE': '\u2AB5', 'prnsim': '\u22E8', 'prod': '\u220F', 'Product': '\u220F', 'profalar': '\u232E', 'profline': '\u2312', 'profsurf': '\u2313', 'prop': '\u221D', 'Proportion': '\u2237', 'Proportional': '\u221D', 'propto': '\u221D', 'prsim': '\u227E', 'prurel': '\u22B0', 'pscr': '\uD835\uDCC5', 'Pscr': '\uD835\uDCAB', 'psi': '\u03C8', 'Psi': '\u03A8', 'puncsp': '\u2008', 'qfr': '\uD835\uDD2E', 'Qfr': '\uD835\uDD14', 'qint': '\u2A0C', 'qopf': '\uD835\uDD62', 'Qopf': '\u211A', 'qprime': '\u2057', 'qscr': '\uD835\uDCC6', 'Qscr': '\uD835\uDCAC', 'quaternions': '\u210D', 'quatint': '\u2A16', 'quest': '?', 'questeq': '\u225F', 'quot': '"', 'QUOT': '"', 'rAarr': '\u21DB', 'race': '\u223D\u0331', 'racute': '\u0155', 'Racute': '\u0154', 'radic': '\u221A', 'raemptyv': '\u29B3', 'rang': '\u27E9', 'Rang': '\u27EB', 'rangd': '\u2992', 'range': '\u29A5', 'rangle': '\u27E9', 'raquo': '\xBB', 'rarr': '\u2192', 'rArr': '\u21D2', 'Rarr': '\u21A0', 'rarrap': '\u2975', 'rarrb': '\u21E5', 'rarrbfs': '\u2920', 'rarrc': '\u2933', 'rarrfs': '\u291E', 'rarrhk': '\u21AA', 'rarrlp': '\u21AC', 'rarrpl': '\u2945', 'rarrsim': '\u2974', 'rarrtl': '\u21A3', 'Rarrtl': '\u2916', 'rarrw': '\u219D', 'ratail': '\u291A', 'rAtail': '\u291C', 'ratio': '\u2236', 'rationals': '\u211A', 'rbarr': '\u290D', 'rBarr': '\u290F', 'RBarr': '\u2910', 'rbbrk': '\u2773', 'rbrace': '}', 'rbrack': ']', 'rbrke': '\u298C', 'rbrksld': '\u298E', 'rbrkslu': '\u2990', 'rcaron': '\u0159', 'Rcaron': '\u0158', 'rcedil': '\u0157', 'Rcedil': '\u0156', 'rceil': '\u2309', 'rcub': '}', 'rcy': '\u0440', 'Rcy': '\u0420', 'rdca': '\u2937', 'rdldhar': '\u2969', 'rdquo': '\u201D', 'rdquor': '\u201D', 'rdsh': '\u21B3', 'Re': '\u211C', 'real': '\u211C', 'realine': '\u211B', 'realpart': '\u211C', 'reals': '\u211D', 'rect': '\u25AD', 'reg': '\xAE', 'REG': '\xAE', 'ReverseElement': '\u220B', 'ReverseEquilibrium': '\u21CB', 'ReverseUpEquilibrium': '\u296F', 'rfisht': '\u297D', 'rfloor': '\u230B', 'rfr': '\uD835\uDD2F', 'Rfr': '\u211C', 'rHar': '\u2964', 'rhard': '\u21C1', 'rharu': '\u21C0', 'rharul': '\u296C', 'rho': '\u03C1', 'Rho': '\u03A1', 'rhov': '\u03F1', 'RightAngleBracket': '\u27E9', 'rightarrow': '\u2192', 'Rightarrow': '\u21D2', 'RightArrow': '\u2192', 'RightArrowBar': '\u21E5', 'RightArrowLeftArrow': '\u21C4', 'rightarrowtail': '\u21A3', 'RightCeiling': '\u2309', 'RightDoubleBracket': '\u27E7', 'RightDownTeeVector': '\u295D', 'RightDownVector': '\u21C2', 'RightDownVectorBar': '\u2955', 'RightFloor': '\u230B', 'rightharpoondown': '\u21C1', 'rightharpoonup': '\u21C0', 'rightleftarrows': '\u21C4', 'rightleftharpoons': '\u21CC', 'rightrightarrows': '\u21C9', 'rightsquigarrow': '\u219D', 'RightTee': '\u22A2', 'RightTeeArrow': '\u21A6', 'RightTeeVector': '\u295B', 'rightthreetimes': '\u22CC', 'RightTriangle': '\u22B3', 'RightTriangleBar': '\u29D0', 'RightTriangleEqual': '\u22B5', 'RightUpDownVector': '\u294F', 'RightUpTeeVector': '\u295C', 'RightUpVector': '\u21BE', 'RightUpVectorBar': '\u2954', 'RightVector': '\u21C0', 'RightVectorBar': '\u2953', 'ring': '\u02DA', 'risingdotseq': '\u2253', 'rlarr': '\u21C4', 'rlhar': '\u21CC', 'rlm': '\u200F', 'rmoust': '\u23B1', 'rmoustache': '\u23B1', 'rnmid': '\u2AEE', 'roang': '\u27ED', 'roarr': '\u21FE', 'robrk': '\u27E7', 'ropar': '\u2986', 'ropf': '\uD835\uDD63', 'Ropf': '\u211D', 'roplus': '\u2A2E', 'rotimes': '\u2A35', 'RoundImplies': '\u2970', 'rpar': ')', 'rpargt': '\u2994', 'rppolint': '\u2A12', 'rrarr': '\u21C9', 'Rrightarrow': '\u21DB', 'rsaquo': '\u203A', 'rscr': '\uD835\uDCC7', 'Rscr': '\u211B', 'rsh': '\u21B1', 'Rsh': '\u21B1', 'rsqb': ']', 'rsquo': '\u2019', 'rsquor': '\u2019', 'rthree': '\u22CC', 'rtimes': '\u22CA', 'rtri': '\u25B9', 'rtrie': '\u22B5', 'rtrif': '\u25B8', 'rtriltri': '\u29CE', 'RuleDelayed': '\u29F4', 'ruluhar': '\u2968', 'rx': '\u211E', 'sacute': '\u015B', 'Sacute': '\u015A', 'sbquo': '\u201A', 'sc': '\u227B', 'Sc': '\u2ABC', 'scap': '\u2AB8', 'scaron': '\u0161', 'Scaron': '\u0160', 'sccue': '\u227D', 'sce': '\u2AB0', 'scE': '\u2AB4', 'scedil': '\u015F', 'Scedil': '\u015E', 'scirc': '\u015D', 'Scirc': '\u015C', 'scnap': '\u2ABA', 'scnE': '\u2AB6', 'scnsim': '\u22E9', 'scpolint': '\u2A13', 'scsim': '\u227F', 'scy': '\u0441', 'Scy': '\u0421', 'sdot': '\u22C5', 'sdotb': '\u22A1', 'sdote': '\u2A66', 'searhk': '\u2925', 'searr': '\u2198', 'seArr': '\u21D8', 'searrow': '\u2198', 'sect': '\xA7', 'semi': ';', 'seswar': '\u2929', 'setminus': '\u2216', 'setmn': '\u2216', 'sext': '\u2736', 'sfr': '\uD835\uDD30', 'Sfr': '\uD835\uDD16', 'sfrown': '\u2322', 'sharp': '\u266F', 'shchcy': '\u0449', 'SHCHcy': '\u0429', 'shcy': '\u0448', 'SHcy': '\u0428', 'ShortDownArrow': '\u2193', 'ShortLeftArrow': '\u2190', 'shortmid': '\u2223', 'shortparallel': '\u2225', 'ShortRightArrow': '\u2192', 'ShortUpArrow': '\u2191', 'shy': '\xAD', 'sigma': '\u03C3', 'Sigma': '\u03A3', 'sigmaf': '\u03C2', 'sigmav': '\u03C2', 'sim': '\u223C', 'simdot': '\u2A6A', 'sime': '\u2243', 'simeq': '\u2243', 'simg': '\u2A9E', 'simgE': '\u2AA0', 'siml': '\u2A9D', 'simlE': '\u2A9F', 'simne': '\u2246', 'simplus': '\u2A24', 'simrarr': '\u2972', 'slarr': '\u2190', 'SmallCircle': '\u2218', 'smallsetminus': '\u2216', 'smashp': '\u2A33', 'smeparsl': '\u29E4', 'smid': '\u2223', 'smile': '\u2323', 'smt': '\u2AAA', 'smte': '\u2AAC', 'smtes': '\u2AAC\uFE00', 'softcy': '\u044C', 'SOFTcy': '\u042C', 'sol': '/', 'solb': '\u29C4', 'solbar': '\u233F', 'sopf': '\uD835\uDD64', 'Sopf': '\uD835\uDD4A', 'spades': '\u2660', 'spadesuit': '\u2660', 'spar': '\u2225', 'sqcap': '\u2293', 'sqcaps': '\u2293\uFE00', 'sqcup': '\u2294', 'sqcups': '\u2294\uFE00', 'Sqrt': '\u221A', 'sqsub': '\u228F', 'sqsube': '\u2291', 'sqsubset': '\u228F', 'sqsubseteq': '\u2291', 'sqsup': '\u2290', 'sqsupe': '\u2292', 'sqsupset': '\u2290', 'sqsupseteq': '\u2292', 'squ': '\u25A1', 'square': '\u25A1', 'Square': '\u25A1', 'SquareIntersection': '\u2293', 'SquareSubset': '\u228F', 'SquareSubsetEqual': '\u2291', 'SquareSuperset': '\u2290', 'SquareSupersetEqual': '\u2292', 'SquareUnion': '\u2294', 'squarf': '\u25AA', 'squf': '\u25AA', 'srarr': '\u2192', 'sscr': '\uD835\uDCC8', 'Sscr': '\uD835\uDCAE', 'ssetmn': '\u2216', 'ssmile': '\u2323', 'sstarf': '\u22C6', 'star': '\u2606', 'Star': '\u22C6', 'starf': '\u2605', 'straightepsilon': '\u03F5', 'straightphi': '\u03D5', 'strns': '\xAF', 'sub': '\u2282', 'Sub': '\u22D0', 'subdot': '\u2ABD', 'sube': '\u2286', 'subE': '\u2AC5', 'subedot': '\u2AC3', 'submult': '\u2AC1', 'subne': '\u228A', 'subnE': '\u2ACB', 'subplus': '\u2ABF', 'subrarr': '\u2979', 'subset': '\u2282', 'Subset': '\u22D0', 'subseteq': '\u2286', 'subseteqq': '\u2AC5', 'SubsetEqual': '\u2286', 'subsetneq': '\u228A', 'subsetneqq': '\u2ACB', 'subsim': '\u2AC7', 'subsub': '\u2AD5', 'subsup': '\u2AD3', 'succ': '\u227B', 'succapprox': '\u2AB8', 'succcurlyeq': '\u227D', 'Succeeds': '\u227B', 'SucceedsEqual': '\u2AB0', 'SucceedsSlantEqual': '\u227D', 'SucceedsTilde': '\u227F', 'succeq': '\u2AB0', 'succnapprox': '\u2ABA', 'succneqq': '\u2AB6', 'succnsim': '\u22E9', 'succsim': '\u227F', 'SuchThat': '\u220B', 'sum': '\u2211', 'Sum': '\u2211', 'sung': '\u266A', 'sup': '\u2283', 'Sup': '\u22D1', 'sup1': '\xB9', 'sup2': '\xB2', 'sup3': '\xB3', 'supdot': '\u2ABE', 'supdsub': '\u2AD8', 'supe': '\u2287', 'supE': '\u2AC6', 'supedot': '\u2AC4', 'Superset': '\u2283', 'SupersetEqual': '\u2287', 'suphsol': '\u27C9', 'suphsub': '\u2AD7', 'suplarr': '\u297B', 'supmult': '\u2AC2', 'supne': '\u228B', 'supnE': '\u2ACC', 'supplus': '\u2AC0', 'supset': '\u2283', 'Supset': '\u22D1', 'supseteq': '\u2287', 'supseteqq': '\u2AC6', 'supsetneq': '\u228B', 'supsetneqq': '\u2ACC', 'supsim': '\u2AC8', 'supsub': '\u2AD4', 'supsup': '\u2AD6', 'swarhk': '\u2926', 'swarr': '\u2199', 'swArr': '\u21D9', 'swarrow': '\u2199', 'swnwar': '\u292A', 'szlig': '\xDF', 'Tab': '\t', 'target': '\u2316', 'tau': '\u03C4', 'Tau': '\u03A4', 'tbrk': '\u23B4', 'tcaron': '\u0165', 'Tcaron': '\u0164', 'tcedil': '\u0163', 'Tcedil': '\u0162', 'tcy': '\u0442', 'Tcy': '\u0422', 'tdot': '\u20DB', 'telrec': '\u2315', 'tfr': '\uD835\uDD31', 'Tfr': '\uD835\uDD17', 'there4': '\u2234', 'therefore': '\u2234', 'Therefore': '\u2234', 'theta': '\u03B8', 'Theta': '\u0398', 'thetasym': '\u03D1', 'thetav': '\u03D1', 'thickapprox': '\u2248', 'thicksim': '\u223C', 'ThickSpace': '\u205F\u200A', 'thinsp': '\u2009', 'ThinSpace': '\u2009', 'thkap': '\u2248', 'thksim': '\u223C', 'thorn': '\xFE', 'THORN': '\xDE', 'tilde': '\u02DC', 'Tilde': '\u223C', 'TildeEqual': '\u2243', 'TildeFullEqual': '\u2245', 'TildeTilde': '\u2248', 'times': '\xD7', 'timesb': '\u22A0', 'timesbar': '\u2A31', 'timesd': '\u2A30', 'tint': '\u222D', 'toea': '\u2928', 'top': '\u22A4', 'topbot': '\u2336', 'topcir': '\u2AF1', 'topf': '\uD835\uDD65', 'Topf': '\uD835\uDD4B', 'topfork': '\u2ADA', 'tosa': '\u2929', 'tprime': '\u2034', 'trade': '\u2122', 'TRADE': '\u2122', 'triangle': '\u25B5', 'triangledown': '\u25BF', 'triangleleft': '\u25C3', 'trianglelefteq': '\u22B4', 'triangleq': '\u225C', 'triangleright': '\u25B9', 'trianglerighteq': '\u22B5', 'tridot': '\u25EC', 'trie': '\u225C', 'triminus': '\u2A3A', 'TripleDot': '\u20DB', 'triplus': '\u2A39', 'trisb': '\u29CD', 'tritime': '\u2A3B', 'trpezium': '\u23E2', 'tscr': '\uD835\uDCC9', 'Tscr': '\uD835\uDCAF', 'tscy': '\u0446', 'TScy': '\u0426', 'tshcy': '\u045B', 'TSHcy': '\u040B', 'tstrok': '\u0167', 'Tstrok': '\u0166', 'twixt': '\u226C', 'twoheadleftarrow': '\u219E', 'twoheadrightarrow': '\u21A0', 'uacute': '\xFA', 'Uacute': '\xDA', 'uarr': '\u2191', 'uArr': '\u21D1', 'Uarr': '\u219F', 'Uarrocir': '\u2949', 'ubrcy': '\u045E', 'Ubrcy': '\u040E', 'ubreve': '\u016D', 'Ubreve': '\u016C', 'ucirc': '\xFB', 'Ucirc': '\xDB', 'ucy': '\u0443', 'Ucy': '\u0423', 'udarr': '\u21C5', 'udblac': '\u0171', 'Udblac': '\u0170', 'udhar': '\u296E', 'ufisht': '\u297E', 'ufr': '\uD835\uDD32', 'Ufr': '\uD835\uDD18', 'ugrave': '\xF9', 'Ugrave': '\xD9', 'uHar': '\u2963', 'uharl': '\u21BF', 'uharr': '\u21BE', 'uhblk': '\u2580', 'ulcorn': '\u231C', 'ulcorner': '\u231C', 'ulcrop': '\u230F', 'ultri': '\u25F8', 'umacr': '\u016B', 'Umacr': '\u016A', 'uml': '\xA8', 'UnderBar': '_', 'UnderBrace': '\u23DF', 'UnderBracket': '\u23B5', 'UnderParenthesis': '\u23DD', 'Union': '\u22C3', 'UnionPlus': '\u228E', 'uogon': '\u0173', 'Uogon': '\u0172', 'uopf': '\uD835\uDD66', 'Uopf': '\uD835\uDD4C', 'uparrow': '\u2191', 'Uparrow': '\u21D1', 'UpArrow': '\u2191', 'UpArrowBar': '\u2912', 'UpArrowDownArrow': '\u21C5', 'updownarrow': '\u2195', 'Updownarrow': '\u21D5', 'UpDownArrow': '\u2195', 'UpEquilibrium': '\u296E', 'upharpoonleft': '\u21BF', 'upharpoonright': '\u21BE', 'uplus': '\u228E', 'UpperLeftArrow': '\u2196', 'UpperRightArrow': '\u2197', 'upsi': '\u03C5', 'Upsi': '\u03D2', 'upsih': '\u03D2', 'upsilon': '\u03C5', 'Upsilon': '\u03A5', 'UpTee': '\u22A5', 'UpTeeArrow': '\u21A5', 'upuparrows': '\u21C8', 'urcorn': '\u231D', 'urcorner': '\u231D', 'urcrop': '\u230E', 'uring': '\u016F', 'Uring': '\u016E', 'urtri': '\u25F9', 'uscr': '\uD835\uDCCA', 'Uscr': '\uD835\uDCB0', 'utdot': '\u22F0', 'utilde': '\u0169', 'Utilde': '\u0168', 'utri': '\u25B5', 'utrif': '\u25B4', 'uuarr': '\u21C8', 'uuml': '\xFC', 'Uuml': '\xDC', 'uwangle': '\u29A7', 'vangrt': '\u299C', 'varepsilon': '\u03F5', 'varkappa': '\u03F0', 'varnothing': '\u2205', 'varphi': '\u03D5', 'varpi': '\u03D6', 'varpropto': '\u221D', 'varr': '\u2195', 'vArr': '\u21D5', 'varrho': '\u03F1', 'varsigma': '\u03C2', 'varsubsetneq': '\u228A\uFE00', 'varsubsetneqq': '\u2ACB\uFE00', 'varsupsetneq': '\u228B\uFE00', 'varsupsetneqq': '\u2ACC\uFE00', 'vartheta': '\u03D1', 'vartriangleleft': '\u22B2', 'vartriangleright': '\u22B3', 'vBar': '\u2AE8', 'Vbar': '\u2AEB', 'vBarv': '\u2AE9', 'vcy': '\u0432', 'Vcy': '\u0412', 'vdash': '\u22A2', 'vDash': '\u22A8', 'Vdash': '\u22A9', 'VDash': '\u22AB', 'Vdashl': '\u2AE6', 'vee': '\u2228', 'Vee': '\u22C1', 'veebar': '\u22BB', 'veeeq': '\u225A', 'vellip': '\u22EE', 'verbar': '|', 'Verbar': '\u2016', 'vert': '|', 'Vert': '\u2016', 'VerticalBar': '\u2223', 'VerticalLine': '|', 'VerticalSeparator': '\u2758', 'VerticalTilde': '\u2240', 'VeryThinSpace': '\u200A', 'vfr': '\uD835\uDD33', 'Vfr': '\uD835\uDD19', 'vltri': '\u22B2', 'vnsub': '\u2282\u20D2', 'vnsup': '\u2283\u20D2', 'vopf': '\uD835\uDD67', 'Vopf': '\uD835\uDD4D', 'vprop': '\u221D', 'vrtri': '\u22B3', 'vscr': '\uD835\uDCCB', 'Vscr': '\uD835\uDCB1', 'vsubne': '\u228A\uFE00', 'vsubnE': '\u2ACB\uFE00', 'vsupne': '\u228B\uFE00', 'vsupnE': '\u2ACC\uFE00', 'Vvdash': '\u22AA', 'vzigzag': '\u299A', 'wcirc': '\u0175', 'Wcirc': '\u0174', 'wedbar': '\u2A5F', 'wedge': '\u2227', 'Wedge': '\u22C0', 'wedgeq': '\u2259', 'weierp': '\u2118', 'wfr': '\uD835\uDD34', 'Wfr': '\uD835\uDD1A', 'wopf': '\uD835\uDD68', 'Wopf': '\uD835\uDD4E', 'wp': '\u2118', 'wr': '\u2240', 'wreath': '\u2240', 'wscr': '\uD835\uDCCC', 'Wscr': '\uD835\uDCB2', 'xcap': '\u22C2', 'xcirc': '\u25EF', 'xcup': '\u22C3', 'xdtri': '\u25BD', 'xfr': '\uD835\uDD35', 'Xfr': '\uD835\uDD1B', 'xharr': '\u27F7', 'xhArr': '\u27FA', 'xi': '\u03BE', 'Xi': '\u039E', 'xlarr': '\u27F5', 'xlArr': '\u27F8', 'xmap': '\u27FC', 'xnis': '\u22FB', 'xodot': '\u2A00', 'xopf': '\uD835\uDD69', 'Xopf': '\uD835\uDD4F', 'xoplus': '\u2A01', 'xotime': '\u2A02', 'xrarr': '\u27F6', 'xrArr': '\u27F9', 'xscr': '\uD835\uDCCD', 'Xscr': '\uD835\uDCB3', 'xsqcup': '\u2A06', 'xuplus': '\u2A04', 'xutri': '\u25B3', 'xvee': '\u22C1', 'xwedge': '\u22C0', 'yacute': '\xFD', 'Yacute': '\xDD', 'yacy': '\u044F', 'YAcy': '\u042F', 'ycirc': '\u0177', 'Ycirc': '\u0176', 'ycy': '\u044B', 'Ycy': '\u042B', 'yen': '\xA5', 'yfr': '\uD835\uDD36', 'Yfr': '\uD835\uDD1C', 'yicy': '\u0457', 'YIcy': '\u0407', 'yopf': '\uD835\uDD6A', 'Yopf': '\uD835\uDD50', 'yscr': '\uD835\uDCCE', 'Yscr': '\uD835\uDCB4', 'yucy': '\u044E', 'YUcy': '\u042E', 'yuml': '\xFF', 'Yuml': '\u0178', 'zacute': '\u017A', 'Zacute': '\u0179', 'zcaron': '\u017E', 'Zcaron': '\u017D', 'zcy': '\u0437', 'Zcy': '\u0417', 'zdot': '\u017C', 'Zdot': '\u017B', 'zeetrf': '\u2128', 'ZeroWidthSpace': '\u200B', 'zeta': '\u03B6', 'Zeta': '\u0396', 'zfr': '\uD835\uDD37', 'Zfr': '\u2128', 'zhcy': '\u0436', 'ZHcy': '\u0416', 'zigrarr': '\u21DD', 'zopf': '\uD835\uDD6B', 'Zopf': '\u2124', 'zscr': '\uD835\uDCCF', 'Zscr': '\uD835\uDCB5', 'zwj': '\u200D', 'zwnj': '\u200C' };
                    var decodeMapLegacy = { 'aacute': '\xE1', 'Aacute': '\xC1', 'acirc': '\xE2', 'Acirc': '\xC2', 'acute': '\xB4', 'aelig': '\xE6', 'AElig': '\xC6', 'agrave': '\xE0', 'Agrave': '\xC0', 'amp': '&', 'AMP': '&', 'aring': '\xE5', 'Aring': '\xC5', 'atilde': '\xE3', 'Atilde': '\xC3', 'auml': '\xE4', 'Auml': '\xC4', 'brvbar': '\xA6', 'ccedil': '\xE7', 'Ccedil': '\xC7', 'cedil': '\xB8', 'cent': '\xA2', 'copy': '\xA9', 'COPY': '\xA9', 'curren': '\xA4', 'deg': '\xB0', 'divide': '\xF7', 'eacute': '\xE9', 'Eacute': '\xC9', 'ecirc': '\xEA', 'Ecirc': '\xCA', 'egrave': '\xE8', 'Egrave': '\xC8', 'eth': '\xF0', 'ETH': '\xD0', 'euml': '\xEB', 'Euml': '\xCB', 'frac12': '\xBD', 'frac14': '\xBC', 'frac34': '\xBE', 'gt': '>', 'GT': '>', 'iacute': '\xED', 'Iacute': '\xCD', 'icirc': '\xEE', 'Icirc': '\xCE', 'iexcl': '\xA1', 'igrave': '\xEC', 'Igrave': '\xCC', 'iquest': '\xBF', 'iuml': '\xEF', 'Iuml': '\xCF', 'laquo': '\xAB', 'lt': '<', 'LT': '<', 'macr': '\xAF', 'micro': '\xB5', 'middot': '\xB7', 'nbsp': '\xA0', 'not': '\xAC', 'ntilde': '\xF1', 'Ntilde': '\xD1', 'oacute': '\xF3', 'Oacute': '\xD3', 'ocirc': '\xF4', 'Ocirc': '\xD4', 'ograve': '\xF2', 'Ograve': '\xD2', 'ordf': '\xAA', 'ordm': '\xBA', 'oslash': '\xF8', 'Oslash': '\xD8', 'otilde': '\xF5', 'Otilde': '\xD5', 'ouml': '\xF6', 'Ouml': '\xD6', 'para': '\xB6', 'plusmn': '\xB1', 'pound': '\xA3', 'quot': '"', 'QUOT': '"', 'raquo': '\xBB', 'reg': '\xAE', 'REG': '\xAE', 'sect': '\xA7', 'shy': '\xAD', 'sup1': '\xB9', 'sup2': '\xB2', 'sup3': '\xB3', 'szlig': '\xDF', 'thorn': '\xFE', 'THORN': '\xDE', 'times': '\xD7', 'uacute': '\xFA', 'Uacute': '\xDA', 'ucirc': '\xFB', 'Ucirc': '\xDB', 'ugrave': '\xF9', 'Ugrave': '\xD9', 'uml': '\xA8', 'uuml': '\xFC', 'Uuml': '\xDC', 'yacute': '\xFD', 'Yacute': '\xDD', 'yen': '\xA5', 'yuml': '\xFF' };
                    var decodeMapNumeric = { '0': '\uFFFD', '128': '\u20AC', '130': '\u201A', '131': '\u0192', '132': '\u201E', '133': '\u2026', '134': '\u2020', '135': '\u2021', '136': '\u02C6', '137': '\u2030', '138': '\u0160', '139': '\u2039', '140': '\u0152', '142': '\u017D', '145': '\u2018', '146': '\u2019', '147': '\u201C', '148': '\u201D', '149': '\u2022', '150': '\u2013', '151': '\u2014', '152': '\u02DC', '153': '\u2122', '154': '\u0161', '155': '\u203A', '156': '\u0153', '158': '\u017E', '159': '\u0178' };
                    var invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65000, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111];
                    /*--------------------------------------------------------------------------*/
                    var stringFromCharCode = String.fromCharCode;
                    var object = {};
                    var hasOwnProperty = object.hasOwnProperty;
                    var has = function (object, propertyName) {
                        return hasOwnProperty.call(object, propertyName);
                    };
                    var contains = function (array, value) {
                        var index = -1;
                        var length = array.length;
                        while (++index < length) {
                            if (array[index] == value) {
                                return true;
                            }
                        }
                        return false;
                    };
                    var merge = function (options, defaults) {
                        if (!options) {
                            return defaults;
                        }
                        var result = {};
                        var key;
                        for (key in defaults) {
                            // A `hasOwnProperty` check is not needed here, since only recognized
                            // option names are used anyway. Any others are ignored.
                            result[key] = has(options, key) ? options[key] : defaults[key];
                        }
                        return result;
                    };
                    // Modified version of `ucs2encode`; see https://mths.be/punycode.
                    var codePointToSymbol = function (codePoint, strict) {
                        var output = '';
                        if ((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF) {
                            // See issue #4:
                            // Otherwise, if the number is in the range 0xD800 to 0xDFFF or is
                            // greater than 0x10FFFF, then this is a parse error. Return a U+FFFD
                            // REPLACEMENT CHARACTER.
                            if (strict) {
                                parseError('character reference outside the permissible Unicode range');
                            }
                            return '\uFFFD';
                        }
                        if (has(decodeMapNumeric, codePoint)) {
                            if (strict) {
                                parseError('disallowed character reference');
                            }
                            return decodeMapNumeric[codePoint];
                        }
                        if (strict && contains(invalidReferenceCodePoints, codePoint)) {
                            parseError('disallowed character reference');
                        }
                        if (codePoint > 0xFFFF) {
                            codePoint -= 0x10000;
                            output += stringFromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
                            codePoint = 0xDC00 | codePoint & 0x3FF;
                        }
                        output += stringFromCharCode(codePoint);
                        return output;
                    };
                    var hexEscape = function (codePoint) {
                        return '&#x' + codePoint.toString(16).toUpperCase() + ';';
                    };
                    var decEscape = function (codePoint) {
                        return '&#' + codePoint + ';';
                    };
                    var parseError = function (message) {
                        throw Error('Parse error: ' + message);
                    };
                    /*--------------------------------------------------------------------------*/
                    var encode = function (string, options) {
                        options = merge(options, encode.options);
                        var strict = options.strict;
                        if (strict && regexInvalidRawCodePoint.test(string)) {
                            parseError('forbidden code point');
                        }
                        var encodeEverything = options.encodeEverything;
                        var useNamedReferences = options.useNamedReferences;
                        var allowUnsafeSymbols = options.allowUnsafeSymbols;
                        var escapeCodePoint = options.decimal ? decEscape : hexEscape;
                        var escapeBmpSymbol = function (symbol) {
                            return escapeCodePoint(symbol.charCodeAt(0));
                        };
                        if (encodeEverything) {
                            // Encode ASCII symbols.
                            string = string.replace(regexAsciiWhitelist, function (symbol) {
                                // Use named references if requested & possible.
                                if (useNamedReferences && has(encodeMap, symbol)) {
                                    return '&' + encodeMap[symbol] + ';';
                                }
                                return escapeBmpSymbol(symbol);
                            });
                            // Shorten a few escapes that represent two symbols, of which at least one
                            // is within the ASCII range.
                            if (useNamedReferences) {
                                string = string
                                    .replace(/&gt;\u20D2/g, '&nvgt;')
                                    .replace(/&lt;\u20D2/g, '&nvlt;')
                                    .replace(/&#x66;&#x6A;/g, '&fjlig;');
                            }
                            // Encode non-ASCII symbols.
                            if (useNamedReferences) {
                                // Encode non-ASCII symbols that can be replaced with a named reference.
                                string = string.replace(regexEncodeNonAscii, function (string) {
                                    // Note: there is no need to check `has(encodeMap, string)` here.
                                    return '&' + encodeMap[string] + ';';
                                });
                            }
                            // Note: any remaining non-ASCII symbols are handled outside of the `if`.
                        }
                        else if (useNamedReferences) {
                            // Apply named character references.
                            // Encode `<>"'&` using named character references.
                            if (!allowUnsafeSymbols) {
                                string = string.replace(regexEscape, function (string) {
                                    return '&' + encodeMap[string] + ';'; // no need to check `has()` here
                                });
                            }
                            // Shorten escapes that represent two symbols, of which at least one is
                            // `<>"'&`.
                            string = string
                                .replace(/&gt;\u20D2/g, '&nvgt;')
                                .replace(/&lt;\u20D2/g, '&nvlt;');
                            // Encode non-ASCII symbols that can be replaced with a named reference.
                            string = string.replace(regexEncodeNonAscii, function (string) {
                                // Note: there is no need to check `has(encodeMap, string)` here.
                                return '&' + encodeMap[string] + ';';
                            });
                        }
                        else if (!allowUnsafeSymbols) {
                            // Encode `<>"'&` using hexadecimal escapes, now that theyre not handled
                            // using named character references.
                            string = string.replace(regexEscape, escapeBmpSymbol);
                        }
                        return string
                            // Encode astral symbols.
                            .replace(regexAstralSymbols, function ($0) {
                            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                            var high = $0.charCodeAt(0);
                            var low = $0.charCodeAt(1);
                            var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
                            return escapeCodePoint(codePoint);
                        })
                            // Encode any remaining BMP symbols that are not printable ASCII symbols
                            // using a hexadecimal escape.
                            .replace(regexBmpWhitelist, escapeBmpSymbol);
                    };
                    // Expose default options (so they can be overridden globally).
                    encode.options = {
                        'allowUnsafeSymbols': false,
                        'encodeEverything': false,
                        'strict': false,
                        'useNamedReferences': false,
                        'decimal': false
                    };
                    var decode = function (html, options) {
                        options = merge(options, decode.options);
                        var strict = options.strict;
                        if (strict && regexInvalidEntity.test(html)) {
                            parseError('malformed character reference');
                        }
                        return html.replace(regexDecode, function ($0, $1, $2, $3, $4, $5, $6, $7, $8) {
                            var codePoint;
                            var semicolon;
                            var decDigits;
                            var hexDigits;
                            var reference;
                            var next;
                            if ($1) {
                                reference = $1;
                                // Note: there is no need to check `has(decodeMap, reference)`.
                                return decodeMap[reference];
                            }
                            if ($2) {
                                // Decode named character references without trailing `;`, e.g. `&amp`.
                                // This is only a parse error if it gets converted to `&`, or if it is
                                // followed by `=` in an attribute context.
                                reference = $2;
                                next = $3;
                                if (next && options.isAttributeValue) {
                                    if (strict && next == '=') {
                                        parseError('`&` did not start a character reference');
                                    }
                                    return $0;
                                }
                                else {
                                    if (strict) {
                                        parseError('named character reference was not terminated by a semicolon');
                                    }
                                    // Note: there is no need to check `has(decodeMapLegacy, reference)`.
                                    return decodeMapLegacy[reference] + (next || '');
                                }
                            }
                            if ($4) {
                                // Decode decimal escapes, e.g. `&#119558;`.
                                decDigits = $4;
                                semicolon = $5;
                                if (strict && !semicolon) {
                                    parseError('character reference was not terminated by a semicolon');
                                }
                                codePoint = parseInt(decDigits, 10);
                                return codePointToSymbol(codePoint, strict);
                            }
                            if ($6) {
                                // Decode hexadecimal escapes, e.g. `&#x1D306;`.
                                hexDigits = $6;
                                semicolon = $7;
                                if (strict && !semicolon) {
                                    parseError('character reference was not terminated by a semicolon');
                                }
                                codePoint = parseInt(hexDigits, 16);
                                return codePointToSymbol(codePoint, strict);
                            }
                            // If were still here, `if ($7)` is implied; its an ambiguous
                            // ampersand for sure. https://mths.be/notes/ambiguous-ampersands
                            if (strict) {
                                parseError('named character reference was not terminated by a semicolon');
                            }
                            return $0;
                        });
                    };
                    // Expose default options (so they can be overridden globally).
                    decode.options = {
                        'isAttributeValue': false,
                        'strict': false
                    };
                    var escape = function (string) {
                        return string.replace(regexEscape, function ($0) {
                            // Note: there is no need to check `has(escapeMap, $0)` here.
                            return escapeMap[$0];
                        });
                    };
                    /*--------------------------------------------------------------------------*/
                    var he = {
                        'version': '1.2.0',
                        'encode': encode,
                        'decode': decode,
                        'escape': escape,
                        'unescape': decode
                    };
                    // Some AMD build optimizers, like r.js, check for specific condition patterns
                    // like the following:
                    if (true) {
                        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
                            return he;
                        }).call(exports, __webpack_require__, exports, module),
                            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                    }
                    else {
                        var key;
                    }
                }(this));
                /***/ 
            }),
            /***/ "./node_modules/lodash/lodash.js": 
            /*!***************************************!*\
              !*** ./node_modules/lodash/lodash.js ***!
              \***************************************/
            /***/ (function (module, exports, __webpack_require__) {
                /* module decorator */ module = __webpack_require__.nmd(module);
                var __WEBPACK_AMD_DEFINE_RESULT__; /**
                 * @license
                 * Lodash <https://lodash.com/>
                 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
                 * Released under MIT license <https://lodash.com/license>
                 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
                 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
                 */
                ;
                (function () {
                    /** Used as a safe reference for `undefined` in pre-ES5 environments. */
                    var undefined;
                    /** Used as the semantic version number. */
                    var VERSION = '4.17.21';
                    /** Used as the size to enable large array optimizations. */
                    var LARGE_ARRAY_SIZE = 200;
                    /** Error message constants. */
                    var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.', FUNC_ERROR_TEXT = 'Expected a function', INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';
                    /** Used to stand-in for `undefined` hash values. */
                    var HASH_UNDEFINED = '__lodash_hash_undefined__';
                    /** Used as the maximum memoize cache size. */
                    var MAX_MEMOIZE_SIZE = 500;
                    /** Used as the internal argument placeholder. */
                    var PLACEHOLDER = '__lodash_placeholder__';
                    /** Used to compose bitmasks for cloning. */
                    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
                    /** Used to compose bitmasks for value comparisons. */
                    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
                    /** Used to compose bitmasks for function metadata. */
                    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
                    /** Used as default options for `_.truncate`. */
                    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = '...';
                    /** Used to detect hot functions by number of calls within a span of milliseconds. */
                    var HOT_COUNT = 800, HOT_SPAN = 16;
                    /** Used to indicate the type of lazy iteratees. */
                    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
                    /** Used as references for various `Number` constants. */
                    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 1.7976931348623157e+308, NAN = 0 / 0;
                    /** Used as references for the maximum length and index of an array. */
                    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
                    /** Used to associate wrap methods with their bit flags. */
                    var wrapFlags = [
                        ['ary', WRAP_ARY_FLAG],
                        ['bind', WRAP_BIND_FLAG],
                        ['bindKey', WRAP_BIND_KEY_FLAG],
                        ['curry', WRAP_CURRY_FLAG],
                        ['curryRight', WRAP_CURRY_RIGHT_FLAG],
                        ['flip', WRAP_FLIP_FLAG],
                        ['partial', WRAP_PARTIAL_FLAG],
                        ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
                        ['rearg', WRAP_REARG_FLAG]
                    ];
                    /** `Object#toString` result references. */
                    var argsTag = '[object Arguments]', arrayTag = '[object Array]', asyncTag = '[object AsyncFunction]', boolTag = '[object Boolean]', dateTag = '[object Date]', domExcTag = '[object DOMException]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', nullTag = '[object Null]', objectTag = '[object Object]', promiseTag = '[object Promise]', proxyTag = '[object Proxy]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', undefinedTag = '[object Undefined]', weakMapTag = '[object WeakMap]', weakSetTag = '[object WeakSet]';
                    var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
                    /** Used to match empty string literals in compiled template source. */
                    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
                    /** Used to match HTML entities and HTML characters. */
                    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
                    /** Used to match template delimiters. */
                    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
                    /** Used to match property names within property paths. */
                    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
                    /**
                     * Used to match `RegExp`
                     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
                     */
                    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
                    /** Used to match leading whitespace. */
                    var reTrimStart = /^\s+/;
                    /** Used to match a single whitespace character. */
                    var reWhitespace = /\s/;
                    /** Used to match wrap detail comments. */
                    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
                    /** Used to match words composed of alphanumeric characters. */
                    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
                    /**
                     * Used to validate the `validate` option in `_.template` variable.
                     *
                     * Forbids characters which could potentially change the meaning of the function argument definition:
                     * - "()," (modification of function parameters)
                     * - "=" (default value)
                     * - "[]{}" (destructuring of function parameters)
                     * - "/" (beginning of a comment)
                     * - whitespace
                     */
                    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
                    /** Used to match backslashes in property paths. */
                    var reEscapeChar = /\\(\\)?/g;
                    /**
                     * Used to match
                     * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
                     */
                    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
                    /** Used to match `RegExp` flags from their coerced string values. */
                    var reFlags = /\w*$/;
                    /** Used to detect bad signed hexadecimal string values. */
                    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
                    /** Used to detect binary string values. */
                    var reIsBinary = /^0b[01]+$/i;
                    /** Used to detect host constructors (Safari). */
                    var reIsHostCtor = /^\[object .+?Constructor\]$/;
                    /** Used to detect octal string values. */
                    var reIsOctal = /^0o[0-7]+$/i;
                    /** Used to detect unsigned integer values. */
                    var reIsUint = /^(?:0|[1-9]\d*)$/;
                    /** Used to match Latin Unicode letters (excluding mathematical operators). */
                    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
                    /** Used to ensure capturing order of template delimiters. */
                    var reNoMatch = /($^)/;
                    /** Used to match unescaped characters in compiled string literals. */
                    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
                    /** Used to compose unicode character classes. */
                    var rsAstralRange = '\\ud800-\\udfff', rsComboMarksRange = '\\u0300-\\u036f', reComboHalfMarksRange = '\\ufe20-\\ufe2f', rsComboSymbolsRange = '\\u20d0-\\u20ff', rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = '\\u2700-\\u27bf', rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff', rsMathOpRange = '\\xac\\xb1\\xd7\\xf7', rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf', rsPunctuationRange = '\\u2000-\\u206f', rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000', rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde', rsVarRange = '\\ufe0e\\ufe0f', rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
                    /** Used to compose unicode capture groups. */
                    var rsApos = "['\u2019]", rsAstral = '[' + rsAstralRange + ']', rsBreak = '[' + rsBreakRange + ']', rsCombo = '[' + rsComboRange + ']', rsDigits = '\\d+', rsDingbat = '[' + rsDingbatRange + ']', rsLower = '[' + rsLowerRange + ']', rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']', rsFitz = '\\ud83c[\\udffb-\\udfff]', rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')', rsNonAstral = '[^' + rsAstralRange + ']', rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}', rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]', rsUpper = '[' + rsUpperRange + ']', rsZWJ = '\\u200d';
                    /** Used to compose unicode regexes. */
                    var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')', rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')', rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?', rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?', reOptMod = rsModifier + '?', rsOptVar = '[' + rsVarRange + ']?', rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*', rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])', rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])', rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq, rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
                    /** Used to match apostrophes. */
                    var reApos = RegExp(rsApos, 'g');
                    /**
                     * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
                     * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
                     */
                    var reComboMark = RegExp(rsCombo, 'g');
                    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
                    var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
                    /** Used to match complex or compound words. */
                    var reUnicodeWord = RegExp([
                        rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
                        rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
                        rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
                        rsUpper + '+' + rsOptContrUpper,
                        rsOrdUpper,
                        rsOrdLower,
                        rsDigits,
                        rsEmoji
                    ].join('|'), 'g');
                    /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
                    var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');
                    /** Used to detect strings that need a more robust regexp to match words. */
                    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
                    /** Used to assign default `context` object properties. */
                    var contextProps = [
                        'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
                        'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
                        'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
                        'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
                        '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
                    ];
                    /** Used to make template sourceURLs easier to identify. */
                    var templateCounter = -1;
                    /** Used to identify `toStringTag` values of typed arrays. */
                    var typedArrayTags = {};
                    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
                        typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
                            typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
                                typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
                                    typedArrayTags[uint32Tag] = true;
                    typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
                        typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
                            typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
                                typedArrayTags[errorTag] = typedArrayTags[funcTag] =
                                    typedArrayTags[mapTag] = typedArrayTags[numberTag] =
                                        typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
                                            typedArrayTags[setTag] = typedArrayTags[stringTag] =
                                                typedArrayTags[weakMapTag] = false;
                    /** Used to identify `toStringTag` values supported by `_.clone`. */
                    var cloneableTags = {};
                    cloneableTags[argsTag] = cloneableTags[arrayTag] =
                        cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
                            cloneableTags[boolTag] = cloneableTags[dateTag] =
                                cloneableTags[float32Tag] = cloneableTags[float64Tag] =
                                    cloneableTags[int8Tag] = cloneableTags[int16Tag] =
                                        cloneableTags[int32Tag] = cloneableTags[mapTag] =
                                            cloneableTags[numberTag] = cloneableTags[objectTag] =
                                                cloneableTags[regexpTag] = cloneableTags[setTag] =
                                                    cloneableTags[stringTag] = cloneableTags[symbolTag] =
                                                        cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
                                                            cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
                    cloneableTags[errorTag] = cloneableTags[funcTag] =
                        cloneableTags[weakMapTag] = false;
                    /** Used to map Latin Unicode letters to basic Latin letters. */
                    var deburredLetters = {
                        // Latin-1 Supplement block.
                        '\xc0': 'A', '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
                        '\xe0': 'a', '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
                        '\xc7': 'C', '\xe7': 'c',
                        '\xd0': 'D', '\xf0': 'd',
                        '\xc8': 'E', '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
                        '\xe8': 'e', '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
                        '\xcc': 'I', '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
                        '\xec': 'i', '\xed': 'i', '\xee': 'i', '\xef': 'i',
                        '\xd1': 'N', '\xf1': 'n',
                        '\xd2': 'O', '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
                        '\xf2': 'o', '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
                        '\xd9': 'U', '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
                        '\xf9': 'u', '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
                        '\xdd': 'Y', '\xfd': 'y', '\xff': 'y',
                        '\xc6': 'Ae', '\xe6': 'ae',
                        '\xde': 'Th', '\xfe': 'th',
                        '\xdf': 'ss',
                        // Latin Extended-A block.
                        '\u0100': 'A', '\u0102': 'A', '\u0104': 'A',
                        '\u0101': 'a', '\u0103': 'a', '\u0105': 'a',
                        '\u0106': 'C', '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
                        '\u0107': 'c', '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
                        '\u010e': 'D', '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
                        '\u0112': 'E', '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
                        '\u0113': 'e', '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
                        '\u011c': 'G', '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
                        '\u011d': 'g', '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
                        '\u0124': 'H', '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
                        '\u0128': 'I', '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
                        '\u0129': 'i', '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
                        '\u0134': 'J', '\u0135': 'j',
                        '\u0136': 'K', '\u0137': 'k', '\u0138': 'k',
                        '\u0139': 'L', '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
                        '\u013a': 'l', '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
                        '\u0143': 'N', '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
                        '\u0144': 'n', '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
                        '\u014c': 'O', '\u014e': 'O', '\u0150': 'O',
                        '\u014d': 'o', '\u014f': 'o', '\u0151': 'o',
                        '\u0154': 'R', '\u0156': 'R', '\u0158': 'R',
                        '\u0155': 'r', '\u0157': 'r', '\u0159': 'r',
                        '\u015a': 'S', '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
                        '\u015b': 's', '\u015d': 's', '\u015f': 's', '\u0161': 's',
                        '\u0162': 'T', '\u0164': 'T', '\u0166': 'T',
                        '\u0163': 't', '\u0165': 't', '\u0167': 't',
                        '\u0168': 'U', '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
                        '\u0169': 'u', '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
                        '\u0174': 'W', '\u0175': 'w',
                        '\u0176': 'Y', '\u0177': 'y', '\u0178': 'Y',
                        '\u0179': 'Z', '\u017b': 'Z', '\u017d': 'Z',
                        '\u017a': 'z', '\u017c': 'z', '\u017e': 'z',
                        '\u0132': 'IJ', '\u0133': 'ij',
                        '\u0152': 'Oe', '\u0153': 'oe',
                        '\u0149': "'n", '\u017f': 's'
                    };
                    /** Used to map characters to HTML entities. */
                    var htmlEscapes = {
                        '&': '&amp;',
                        '<': '&lt;',
                        '>': '&gt;',
                        '"': '&quot;',
                        "'": '&#39;'
                    };
                    /** Used to map HTML entities to characters. */
                    var htmlUnescapes = {
                        '&amp;': '&',
                        '&lt;': '<',
                        '&gt;': '>',
                        '&quot;': '"',
                        '&#39;': "'"
                    };
                    /** Used to escape characters for inclusion in compiled string literals. */
                    var stringEscapes = {
                        '\\': '\\',
                        "'": "'",
                        '\n': 'n',
                        '\r': 'r',
                        '\u2028': 'u2028',
                        '\u2029': 'u2029'
                    };
                    /** Built-in method references without a dependency on `root`. */
                    var freeParseFloat = parseFloat, freeParseInt = parseInt;
                    /** Detect free variable `global` from Node.js. */
                    var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;
                    /** Detect free variable `self`. */
                    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
                    /** Used as a reference to the global object. */
                    var root = freeGlobal || freeSelf || Function('return this')();
                    /** Detect free variable `exports`. */
                    var freeExports = true && exports && !exports.nodeType && exports;
                    /** Detect free variable `module`. */
                    var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;
                    /** Detect the popular CommonJS extension `module.exports`. */
                    var moduleExports = freeModule && freeModule.exports === freeExports;
                    /** Detect free variable `process` from Node.js. */
                    var freeProcess = moduleExports && freeGlobal.process;
                    /** Used to access faster Node.js helpers. */
                    var nodeUtil = (function () {
                        try {
                            // Use `util.types` for Node.js 10+.
                            var types = freeModule && freeModule.require && freeModule.require('util').types;
                            if (types) {
                                return types;
                            }
                            // Legacy `process.binding('util')` for Node.js < 10.
                            return freeProcess && freeProcess.binding && freeProcess.binding('util');
                        }
                        catch (e) { }
                    }());
                    /* Node.js helper references. */
                    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
                    /*--------------------------------------------------------------------------*/
                    /**
                     * A faster alternative to `Function#apply`, this function invokes `func`
                     * with the `this` binding of `thisArg` and the arguments of `args`.
                     *
                     * @private
                     * @param {Function} func The function to invoke.
                     * @param {*} thisArg The `this` binding of `func`.
                     * @param {Array} args The arguments to invoke `func` with.
                     * @returns {*} Returns the result of `func`.
                     */
                    function apply(func, thisArg, args) {
                        switch (args.length) {
                            case 0: return func.call(thisArg);
                            case 1: return func.call(thisArg, args[0]);
                            case 2: return func.call(thisArg, args[0], args[1]);
                            case 3: return func.call(thisArg, args[0], args[1], args[2]);
                        }
                        return func.apply(thisArg, args);
                    }
                    /**
                     * A specialized version of `baseAggregator` for arrays.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} setter The function to set `accumulator` values.
                     * @param {Function} iteratee The iteratee to transform keys.
                     * @param {Object} accumulator The initial aggregated object.
                     * @returns {Function} Returns `accumulator`.
                     */
                    function arrayAggregator(array, setter, iteratee, accumulator) {
                        var index = -1, length = array == null ? 0 : array.length;
                        while (++index < length) {
                            var value = array[index];
                            setter(accumulator, value, iteratee(value), array);
                        }
                        return accumulator;
                    }
                    /**
                     * A specialized version of `_.forEach` for arrays without support for
                     * iteratee shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns `array`.
                     */
                    function arrayEach(array, iteratee) {
                        var index = -1, length = array == null ? 0 : array.length;
                        while (++index < length) {
                            if (iteratee(array[index], index, array) === false) {
                                break;
                            }
                        }
                        return array;
                    }
                    /**
                     * A specialized version of `_.forEachRight` for arrays without support for
                     * iteratee shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns `array`.
                     */
                    function arrayEachRight(array, iteratee) {
                        var length = array == null ? 0 : array.length;
                        while (length--) {
                            if (iteratee(array[length], length, array) === false) {
                                break;
                            }
                        }
                        return array;
                    }
                    /**
                     * A specialized version of `_.every` for arrays without support for
                     * iteratee shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {boolean} Returns `true` if all elements pass the predicate check,
                     *  else `false`.
                     */
                    function arrayEvery(array, predicate) {
                        var index = -1, length = array == null ? 0 : array.length;
                        while (++index < length) {
                            if (!predicate(array[index], index, array)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    /**
                     * A specialized version of `_.filter` for arrays without support for
                     * iteratee shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {Array} Returns the new filtered array.
                     */
                    function arrayFilter(array, predicate) {
                        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
                        while (++index < length) {
                            var value = array[index];
                            if (predicate(value, index, array)) {
                                result[resIndex++] = value;
                            }
                        }
                        return result;
                    }
                    /**
                     * A specialized version of `_.includes` for arrays without support for
                     * specifying an index to search from.
                     *
                     * @private
                     * @param {Array} [array] The array to inspect.
                     * @param {*} target The value to search for.
                     * @returns {boolean} Returns `true` if `target` is found, else `false`.
                     */
                    function arrayIncludes(array, value) {
                        var length = array == null ? 0 : array.length;
                        return !!length && baseIndexOf(array, value, 0) > -1;
                    }
                    /**
                     * This function is like `arrayIncludes` except that it accepts a comparator.
                     *
                     * @private
                     * @param {Array} [array] The array to inspect.
                     * @param {*} target The value to search for.
                     * @param {Function} comparator The comparator invoked per element.
                     * @returns {boolean} Returns `true` if `target` is found, else `false`.
                     */
                    function arrayIncludesWith(array, value, comparator) {
                        var index = -1, length = array == null ? 0 : array.length;
                        while (++index < length) {
                            if (comparator(value, array[index])) {
                                return true;
                            }
                        }
                        return false;
                    }
                    /**
                     * A specialized version of `_.map` for arrays without support for iteratee
                     * shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns the new mapped array.
                     */
                    function arrayMap(array, iteratee) {
                        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
                        while (++index < length) {
                            result[index] = iteratee(array[index], index, array);
                        }
                        return result;
                    }
                    /**
                     * Appends the elements of `values` to `array`.
                     *
                     * @private
                     * @param {Array} array The array to modify.
                     * @param {Array} values The values to append.
                     * @returns {Array} Returns `array`.
                     */
                    function arrayPush(array, values) {
                        var index = -1, length = values.length, offset = array.length;
                        while (++index < length) {
                            array[offset + index] = values[index];
                        }
                        return array;
                    }
                    /**
                     * A specialized version of `_.reduce` for arrays without support for
                     * iteratee shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {*} [accumulator] The initial value.
                     * @param {boolean} [initAccum] Specify using the first element of `array` as
                     *  the initial value.
                     * @returns {*} Returns the accumulated value.
                     */
                    function arrayReduce(array, iteratee, accumulator, initAccum) {
                        var index = -1, length = array == null ? 0 : array.length;
                        if (initAccum && length) {
                            accumulator = array[++index];
                        }
                        while (++index < length) {
                            accumulator = iteratee(accumulator, array[index], index, array);
                        }
                        return accumulator;
                    }
                    /**
                     * A specialized version of `_.reduceRight` for arrays without support for
                     * iteratee shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {*} [accumulator] The initial value.
                     * @param {boolean} [initAccum] Specify using the last element of `array` as
                     *  the initial value.
                     * @returns {*} Returns the accumulated value.
                     */
                    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
                        var length = array == null ? 0 : array.length;
                        if (initAccum && length) {
                            accumulator = array[--length];
                        }
                        while (length--) {
                            accumulator = iteratee(accumulator, array[length], length, array);
                        }
                        return accumulator;
                    }
                    /**
                     * A specialized version of `_.some` for arrays without support for iteratee
                     * shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {boolean} Returns `true` if any element passes the predicate check,
                     *  else `false`.
                     */
                    function arraySome(array, predicate) {
                        var index = -1, length = array == null ? 0 : array.length;
                        while (++index < length) {
                            if (predicate(array[index], index, array)) {
                                return true;
                            }
                        }
                        return false;
                    }
                    /**
                     * Gets the size of an ASCII `string`.
                     *
                     * @private
                     * @param {string} string The string inspect.
                     * @returns {number} Returns the string size.
                     */
                    var asciiSize = baseProperty('length');
                    /**
                     * Converts an ASCII `string` to an array.
                     *
                     * @private
                     * @param {string} string The string to convert.
                     * @returns {Array} Returns the converted array.
                     */
                    function asciiToArray(string) {
                        return string.split('');
                    }
                    /**
                     * Splits an ASCII `string` into an array of its words.
                     *
                     * @private
                     * @param {string} The string to inspect.
                     * @returns {Array} Returns the words of `string`.
                     */
                    function asciiWords(string) {
                        return string.match(reAsciiWord) || [];
                    }
                    /**
                     * The base implementation of methods like `_.findKey` and `_.findLastKey`,
                     * without support for iteratee shorthands, which iterates over `collection`
                     * using `eachFunc`.
                     *
                     * @private
                     * @param {Array|Object} collection The collection to inspect.
                     * @param {Function} predicate The function invoked per iteration.
                     * @param {Function} eachFunc The function to iterate over `collection`.
                     * @returns {*} Returns the found element or its key, else `undefined`.
                     */
                    function baseFindKey(collection, predicate, eachFunc) {
                        var result;
                        eachFunc(collection, function (value, key, collection) {
                            if (predicate(value, key, collection)) {
                                result = key;
                                return false;
                            }
                        });
                        return result;
                    }
                    /**
                     * The base implementation of `_.findIndex` and `_.findLastIndex` without
                     * support for iteratee shorthands.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {Function} predicate The function invoked per iteration.
                     * @param {number} fromIndex The index to search from.
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {number} Returns the index of the matched value, else `-1`.
                     */
                    function baseFindIndex(array, predicate, fromIndex, fromRight) {
                        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
                        while ((fromRight ? index-- : ++index < length)) {
                            if (predicate(array[index], index, array)) {
                                return index;
                            }
                        }
                        return -1;
                    }
                    /**
                     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {*} value The value to search for.
                     * @param {number} fromIndex The index to search from.
                     * @returns {number} Returns the index of the matched value, else `-1`.
                     */
                    function baseIndexOf(array, value, fromIndex) {
                        return value === value
                            ? strictIndexOf(array, value, fromIndex)
                            : baseFindIndex(array, baseIsNaN, fromIndex);
                    }
                    /**
                     * This function is like `baseIndexOf` except that it accepts a comparator.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {*} value The value to search for.
                     * @param {number} fromIndex The index to search from.
                     * @param {Function} comparator The comparator invoked per element.
                     * @returns {number} Returns the index of the matched value, else `-1`.
                     */
                    function baseIndexOfWith(array, value, fromIndex, comparator) {
                        var index = fromIndex - 1, length = array.length;
                        while (++index < length) {
                            if (comparator(array[index], value)) {
                                return index;
                            }
                        }
                        return -1;
                    }
                    /**
                     * The base implementation of `_.isNaN` without support for number objects.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
                     */
                    function baseIsNaN(value) {
                        return value !== value;
                    }
                    /**
                     * The base implementation of `_.mean` and `_.meanBy` without support for
                     * iteratee shorthands.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {number} Returns the mean.
                     */
                    function baseMean(array, iteratee) {
                        var length = array == null ? 0 : array.length;
                        return length ? (baseSum(array, iteratee) / length) : NAN;
                    }
                    /**
                     * The base implementation of `_.property` without support for deep paths.
                     *
                     * @private
                     * @param {string} key The key of the property to get.
                     * @returns {Function} Returns the new accessor function.
                     */
                    function baseProperty(key) {
                        return function (object) {
                            return object == null ? undefined : object[key];
                        };
                    }
                    /**
                     * The base implementation of `_.propertyOf` without support for deep paths.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {Function} Returns the new accessor function.
                     */
                    function basePropertyOf(object) {
                        return function (key) {
                            return object == null ? undefined : object[key];
                        };
                    }
                    /**
                     * The base implementation of `_.reduce` and `_.reduceRight`, without support
                     * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
                     *
                     * @private
                     * @param {Array|Object} collection The collection to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {*} accumulator The initial value.
                     * @param {boolean} initAccum Specify using the first or last element of
                     *  `collection` as the initial value.
                     * @param {Function} eachFunc The function to iterate over `collection`.
                     * @returns {*} Returns the accumulated value.
                     */
                    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
                        eachFunc(collection, function (value, index, collection) {
                            accumulator = initAccum
                                ? (initAccum = false, value)
                                : iteratee(accumulator, value, index, collection);
                        });
                        return accumulator;
                    }
                    /**
                     * The base implementation of `_.sortBy` which uses `comparer` to define the
                     * sort order of `array` and replaces criteria objects with their corresponding
                     * values.
                     *
                     * @private
                     * @param {Array} array The array to sort.
                     * @param {Function} comparer The function to define sort order.
                     * @returns {Array} Returns `array`.
                     */
                    function baseSortBy(array, comparer) {
                        var length = array.length;
                        array.sort(comparer);
                        while (length--) {
                            array[length] = array[length].value;
                        }
                        return array;
                    }
                    /**
                     * The base implementation of `_.sum` and `_.sumBy` without support for
                     * iteratee shorthands.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {number} Returns the sum.
                     */
                    function baseSum(array, iteratee) {
                        var result, index = -1, length = array.length;
                        while (++index < length) {
                            var current = iteratee(array[index]);
                            if (current !== undefined) {
                                result = result === undefined ? current : (result + current);
                            }
                        }
                        return result;
                    }
                    /**
                     * The base implementation of `_.times` without support for iteratee shorthands
                     * or max array length checks.
                     *
                     * @private
                     * @param {number} n The number of times to invoke `iteratee`.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns the array of results.
                     */
                    function baseTimes(n, iteratee) {
                        var index = -1, result = Array(n);
                        while (++index < n) {
                            result[index] = iteratee(index);
                        }
                        return result;
                    }
                    /**
                     * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
                     * of key-value pairs for `object` corresponding to the property names of `props`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {Array} props The property names to get values for.
                     * @returns {Object} Returns the key-value pairs.
                     */
                    function baseToPairs(object, props) {
                        return arrayMap(props, function (key) {
                            return [key, object[key]];
                        });
                    }
                    /**
                     * The base implementation of `_.trim`.
                     *
                     * @private
                     * @param {string} string The string to trim.
                     * @returns {string} Returns the trimmed string.
                     */
                    function baseTrim(string) {
                        return string
                            ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
                            : string;
                    }
                    /**
                     * The base implementation of `_.unary` without support for storing metadata.
                     *
                     * @private
                     * @param {Function} func The function to cap arguments for.
                     * @returns {Function} Returns the new capped function.
                     */
                    function baseUnary(func) {
                        return function (value) {
                            return func(value);
                        };
                    }
                    /**
                     * The base implementation of `_.values` and `_.valuesIn` which creates an
                     * array of `object` property values corresponding to the property names
                     * of `props`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {Array} props The property names to get values for.
                     * @returns {Object} Returns the array of property values.
                     */
                    function baseValues(object, props) {
                        return arrayMap(props, function (key) {
                            return object[key];
                        });
                    }
                    /**
                     * Checks if a `cache` value for `key` exists.
                     *
                     * @private
                     * @param {Object} cache The cache to query.
                     * @param {string} key The key of the entry to check.
                     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                     */
                    function cacheHas(cache, key) {
                        return cache.has(key);
                    }
                    /**
                     * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
                     * that is not found in the character symbols.
                     *
                     * @private
                     * @param {Array} strSymbols The string symbols to inspect.
                     * @param {Array} chrSymbols The character symbols to find.
                     * @returns {number} Returns the index of the first unmatched string symbol.
                     */
                    function charsStartIndex(strSymbols, chrSymbols) {
                        var index = -1, length = strSymbols.length;
                        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) { }
                        return index;
                    }
                    /**
                     * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
                     * that is not found in the character symbols.
                     *
                     * @private
                     * @param {Array} strSymbols The string symbols to inspect.
                     * @param {Array} chrSymbols The character symbols to find.
                     * @returns {number} Returns the index of the last unmatched string symbol.
                     */
                    function charsEndIndex(strSymbols, chrSymbols) {
                        var index = strSymbols.length;
                        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) { }
                        return index;
                    }
                    /**
                     * Gets the number of `placeholder` occurrences in `array`.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {*} placeholder The placeholder to search for.
                     * @returns {number} Returns the placeholder count.
                     */
                    function countHolders(array, placeholder) {
                        var length = array.length, result = 0;
                        while (length--) {
                            if (array[length] === placeholder) {
                                ++result;
                            }
                        }
                        return result;
                    }
                    /**
                     * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
                     * letters to basic Latin letters.
                     *
                     * @private
                     * @param {string} letter The matched letter to deburr.
                     * @returns {string} Returns the deburred letter.
                     */
                    var deburrLetter = basePropertyOf(deburredLetters);
                    /**
                     * Used by `_.escape` to convert characters to HTML entities.
                     *
                     * @private
                     * @param {string} chr The matched character to escape.
                     * @returns {string} Returns the escaped character.
                     */
                    var escapeHtmlChar = basePropertyOf(htmlEscapes);
                    /**
                     * Used by `_.template` to escape characters for inclusion in compiled string literals.
                     *
                     * @private
                     * @param {string} chr The matched character to escape.
                     * @returns {string} Returns the escaped character.
                     */
                    function escapeStringChar(chr) {
                        return '\\' + stringEscapes[chr];
                    }
                    /**
                     * Gets the value at `key` of `object`.
                     *
                     * @private
                     * @param {Object} [object] The object to query.
                     * @param {string} key The key of the property to get.
                     * @returns {*} Returns the property value.
                     */
                    function getValue(object, key) {
                        return object == null ? undefined : object[key];
                    }
                    /**
                     * Checks if `string` contains Unicode symbols.
                     *
                     * @private
                     * @param {string} string The string to inspect.
                     * @returns {boolean} Returns `true` if a symbol is found, else `false`.
                     */
                    function hasUnicode(string) {
                        return reHasUnicode.test(string);
                    }
                    /**
                     * Checks if `string` contains a word composed of Unicode symbols.
                     *
                     * @private
                     * @param {string} string The string to inspect.
                     * @returns {boolean} Returns `true` if a word is found, else `false`.
                     */
                    function hasUnicodeWord(string) {
                        return reHasUnicodeWord.test(string);
                    }
                    /**
                     * Converts `iterator` to an array.
                     *
                     * @private
                     * @param {Object} iterator The iterator to convert.
                     * @returns {Array} Returns the converted array.
                     */
                    function iteratorToArray(iterator) {
                        var data, result = [];
                        while (!(data = iterator.next()).done) {
                            result.push(data.value);
                        }
                        return result;
                    }
                    /**
                     * Converts `map` to its key-value pairs.
                     *
                     * @private
                     * @param {Object} map The map to convert.
                     * @returns {Array} Returns the key-value pairs.
                     */
                    function mapToArray(map) {
                        var index = -1, result = Array(map.size);
                        map.forEach(function (value, key) {
                            result[++index] = [key, value];
                        });
                        return result;
                    }
                    /**
                     * Creates a unary function that invokes `func` with its argument transformed.
                     *
                     * @private
                     * @param {Function} func The function to wrap.
                     * @param {Function} transform The argument transform.
                     * @returns {Function} Returns the new function.
                     */
                    function overArg(func, transform) {
                        return function (arg) {
                            return func(transform(arg));
                        };
                    }
                    /**
                     * Replaces all `placeholder` elements in `array` with an internal placeholder
                     * and returns an array of their indexes.
                     *
                     * @private
                     * @param {Array} array The array to modify.
                     * @param {*} placeholder The placeholder to replace.
                     * @returns {Array} Returns the new array of placeholder indexes.
                     */
                    function replaceHolders(array, placeholder) {
                        var index = -1, length = array.length, resIndex = 0, result = [];
                        while (++index < length) {
                            var value = array[index];
                            if (value === placeholder || value === PLACEHOLDER) {
                                array[index] = PLACEHOLDER;
                                result[resIndex++] = index;
                            }
                        }
                        return result;
                    }
                    /**
                     * Converts `set` to an array of its values.
                     *
                     * @private
                     * @param {Object} set The set to convert.
                     * @returns {Array} Returns the values.
                     */
                    function setToArray(set) {
                        var index = -1, result = Array(set.size);
                        set.forEach(function (value) {
                            result[++index] = value;
                        });
                        return result;
                    }
                    /**
                     * Converts `set` to its value-value pairs.
                     *
                     * @private
                     * @param {Object} set The set to convert.
                     * @returns {Array} Returns the value-value pairs.
                     */
                    function setToPairs(set) {
                        var index = -1, result = Array(set.size);
                        set.forEach(function (value) {
                            result[++index] = [value, value];
                        });
                        return result;
                    }
                    /**
                     * A specialized version of `_.indexOf` which performs strict equality
                     * comparisons of values, i.e. `===`.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {*} value The value to search for.
                     * @param {number} fromIndex The index to search from.
                     * @returns {number} Returns the index of the matched value, else `-1`.
                     */
                    function strictIndexOf(array, value, fromIndex) {
                        var index = fromIndex - 1, length = array.length;
                        while (++index < length) {
                            if (array[index] === value) {
                                return index;
                            }
                        }
                        return -1;
                    }
                    /**
                     * A specialized version of `_.lastIndexOf` which performs strict equality
                     * comparisons of values, i.e. `===`.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {*} value The value to search for.
                     * @param {number} fromIndex The index to search from.
                     * @returns {number} Returns the index of the matched value, else `-1`.
                     */
                    function strictLastIndexOf(array, value, fromIndex) {
                        var index = fromIndex + 1;
                        while (index--) {
                            if (array[index] === value) {
                                return index;
                            }
                        }
                        return index;
                    }
                    /**
                     * Gets the number of symbols in `string`.
                     *
                     * @private
                     * @param {string} string The string to inspect.
                     * @returns {number} Returns the string size.
                     */
                    function stringSize(string) {
                        return hasUnicode(string)
                            ? unicodeSize(string)
                            : asciiSize(string);
                    }
                    /**
                     * Converts `string` to an array.
                     *
                     * @private
                     * @param {string} string The string to convert.
                     * @returns {Array} Returns the converted array.
                     */
                    function stringToArray(string) {
                        return hasUnicode(string)
                            ? unicodeToArray(string)
                            : asciiToArray(string);
                    }
                    /**
                     * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
                     * character of `string`.
                     *
                     * @private
                     * @param {string} string The string to inspect.
                     * @returns {number} Returns the index of the last non-whitespace character.
                     */
                    function trimmedEndIndex(string) {
                        var index = string.length;
                        while (index-- && reWhitespace.test(string.charAt(index))) { }
                        return index;
                    }
                    /**
                     * Used by `_.unescape` to convert HTML entities to characters.
                     *
                     * @private
                     * @param {string} chr The matched character to unescape.
                     * @returns {string} Returns the unescaped character.
                     */
                    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
                    /**
                     * Gets the size of a Unicode `string`.
                     *
                     * @private
                     * @param {string} string The string inspect.
                     * @returns {number} Returns the string size.
                     */
                    function unicodeSize(string) {
                        var result = reUnicode.lastIndex = 0;
                        while (reUnicode.test(string)) {
                            ++result;
                        }
                        return result;
                    }
                    /**
                     * Converts a Unicode `string` to an array.
                     *
                     * @private
                     * @param {string} string The string to convert.
                     * @returns {Array} Returns the converted array.
                     */
                    function unicodeToArray(string) {
                        return string.match(reUnicode) || [];
                    }
                    /**
                     * Splits a Unicode `string` into an array of its words.
                     *
                     * @private
                     * @param {string} The string to inspect.
                     * @returns {Array} Returns the words of `string`.
                     */
                    function unicodeWords(string) {
                        return string.match(reUnicodeWord) || [];
                    }
                    /*--------------------------------------------------------------------------*/
                    /**
                     * Create a new pristine `lodash` function using the `context` object.
                     *
                     * @static
                     * @memberOf _
                     * @since 1.1.0
                     * @category Util
                     * @param {Object} [context=root] The context object.
                     * @returns {Function} Returns a new `lodash` function.
                     * @example
                     *
                     * _.mixin({ 'foo': _.constant('foo') });
                     *
                     * var lodash = _.runInContext();
                     * lodash.mixin({ 'bar': lodash.constant('bar') });
                     *
                     * _.isFunction(_.foo);
                     * // => true
                     * _.isFunction(_.bar);
                     * // => false
                     *
                     * lodash.isFunction(lodash.foo);
                     * // => false
                     * lodash.isFunction(lodash.bar);
                     * // => true
                     *
                     * // Create a suped-up `defer` in Node.js.
                     * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
                     */
                    var runInContext = (function runInContext(context) {
                        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
                        /** Built-in constructor references. */
                        var Array = context.Array, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
                        /** Used for built-in method references. */
                        var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
                        /** Used to detect overreaching core-js shims. */
                        var coreJsData = context['__core-js_shared__'];
                        /** Used to resolve the decompiled source of functions. */
                        var funcToString = funcProto.toString;
                        /** Used to check objects for own properties. */
                        var hasOwnProperty = objectProto.hasOwnProperty;
                        /** Used to generate unique IDs. */
                        var idCounter = 0;
                        /** Used to detect methods masquerading as native. */
                        var maskSrcKey = (function () {
                            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
                            return uid ? ('Symbol(src)_1.' + uid) : '';
                        }());
                        /**
                         * Used to resolve the
                         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
                         * of values.
                         */
                        var nativeObjectToString = objectProto.toString;
                        /** Used to infer the `Object` constructor. */
                        var objectCtorString = funcToString.call(Object);
                        /** Used to restore the original `_` reference in `_.noConflict`. */
                        var oldDash = root._;
                        /** Used to detect if a method is native. */
                        var reIsNative = RegExp('^' +
                            funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
                                .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
                        /** Built-in value references. */
                        var Buffer = moduleExports ? context.Buffer : undefined, Symbol = context.Symbol, Uint8Array = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined, symIterator = Symbol ? Symbol.iterator : undefined, symToStringTag = Symbol ? Symbol.toStringTag : undefined;
                        var defineProperty = (function () {
                            try {
                                var func = getNative(Object, 'defineProperty');
                                func({}, '', {});
                                return func;
                            }
                            catch (e) { }
                        }());
                        /** Mocked built-ins. */
                        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date && Date.now !== root.Date.now && Date.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
                        /* Built-in method references for those with the same name as other `lodash` methods. */
                        var nativeCeil = Math.ceil, nativeFloor = Math.floor, nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max, nativeMin = Math.min, nativeNow = Date.now, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeReverse = arrayProto.reverse;
                        /* Built-in method references that are verified to be native. */
                        var DataView = getNative(context, 'DataView'), Map = getNative(context, 'Map'), Promise = getNative(context, 'Promise'), Set = getNative(context, 'Set'), WeakMap = getNative(context, 'WeakMap'), nativeCreate = getNative(Object, 'create');
                        /** Used to store function metadata. */
                        var metaMap = WeakMap && new WeakMap;
                        /** Used to lookup unminified function names. */
                        var realNames = {};
                        /** Used to detect maps, sets, and weakmaps. */
                        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
                        /** Used to convert symbols to primitives and strings. */
                        var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
                        /*------------------------------------------------------------------------*/
                        /**
                         * Creates a `lodash` object which wraps `value` to enable implicit method
                         * chain sequences. Methods that operate on and return arrays, collections,
                         * and functions can be chained together. Methods that retrieve a single value
                         * or may return a primitive value will automatically end the chain sequence
                         * and return the unwrapped value. Otherwise, the value must be unwrapped
                         * with `_#value`.
                         *
                         * Explicit chain sequences, which must be unwrapped with `_#value`, may be
                         * enabled using `_.chain`.
                         *
                         * The execution of chained methods is lazy, that is, it's deferred until
                         * `_#value` is implicitly or explicitly called.
                         *
                         * Lazy evaluation allows several methods to support shortcut fusion.
                         * Shortcut fusion is an optimization to merge iteratee calls; this avoids
                         * the creation of intermediate arrays and can greatly reduce the number of
                         * iteratee executions. Sections of a chain sequence qualify for shortcut
                         * fusion if the section is applied to an array and iteratees accept only
                         * one argument. The heuristic for whether a section qualifies for shortcut
                         * fusion is subject to change.
                         *
                         * Chaining is supported in custom builds as long as the `_#value` method is
                         * directly or indirectly included in the build.
                         *
                         * In addition to lodash methods, wrappers have `Array` and `String` methods.
                         *
                         * The wrapper `Array` methods are:
                         * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
                         *
                         * The wrapper `String` methods are:
                         * `replace` and `split`
                         *
                         * The wrapper methods that support shortcut fusion are:
                         * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
                         * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
                         * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
                         *
                         * The chainable wrapper methods are:
                         * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
                         * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
                         * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
                         * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
                         * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
                         * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
                         * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
                         * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
                         * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
                         * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
                         * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
                         * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
                         * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
                         * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
                         * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
                         * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
                         * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
                         * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
                         * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
                         * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
                         * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
                         * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
                         * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
                         * `zipObject`, `zipObjectDeep`, and `zipWith`
                         *
                         * The wrapper methods that are **not** chainable by default are:
                         * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
                         * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
                         * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
                         * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
                         * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
                         * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
                         * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
                         * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
                         * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
                         * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
                         * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
                         * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
                         * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
                         * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
                         * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
                         * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
                         * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
                         * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
                         * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
                         * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
                         * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
                         * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
                         * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
                         * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
                         * `upperFirst`, `value`, and `words`
                         *
                         * @name _
                         * @constructor
                         * @category Seq
                         * @param {*} value The value to wrap in a `lodash` instance.
                         * @returns {Object} Returns the new `lodash` wrapper instance.
                         * @example
                         *
                         * function square(n) {
                         *   return n * n;
                         * }
                         *
                         * var wrapped = _([1, 2, 3]);
                         *
                         * // Returns an unwrapped value.
                         * wrapped.reduce(_.add);
                         * // => 6
                         *
                         * // Returns a wrapped value.
                         * var squares = wrapped.map(square);
                         *
                         * _.isArray(squares);
                         * // => false
                         *
                         * _.isArray(squares.value());
                         * // => true
                         */
                        function lodash(value) {
                            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                                if (value instanceof LodashWrapper) {
                                    return value;
                                }
                                if (hasOwnProperty.call(value, '__wrapped__')) {
                                    return wrapperClone(value);
                                }
                            }
                            return new LodashWrapper(value);
                        }
                        /**
                         * The base implementation of `_.create` without support for assigning
                         * properties to the created object.
                         *
                         * @private
                         * @param {Object} proto The object to inherit from.
                         * @returns {Object} Returns the new object.
                         */
                        var baseCreate = (function () {
                            function object() { }
                            return function (proto) {
                                if (!isObject(proto)) {
                                    return {};
                                }
                                if (objectCreate) {
                                    return objectCreate(proto);
                                }
                                object.prototype = proto;
                                var result = new object;
                                object.prototype = undefined;
                                return result;
                            };
                        }());
                        /**
                         * The function whose prototype chain sequence wrappers inherit from.
                         *
                         * @private
                         */
                        function baseLodash() {
                            // No operation performed.
                        }
                        /**
                         * The base constructor for creating `lodash` wrapper objects.
                         *
                         * @private
                         * @param {*} value The value to wrap.
                         * @param {boolean} [chainAll] Enable explicit method chain sequences.
                         */
                        function LodashWrapper(value, chainAll) {
                            this.__wrapped__ = value;
                            this.__actions__ = [];
                            this.__chain__ = !!chainAll;
                            this.__index__ = 0;
                            this.__values__ = undefined;
                        }
                        /**
                         * By default, the template delimiters used by lodash are like those in
                         * embedded Ruby (ERB) as well as ES2015 template strings. Change the
                         * following template settings to use alternative delimiters.
                         *
                         * @static
                         * @memberOf _
                         * @type {Object}
                         */
                        lodash.templateSettings = {
                            /**
                             * Used to detect `data` property values to be HTML-escaped.
                             *
                             * @memberOf _.templateSettings
                             * @type {RegExp}
                             */
                            'escape': reEscape,
                            /**
                             * Used to detect code to be evaluated.
                             *
                             * @memberOf _.templateSettings
                             * @type {RegExp}
                             */
                            'evaluate': reEvaluate,
                            /**
                             * Used to detect `data` property values to inject.
                             *
                             * @memberOf _.templateSettings
                             * @type {RegExp}
                             */
                            'interpolate': reInterpolate,
                            /**
                             * Used to reference the data object in the template text.
                             *
                             * @memberOf _.templateSettings
                             * @type {string}
                             */
                            'variable': '',
                            /**
                             * Used to import variables into the compiled template.
                             *
                             * @memberOf _.templateSettings
                             * @type {Object}
                             */
                            'imports': {
                                /**
                                 * A reference to the `lodash` function.
                                 *
                                 * @memberOf _.templateSettings.imports
                                 * @type {Function}
                                 */
                                '_': lodash
                            }
                        };
                        // Ensure wrappers are instances of `baseLodash`.
                        lodash.prototype = baseLodash.prototype;
                        lodash.prototype.constructor = lodash;
                        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
                        LodashWrapper.prototype.constructor = LodashWrapper;
                        /*------------------------------------------------------------------------*/
                        /**
                         * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
                         *
                         * @private
                         * @constructor
                         * @param {*} value The value to wrap.
                         */
                        function LazyWrapper(value) {
                            this.__wrapped__ = value;
                            this.__actions__ = [];
                            this.__dir__ = 1;
                            this.__filtered__ = false;
                            this.__iteratees__ = [];
                            this.__takeCount__ = MAX_ARRAY_LENGTH;
                            this.__views__ = [];
                        }
                        /**
                         * Creates a clone of the lazy wrapper object.
                         *
                         * @private
                         * @name clone
                         * @memberOf LazyWrapper
                         * @returns {Object} Returns the cloned `LazyWrapper` object.
                         */
                        function lazyClone() {
                            var result = new LazyWrapper(this.__wrapped__);
                            result.__actions__ = copyArray(this.__actions__);
                            result.__dir__ = this.__dir__;
                            result.__filtered__ = this.__filtered__;
                            result.__iteratees__ = copyArray(this.__iteratees__);
                            result.__takeCount__ = this.__takeCount__;
                            result.__views__ = copyArray(this.__views__);
                            return result;
                        }
                        /**
                         * Reverses the direction of lazy iteration.
                         *
                         * @private
                         * @name reverse
                         * @memberOf LazyWrapper
                         * @returns {Object} Returns the new reversed `LazyWrapper` object.
                         */
                        function lazyReverse() {
                            if (this.__filtered__) {
                                var result = new LazyWrapper(this);
                                result.__dir__ = -1;
                                result.__filtered__ = true;
                            }
                            else {
                                result = this.clone();
                                result.__dir__ *= -1;
                            }
                            return result;
                        }
                        /**
                         * Extracts the unwrapped value from its lazy wrapper.
                         *
                         * @private
                         * @name value
                         * @memberOf LazyWrapper
                         * @returns {*} Returns the unwrapped value.
                         */
                        function lazyValue() {
                            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : (start - 1), iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
                            if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
                                return baseWrapperValue(array, this.__actions__);
                            }
                            var result = [];
                            outer: while (length-- && resIndex < takeCount) {
                                index += dir;
                                var iterIndex = -1, value = array[index];
                                while (++iterIndex < iterLength) {
                                    var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value);
                                    if (type == LAZY_MAP_FLAG) {
                                        value = computed;
                                    }
                                    else if (!computed) {
                                        if (type == LAZY_FILTER_FLAG) {
                                            continue outer;
                                        }
                                        else {
                                            break outer;
                                        }
                                    }
                                }
                                result[resIndex++] = value;
                            }
                            return result;
                        }
                        // Ensure `LazyWrapper` is an instance of `baseLodash`.
                        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
                        LazyWrapper.prototype.constructor = LazyWrapper;
                        /*------------------------------------------------------------------------*/
                        /**
                         * Creates a hash object.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [entries] The key-value pairs to cache.
                         */
                        function Hash(entries) {
                            var index = -1, length = entries == null ? 0 : entries.length;
                            this.clear();
                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1]);
                            }
                        }
                        /**
                         * Removes all key-value entries from the hash.
                         *
                         * @private
                         * @name clear
                         * @memberOf Hash
                         */
                        function hashClear() {
                            this.__data__ = nativeCreate ? nativeCreate(null) : {};
                            this.size = 0;
                        }
                        /**
                         * Removes `key` and its value from the hash.
                         *
                         * @private
                         * @name delete
                         * @memberOf Hash
                         * @param {Object} hash The hash to modify.
                         * @param {string} key The key of the value to remove.
                         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                         */
                        function hashDelete(key) {
                            var result = this.has(key) && delete this.__data__[key];
                            this.size -= result ? 1 : 0;
                            return result;
                        }
                        /**
                         * Gets the hash value for `key`.
                         *
                         * @private
                         * @name get
                         * @memberOf Hash
                         * @param {string} key The key of the value to get.
                         * @returns {*} Returns the entry value.
                         */
                        function hashGet(key) {
                            var data = this.__data__;
                            if (nativeCreate) {
                                var result = data[key];
                                return result === HASH_UNDEFINED ? undefined : result;
                            }
                            return hasOwnProperty.call(data, key) ? data[key] : undefined;
                        }
                        /**
                         * Checks if a hash value for `key` exists.
                         *
                         * @private
                         * @name has
                         * @memberOf Hash
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */
                        function hashHas(key) {
                            var data = this.__data__;
                            return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
                        }
                        /**
                         * Sets the hash `key` to `value`.
                         *
                         * @private
                         * @name set
                         * @memberOf Hash
                         * @param {string} key The key of the value to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns the hash instance.
                         */
                        function hashSet(key, value) {
                            var data = this.__data__;
                            this.size += this.has(key) ? 0 : 1;
                            data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
                            return this;
                        }
                        // Add methods to `Hash`.
                        Hash.prototype.clear = hashClear;
                        Hash.prototype['delete'] = hashDelete;
                        Hash.prototype.get = hashGet;
                        Hash.prototype.has = hashHas;
                        Hash.prototype.set = hashSet;
                        /*------------------------------------------------------------------------*/
                        /**
                         * Creates an list cache object.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [entries] The key-value pairs to cache.
                         */
                        function ListCache(entries) {
                            var index = -1, length = entries == null ? 0 : entries.length;
                            this.clear();
                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1]);
                            }
                        }
                        /**
                         * Removes all key-value entries from the list cache.
                         *
                         * @private
                         * @name clear
                         * @memberOf ListCache
                         */
                        function listCacheClear() {
                            this.__data__ = [];
                            this.size = 0;
                        }
                        /**
                         * Removes `key` and its value from the list cache.
                         *
                         * @private
                         * @name delete
                         * @memberOf ListCache
                         * @param {string} key The key of the value to remove.
                         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                         */
                        function listCacheDelete(key) {
                            var data = this.__data__, index = assocIndexOf(data, key);
                            if (index < 0) {
                                return false;
                            }
                            var lastIndex = data.length - 1;
                            if (index == lastIndex) {
                                data.pop();
                            }
                            else {
                                splice.call(data, index, 1);
                            }
                            --this.size;
                            return true;
                        }
                        /**
                         * Gets the list cache value for `key`.
                         *
                         * @private
                         * @name get
                         * @memberOf ListCache
                         * @param {string} key The key of the value to get.
                         * @returns {*} Returns the entry value.
                         */
                        function listCacheGet(key) {
                            var data = this.__data__, index = assocIndexOf(data, key);
                            return index < 0 ? undefined : data[index][1];
                        }
                        /**
                         * Checks if a list cache value for `key` exists.
                         *
                         * @private
                         * @name has
                         * @memberOf ListCache
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */
                        function listCacheHas(key) {
                            return assocIndexOf(this.__data__, key) > -1;
                        }
                        /**
                         * Sets the list cache `key` to `value`.
                         *
                         * @private
                         * @name set
                         * @memberOf ListCache
                         * @param {string} key The key of the value to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns the list cache instance.
                         */
                        function listCacheSet(key, value) {
                            var data = this.__data__, index = assocIndexOf(data, key);
                            if (index < 0) {
                                ++this.size;
                                data.push([key, value]);
                            }
                            else {
                                data[index][1] = value;
                            }
                            return this;
                        }
                        // Add methods to `ListCache`.
                        ListCache.prototype.clear = listCacheClear;
                        ListCache.prototype['delete'] = listCacheDelete;
                        ListCache.prototype.get = listCacheGet;
                        ListCache.prototype.has = listCacheHas;
                        ListCache.prototype.set = listCacheSet;
                        /*------------------------------------------------------------------------*/
                        /**
                         * Creates a map cache object to store key-value pairs.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [entries] The key-value pairs to cache.
                         */
                        function MapCache(entries) {
                            var index = -1, length = entries == null ? 0 : entries.length;
                            this.clear();
                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1]);
                            }
                        }
                        /**
                         * Removes all key-value entries from the map.
                         *
                         * @private
                         * @name clear
                         * @memberOf MapCache
                         */
                        function mapCacheClear() {
                            this.size = 0;
                            this.__data__ = {
                                'hash': new Hash,
                                'map': new (Map || ListCache),
                                'string': new Hash
                            };
                        }
                        /**
                         * Removes `key` and its value from the map.
                         *
                         * @private
                         * @name delete
                         * @memberOf MapCache
                         * @param {string} key The key of the value to remove.
                         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                         */
                        function mapCacheDelete(key) {
                            var result = getMapData(this, key)['delete'](key);
                            this.size -= result ? 1 : 0;
                            return result;
                        }
                        /**
                         * Gets the map value for `key`.
                         *
                         * @private
                         * @name get
                         * @memberOf MapCache
                         * @param {string} key The key of the value to get.
                         * @returns {*} Returns the entry value.
                         */
                        function mapCacheGet(key) {
                            return getMapData(this, key).get(key);
                        }
                        /**
                         * Checks if a map value for `key` exists.
                         *
                         * @private
                         * @name has
                         * @memberOf MapCache
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */
                        function mapCacheHas(key) {
                            return getMapData(this, key).has(key);
                        }
                        /**
                         * Sets the map `key` to `value`.
                         *
                         * @private
                         * @name set
                         * @memberOf MapCache
                         * @param {string} key The key of the value to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns the map cache instance.
                         */
                        function mapCacheSet(key, value) {
                            var data = getMapData(this, key), size = data.size;
                            data.set(key, value);
                            this.size += data.size == size ? 0 : 1;
                            return this;
                        }
                        // Add methods to `MapCache`.
                        MapCache.prototype.clear = mapCacheClear;
                        MapCache.prototype['delete'] = mapCacheDelete;
                        MapCache.prototype.get = mapCacheGet;
                        MapCache.prototype.has = mapCacheHas;
                        MapCache.prototype.set = mapCacheSet;
                        /*------------------------------------------------------------------------*/
                        /**
                         *
                         * Creates an array cache object to store unique values.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [values] The values to cache.
                         */
                        function SetCache(values) {
                            var index = -1, length = values == null ? 0 : values.length;
                            this.__data__ = new MapCache;
                            while (++index < length) {
                                this.add(values[index]);
                            }
                        }
                        /**
                         * Adds `value` to the array cache.
                         *
                         * @private
                         * @name add
                         * @memberOf SetCache
                         * @alias push
                         * @param {*} value The value to cache.
                         * @returns {Object} Returns the cache instance.
                         */
                        function setCacheAdd(value) {
                            this.__data__.set(value, HASH_UNDEFINED);
                            return this;
                        }
                        /**
                         * Checks if `value` is in the array cache.
                         *
                         * @private
                         * @name has
                         * @memberOf SetCache
                         * @param {*} value The value to search for.
                         * @returns {number} Returns `true` if `value` is found, else `false`.
                         */
                        function setCacheHas(value) {
                            return this.__data__.has(value);
                        }
                        // Add methods to `SetCache`.
                        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
                        SetCache.prototype.has = setCacheHas;
                        /*------------------------------------------------------------------------*/
                        /**
                         * Creates a stack cache object to store key-value pairs.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [entries] The key-value pairs to cache.
                         */
                        function Stack(entries) {
                            var data = this.__data__ = new ListCache(entries);
                            this.size = data.size;
                        }
                        /**
                         * Removes all key-value entries from the stack.
                         *
                         * @private
                         * @name clear
                         * @memberOf Stack
                         */
                        function stackClear() {
                            this.__data__ = new ListCache;
                            this.size = 0;
                        }
                        /**
                         * Removes `key` and its value from the stack.
                         *
                         * @private
                         * @name delete
                         * @memberOf Stack
                         * @param {string} key The key of the value to remove.
                         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                         */
                        function stackDelete(key) {
                            var data = this.__data__, result = data['delete'](key);
                            this.size = data.size;
                            return result;
                        }
                        /**
                         * Gets the stack value for `key`.
                         *
                         * @private
                         * @name get
                         * @memberOf Stack
                         * @param {string} key The key of the value to get.
                         * @returns {*} Returns the entry value.
                         */
                        function stackGet(key) {
                            return this.__data__.get(key);
                        }
                        /**
                         * Checks if a stack value for `key` exists.
                         *
                         * @private
                         * @name has
                         * @memberOf Stack
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */
                        function stackHas(key) {
                            return this.__data__.has(key);
                        }
                        /**
                         * Sets the stack `key` to `value`.
                         *
                         * @private
                         * @name set
                         * @memberOf Stack
                         * @param {string} key The key of the value to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns the stack cache instance.
                         */
                        function stackSet(key, value) {
                            var data = this.__data__;
                            if (data instanceof ListCache) {
                                var pairs = data.__data__;
                                if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
                                    pairs.push([key, value]);
                                    this.size = ++data.size;
                                    return this;
                                }
                                data = this.__data__ = new MapCache(pairs);
                            }
                            data.set(key, value);
                            this.size = data.size;
                            return this;
                        }
                        // Add methods to `Stack`.
                        Stack.prototype.clear = stackClear;
                        Stack.prototype['delete'] = stackDelete;
                        Stack.prototype.get = stackGet;
                        Stack.prototype.has = stackHas;
                        Stack.prototype.set = stackSet;
                        /*------------------------------------------------------------------------*/
                        /**
                         * Creates an array of the enumerable property names of the array-like `value`.
                         *
                         * @private
                         * @param {*} value The value to query.
                         * @param {boolean} inherited Specify returning inherited property names.
                         * @returns {Array} Returns the array of property names.
                         */
                        function arrayLikeKeys(value, inherited) {
                            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
                            for (var key in value) {
                                if ((inherited || hasOwnProperty.call(value, key)) &&
                                    !(skipIndexes && (
                                    // Safari 9 has enumerable `arguments.length` in strict mode.
                                    key == 'length' ||
                                        // Node.js 0.10 has enumerable non-index properties on buffers.
                                        (isBuff && (key == 'offset' || key == 'parent')) ||
                                        // PhantomJS 2 has enumerable non-index properties on typed arrays.
                                        (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
                                        // Skip index properties.
                                        isIndex(key, length)))) {
                                    result.push(key);
                                }
                            }
                            return result;
                        }
                        /**
                         * A specialized version of `_.sample` for arrays.
                         *
                         * @private
                         * @param {Array} array The array to sample.
                         * @returns {*} Returns the random element.
                         */
                        function arraySample(array) {
                            var length = array.length;
                            return length ? array[baseRandom(0, length - 1)] : undefined;
                        }
                        /**
                         * A specialized version of `_.sampleSize` for arrays.
                         *
                         * @private
                         * @param {Array} array The array to sample.
                         * @param {number} n The number of elements to sample.
                         * @returns {Array} Returns the random elements.
                         */
                        function arraySampleSize(array, n) {
                            return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
                        }
                        /**
                         * A specialized version of `_.shuffle` for arrays.
                         *
                         * @private
                         * @param {Array} array The array to shuffle.
                         * @returns {Array} Returns the new shuffled array.
                         */
                        function arrayShuffle(array) {
                            return shuffleSelf(copyArray(array));
                        }
                        /**
                         * This function is like `assignValue` except that it doesn't assign
                         * `undefined` values.
                         *
                         * @private
                         * @param {Object} object The object to modify.
                         * @param {string} key The key of the property to assign.
                         * @param {*} value The value to assign.
                         */
                        function assignMergeValue(object, key, value) {
                            if ((value !== undefined && !eq(object[key], value)) ||
                                (value === undefined && !(key in object))) {
                                baseAssignValue(object, key, value);
                            }
                        }
                        /**
                         * Assigns `value` to `key` of `object` if the existing value is not equivalent
                         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * for equality comparisons.
                         *
                         * @private
                         * @param {Object} object The object to modify.
                         * @param {string} key The key of the property to assign.
                         * @param {*} value The value to assign.
                         */
                        function assignValue(object, key, value) {
                            var objValue = object[key];
                            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
                                (value === undefined && !(key in object))) {
                                baseAssignValue(object, key, value);
                            }
                        }
                        /**
                         * Gets the index at which the `key` is found in `array` of key-value pairs.
                         *
                         * @private
                         * @param {Array} array The array to inspect.
                         * @param {*} key The key to search for.
                         * @returns {number} Returns the index of the matched value, else `-1`.
                         */
                        function assocIndexOf(array, key) {
                            var length = array.length;
                            while (length--) {
                                if (eq(array[length][0], key)) {
                                    return length;
                                }
                            }
                            return -1;
                        }
                        /**
                         * Aggregates elements of `collection` on `accumulator` with keys transformed
                         * by `iteratee` and values set by `setter`.
                         *
                         * @private
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} setter The function to set `accumulator` values.
                         * @param {Function} iteratee The iteratee to transform keys.
                         * @param {Object} accumulator The initial aggregated object.
                         * @returns {Function} Returns `accumulator`.
                         */
                        function baseAggregator(collection, setter, iteratee, accumulator) {
                            baseEach(collection, function (value, key, collection) {
                                setter(accumulator, value, iteratee(value), collection);
                            });
                            return accumulator;
                        }
                        /**
                         * The base implementation of `_.assign` without support for multiple sources
                         * or `customizer` functions.
                         *
                         * @private
                         * @param {Object} object The destination object.
                         * @param {Object} source The source object.
                         * @returns {Object} Returns `object`.
                         */
                        function baseAssign(object, source) {
                            return object && copyObject(source, keys(source), object);
                        }
                        /**
                         * The base implementation of `_.assignIn` without support for multiple sources
                         * or `customizer` functions.
                         *
                         * @private
                         * @param {Object} object The destination object.
                         * @param {Object} source The source object.
                         * @returns {Object} Returns `object`.
                         */
                        function baseAssignIn(object, source) {
                            return object && copyObject(source, keysIn(source), object);
                        }
                        /**
                         * The base implementation of `assignValue` and `assignMergeValue` without
                         * value checks.
                         *
                         * @private
                         * @param {Object} object The object to modify.
                         * @param {string} key The key of the property to assign.
                         * @param {*} value The value to assign.
                         */
                        function baseAssignValue(object, key, value) {
                            if (key == '__proto__' && defineProperty) {
                                defineProperty(object, key, {
                                    'configurable': true,
                                    'enumerable': true,
                                    'value': value,
                                    'writable': true
                                });
                            }
                            else {
                                object[key] = value;
                            }
                        }
                        /**
                         * The base implementation of `_.at` without support for individual paths.
                         *
                         * @private
                         * @param {Object} object The object to iterate over.
                         * @param {string[]} paths The property paths to pick.
                         * @returns {Array} Returns the picked elements.
                         */
                        function baseAt(object, paths) {
                            var index = -1, length = paths.length, result = Array(length), skip = object == null;
                            while (++index < length) {
                                result[index] = skip ? undefined : get(object, paths[index]);
                            }
                            return result;
                        }
                        /**
                         * The base implementation of `_.clamp` which doesn't coerce arguments.
                         *
                         * @private
                         * @param {number} number The number to clamp.
                         * @param {number} [lower] The lower bound.
                         * @param {number} upper The upper bound.
                         * @returns {number} Returns the clamped number.
                         */
                        function baseClamp(number, lower, upper) {
                            if (number === number) {
                                if (upper !== undefined) {
                                    number = number <= upper ? number : upper;
                                }
                                if (lower !== undefined) {
                                    number = number >= lower ? number : lower;
                                }
                            }
                            return number;
                        }
                        /**
                         * The base implementation of `_.clone` and `_.cloneDeep` which tracks
                         * traversed objects.
                         *
                         * @private
                         * @param {*} value The value to clone.
                         * @param {boolean} bitmask The bitmask flags.
                         *  1 - Deep clone
                         *  2 - Flatten inherited properties
                         *  4 - Clone symbols
                         * @param {Function} [customizer] The function to customize cloning.
                         * @param {string} [key] The key of `value`.
                         * @param {Object} [object] The parent object of `value`.
                         * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
                         * @returns {*} Returns the cloned value.
                         */
                        function baseClone(value, bitmask, customizer, key, object, stack) {
                            var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
                            if (customizer) {
                                result = object ? customizer(value, key, object, stack) : customizer(value);
                            }
                            if (result !== undefined) {
                                return result;
                            }
                            if (!isObject(value)) {
                                return value;
                            }
                            var isArr = isArray(value);
                            if (isArr) {
                                result = initCloneArray(value);
                                if (!isDeep) {
                                    return copyArray(value, result);
                                }
                            }
                            else {
                                var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                                if (isBuffer(value)) {
                                    return cloneBuffer(value, isDeep);
                                }
                                if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                                    result = (isFlat || isFunc) ? {} : initCloneObject(value);
                                    if (!isDeep) {
                                        return isFlat
                                            ? copySymbolsIn(value, baseAssignIn(result, value))
                                            : copySymbols(value, baseAssign(result, value));
                                    }
                                }
                                else {
                                    if (!cloneableTags[tag]) {
                                        return object ? value : {};
                                    }
                                    result = initCloneByTag(value, tag, isDeep);
                                }
                            }
                            // Check for circular references and return its corresponding clone.
                            stack || (stack = new Stack);
                            var stacked = stack.get(value);
                            if (stacked) {
                                return stacked;
                            }
                            stack.set(value, result);
                            if (isSet(value)) {
                                value.forEach(function (subValue) {
                                    result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
                                });
                            }
                            else if (isMap(value)) {
                                value.forEach(function (subValue, key) {
                                    result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
                                });
                            }
                            var keysFunc = isFull
                                ? (isFlat ? getAllKeysIn : getAllKeys)
                                : (isFlat ? keysIn : keys);
                            var props = isArr ? undefined : keysFunc(value);
                            arrayEach(props || value, function (subValue, key) {
                                if (props) {
                                    key = subValue;
                                    subValue = value[key];
                                }
                                // Recursively populate clone (susceptible to call stack limits).
                                assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
                            });
                            return result;
                        }
                        /**
                         * The base implementation of `_.conforms` which doesn't clone `source`.
                         *
                         * @private
                         * @param {Object} source The object of property predicates to conform to.
                         * @returns {Function} Returns the new spec function.
                         */
                        function baseConforms(source) {
                            var props = keys(source);
                            return function (object) {
                                return baseConformsTo(object, source, props);
                            };
                        }
                        /**
                         * The base implementation of `_.conformsTo` which accepts `props` to check.
                         *
                         * @private
                         * @param {Object} object The object to inspect.
                         * @param {Object} source The object of property predicates to conform to.
                         * @returns {boolean} Returns `true` if `object` conforms, else `false`.
                         */
                        function baseConformsTo(object, source, props) {
                            var length = props.length;
                            if (object == null) {
                                return !length;
                            }
                            object = Object(object);
                            while (length--) {
                                var key = props[length], predicate = source[key], value = object[key];
                                if ((value === undefined && !(key in object)) || !predicate(value)) {
                                    return false;
                                }
                            }
                            return true;
                        }
                        /**
                         * The base implementation of `_.delay` and `_.defer` which accepts `args`
                         * to provide to `func`.
                         *
                         * @private
                         * @param {Function} func The function to delay.
                         * @param {number} wait The number of milliseconds to delay invocation.
                         * @param {Array} args The arguments to provide to `func`.
                         * @returns {number|Object} Returns the timer id or timeout object.
                         */
                        function baseDelay(func, wait, args) {
                            if (typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            return setTimeout(function () { func.apply(undefined, args); }, wait);
                        }
                        /**
                         * The base implementation of methods like `_.difference` without support
                         * for excluding multiple arrays or iteratee shorthands.
                         *
                         * @private
                         * @param {Array} array The array to inspect.
                         * @param {Array} values The values to exclude.
                         * @param {Function} [iteratee] The iteratee invoked per element.
                         * @param {Function} [comparator] The comparator invoked per element.
                         * @returns {Array} Returns the new array of filtered values.
                         */
                        function baseDifference(array, values, iteratee, comparator) {
                            var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
                            if (!length) {
                                return result;
                            }
                            if (iteratee) {
                                values = arrayMap(values, baseUnary(iteratee));
                            }
                            if (comparator) {
                                includes = arrayIncludesWith;
                                isCommon = false;
                            }
                            else if (values.length >= LARGE_ARRAY_SIZE) {
                                includes = cacheHas;
                                isCommon = false;
                                values = new SetCache(values);
                            }
                            outer: while (++index < length) {
                                var value = array[index], computed = iteratee == null ? value : iteratee(value);
                                value = (comparator || value !== 0) ? value : 0;
                                if (isCommon && computed === computed) {
                                    var valuesIndex = valuesLength;
                                    while (valuesIndex--) {
                                        if (values[valuesIndex] === computed) {
                                            continue outer;
                                        }
                                    }
                                    result.push(value);
                                }
                                else if (!includes(values, computed, comparator)) {
                                    result.push(value);
                                }
                            }
                            return result;
                        }
                        /**
                         * The base implementation of `_.forEach` without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} iteratee The function invoked per iteration.
                         * @returns {Array|Object} Returns `collection`.
                         */
                        var baseEach = createBaseEach(baseForOwn);
                        /**
                         * The base implementation of `_.forEachRight` without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} iteratee The function invoked per iteration.
                         * @returns {Array|Object} Returns `collection`.
                         */
                        var baseEachRight = createBaseEach(baseForOwnRight, true);
                        /**
                         * The base implementation of `_.every` without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} predicate The function invoked per iteration.
                         * @returns {boolean} Returns `true` if all elements pass the predicate check,
                         *  else `false`
                         */
                        function baseEvery(collection, predicate) {
                            var result = true;
                            baseEach(collection, function (value, index, collection) {
                                result = !!predicate(value, index, collection);
                                return result;
                            });
                            return result;
                        }
                        /**
                         * The base implementation of methods like `_.max` and `_.min` which accepts a
                         * `comparator` to determine the extremum value.
                         *
                         * @private
                         * @param {Array} array The array to iterate over.
                         * @param {Function} iteratee The iteratee invoked per iteration.
                         * @param {Function} comparator The comparator used to compare values.
                         * @returns {*} Returns the extremum value.
                         */
                        function baseExtremum(array, iteratee, comparator) {
                            var index = -1, length = array.length;
                            while (++index < length) {
                                var value = array[index], current = iteratee(value);
                                if (current != null && (computed === undefined
                                    ? (current === current && !isSymbol(current))
                                    : comparator(current, computed))) {
                                    var computed = current, result = value;
                                }
                            }
                            return result;
                        }
                        /**
                         * The base implementation of `_.fill` without an iteratee call guard.
                         *
                         * @private
                         * @param {Array} array The array to fill.
                         * @param {*} value The value to fill `array` with.
                         * @param {number} [start=0] The start position.
                         * @param {number} [end=array.length] The end position.
                         * @returns {Array} Returns `array`.
                         */
                        function baseFill(array, value, start, end) {
                            var length = array.length;
                            start = toInteger(start);
                            if (start < 0) {
                                start = -start > length ? 0 : (length + start);
                            }
                            end = (end === undefined || end > length) ? length : toInteger(end);
                            if (end < 0) {
                                end += length;
                            }
                            end = start > end ? 0 : toLength(end);
                            while (start < end) {
                                array[start++] = value;
                            }
                            return array;
                        }
                        /**
                         * The base implementation of `_.filter` without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} predicate The function invoked per iteration.
                         * @returns {Array} Returns the new filtered array.
                         */
                        function baseFilter(collection, predicate) {
                            var result = [];
                            baseEach(collection, function (value, index, collection) {
                                if (predicate(value, index, collection)) {
                                    result.push(value);
                                }
                            });
                            return result;
                        }
                        /**
                         * The base implementation of `_.flatten` with support for restricting flattening.
                         *
                         * @private
                         * @param {Array} array The array to flatten.
                         * @param {number} depth The maximum recursion depth.
                         * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
                         * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
                         * @param {Array} [result=[]] The initial result value.
                         * @returns {Array} Returns the new flattened array.
                         */
                        function baseFlatten(array, depth, predicate, isStrict, result) {
                            var index = -1, length = array.length;
                            predicate || (predicate = isFlattenable);
                            result || (result = []);
                            while (++index < length) {
                                var value = array[index];
                                if (depth > 0 && predicate(value)) {
                                    if (depth > 1) {
                                        // Recursively flatten arrays (susceptible to call stack limits).
                                        baseFlatten(value, depth - 1, predicate, isStrict, result);
                                    }
                                    else {
                                        arrayPush(result, value);
                                    }
                                }
                                else if (!isStrict) {
                                    result[result.length] = value;
                                }
                            }
                            return result;
                        }
                        /**
                         * The base implementation of `baseForOwn` which iterates over `object`
                         * properties returned by `keysFunc` and invokes `iteratee` for each property.
                         * Iteratee functions may exit iteration early by explicitly returning `false`.
                         *
                         * @private
                         * @param {Object} object The object to iterate over.
                         * @param {Function} iteratee The function invoked per iteration.
                         * @param {Function} keysFunc The function to get the keys of `object`.
                         * @returns {Object} Returns `object`.
                         */
                        var baseFor = createBaseFor();
                        /**
                         * This function is like `baseFor` except that it iterates over properties
                         * in the opposite order.
                         *
                         * @private
                         * @param {Object} object The object to iterate over.
                         * @param {Function} iteratee The function invoked per iteration.
                         * @param {Function} keysFunc The function to get the keys of `object`.
                         * @returns {Object} Returns `object`.
                         */
                        var baseForRight = createBaseFor(true);
                        /**
                         * The base implementation of `_.forOwn` without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Object} object The object to iterate over.
                         * @param {Function} iteratee The function invoked per iteration.
                         * @returns {Object} Returns `object`.
                         */
                        function baseForOwn(object, iteratee) {
                            return object && baseFor(object, iteratee, keys);
                        }
                        /**
                         * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Object} object The object to iterate over.
                         * @param {Function} iteratee The function invoked per iteration.
                         * @returns {Object} Returns `object`.
                         */
                        function baseForOwnRight(object, iteratee) {
                            return object && baseForRight(object, iteratee, keys);
                        }
                        /**
                         * The base implementation of `_.functions` which creates an array of
                         * `object` function property names filtered from `props`.
                         *
                         * @private
                         * @param {Object} object The object to inspect.
                         * @param {Array} props The property names to filter.
                         * @returns {Array} Returns the function names.
                         */
                        function baseFunctions(object, props) {
                            return arrayFilter(props, function (key) {
                                return isFunction(object[key]);
                            });
                        }
                        /**
                         * The base implementation of `_.get` without support for default values.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @param {Array|string} path The path of the property to get.
                         * @returns {*} Returns the resolved value.
                         */
                        function baseGet(object, path) {
                            path = castPath(path, object);
                            var index = 0, length = path.length;
                            while (object != null && index < length) {
                                object = object[toKey(path[index++])];
                            }
                            return (index && index == length) ? object : undefined;
                        }
                        /**
                         * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
                         * `keysFunc` and `symbolsFunc` to get the enumerable property names and
                         * symbols of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @param {Function} keysFunc The function to get the keys of `object`.
                         * @param {Function} symbolsFunc The function to get the symbols of `object`.
                         * @returns {Array} Returns the array of property names and symbols.
                         */
                        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                            var result = keysFunc(object);
                            return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
                        }
                        /**
                         * The base implementation of `getTag` without fallbacks for buggy environments.
                         *
                         * @private
                         * @param {*} value The value to query.
                         * @returns {string} Returns the `toStringTag`.
                         */
                        function baseGetTag(value) {
                            if (value == null) {
                                return value === undefined ? undefinedTag : nullTag;
                            }
                            return (symToStringTag && symToStringTag in Object(value))
                                ? getRawTag(value)
                                : objectToString(value);
                        }
                        /**
                         * The base implementation of `_.gt` which doesn't coerce arguments.
                         *
                         * @private
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @returns {boolean} Returns `true` if `value` is greater than `other`,
                         *  else `false`.
                         */
                        function baseGt(value, other) {
                            return value > other;
                        }
                        /**
                         * The base implementation of `_.has` without support for deep paths.
                         *
                         * @private
                         * @param {Object} [object] The object to query.
                         * @param {Array|string} key The key to check.
                         * @returns {boolean} Returns `true` if `key` exists, else `false`.
                         */
                        function baseHas(object, key) {
                            return object != null && hasOwnProperty.call(object, key);
                        }
                        /**
                         * The base implementation of `_.hasIn` without support for deep paths.
                         *
                         * @private
                         * @param {Object} [object] The object to query.
                         * @param {Array|string} key The key to check.
                         * @returns {boolean} Returns `true` if `key` exists, else `false`.
                         */
                        function baseHasIn(object, key) {
                            return object != null && key in Object(object);
                        }
                        /**
                         * The base implementation of `_.inRange` which doesn't coerce arguments.
                         *
                         * @private
                         * @param {number} number The number to check.
                         * @param {number} start The start of the range.
                         * @param {number} end The end of the range.
                         * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
                         */
                        function baseInRange(number, start, end) {
                            return number >= nativeMin(start, end) && number < nativeMax(start, end);
                        }
                        /**
                         * The base implementation of methods like `_.intersection`, without support
                         * for iteratee shorthands, that accepts an array of arrays to inspect.
                         *
                         * @private
                         * @param {Array} arrays The arrays to inspect.
                         * @param {Function} [iteratee] The iteratee invoked per element.
                         * @param {Function} [comparator] The comparator invoked per element.
                         * @returns {Array} Returns the new array of shared values.
                         */
                        function baseIntersection(arrays, iteratee, comparator) {
                            var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
                            while (othIndex--) {
                                var array = arrays[othIndex];
                                if (othIndex && iteratee) {
                                    array = arrayMap(array, baseUnary(iteratee));
                                }
                                maxLength = nativeMin(array.length, maxLength);
                                caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
                                    ? new SetCache(othIndex && array)
                                    : undefined;
                            }
                            array = arrays[0];
                            var index = -1, seen = caches[0];
                            outer: while (++index < length && result.length < maxLength) {
                                var value = array[index], computed = iteratee ? iteratee(value) : value;
                                value = (comparator || value !== 0) ? value : 0;
                                if (!(seen
                                    ? cacheHas(seen, computed)
                                    : includes(result, computed, comparator))) {
                                    othIndex = othLength;
                                    while (--othIndex) {
                                        var cache = caches[othIndex];
                                        if (!(cache
                                            ? cacheHas(cache, computed)
                                            : includes(arrays[othIndex], computed, comparator))) {
                                            continue outer;
                                        }
                                    }
                                    if (seen) {
                                        seen.push(computed);
                                    }
                                    result.push(value);
                                }
                            }
                            return result;
                        }
                        /**
                         * The base implementation of `_.invert` and `_.invertBy` which inverts
                         * `object` with values transformed by `iteratee` and set by `setter`.
                         *
                         * @private
                         * @param {Object} object The object to iterate over.
                         * @param {Function} setter The function to set `accumulator` values.
                         * @param {Function} iteratee The iteratee to transform values.
                         * @param {Object} accumulator The initial inverted object.
                         * @returns {Function} Returns `accumulator`.
                         */
                        function baseInverter(object, setter, iteratee, accumulator) {
                            baseForOwn(object, function (value, key, object) {
                                setter(accumulator, iteratee(value), key, object);
                            });
                            return accumulator;
                        }
                        /**
                         * The base implementation of `_.invoke` without support for individual
                         * method arguments.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @param {Array|string} path The path of the method to invoke.
                         * @param {Array} args The arguments to invoke the method with.
                         * @returns {*} Returns the result of the invoked method.
                         */
                        function baseInvoke(object, path, args) {
                            path = castPath(path, object);
                            object = parent(object, path);
                            var func = object == null ? object : object[toKey(last(path))];
                            return func == null ? undefined : apply(func, object, args);
                        }
                        /**
                         * The base implementation of `_.isArguments`.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
                         */
                        function baseIsArguments(value) {
                            return isObjectLike(value) && baseGetTag(value) == argsTag;
                        }
                        /**
                         * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
                         */
                        function baseIsArrayBuffer(value) {
                            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
                        }
                        /**
                         * The base implementation of `_.isDate` without Node.js optimizations.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
                         */
                        function baseIsDate(value) {
                            return isObjectLike(value) && baseGetTag(value) == dateTag;
                        }
                        /**
                         * The base implementation of `_.isEqual` which supports partial comparisons
                         * and tracks traversed objects.
                         *
                         * @private
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @param {boolean} bitmask The bitmask flags.
                         *  1 - Unordered comparison
                         *  2 - Partial comparison
                         * @param {Function} [customizer] The function to customize comparisons.
                         * @param {Object} [stack] Tracks traversed `value` and `other` objects.
                         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                         */
                        function baseIsEqual(value, other, bitmask, customizer, stack) {
                            if (value === other) {
                                return true;
                            }
                            if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
                                return value !== value && other !== other;
                            }
                            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
                        }
                        /**
                         * A specialized version of `baseIsEqual` for arrays and objects which performs
                         * deep comparisons and tracks traversed objects enabling objects with circular
                         * references to be compared.
                         *
                         * @private
                         * @param {Object} object The object to compare.
                         * @param {Object} other The other object to compare.
                         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
                         * @param {Function} customizer The function to customize comparisons.
                         * @param {Function} equalFunc The function to determine equivalents of values.
                         * @param {Object} [stack] Tracks traversed `object` and `other` objects.
                         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                         */
                        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
                            objTag = objTag == argsTag ? objectTag : objTag;
                            othTag = othTag == argsTag ? objectTag : othTag;
                            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
                            if (isSameTag && isBuffer(object)) {
                                if (!isBuffer(other)) {
                                    return false;
                                }
                                objIsArr = true;
                                objIsObj = false;
                            }
                            if (isSameTag && !objIsObj) {
                                stack || (stack = new Stack);
                                return (objIsArr || isTypedArray(object))
                                    ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
                                    : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
                            }
                            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                                var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'), othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
                                if (objIsWrapped || othIsWrapped) {
                                    var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                                    stack || (stack = new Stack);
                                    return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                                }
                            }
                            if (!isSameTag) {
                                return false;
                            }
                            stack || (stack = new Stack);
                            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
                        }
                        /**
                         * The base implementation of `_.isMap` without Node.js optimizations.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a map, else `false`.
                         */
                        function baseIsMap(value) {
                            return isObjectLike(value) && getTag(value) == mapTag;
                        }
                        /**
                         * The base implementation of `_.isMatch` without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Object} object The object to inspect.
                         * @param {Object} source The object of property values to match.
                         * @param {Array} matchData The property names, values, and compare flags to match.
                         * @param {Function} [customizer] The function to customize comparisons.
                         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
                         */
                        function baseIsMatch(object, source, matchData, customizer) {
                            var index = matchData.length, length = index, noCustomizer = !customizer;
                            if (object == null) {
                                return !length;
                            }
                            object = Object(object);
                            while (index--) {
                                var data = matchData[index];
                                if ((noCustomizer && data[2])
                                    ? data[1] !== object[data[0]]
                                    : !(data[0] in object)) {
                                    return false;
                                }
                            }
                            while (++index < length) {
                                data = matchData[index];
                                var key = data[0], objValue = object[key], srcValue = data[1];
                                if (noCustomizer && data[2]) {
                                    if (objValue === undefined && !(key in object)) {
                                        return false;
                                    }
                                }
                                else {
                                    var stack = new Stack;
                                    if (customizer) {
                                        var result = customizer(objValue, srcValue, key, object, source, stack);
                                    }
                                    if (!(result === undefined
                                        ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                                        : result)) {
                                        return false;
                                    }
                                }
                            }
                            return true;
                        }
                        /**
                         * The base implementation of `_.isNative` without bad shim checks.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a native function,
                         *  else `false`.
                         */
                        function baseIsNative(value) {
                            if (!isObject(value) || isMasked(value)) {
                                return false;
                            }
                            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                            return pattern.test(toSource(value));
                        }
                        /**
                         * The base implementation of `_.isRegExp` without Node.js optimizations.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
                         */
                        function baseIsRegExp(value) {
                            return isObjectLike(value) && baseGetTag(value) == regexpTag;
                        }
                        /**
                         * The base implementation of `_.isSet` without Node.js optimizations.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a set, else `false`.
                         */
                        function baseIsSet(value) {
                            return isObjectLike(value) && getTag(value) == setTag;
                        }
                        /**
                         * The base implementation of `_.isTypedArray` without Node.js optimizations.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
                         */
                        function baseIsTypedArray(value) {
                            return isObjectLike(value) &&
                                isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
                        }
                        /**
                         * The base implementation of `_.iteratee`.
                         *
                         * @private
                         * @param {*} [value=_.identity] The value to convert to an iteratee.
                         * @returns {Function} Returns the iteratee.
                         */
                        function baseIteratee(value) {
                            // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
                            // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
                            if (typeof value == 'function') {
                                return value;
                            }
                            if (value == null) {
                                return identity;
                            }
                            if (typeof value == 'object') {
                                return isArray(value)
                                    ? baseMatchesProperty(value[0], value[1])
                                    : baseMatches(value);
                            }
                            return property(value);
                        }
                        /**
                         * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property names.
                         */
                        function baseKeys(object) {
                            if (!isPrototype(object)) {
                                return nativeKeys(object);
                            }
                            var result = [];
                            for (var key in Object(object)) {
                                if (hasOwnProperty.call(object, key) && key != 'constructor') {
                                    result.push(key);
                                }
                            }
                            return result;
                        }
                        /**
                         * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property names.
                         */
                        function baseKeysIn(object) {
                            if (!isObject(object)) {
                                return nativeKeysIn(object);
                            }
                            var isProto = isPrototype(object), result = [];
                            for (var key in object) {
                                if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                                    result.push(key);
                                }
                            }
                            return result;
                        }
                        /**
                         * The base implementation of `_.lt` which doesn't coerce arguments.
                         *
                         * @private
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @returns {boolean} Returns `true` if `value` is less than `other`,
                         *  else `false`.
                         */
                        function baseLt(value, other) {
                            return value < other;
                        }
                        /**
                         * The base implementation of `_.map` without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} iteratee The function invoked per iteration.
                         * @returns {Array} Returns the new mapped array.
                         */
                        function baseMap(collection, iteratee) {
                            var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
                            baseEach(collection, function (value, key, collection) {
                                result[++index] = iteratee(value, key, collection);
                            });
                            return result;
                        }
                        /**
                         * The base implementation of `_.matches` which doesn't clone `source`.
                         *
                         * @private
                         * @param {Object} source The object of property values to match.
                         * @returns {Function} Returns the new spec function.
                         */
                        function baseMatches(source) {
                            var matchData = getMatchData(source);
                            if (matchData.length == 1 && matchData[0][2]) {
                                return matchesStrictComparable(matchData[0][0], matchData[0][1]);
                            }
                            return function (object) {
                                return object === source || baseIsMatch(object, source, matchData);
                            };
                        }
                        /**
                         * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
                         *
                         * @private
                         * @param {string} path The path of the property to get.
                         * @param {*} srcValue The value to match.
                         * @returns {Function} Returns the new spec function.
                         */
                        function baseMatchesProperty(path, srcValue) {
                            if (isKey(path) && isStrictComparable(srcValue)) {
                                return matchesStrictComparable(toKey(path), srcValue);
                            }
                            return function (object) {
                                var objValue = get(object, path);
                                return (objValue === undefined && objValue === srcValue)
                                    ? hasIn(object, path)
                                    : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
                            };
                        }
                        /**
                         * The base implementation of `_.merge` without support for multiple sources.
                         *
                         * @private
                         * @param {Object} object The destination object.
                         * @param {Object} source The source object.
                         * @param {number} srcIndex The index of `source`.
                         * @param {Function} [customizer] The function to customize merged values.
                         * @param {Object} [stack] Tracks traversed source values and their merged
                         *  counterparts.
                         */
                        function baseMerge(object, source, srcIndex, customizer, stack) {
                            if (object === source) {
                                return;
                            }
                            baseFor(source, function (srcValue, key) {
                                stack || (stack = new Stack);
                                if (isObject(srcValue)) {
                                    baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
                                }
                                else {
                                    var newValue = customizer
                                        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
                                        : undefined;
                                    if (newValue === undefined) {
                                        newValue = srcValue;
                                    }
                                    assignMergeValue(object, key, newValue);
                                }
                            }, keysIn);
                        }
                        /**
                         * A specialized version of `baseMerge` for arrays and objects which performs
                         * deep merges and tracks traversed objects enabling objects with circular
                         * references to be merged.
                         *
                         * @private
                         * @param {Object} object The destination object.
                         * @param {Object} source The source object.
                         * @param {string} key The key of the value to merge.
                         * @param {number} srcIndex The index of `source`.
                         * @param {Function} mergeFunc The function to merge values.
                         * @param {Function} [customizer] The function to customize assigned values.
                         * @param {Object} [stack] Tracks traversed source values and their merged
                         *  counterparts.
                         */
                        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
                            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
                            if (stacked) {
                                assignMergeValue(object, key, stacked);
                                return;
                            }
                            var newValue = customizer
                                ? customizer(objValue, srcValue, (key + ''), object, source, stack)
                                : undefined;
                            var isCommon = newValue === undefined;
                            if (isCommon) {
                                var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                                newValue = srcValue;
                                if (isArr || isBuff || isTyped) {
                                    if (isArray(objValue)) {
                                        newValue = objValue;
                                    }
                                    else if (isArrayLikeObject(objValue)) {
                                        newValue = copyArray(objValue);
                                    }
                                    else if (isBuff) {
                                        isCommon = false;
                                        newValue = cloneBuffer(srcValue, true);
                                    }
                                    else if (isTyped) {
                                        isCommon = false;
                                        newValue = cloneTypedArray(srcValue, true);
                                    }
                                    else {
                                        newValue = [];
                                    }
                                }
                                else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                                    newValue = objValue;
                                    if (isArguments(objValue)) {
                                        newValue = toPlainObject(objValue);
                                    }
                                    else if (!isObject(objValue) || isFunction(objValue)) {
                                        newValue = initCloneObject(srcValue);
                                    }
                                }
                                else {
                                    isCommon = false;
                                }
                            }
                            if (isCommon) {
                                // Recursively merge objects and arrays (susceptible to call stack limits).
                                stack.set(srcValue, newValue);
                                mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                                stack['delete'](srcValue);
                            }
                            assignMergeValue(object, key, newValue);
                        }
                        /**
                         * The base implementation of `_.nth` which doesn't coerce arguments.
                         *
                         * @private
                         * @param {Array} array The array to query.
                         * @param {number} n The index of the element to return.
                         * @returns {*} Returns the nth element of `array`.
                         */
                        function baseNth(array, n) {
                            var length = array.length;
                            if (!length) {
                                return;
                            }
                            n += n < 0 ? length : 0;
                            return isIndex(n, length) ? array[n] : undefined;
                        }
                        /**
                         * The base implementation of `_.orderBy` without param guards.
                         *
                         * @private
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
                         * @param {string[]} orders The sort orders of `iteratees`.
                         * @returns {Array} Returns the new sorted array.
                         */
                        function baseOrderBy(collection, iteratees, orders) {
                            if (iteratees.length) {
                                iteratees = arrayMap(iteratees, function (iteratee) {
                                    if (isArray(iteratee)) {
                                        return function (value) {
                                            return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
                                        };
                                    }
                                    return iteratee;
                                });
                            }
                            else {
                                iteratees = [identity];
                            }
                            var index = -1;
                            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                            var result = baseMap(collection, function (value, key, collection) {
                                var criteria = arrayMap(iteratees, function (iteratee) {
                                    return iteratee(value);
                                });
                                return { 'criteria': criteria, 'index': ++index, 'value': value };
                            });
                            return baseSortBy(result, function (object, other) {
                                return compareMultiple(object, other, orders);
                            });
                        }
                        /**
                         * The base implementation of `_.pick` without support for individual
                         * property identifiers.
                         *
                         * @private
                         * @param {Object} object The source object.
                         * @param {string[]} paths The property paths to pick.
                         * @returns {Object} Returns the new object.
                         */
                        function basePick(object, paths) {
                            return basePickBy(object, paths, function (value, path) {
                                return hasIn(object, path);
                            });
                        }
                        /**
                         * The base implementation of  `_.pickBy` without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Object} object The source object.
                         * @param {string[]} paths The property paths to pick.
                         * @param {Function} predicate The function invoked per property.
                         * @returns {Object} Returns the new object.
                         */
                        function basePickBy(object, paths, predicate) {
                            var index = -1, length = paths.length, result = {};
                            while (++index < length) {
                                var path = paths[index], value = baseGet(object, path);
                                if (predicate(value, path)) {
                                    baseSet(result, castPath(path, object), value);
                                }
                            }
                            return result;
                        }
                        /**
                         * A specialized version of `baseProperty` which supports deep paths.
                         *
                         * @private
                         * @param {Array|string} path The path of the property to get.
                         * @returns {Function} Returns the new accessor function.
                         */
                        function basePropertyDeep(path) {
                            return function (object) {
                                return baseGet(object, path);
                            };
                        }
                        /**
                         * The base implementation of `_.pullAllBy` without support for iteratee
                         * shorthands.
                         *
                         * @private
                         * @param {Array} array The array to modify.
                         * @param {Array} values The values to remove.
                         * @param {Function} [iteratee] The iteratee invoked per element.
                         * @param {Function} [comparator] The comparator invoked per element.
                         * @returns {Array} Returns `array`.
                         */
                        function basePullAll(array, values, iteratee, comparator) {
                            var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;
                            if (array === values) {
                                values = copyArray(values);
                            }
                            if (iteratee) {
                                seen = arrayMap(array, baseUnary(iteratee));
                            }
                            while (++index < length) {
                                var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
                                while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
                                    if (seen !== array) {
                                        splice.call(seen, fromIndex, 1);
                                    }
                                    splice.call(array, fromIndex, 1);
                                }
                            }
                            return array;
                        }
                        /**
                         * The base implementation of `_.pullAt` without support for individual
                         * indexes or capturing the removed elements.
                         *
                         * @private
                         * @param {Array} array The array to modify.
                         * @param {number[]} indexes The indexes of elements to remove.
                         * @returns {Array} Returns `array`.
                         */
                        function basePullAt(array, indexes) {
                            var length = array ? indexes.length : 0, lastIndex = length - 1;
                            while (length--) {
                                var index = indexes[length];
                                if (length == lastIndex || index !== previous) {
                                    var previous = index;
                                    if (isIndex(index)) {
                                        splice.call(array, index, 1);
                                    }
                                    else {
                                        baseUnset(array, index);
                                    }
                                }
                            }
                            return array;
                        }
                        /**
                         * The base implementation of `_.random` without support for returning
                         * floating-point numbers.
                         *
                         * @private
                         * @param {number} lower The lower bound.
                         * @param {number} upper The upper bound.
                         * @returns {number} Returns the random number.
                         */
                        function baseRandom(lower, upper) {
                            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
                        }
                        /**
                         * The base implementation of `_.range` and `_.rangeRight` which doesn't
                         * coerce arguments.
                         *
                         * @private
                         * @param {number} start The start of the range.
                         * @param {number} end The end of the range.
                         * @param {number} step The value to increment or decrement by.
                         * @param {boolean} [fromRight] Specify iterating from right to left.
                         * @returns {Array} Returns the range of numbers.
                         */
                        function baseRange(start, end, step, fromRight) {
                            var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
                            while (length--) {
                                result[fromRight ? length : ++index] = start;
                                start += step;
                            }
                            return result;
                        }
                        /**
                         * The base implementation of `_.repeat` which doesn't coerce arguments.
                         *
                         * @private
                         * @param {string} string The string to repeat.
                         * @param {number} n The number of times to repeat the string.
                         * @returns {string} Returns the repeated string.
                         */
                        function baseRepeat(string, n) {
                            var result = '';
                            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
                                return result;
                            }
                            // Leverage the exponentiation by squaring algorithm for a faster repeat.
                            // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
                            do {
                                if (n % 2) {
                                    result += string;
                                }
                                n = nativeFloor(n / 2);
                                if (n) {
                                    string += string;
                                }
                            } while (n);
                            return result;
                        }
                        /**
                         * The base implementation of `_.rest` which doesn't validate or coerce arguments.
                         *
                         * @private
                         * @param {Function} func The function to apply a rest parameter to.
                         * @param {number} [start=func.length-1] The start position of the rest parameter.
                         * @returns {Function} Returns the new function.
                         */
                        function baseRest(func, start) {
                            return setToString(overRest(func, start, identity), func + '');
                        }
                        /**
                         * The base implementation of `_.sample`.
                         *
                         * @private
                         * @param {Array|Object} collection The collection to sample.
                         * @returns {*} Returns the random element.
                         */
                        function baseSample(collection) {
                            return arraySample(values(collection));
                        }
                        /**
                         * The base implementation of `_.sampleSize` without param guards.
                         *
                         * @private
                         * @param {Array|Object} collection The collection to sample.
                         * @param {number} n The number of elements to sample.
                         * @returns {Array} Returns the random elements.
                         */
                        function baseSampleSize(collection, n) {
                            var array = values(collection);
                            return shuffleSelf(array, baseClamp(n, 0, array.length));
                        }
                        /**
                         * The base implementation of `_.set`.
                         *
                         * @private
                         * @param {Object} object The object to modify.
                         * @param {Array|string} path The path of the property to set.
                         * @param {*} value The value to set.
                         * @param {Function} [customizer] The function to customize path creation.
                         * @returns {Object} Returns `object`.
                         */
                        function baseSet(object, path, value, customizer) {
                            if (!isObject(object)) {
                                return object;
                            }
                            path = castPath(path, object);
                            var index = -1, length = path.length, lastIndex = length - 1, nested = object;
                            while (nested != null && ++index < length) {
                                var key = toKey(path[index]), newValue = value;
                                if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
                                    return object;
                                }
                                if (index != lastIndex) {
                                    var objValue = nested[key];
                                    newValue = customizer ? customizer(objValue, key, nested) : undefined;
                                    if (newValue === undefined) {
                                        newValue = isObject(objValue)
                                            ? objValue
                                            : (isIndex(path[index + 1]) ? [] : {});
                                    }
                                }
                                assignValue(nested, key, newValue);
                                nested = nested[key];
                            }
                            return object;
                        }
                        /**
                         * The base implementation of `setData` without support for hot loop shorting.
                         *
                         * @private
                         * @param {Function} func The function to associate metadata with.
                         * @param {*} data The metadata.
                         * @returns {Function} Returns `func`.
                         */
                        var baseSetData = !metaMap ? identity : function (func, data) {
                            metaMap.set(func, data);
                            return func;
                        };
                        /**
                         * The base implementation of `setToString` without support for hot loop shorting.
                         *
                         * @private
                         * @param {Function} func The function to modify.
                         * @param {Function} string The `toString` result.
                         * @returns {Function} Returns `func`.
                         */
                        var baseSetToString = !defineProperty ? identity : function (func, string) {
                            return defineProperty(func, 'toString', {
                                'configurable': true,
                                'enumerable': false,
                                'value': constant(string),
                                'writable': true
                            });
                        };
                        /**
                         * The base implementation of `_.shuffle`.
                         *
                         * @private
                         * @param {Array|Object} collection The collection to shuffle.
                         * @returns {Array} Returns the new shuffled array.
                         */
                        function baseShuffle(collection) {
                            return shuffleSelf(values(collection));
                        }
                        /**
                         * The base implementation of `_.slice` without an iteratee call guard.
                         *
                         * @private
                         * @param {Array} array The array to slice.
                         * @param {number} [start=0] The start position.
                         * @param {number} [end=array.length] The end position.
                         * @returns {Array} Returns the slice of `array`.
                         */
                        function baseSlice(array, start, end) {
                            var index = -1, length = array.length;
                            if (start < 0) {
                                start = -start > length ? 0 : (length + start);
                            }
                            end = end > length ? length : end;
                            if (end < 0) {
                                end += length;
                            }
                            length = start > end ? 0 : ((end - start) >>> 0);
                            start >>>= 0;
                            var result = Array(length);
                            while (++index < length) {
                                result[index] = array[index + start];
                            }
                            return result;
                        }
                        /**
                         * The base implementation of `_.some` without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} predicate The function invoked per iteration.
                         * @returns {boolean} Returns `true` if any element passes the predicate check,
                         *  else `false`.
                         */
                        function baseSome(collection, predicate) {
                            var result;
                            baseEach(collection, function (value, index, collection) {
                                result = predicate(value, index, collection);
                                return !result;
                            });
                            return !!result;
                        }
                        /**
                         * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
                         * performs a binary search of `array` to determine the index at which `value`
                         * should be inserted into `array` in order to maintain its sort order.
                         *
                         * @private
                         * @param {Array} array The sorted array to inspect.
                         * @param {*} value The value to evaluate.
                         * @param {boolean} [retHighest] Specify returning the highest qualified index.
                         * @returns {number} Returns the index at which `value` should be inserted
                         *  into `array`.
                         */
                        function baseSortedIndex(array, value, retHighest) {
                            var low = 0, high = array == null ? low : array.length;
                            if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                                while (low < high) {
                                    var mid = (low + high) >>> 1, computed = array[mid];
                                    if (computed !== null && !isSymbol(computed) &&
                                        (retHighest ? (computed <= value) : (computed < value))) {
                                        low = mid + 1;
                                    }
                                    else {
                                        high = mid;
                                    }
                                }
                                return high;
                            }
                            return baseSortedIndexBy(array, value, identity, retHighest);
                        }
                        /**
                         * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
                         * which invokes `iteratee` for `value` and each element of `array` to compute
                         * their sort ranking. The iteratee is invoked with one argument; (value).
                         *
                         * @private
                         * @param {Array} array The sorted array to inspect.
                         * @param {*} value The value to evaluate.
                         * @param {Function} iteratee The iteratee invoked per element.
                         * @param {boolean} [retHighest] Specify returning the highest qualified index.
                         * @returns {number} Returns the index at which `value` should be inserted
                         *  into `array`.
                         */
                        function baseSortedIndexBy(array, value, iteratee, retHighest) {
                            var low = 0, high = array == null ? 0 : array.length;
                            if (high === 0) {
                                return 0;
                            }
                            value = iteratee(value);
                            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined;
                            while (low < high) {
                                var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]), othIsDefined = computed !== undefined, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
                                if (valIsNaN) {
                                    var setLow = retHighest || othIsReflexive;
                                }
                                else if (valIsUndefined) {
                                    setLow = othIsReflexive && (retHighest || othIsDefined);
                                }
                                else if (valIsNull) {
                                    setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
                                }
                                else if (valIsSymbol) {
                                    setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
                                }
                                else if (othIsNull || othIsSymbol) {
                                    setLow = false;
                                }
                                else {
                                    setLow = retHighest ? (computed <= value) : (computed < value);
                                }
                                if (setLow) {
                                    low = mid + 1;
                                }
                                else {
                                    high = mid;
                                }
                            }
                            return nativeMin(high, MAX_ARRAY_INDEX);
                        }
                        /**
                         * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
                         * support for iteratee shorthands.
                         *
                         * @private
                         * @param {Array} array The array to inspect.
                         * @param {Function} [iteratee] The iteratee invoked per element.
                         * @returns {Array} Returns the new duplicate free array.
                         */
                        function baseSortedUniq(array, iteratee) {
                            var index = -1, length = array.length, resIndex = 0, result = [];
                            while (++index < length) {
                                var value = array[index], computed = iteratee ? iteratee(value) : value;
                                if (!index || !eq(computed, seen)) {
                                    var seen = computed;
                                    result[resIndex++] = value === 0 ? 0 : value;
                                }
                            }
                            return result;
                        }
                        /**
                         * The base implementation of `_.toNumber` which doesn't ensure correct
                         * conversions of binary, hexadecimal, or octal string values.
                         *
                         * @private
                         * @param {*} value The value to process.
                         * @returns {number} Returns the number.
                         */
                        function baseToNumber(value) {
                            if (typeof value == 'number') {
                                return value;
                            }
                            if (isSymbol(value)) {
                                return NAN;
                            }
                            return +value;
                        }
                        /**
                         * The base implementation of `_.toString` which doesn't convert nullish
                         * values to empty strings.
                         *
                         * @private
                         * @param {*} value The value to process.
                         * @returns {string} Returns the string.
                         */
                        function baseToString(value) {
                            // Exit early for strings to avoid a performance hit in some environments.
                            if (typeof value == 'string') {
                                return value;
                            }
                            if (isArray(value)) {
                                // Recursively convert values (susceptible to call stack limits).
                                return arrayMap(value, baseToString) + '';
                            }
                            if (isSymbol(value)) {
                                return symbolToString ? symbolToString.call(value) : '';
                            }
                            var result = (value + '');
                            return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
                        }
                        /**
                         * The base implementation of `_.uniqBy` without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Array} array The array to inspect.
                         * @param {Function} [iteratee] The iteratee invoked per element.
                         * @param {Function} [comparator] The comparator invoked per element.
                         * @returns {Array} Returns the new duplicate free array.
                         */
                        function baseUniq(array, iteratee, comparator) {
                            var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
                            if (comparator) {
                                isCommon = false;
                                includes = arrayIncludesWith;
                            }
                            else if (length >= LARGE_ARRAY_SIZE) {
                                var set = iteratee ? null : createSet(array);
                                if (set) {
                                    return setToArray(set);
                                }
                                isCommon = false;
                                includes = cacheHas;
                                seen = new SetCache;
                            }
                            else {
                                seen = iteratee ? [] : result;
                            }
                            outer: while (++index < length) {
                                var value = array[index], computed = iteratee ? iteratee(value) : value;
                                value = (comparator || value !== 0) ? value : 0;
                                if (isCommon && computed === computed) {
                                    var seenIndex = seen.length;
                                    while (seenIndex--) {
                                        if (seen[seenIndex] === computed) {
                                            continue outer;
                                        }
                                    }
                                    if (iteratee) {
                                        seen.push(computed);
                                    }
                                    result.push(value);
                                }
                                else if (!includes(seen, computed, comparator)) {
                                    if (seen !== result) {
                                        seen.push(computed);
                                    }
                                    result.push(value);
                                }
                            }
                            return result;
                        }
                        /**
                         * The base implementation of `_.unset`.
                         *
                         * @private
                         * @param {Object} object The object to modify.
                         * @param {Array|string} path The property path to unset.
                         * @returns {boolean} Returns `true` if the property is deleted, else `false`.
                         */
                        function baseUnset(object, path) {
                            path = castPath(path, object);
                            object = parent(object, path);
                            return object == null || delete object[toKey(last(path))];
                        }
                        /**
                         * The base implementation of `_.update`.
                         *
                         * @private
                         * @param {Object} object The object to modify.
                         * @param {Array|string} path The path of the property to update.
                         * @param {Function} updater The function to produce the updated value.
                         * @param {Function} [customizer] The function to customize path creation.
                         * @returns {Object} Returns `object`.
                         */
                        function baseUpdate(object, path, updater, customizer) {
                            return baseSet(object, path, updater(baseGet(object, path)), customizer);
                        }
                        /**
                         * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
                         * without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Array} array The array to query.
                         * @param {Function} predicate The function invoked per iteration.
                         * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
                         * @param {boolean} [fromRight] Specify iterating from right to left.
                         * @returns {Array} Returns the slice of `array`.
                         */
                        function baseWhile(array, predicate, isDrop, fromRight) {
                            var length = array.length, index = fromRight ? length : -1;
                            while ((fromRight ? index-- : ++index < length) &&
                                predicate(array[index], index, array)) { }
                            return isDrop
                                ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
                                : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
                        }
                        /**
                         * The base implementation of `wrapperValue` which returns the result of
                         * performing a sequence of actions on the unwrapped `value`, where each
                         * successive action is supplied the return value of the previous.
                         *
                         * @private
                         * @param {*} value The unwrapped value.
                         * @param {Array} actions Actions to perform to resolve the unwrapped value.
                         * @returns {*} Returns the resolved value.
                         */
                        function baseWrapperValue(value, actions) {
                            var result = value;
                            if (result instanceof LazyWrapper) {
                                result = result.value();
                            }
                            return arrayReduce(actions, function (result, action) {
                                return action.func.apply(action.thisArg, arrayPush([result], action.args));
                            }, result);
                        }
                        /**
                         * The base implementation of methods like `_.xor`, without support for
                         * iteratee shorthands, that accepts an array of arrays to inspect.
                         *
                         * @private
                         * @param {Array} arrays The arrays to inspect.
                         * @param {Function} [iteratee] The iteratee invoked per element.
                         * @param {Function} [comparator] The comparator invoked per element.
                         * @returns {Array} Returns the new array of values.
                         */
                        function baseXor(arrays, iteratee, comparator) {
                            var length = arrays.length;
                            if (length < 2) {
                                return length ? baseUniq(arrays[0]) : [];
                            }
                            var index = -1, result = Array(length);
                            while (++index < length) {
                                var array = arrays[index], othIndex = -1;
                                while (++othIndex < length) {
                                    if (othIndex != index) {
                                        result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
                                    }
                                }
                            }
                            return baseUniq(baseFlatten(result, 1), iteratee, comparator);
                        }
                        /**
                         * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
                         *
                         * @private
                         * @param {Array} props The property identifiers.
                         * @param {Array} values The property values.
                         * @param {Function} assignFunc The function to assign values.
                         * @returns {Object} Returns the new object.
                         */
                        function baseZipObject(props, values, assignFunc) {
                            var index = -1, length = props.length, valsLength = values.length, result = {};
                            while (++index < length) {
                                var value = index < valsLength ? values[index] : undefined;
                                assignFunc(result, props[index], value);
                            }
                            return result;
                        }
                        /**
                         * Casts `value` to an empty array if it's not an array like object.
                         *
                         * @private
                         * @param {*} value The value to inspect.
                         * @returns {Array|Object} Returns the cast array-like object.
                         */
                        function castArrayLikeObject(value) {
                            return isArrayLikeObject(value) ? value : [];
                        }
                        /**
                         * Casts `value` to `identity` if it's not a function.
                         *
                         * @private
                         * @param {*} value The value to inspect.
                         * @returns {Function} Returns cast function.
                         */
                        function castFunction(value) {
                            return typeof value == 'function' ? value : identity;
                        }
                        /**
                         * Casts `value` to a path array if it's not one.
                         *
                         * @private
                         * @param {*} value The value to inspect.
                         * @param {Object} [object] The object to query keys on.
                         * @returns {Array} Returns the cast property path array.
                         */
                        function castPath(value, object) {
                            if (isArray(value)) {
                                return value;
                            }
                            return isKey(value, object) ? [value] : stringToPath(toString(value));
                        }
                        /**
                         * A `baseRest` alias which can be replaced with `identity` by module
                         * replacement plugins.
                         *
                         * @private
                         * @type {Function}
                         * @param {Function} func The function to apply a rest parameter to.
                         * @returns {Function} Returns the new function.
                         */
                        var castRest = baseRest;
                        /**
                         * Casts `array` to a slice if it's needed.
                         *
                         * @private
                         * @param {Array} array The array to inspect.
                         * @param {number} start The start position.
                         * @param {number} [end=array.length] The end position.
                         * @returns {Array} Returns the cast slice.
                         */
                        function castSlice(array, start, end) {
                            var length = array.length;
                            end = end === undefined ? length : end;
                            return (!start && end >= length) ? array : baseSlice(array, start, end);
                        }
                        /**
                         * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
                         *
                         * @private
                         * @param {number|Object} id The timer id or timeout object of the timer to clear.
                         */
                        var clearTimeout = ctxClearTimeout || function (id) {
                            return root.clearTimeout(id);
                        };
                        /**
                         * Creates a clone of  `buffer`.
                         *
                         * @private
                         * @param {Buffer} buffer The buffer to clone.
                         * @param {boolean} [isDeep] Specify a deep clone.
                         * @returns {Buffer} Returns the cloned buffer.
                         */
                        function cloneBuffer(buffer, isDeep) {
                            if (isDeep) {
                                return buffer.slice();
                            }
                            var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
                            buffer.copy(result);
                            return result;
                        }
                        /**
                         * Creates a clone of `arrayBuffer`.
                         *
                         * @private
                         * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
                         * @returns {ArrayBuffer} Returns the cloned array buffer.
                         */
                        function cloneArrayBuffer(arrayBuffer) {
                            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
                            new Uint8Array(result).set(new Uint8Array(arrayBuffer));
                            return result;
                        }
                        /**
                         * Creates a clone of `dataView`.
                         *
                         * @private
                         * @param {Object} dataView The data view to clone.
                         * @param {boolean} [isDeep] Specify a deep clone.
                         * @returns {Object} Returns the cloned data view.
                         */
                        function cloneDataView(dataView, isDeep) {
                            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
                        }
                        /**
                         * Creates a clone of `regexp`.
                         *
                         * @private
                         * @param {Object} regexp The regexp to clone.
                         * @returns {Object} Returns the cloned regexp.
                         */
                        function cloneRegExp(regexp) {
                            var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                            result.lastIndex = regexp.lastIndex;
                            return result;
                        }
                        /**
                         * Creates a clone of the `symbol` object.
                         *
                         * @private
                         * @param {Object} symbol The symbol object to clone.
                         * @returns {Object} Returns the cloned symbol object.
                         */
                        function cloneSymbol(symbol) {
                            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
                        }
                        /**
                         * Creates a clone of `typedArray`.
                         *
                         * @private
                         * @param {Object} typedArray The typed array to clone.
                         * @param {boolean} [isDeep] Specify a deep clone.
                         * @returns {Object} Returns the cloned typed array.
                         */
                        function cloneTypedArray(typedArray, isDeep) {
                            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
                        }
                        /**
                         * Compares values to sort them in ascending order.
                         *
                         * @private
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @returns {number} Returns the sort order indicator for `value`.
                         */
                        function compareAscending(value, other) {
                            if (value !== other) {
                                var valIsDefined = value !== undefined, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
                                var othIsDefined = other !== undefined, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
                                if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
                                    (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
                                    (valIsNull && othIsDefined && othIsReflexive) ||
                                    (!valIsDefined && othIsReflexive) ||
                                    !valIsReflexive) {
                                    return 1;
                                }
                                if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
                                    (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
                                    (othIsNull && valIsDefined && valIsReflexive) ||
                                    (!othIsDefined && valIsReflexive) ||
                                    !othIsReflexive) {
                                    return -1;
                                }
                            }
                            return 0;
                        }
                        /**
                         * Used by `_.orderBy` to compare multiple properties of a value to another
                         * and stable sort them.
                         *
                         * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
                         * specify an order of "desc" for descending or "asc" for ascending sort order
                         * of corresponding values.
                         *
                         * @private
                         * @param {Object} object The object to compare.
                         * @param {Object} other The other object to compare.
                         * @param {boolean[]|string[]} orders The order to sort by for each property.
                         * @returns {number} Returns the sort order indicator for `object`.
                         */
                        function compareMultiple(object, other, orders) {
                            var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
                            while (++index < length) {
                                var result = compareAscending(objCriteria[index], othCriteria[index]);
                                if (result) {
                                    if (index >= ordersLength) {
                                        return result;
                                    }
                                    var order = orders[index];
                                    return result * (order == 'desc' ? -1 : 1);
                                }
                            }
                            // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
                            // that causes it, under certain circumstances, to provide the same value for
                            // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
                            // for more details.
                            //
                            // This also ensures a stable sort in V8 and other engines.
                            // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
                            return object.index - other.index;
                        }
                        /**
                         * Creates an array that is the composition of partially applied arguments,
                         * placeholders, and provided arguments into a single array of arguments.
                         *
                         * @private
                         * @param {Array} args The provided arguments.
                         * @param {Array} partials The arguments to prepend to those provided.
                         * @param {Array} holders The `partials` placeholder indexes.
                         * @params {boolean} [isCurried] Specify composing for a curried function.
                         * @returns {Array} Returns the new array of composed arguments.
                         */
                        function composeArgs(args, partials, holders, isCurried) {
                            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
                            while (++leftIndex < leftLength) {
                                result[leftIndex] = partials[leftIndex];
                            }
                            while (++argsIndex < holdersLength) {
                                if (isUncurried || argsIndex < argsLength) {
                                    result[holders[argsIndex]] = args[argsIndex];
                                }
                            }
                            while (rangeLength--) {
                                result[leftIndex++] = args[argsIndex++];
                            }
                            return result;
                        }
                        /**
                         * This function is like `composeArgs` except that the arguments composition
                         * is tailored for `_.partialRight`.
                         *
                         * @private
                         * @param {Array} args The provided arguments.
                         * @param {Array} partials The arguments to append to those provided.
                         * @param {Array} holders The `partials` placeholder indexes.
                         * @params {boolean} [isCurried] Specify composing for a curried function.
                         * @returns {Array} Returns the new array of composed arguments.
                         */
                        function composeArgsRight(args, partials, holders, isCurried) {
                            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
                            while (++argsIndex < rangeLength) {
                                result[argsIndex] = args[argsIndex];
                            }
                            var offset = argsIndex;
                            while (++rightIndex < rightLength) {
                                result[offset + rightIndex] = partials[rightIndex];
                            }
                            while (++holdersIndex < holdersLength) {
                                if (isUncurried || argsIndex < argsLength) {
                                    result[offset + holders[holdersIndex]] = args[argsIndex++];
                                }
                            }
                            return result;
                        }
                        /**
                         * Copies the values of `source` to `array`.
                         *
                         * @private
                         * @param {Array} source The array to copy values from.
                         * @param {Array} [array=[]] The array to copy values to.
                         * @returns {Array} Returns `array`.
                         */
                        function copyArray(source, array) {
                            var index = -1, length = source.length;
                            array || (array = Array(length));
                            while (++index < length) {
                                array[index] = source[index];
                            }
                            return array;
                        }
                        /**
                         * Copies properties of `source` to `object`.
                         *
                         * @private
                         * @param {Object} source The object to copy properties from.
                         * @param {Array} props The property identifiers to copy.
                         * @param {Object} [object={}] The object to copy properties to.
                         * @param {Function} [customizer] The function to customize copied values.
                         * @returns {Object} Returns `object`.
                         */
                        function copyObject(source, props, object, customizer) {
                            var isNew = !object;
                            object || (object = {});
                            var index = -1, length = props.length;
                            while (++index < length) {
                                var key = props[index];
                                var newValue = customizer
                                    ? customizer(object[key], source[key], key, object, source)
                                    : undefined;
                                if (newValue === undefined) {
                                    newValue = source[key];
                                }
                                if (isNew) {
                                    baseAssignValue(object, key, newValue);
                                }
                                else {
                                    assignValue(object, key, newValue);
                                }
                            }
                            return object;
                        }
                        /**
                         * Copies own symbols of `source` to `object`.
                         *
                         * @private
                         * @param {Object} source The object to copy symbols from.
                         * @param {Object} [object={}] The object to copy symbols to.
                         * @returns {Object} Returns `object`.
                         */
                        function copySymbols(source, object) {
                            return copyObject(source, getSymbols(source), object);
                        }
                        /**
                         * Copies own and inherited symbols of `source` to `object`.
                         *
                         * @private
                         * @param {Object} source The object to copy symbols from.
                         * @param {Object} [object={}] The object to copy symbols to.
                         * @returns {Object} Returns `object`.
                         */
                        function copySymbolsIn(source, object) {
                            return copyObject(source, getSymbolsIn(source), object);
                        }
                        /**
                         * Creates a function like `_.groupBy`.
                         *
                         * @private
                         * @param {Function} setter The function to set accumulator values.
                         * @param {Function} [initializer] The accumulator object initializer.
                         * @returns {Function} Returns the new aggregator function.
                         */
                        function createAggregator(setter, initializer) {
                            return function (collection, iteratee) {
                                var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
                                return func(collection, setter, getIteratee(iteratee, 2), accumulator);
                            };
                        }
                        /**
                         * Creates a function like `_.assign`.
                         *
                         * @private
                         * @param {Function} assigner The function to assign values.
                         * @returns {Function} Returns the new assigner function.
                         */
                        function createAssigner(assigner) {
                            return baseRest(function (object, sources) {
                                var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
                                customizer = (assigner.length > 3 && typeof customizer == 'function')
                                    ? (length--, customizer)
                                    : undefined;
                                if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                                    customizer = length < 3 ? undefined : customizer;
                                    length = 1;
                                }
                                object = Object(object);
                                while (++index < length) {
                                    var source = sources[index];
                                    if (source) {
                                        assigner(object, source, index, customizer);
                                    }
                                }
                                return object;
                            });
                        }
                        /**
                         * Creates a `baseEach` or `baseEachRight` function.
                         *
                         * @private
                         * @param {Function} eachFunc The function to iterate over a collection.
                         * @param {boolean} [fromRight] Specify iterating from right to left.
                         * @returns {Function} Returns the new base function.
                         */
                        function createBaseEach(eachFunc, fromRight) {
                            return function (collection, iteratee) {
                                if (collection == null) {
                                    return collection;
                                }
                                if (!isArrayLike(collection)) {
                                    return eachFunc(collection, iteratee);
                                }
                                var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
                                while ((fromRight ? index-- : ++index < length)) {
                                    if (iteratee(iterable[index], index, iterable) === false) {
                                        break;
                                    }
                                }
                                return collection;
                            };
                        }
                        /**
                         * Creates a base function for methods like `_.forIn` and `_.forOwn`.
                         *
                         * @private
                         * @param {boolean} [fromRight] Specify iterating from right to left.
                         * @returns {Function} Returns the new base function.
                         */
                        function createBaseFor(fromRight) {
                            return function (object, iteratee, keysFunc) {
                                var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
                                while (length--) {
                                    var key = props[fromRight ? length : ++index];
                                    if (iteratee(iterable[key], key, iterable) === false) {
                                        break;
                                    }
                                }
                                return object;
                            };
                        }
                        /**
                         * Creates a function that wraps `func` to invoke it with the optional `this`
                         * binding of `thisArg`.
                         *
                         * @private
                         * @param {Function} func The function to wrap.
                         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
                         * @param {*} [thisArg] The `this` binding of `func`.
                         * @returns {Function} Returns the new wrapped function.
                         */
                        function createBind(func, bitmask, thisArg) {
                            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                            function wrapper() {
                                var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
                                return fn.apply(isBind ? thisArg : this, arguments);
                            }
                            return wrapper;
                        }
                        /**
                         * Creates a function like `_.lowerFirst`.
                         *
                         * @private
                         * @param {string} methodName The name of the `String` case method to use.
                         * @returns {Function} Returns the new case function.
                         */
                        function createCaseFirst(methodName) {
                            return function (string) {
                                string = toString(string);
                                var strSymbols = hasUnicode(string)
                                    ? stringToArray(string)
                                    : undefined;
                                var chr = strSymbols
                                    ? strSymbols[0]
                                    : string.charAt(0);
                                var trailing = strSymbols
                                    ? castSlice(strSymbols, 1).join('')
                                    : string.slice(1);
                                return chr[methodName]() + trailing;
                            };
                        }
                        /**
                         * Creates a function like `_.camelCase`.
                         *
                         * @private
                         * @param {Function} callback The function to combine each word.
                         * @returns {Function} Returns the new compounder function.
                         */
                        function createCompounder(callback) {
                            return function (string) {
                                return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
                            };
                        }
                        /**
                         * Creates a function that produces an instance of `Ctor` regardless of
                         * whether it was invoked as part of a `new` expression or by `call` or `apply`.
                         *
                         * @private
                         * @param {Function} Ctor The constructor to wrap.
                         * @returns {Function} Returns the new wrapped function.
                         */
                        function createCtor(Ctor) {
                            return function () {
                                // Use a `switch` statement to work with class constructors. See
                                // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
                                // for more details.
                                var args = arguments;
                                switch (args.length) {
                                    case 0: return new Ctor;
                                    case 1: return new Ctor(args[0]);
                                    case 2: return new Ctor(args[0], args[1]);
                                    case 3: return new Ctor(args[0], args[1], args[2]);
                                    case 4: return new Ctor(args[0], args[1], args[2], args[3]);
                                    case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                                    case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                                    case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                                }
                                var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
                                // Mimic the constructor's `return` behavior.
                                // See https://es5.github.io/#x13.2.2 for more details.
                                return isObject(result) ? result : thisBinding;
                            };
                        }
                        /**
                         * Creates a function that wraps `func` to enable currying.
                         *
                         * @private
                         * @param {Function} func The function to wrap.
                         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
                         * @param {number} arity The arity of `func`.
                         * @returns {Function} Returns the new wrapped function.
                         */
                        function createCurry(func, bitmask, arity) {
                            var Ctor = createCtor(func);
                            function wrapper() {
                                var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper);
                                while (index--) {
                                    args[index] = arguments[index];
                                }
                                var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
                                    ? []
                                    : replaceHolders(args, placeholder);
                                length -= holders.length;
                                if (length < arity) {
                                    return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
                                }
                                var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
                                return apply(fn, this, args);
                            }
                            return wrapper;
                        }
                        /**
                         * Creates a `_.find` or `_.findLast` function.
                         *
                         * @private
                         * @param {Function} findIndexFunc The function to find the collection index.
                         * @returns {Function} Returns the new find function.
                         */
                        function createFind(findIndexFunc) {
                            return function (collection, predicate, fromIndex) {
                                var iterable = Object(collection);
                                if (!isArrayLike(collection)) {
                                    var iteratee = getIteratee(predicate, 3);
                                    collection = keys(collection);
                                    predicate = function (key) { return iteratee(iterable[key], key, iterable); };
                                }
                                var index = findIndexFunc(collection, predicate, fromIndex);
                                return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
                            };
                        }
                        /**
                         * Creates a `_.flow` or `_.flowRight` function.
                         *
                         * @private
                         * @param {boolean} [fromRight] Specify iterating from right to left.
                         * @returns {Function} Returns the new flow function.
                         */
                        function createFlow(fromRight) {
                            return flatRest(function (funcs) {
                                var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
                                if (fromRight) {
                                    funcs.reverse();
                                }
                                while (index--) {
                                    var func = funcs[index];
                                    if (typeof func != 'function') {
                                        throw new TypeError(FUNC_ERROR_TEXT);
                                    }
                                    if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
                                        var wrapper = new LodashWrapper([], true);
                                    }
                                }
                                index = wrapper ? index : length;
                                while (++index < length) {
                                    func = funcs[index];
                                    var funcName = getFuncName(func), data = funcName == 'wrapper' ? getData(func) : undefined;
                                    if (data && isLaziable(data[0]) &&
                                        data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                                        !data[4].length && data[9] == 1) {
                                        wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                                    }
                                    else {
                                        wrapper = (func.length == 1 && isLaziable(func))
                                            ? wrapper[funcName]()
                                            : wrapper.thru(func);
                                    }
                                }
                                return function () {
                                    var args = arguments, value = args[0];
                                    if (wrapper && args.length == 1 && isArray(value)) {
                                        return wrapper.plant(value).value();
                                    }
                                    var index = 0, result = length ? funcs[index].apply(this, args) : value;
                                    while (++index < length) {
                                        result = funcs[index].call(this, result);
                                    }
                                    return result;
                                };
                            });
                        }
                        /**
                         * Creates a function that wraps `func` to invoke it with optional `this`
                         * binding of `thisArg`, partial application, and currying.
                         *
                         * @private
                         * @param {Function|string} func The function or method name to wrap.
                         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
                         * @param {*} [thisArg] The `this` binding of `func`.
                         * @param {Array} [partials] The arguments to prepend to those provided to
                         *  the new function.
                         * @param {Array} [holders] The `partials` placeholder indexes.
                         * @param {Array} [partialsRight] The arguments to append to those provided
                         *  to the new function.
                         * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
                         * @param {Array} [argPos] The argument positions of the new function.
                         * @param {number} [ary] The arity cap of `func`.
                         * @param {number} [arity] The arity of `func`.
                         * @returns {Function} Returns the new wrapped function.
                         */
                        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined : createCtor(func);
                            function wrapper() {
                                var length = arguments.length, args = Array(length), index = length;
                                while (index--) {
                                    args[index] = arguments[index];
                                }
                                if (isCurried) {
                                    var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
                                }
                                if (partials) {
                                    args = composeArgs(args, partials, holders, isCurried);
                                }
                                if (partialsRight) {
                                    args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
                                }
                                length -= holdersCount;
                                if (isCurried && length < arity) {
                                    var newHolders = replaceHolders(args, placeholder);
                                    return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
                                }
                                var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
                                length = args.length;
                                if (argPos) {
                                    args = reorder(args, argPos);
                                }
                                else if (isFlip && length > 1) {
                                    args.reverse();
                                }
                                if (isAry && ary < length) {
                                    args.length = ary;
                                }
                                if (this && this !== root && this instanceof wrapper) {
                                    fn = Ctor || createCtor(fn);
                                }
                                return fn.apply(thisBinding, args);
                            }
                            return wrapper;
                        }
                        /**
                         * Creates a function like `_.invertBy`.
                         *
                         * @private
                         * @param {Function} setter The function to set accumulator values.
                         * @param {Function} toIteratee The function to resolve iteratees.
                         * @returns {Function} Returns the new inverter function.
                         */
                        function createInverter(setter, toIteratee) {
                            return function (object, iteratee) {
                                return baseInverter(object, setter, toIteratee(iteratee), {});
                            };
                        }
                        /**
                         * Creates a function that performs a mathematical operation on two values.
                         *
                         * @private
                         * @param {Function} operator The function to perform the operation.
                         * @param {number} [defaultValue] The value used for `undefined` arguments.
                         * @returns {Function} Returns the new mathematical operation function.
                         */
                        function createMathOperation(operator, defaultValue) {
                            return function (value, other) {
                                var result;
                                if (value === undefined && other === undefined) {
                                    return defaultValue;
                                }
                                if (value !== undefined) {
                                    result = value;
                                }
                                if (other !== undefined) {
                                    if (result === undefined) {
                                        return other;
                                    }
                                    if (typeof value == 'string' || typeof other == 'string') {
                                        value = baseToString(value);
                                        other = baseToString(other);
                                    }
                                    else {
                                        value = baseToNumber(value);
                                        other = baseToNumber(other);
                                    }
                                    result = operator(value, other);
                                }
                                return result;
                            };
                        }
                        /**
                         * Creates a function like `_.over`.
                         *
                         * @private
                         * @param {Function} arrayFunc The function to iterate over iteratees.
                         * @returns {Function} Returns the new over function.
                         */
                        function createOver(arrayFunc) {
                            return flatRest(function (iteratees) {
                                iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                                return baseRest(function (args) {
                                    var thisArg = this;
                                    return arrayFunc(iteratees, function (iteratee) {
                                        return apply(iteratee, thisArg, args);
                                    });
                                });
                            });
                        }
                        /**
                         * Creates the padding for `string` based on `length`. The `chars` string
                         * is truncated if the number of characters exceeds `length`.
                         *
                         * @private
                         * @param {number} length The padding length.
                         * @param {string} [chars=' '] The string used as padding.
                         * @returns {string} Returns the padding for `string`.
                         */
                        function createPadding(length, chars) {
                            chars = chars === undefined ? ' ' : baseToString(chars);
                            var charsLength = chars.length;
                            if (charsLength < 2) {
                                return charsLength ? baseRepeat(chars, length) : chars;
                            }
                            var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
                            return hasUnicode(chars)
                                ? castSlice(stringToArray(result), 0, length).join('')
                                : result.slice(0, length);
                        }
                        /**
                         * Creates a function that wraps `func` to invoke it with the `this` binding
                         * of `thisArg` and `partials` prepended to the arguments it receives.
                         *
                         * @private
                         * @param {Function} func The function to wrap.
                         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
                         * @param {*} thisArg The `this` binding of `func`.
                         * @param {Array} partials The arguments to prepend to those provided to
                         *  the new function.
                         * @returns {Function} Returns the new wrapped function.
                         */
                        function createPartial(func, bitmask, thisArg, partials) {
                            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                            function wrapper() {
                                var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
                                while (++leftIndex < leftLength) {
                                    args[leftIndex] = partials[leftIndex];
                                }
                                while (argsLength--) {
                                    args[leftIndex++] = arguments[++argsIndex];
                                }
                                return apply(fn, isBind ? thisArg : this, args);
                            }
                            return wrapper;
                        }
                        /**
                         * Creates a `_.range` or `_.rangeRight` function.
                         *
                         * @private
                         * @param {boolean} [fromRight] Specify iterating from right to left.
                         * @returns {Function} Returns the new range function.
                         */
                        function createRange(fromRight) {
                            return function (start, end, step) {
                                if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
                                    end = step = undefined;
                                }
                                // Ensure the sign of `-0` is preserved.
                                start = toFinite(start);
                                if (end === undefined) {
                                    end = start;
                                    start = 0;
                                }
                                else {
                                    end = toFinite(end);
                                }
                                step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
                                return baseRange(start, end, step, fromRight);
                            };
                        }
                        /**
                         * Creates a function that performs a relational operation on two values.
                         *
                         * @private
                         * @param {Function} operator The function to perform the operation.
                         * @returns {Function} Returns the new relational operation function.
                         */
                        function createRelationalOperation(operator) {
                            return function (value, other) {
                                if (!(typeof value == 'string' && typeof other == 'string')) {
                                    value = toNumber(value);
                                    other = toNumber(other);
                                }
                                return operator(value, other);
                            };
                        }
                        /**
                         * Creates a function that wraps `func` to continue currying.
                         *
                         * @private
                         * @param {Function} func The function to wrap.
                         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
                         * @param {Function} wrapFunc The function to create the `func` wrapper.
                         * @param {*} placeholder The placeholder value.
                         * @param {*} [thisArg] The `this` binding of `func`.
                         * @param {Array} [partials] The arguments to prepend to those provided to
                         *  the new function.
                         * @param {Array} [holders] The `partials` placeholder indexes.
                         * @param {Array} [argPos] The argument positions of the new function.
                         * @param {number} [ary] The arity cap of `func`.
                         * @param {number} [arity] The arity of `func`.
                         * @returns {Function} Returns the new wrapped function.
                         */
                        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
                            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined, newHoldersRight = isCurry ? undefined : holders, newPartials = isCurry ? partials : undefined, newPartialsRight = isCurry ? undefined : partials;
                            bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
                            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
                            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
                                bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
                            }
                            var newData = [
                                func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
                                newHoldersRight, argPos, ary, arity
                            ];
                            var result = wrapFunc.apply(undefined, newData);
                            if (isLaziable(func)) {
                                setData(result, newData);
                            }
                            result.placeholder = placeholder;
                            return setWrapToString(result, func, bitmask);
                        }
                        /**
                         * Creates a function like `_.round`.
                         *
                         * @private
                         * @param {string} methodName The name of the `Math` method to use when rounding.
                         * @returns {Function} Returns the new round function.
                         */
                        function createRound(methodName) {
                            var func = Math[methodName];
                            return function (number, precision) {
                                number = toNumber(number);
                                precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
                                if (precision && nativeIsFinite(number)) {
                                    // Shift with exponential notation to avoid floating-point issues.
                                    // See [MDN](https://mdn.io/round#Examples) for more details.
                                    var pair = (toString(number) + 'e').split('e'), value = func(pair[0] + 'e' + (+pair[1] + precision));
                                    pair = (toString(value) + 'e').split('e');
                                    return +(pair[0] + 'e' + (+pair[1] - precision));
                                }
                                return func(number);
                            };
                        }
                        /**
                         * Creates a set object of `values`.
                         *
                         * @private
                         * @param {Array} values The values to add to the set.
                         * @returns {Object} Returns the new set.
                         */
                        var createSet = !(Set && (1 / setToArray(new Set([, -0]))[1]) == INFINITY) ? noop : function (values) {
                            return new Set(values);
                        };
                        /**
                         * Creates a `_.toPairs` or `_.toPairsIn` function.
                         *
                         * @private
                         * @param {Function} keysFunc The function to get the keys of a given object.
                         * @returns {Function} Returns the new pairs function.
                         */
                        function createToPairs(keysFunc) {
                            return function (object) {
                                var tag = getTag(object);
                                if (tag == mapTag) {
                                    return mapToArray(object);
                                }
                                if (tag == setTag) {
                                    return setToPairs(object);
                                }
                                return baseToPairs(object, keysFunc(object));
                            };
                        }
                        /**
                         * Creates a function that either curries or invokes `func` with optional
                         * `this` binding and partially applied arguments.
                         *
                         * @private
                         * @param {Function|string} func The function or method name to wrap.
                         * @param {number} bitmask The bitmask flags.
                         *    1 - `_.bind`
                         *    2 - `_.bindKey`
                         *    4 - `_.curry` or `_.curryRight` of a bound function
                         *    8 - `_.curry`
                         *   16 - `_.curryRight`
                         *   32 - `_.partial`
                         *   64 - `_.partialRight`
                         *  128 - `_.rearg`
                         *  256 - `_.ary`
                         *  512 - `_.flip`
                         * @param {*} [thisArg] The `this` binding of `func`.
                         * @param {Array} [partials] The arguments to be partially applied.
                         * @param {Array} [holders] The `partials` placeholder indexes.
                         * @param {Array} [argPos] The argument positions of the new function.
                         * @param {number} [ary] The arity cap of `func`.
                         * @param {number} [arity] The arity of `func`.
                         * @returns {Function} Returns the new wrapped function.
                         */
                        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
                            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
                            if (!isBindKey && typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            var length = partials ? partials.length : 0;
                            if (!length) {
                                bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
                                partials = holders = undefined;
                            }
                            ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
                            arity = arity === undefined ? arity : toInteger(arity);
                            length -= holders ? holders.length : 0;
                            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                                var partialsRight = partials, holdersRight = holders;
                                partials = holders = undefined;
                            }
                            var data = isBindKey ? undefined : getData(func);
                            var newData = [
                                func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
                                argPos, ary, arity
                            ];
                            if (data) {
                                mergeData(newData, data);
                            }
                            func = newData[0];
                            bitmask = newData[1];
                            thisArg = newData[2];
                            partials = newData[3];
                            holders = newData[4];
                            arity = newData[9] = newData[9] === undefined
                                ? (isBindKey ? 0 : func.length)
                                : nativeMax(newData[9] - length, 0);
                            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
                                bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
                            }
                            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
                                var result = createBind(func, bitmask, thisArg);
                            }
                            else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
                                result = createCurry(func, bitmask, arity);
                            }
                            else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
                                result = createPartial(func, bitmask, thisArg, partials);
                            }
                            else {
                                result = createHybrid.apply(undefined, newData);
                            }
                            var setter = data ? baseSetData : setData;
                            return setWrapToString(setter(result, newData), func, bitmask);
                        }
                        /**
                         * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
                         * of source objects to the destination object for all destination properties
                         * that resolve to `undefined`.
                         *
                         * @private
                         * @param {*} objValue The destination value.
                         * @param {*} srcValue The source value.
                         * @param {string} key The key of the property to assign.
                         * @param {Object} object The parent object of `objValue`.
                         * @returns {*} Returns the value to assign.
                         */
                        function customDefaultsAssignIn(objValue, srcValue, key, object) {
                            if (objValue === undefined ||
                                (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
                                return srcValue;
                            }
                            return objValue;
                        }
                        /**
                         * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
                         * objects into destination objects that are passed thru.
                         *
                         * @private
                         * @param {*} objValue The destination value.
                         * @param {*} srcValue The source value.
                         * @param {string} key The key of the property to merge.
                         * @param {Object} object The parent object of `objValue`.
                         * @param {Object} source The parent object of `srcValue`.
                         * @param {Object} [stack] Tracks traversed source values and their merged
                         *  counterparts.
                         * @returns {*} Returns the value to assign.
                         */
                        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
                            if (isObject(objValue) && isObject(srcValue)) {
                                // Recursively merge objects and arrays (susceptible to call stack limits).
                                stack.set(srcValue, objValue);
                                baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
                                stack['delete'](srcValue);
                            }
                            return objValue;
                        }
                        /**
                         * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
                         * objects.
                         *
                         * @private
                         * @param {*} value The value to inspect.
                         * @param {string} key The key of the property to inspect.
                         * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
                         */
                        function customOmitClone(value) {
                            return isPlainObject(value) ? undefined : value;
                        }
                        /**
                         * A specialized version of `baseIsEqualDeep` for arrays with support for
                         * partial deep comparisons.
                         *
                         * @private
                         * @param {Array} array The array to compare.
                         * @param {Array} other The other array to compare.
                         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
                         * @param {Function} customizer The function to customize comparisons.
                         * @param {Function} equalFunc The function to determine equivalents of values.
                         * @param {Object} stack Tracks traversed `array` and `other` objects.
                         * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
                         */
                        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
                            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                                return false;
                            }
                            // Check that cyclic values are equal.
                            var arrStacked = stack.get(array);
                            var othStacked = stack.get(other);
                            if (arrStacked && othStacked) {
                                return arrStacked == other && othStacked == array;
                            }
                            var index = -1, result = true, seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;
                            stack.set(array, other);
                            stack.set(other, array);
                            // Ignore non-index properties.
                            while (++index < arrLength) {
                                var arrValue = array[index], othValue = other[index];
                                if (customizer) {
                                    var compared = isPartial
                                        ? customizer(othValue, arrValue, index, other, array, stack)
                                        : customizer(arrValue, othValue, index, array, other, stack);
                                }
                                if (compared !== undefined) {
                                    if (compared) {
                                        continue;
                                    }
                                    result = false;
                                    break;
                                }
                                // Recursively compare arrays (susceptible to call stack limits).
                                if (seen) {
                                    if (!arraySome(other, function (othValue, othIndex) {
                                        if (!cacheHas(seen, othIndex) &&
                                            (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                                            return seen.push(othIndex);
                                        }
                                    })) {
                                        result = false;
                                        break;
                                    }
                                }
                                else if (!(arrValue === othValue ||
                                    equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                                    result = false;
                                    break;
                                }
                            }
                            stack['delete'](array);
                            stack['delete'](other);
                            return result;
                        }
                        /**
                         * A specialized version of `baseIsEqualDeep` for comparing objects of
                         * the same `toStringTag`.
                         *
                         * **Note:** This function only supports comparing values with tags of
                         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
                         *
                         * @private
                         * @param {Object} object The object to compare.
                         * @param {Object} other The other object to compare.
                         * @param {string} tag The `toStringTag` of the objects to compare.
                         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
                         * @param {Function} customizer The function to customize comparisons.
                         * @param {Function} equalFunc The function to determine equivalents of values.
                         * @param {Object} stack Tracks traversed `object` and `other` objects.
                         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                         */
                        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                            switch (tag) {
                                case dataViewTag:
                                    if ((object.byteLength != other.byteLength) ||
                                        (object.byteOffset != other.byteOffset)) {
                                        return false;
                                    }
                                    object = object.buffer;
                                    other = other.buffer;
                                case arrayBufferTag:
                                    if ((object.byteLength != other.byteLength) ||
                                        !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                                        return false;
                                    }
                                    return true;
                                case boolTag:
                                case dateTag:
                                case numberTag:
                                    // Coerce booleans to `1` or `0` and dates to milliseconds.
                                    // Invalid dates are coerced to `NaN`.
                                    return eq(+object, +other);
                                case errorTag:
                                    return object.name == other.name && object.message == other.message;
                                case regexpTag:
                                case stringTag:
                                    // Coerce regexes to strings and treat strings, primitives and objects,
                                    // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                                    // for more details.
                                    return object == (other + '');
                                case mapTag:
                                    var convert = mapToArray;
                                case setTag:
                                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                                    convert || (convert = setToArray);
                                    if (object.size != other.size && !isPartial) {
                                        return false;
                                    }
                                    // Assume cyclic values are equal.
                                    var stacked = stack.get(object);
                                    if (stacked) {
                                        return stacked == other;
                                    }
                                    bitmask |= COMPARE_UNORDERED_FLAG;
                                    // Recursively compare objects (susceptible to call stack limits).
                                    stack.set(object, other);
                                    var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                                    stack['delete'](object);
                                    return result;
                                case symbolTag:
                                    if (symbolValueOf) {
                                        return symbolValueOf.call(object) == symbolValueOf.call(other);
                                    }
                            }
                            return false;
                        }
                        /**
                         * A specialized version of `baseIsEqualDeep` for objects with support for
                         * partial deep comparisons.
                         *
                         * @private
                         * @param {Object} object The object to compare.
                         * @param {Object} other The other object to compare.
                         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
                         * @param {Function} customizer The function to customize comparisons.
                         * @param {Function} equalFunc The function to determine equivalents of values.
                         * @param {Object} stack Tracks traversed `object` and `other` objects.
                         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                         */
                        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
                            if (objLength != othLength && !isPartial) {
                                return false;
                            }
                            var index = objLength;
                            while (index--) {
                                var key = objProps[index];
                                if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                                    return false;
                                }
                            }
                            // Check that cyclic values are equal.
                            var objStacked = stack.get(object);
                            var othStacked = stack.get(other);
                            if (objStacked && othStacked) {
                                return objStacked == other && othStacked == object;
                            }
                            var result = true;
                            stack.set(object, other);
                            stack.set(other, object);
                            var skipCtor = isPartial;
                            while (++index < objLength) {
                                key = objProps[index];
                                var objValue = object[key], othValue = other[key];
                                if (customizer) {
                                    var compared = isPartial
                                        ? customizer(othValue, objValue, key, other, object, stack)
                                        : customizer(objValue, othValue, key, object, other, stack);
                                }
                                // Recursively compare objects (susceptible to call stack limits).
                                if (!(compared === undefined
                                    ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
                                    : compared)) {
                                    result = false;
                                    break;
                                }
                                skipCtor || (skipCtor = key == 'constructor');
                            }
                            if (result && !skipCtor) {
                                var objCtor = object.constructor, othCtor = other.constructor;
                                // Non `Object` object instances with different constructors are not equal.
                                if (objCtor != othCtor &&
                                    ('constructor' in object && 'constructor' in other) &&
                                    !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                                        typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                                    result = false;
                                }
                            }
                            stack['delete'](object);
                            stack['delete'](other);
                            return result;
                        }
                        /**
                         * A specialized version of `baseRest` which flattens the rest array.
                         *
                         * @private
                         * @param {Function} func The function to apply a rest parameter to.
                         * @returns {Function} Returns the new function.
                         */
                        function flatRest(func) {
                            return setToString(overRest(func, undefined, flatten), func + '');
                        }
                        /**
                         * Creates an array of own enumerable property names and symbols of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property names and symbols.
                         */
                        function getAllKeys(object) {
                            return baseGetAllKeys(object, keys, getSymbols);
                        }
                        /**
                         * Creates an array of own and inherited enumerable property names and
                         * symbols of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property names and symbols.
                         */
                        function getAllKeysIn(object) {
                            return baseGetAllKeys(object, keysIn, getSymbolsIn);
                        }
                        /**
                         * Gets metadata for `func`.
                         *
                         * @private
                         * @param {Function} func The function to query.
                         * @returns {*} Returns the metadata for `func`.
                         */
                        var getData = !metaMap ? noop : function (func) {
                            return metaMap.get(func);
                        };
                        /**
                         * Gets the name of `func`.
                         *
                         * @private
                         * @param {Function} func The function to query.
                         * @returns {string} Returns the function name.
                         */
                        function getFuncName(func) {
                            var result = (func.name + ''), array = realNames[result], length = hasOwnProperty.call(realNames, result) ? array.length : 0;
                            while (length--) {
                                var data = array[length], otherFunc = data.func;
                                if (otherFunc == null || otherFunc == func) {
                                    return data.name;
                                }
                            }
                            return result;
                        }
                        /**
                         * Gets the argument placeholder value for `func`.
                         *
                         * @private
                         * @param {Function} func The function to inspect.
                         * @returns {*} Returns the placeholder value.
                         */
                        function getHolder(func) {
                            var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
                            return object.placeholder;
                        }
                        /**
                         * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
                         * this function returns the custom method, otherwise it returns `baseIteratee`.
                         * If arguments are provided, the chosen function is invoked with them and
                         * its result is returned.
                         *
                         * @private
                         * @param {*} [value] The value to convert to an iteratee.
                         * @param {number} [arity] The arity of the created iteratee.
                         * @returns {Function} Returns the chosen function or its result.
                         */
                        function getIteratee() {
                            var result = lodash.iteratee || iteratee;
                            result = result === iteratee ? baseIteratee : result;
                            return arguments.length ? result(arguments[0], arguments[1]) : result;
                        }
                        /**
                         * Gets the data for `map`.
                         *
                         * @private
                         * @param {Object} map The map to query.
                         * @param {string} key The reference key.
                         * @returns {*} Returns the map data.
                         */
                        function getMapData(map, key) {
                            var data = map.__data__;
                            return isKeyable(key)
                                ? data[typeof key == 'string' ? 'string' : 'hash']
                                : data.map;
                        }
                        /**
                         * Gets the property names, values, and compare flags of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the match data of `object`.
                         */
                        function getMatchData(object) {
                            var result = keys(object), length = result.length;
                            while (length--) {
                                var key = result[length], value = object[key];
                                result[length] = [key, value, isStrictComparable(value)];
                            }
                            return result;
                        }
                        /**
                         * Gets the native function at `key` of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @param {string} key The key of the method to get.
                         * @returns {*} Returns the function if it's native, else `undefined`.
                         */
                        function getNative(object, key) {
                            var value = getValue(object, key);
                            return baseIsNative(value) ? value : undefined;
                        }
                        /**
                         * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
                         *
                         * @private
                         * @param {*} value The value to query.
                         * @returns {string} Returns the raw `toStringTag`.
                         */
                        function getRawTag(value) {
                            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                            try {
                                value[symToStringTag] = undefined;
                                var unmasked = true;
                            }
                            catch (e) { }
                            var result = nativeObjectToString.call(value);
                            if (unmasked) {
                                if (isOwn) {
                                    value[symToStringTag] = tag;
                                }
                                else {
                                    delete value[symToStringTag];
                                }
                            }
                            return result;
                        }
                        /**
                         * Creates an array of the own enumerable symbols of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of symbols.
                         */
                        var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
                            if (object == null) {
                                return [];
                            }
                            object = Object(object);
                            return arrayFilter(nativeGetSymbols(object), function (symbol) {
                                return propertyIsEnumerable.call(object, symbol);
                            });
                        };
                        /**
                         * Creates an array of the own and inherited enumerable symbols of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of symbols.
                         */
                        var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
                            var result = [];
                            while (object) {
                                arrayPush(result, getSymbols(object));
                                object = getPrototype(object);
                            }
                            return result;
                        };
                        /**
                         * Gets the `toStringTag` of `value`.
                         *
                         * @private
                         * @param {*} value The value to query.
                         * @returns {string} Returns the `toStringTag`.
                         */
                        var getTag = baseGetTag;
                        // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
                        if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
                            (Map && getTag(new Map) != mapTag) ||
                            (Promise && getTag(Promise.resolve()) != promiseTag) ||
                            (Set && getTag(new Set) != setTag) ||
                            (WeakMap && getTag(new WeakMap) != weakMapTag)) {
                            getTag = function (value) {
                                var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : '';
                                if (ctorString) {
                                    switch (ctorString) {
                                        case dataViewCtorString: return dataViewTag;
                                        case mapCtorString: return mapTag;
                                        case promiseCtorString: return promiseTag;
                                        case setCtorString: return setTag;
                                        case weakMapCtorString: return weakMapTag;
                                    }
                                }
                                return result;
                            };
                        }
                        /**
                         * Gets the view, applying any `transforms` to the `start` and `end` positions.
                         *
                         * @private
                         * @param {number} start The start of the view.
                         * @param {number} end The end of the view.
                         * @param {Array} transforms The transformations to apply to the view.
                         * @returns {Object} Returns an object containing the `start` and `end`
                         *  positions of the view.
                         */
                        function getView(start, end, transforms) {
                            var index = -1, length = transforms.length;
                            while (++index < length) {
                                var data = transforms[index], size = data.size;
                                switch (data.type) {
                                    case 'drop':
                                        start += size;
                                        break;
                                    case 'dropRight':
                                        end -= size;
                                        break;
                                    case 'take':
                                        end = nativeMin(end, start + size);
                                        break;
                                    case 'takeRight':
                                        start = nativeMax(start, end - size);
                                        break;
                                }
                            }
                            return { 'start': start, 'end': end };
                        }
                        /**
                         * Extracts wrapper details from the `source` body comment.
                         *
                         * @private
                         * @param {string} source The source to inspect.
                         * @returns {Array} Returns the wrapper details.
                         */
                        function getWrapDetails(source) {
                            var match = source.match(reWrapDetails);
                            return match ? match[1].split(reSplitDetails) : [];
                        }
                        /**
                         * Checks if `path` exists on `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @param {Array|string} path The path to check.
                         * @param {Function} hasFunc The function to check properties.
                         * @returns {boolean} Returns `true` if `path` exists, else `false`.
                         */
                        function hasPath(object, path, hasFunc) {
                            path = castPath(path, object);
                            var index = -1, length = path.length, result = false;
                            while (++index < length) {
                                var key = toKey(path[index]);
                                if (!(result = object != null && hasFunc(object, key))) {
                                    break;
                                }
                                object = object[key];
                            }
                            if (result || ++index != length) {
                                return result;
                            }
                            length = object == null ? 0 : object.length;
                            return !!length && isLength(length) && isIndex(key, length) &&
                                (isArray(object) || isArguments(object));
                        }
                        /**
                         * Initializes an array clone.
                         *
                         * @private
                         * @param {Array} array The array to clone.
                         * @returns {Array} Returns the initialized clone.
                         */
                        function initCloneArray(array) {
                            var length = array.length, result = new array.constructor(length);
                            // Add properties assigned by `RegExp#exec`.
                            if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
                                result.index = array.index;
                                result.input = array.input;
                            }
                            return result;
                        }
                        /**
                         * Initializes an object clone.
                         *
                         * @private
                         * @param {Object} object The object to clone.
                         * @returns {Object} Returns the initialized clone.
                         */
                        function initCloneObject(object) {
                            return (typeof object.constructor == 'function' && !isPrototype(object))
                                ? baseCreate(getPrototype(object))
                                : {};
                        }
                        /**
                         * Initializes an object clone based on its `toStringTag`.
                         *
                         * **Note:** This function only supports cloning values with tags of
                         * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
                         *
                         * @private
                         * @param {Object} object The object to clone.
                         * @param {string} tag The `toStringTag` of the object to clone.
                         * @param {boolean} [isDeep] Specify a deep clone.
                         * @returns {Object} Returns the initialized clone.
                         */
                        function initCloneByTag(object, tag, isDeep) {
                            var Ctor = object.constructor;
                            switch (tag) {
                                case arrayBufferTag:
                                    return cloneArrayBuffer(object);
                                case boolTag:
                                case dateTag:
                                    return new Ctor(+object);
                                case dataViewTag:
                                    return cloneDataView(object, isDeep);
                                case float32Tag:
                                case float64Tag:
                                case int8Tag:
                                case int16Tag:
                                case int32Tag:
                                case uint8Tag:
                                case uint8ClampedTag:
                                case uint16Tag:
                                case uint32Tag:
                                    return cloneTypedArray(object, isDeep);
                                case mapTag:
                                    return new Ctor;
                                case numberTag:
                                case stringTag:
                                    return new Ctor(object);
                                case regexpTag:
                                    return cloneRegExp(object);
                                case setTag:
                                    return new Ctor;
                                case symbolTag:
                                    return cloneSymbol(object);
                            }
                        }
                        /**
                         * Inserts wrapper `details` in a comment at the top of the `source` body.
                         *
                         * @private
                         * @param {string} source The source to modify.
                         * @returns {Array} details The details to insert.
                         * @returns {string} Returns the modified source.
                         */
                        function insertWrapDetails(source, details) {
                            var length = details.length;
                            if (!length) {
                                return source;
                            }
                            var lastIndex = length - 1;
                            details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
                            details = details.join(length > 2 ? ', ' : ' ');
                            return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
                        }
                        /**
                         * Checks if `value` is a flattenable `arguments` object or array.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
                         */
                        function isFlattenable(value) {
                            return isArray(value) || isArguments(value) ||
                                !!(spreadableSymbol && value && value[spreadableSymbol]);
                        }
                        /**
                         * Checks if `value` is a valid array-like index.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
                         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
                         */
                        function isIndex(value, length) {
                            var type = typeof value;
                            length = length == null ? MAX_SAFE_INTEGER : length;
                            return !!length &&
                                (type == 'number' ||
                                    (type != 'symbol' && reIsUint.test(value))) &&
                                (value > -1 && value % 1 == 0 && value < length);
                        }
                        /**
                         * Checks if the given arguments are from an iteratee call.
                         *
                         * @private
                         * @param {*} value The potential iteratee value argument.
                         * @param {*} index The potential iteratee index or key argument.
                         * @param {*} object The potential iteratee object argument.
                         * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
                         *  else `false`.
                         */
                        function isIterateeCall(value, index, object) {
                            if (!isObject(object)) {
                                return false;
                            }
                            var type = typeof index;
                            if (type == 'number'
                                ? (isArrayLike(object) && isIndex(index, object.length))
                                : (type == 'string' && index in object)) {
                                return eq(object[index], value);
                            }
                            return false;
                        }
                        /**
                         * Checks if `value` is a property name and not a property path.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @param {Object} [object] The object to query keys on.
                         * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
                         */
                        function isKey(value, object) {
                            if (isArray(value)) {
                                return false;
                            }
                            var type = typeof value;
                            if (type == 'number' || type == 'symbol' || type == 'boolean' ||
                                value == null || isSymbol(value)) {
                                return true;
                            }
                            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
                                (object != null && value in Object(object));
                        }
                        /**
                         * Checks if `value` is suitable for use as unique object key.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
                         */
                        function isKeyable(value) {
                            var type = typeof value;
                            return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
                                ? (value !== '__proto__')
                                : (value === null);
                        }
                        /**
                         * Checks if `func` has a lazy counterpart.
                         *
                         * @private
                         * @param {Function} func The function to check.
                         * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
                         *  else `false`.
                         */
                        function isLaziable(func) {
                            var funcName = getFuncName(func), other = lodash[funcName];
                            if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
                                return false;
                            }
                            if (func === other) {
                                return true;
                            }
                            var data = getData(other);
                            return !!data && func === data[0];
                        }
                        /**
                         * Checks if `func` has its source masked.
                         *
                         * @private
                         * @param {Function} func The function to check.
                         * @returns {boolean} Returns `true` if `func` is masked, else `false`.
                         */
                        function isMasked(func) {
                            return !!maskSrcKey && (maskSrcKey in func);
                        }
                        /**
                         * Checks if `func` is capable of being masked.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
                         */
                        var isMaskable = coreJsData ? isFunction : stubFalse;
                        /**
                         * Checks if `value` is likely a prototype object.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
                         */
                        function isPrototype(value) {
                            var Ctor = value && value.constructor, proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
                            return value === proto;
                        }
                        /**
                         * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` if suitable for strict
                         *  equality comparisons, else `false`.
                         */
                        function isStrictComparable(value) {
                            return value === value && !isObject(value);
                        }
                        /**
                         * A specialized version of `matchesProperty` for source values suitable
                         * for strict equality comparisons, i.e. `===`.
                         *
                         * @private
                         * @param {string} key The key of the property to get.
                         * @param {*} srcValue The value to match.
                         * @returns {Function} Returns the new spec function.
                         */
                        function matchesStrictComparable(key, srcValue) {
                            return function (object) {
                                if (object == null) {
                                    return false;
                                }
                                return object[key] === srcValue &&
                                    (srcValue !== undefined || (key in Object(object)));
                            };
                        }
                        /**
                         * A specialized version of `_.memoize` which clears the memoized function's
                         * cache when it exceeds `MAX_MEMOIZE_SIZE`.
                         *
                         * @private
                         * @param {Function} func The function to have its output memoized.
                         * @returns {Function} Returns the new memoized function.
                         */
                        function memoizeCapped(func) {
                            var result = memoize(func, function (key) {
                                if (cache.size === MAX_MEMOIZE_SIZE) {
                                    cache.clear();
                                }
                                return key;
                            });
                            var cache = result.cache;
                            return result;
                        }
                        /**
                         * Merges the function metadata of `source` into `data`.
                         *
                         * Merging metadata reduces the number of wrappers used to invoke a function.
                         * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
                         * may be applied regardless of execution order. Methods like `_.ary` and
                         * `_.rearg` modify function arguments, making the order in which they are
                         * executed important, preventing the merging of metadata. However, we make
                         * an exception for a safe combined case where curried functions have `_.ary`
                         * and or `_.rearg` applied.
                         *
                         * @private
                         * @param {Array} data The destination metadata.
                         * @param {Array} source The source metadata.
                         * @returns {Array} Returns `data`.
                         */
                        function mergeData(data, source) {
                            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
                            var isCombo = ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
                                ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
                                ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));
                            // Exit early if metadata can't be merged.
                            if (!(isCommon || isCombo)) {
                                return data;
                            }
                            // Use source `thisArg` if available.
                            if (srcBitmask & WRAP_BIND_FLAG) {
                                data[2] = source[2];
                                // Set when currying a bound function.
                                newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
                            }
                            // Compose partial arguments.
                            var value = source[3];
                            if (value) {
                                var partials = data[3];
                                data[3] = partials ? composeArgs(partials, value, source[4]) : value;
                                data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
                            }
                            // Compose partial right arguments.
                            value = source[5];
                            if (value) {
                                partials = data[5];
                                data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
                                data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
                            }
                            // Use source `argPos` if available.
                            value = source[7];
                            if (value) {
                                data[7] = value;
                            }
                            // Use source `ary` if it's smaller.
                            if (srcBitmask & WRAP_ARY_FLAG) {
                                data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                            }
                            // Use source `arity` if one is not provided.
                            if (data[9] == null) {
                                data[9] = source[9];
                            }
                            // Use source `func` and merge bitmasks.
                            data[0] = source[0];
                            data[1] = newBitmask;
                            return data;
                        }
                        /**
                         * This function is like
                         * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
                         * except that it includes inherited enumerable properties.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property names.
                         */
                        function nativeKeysIn(object) {
                            var result = [];
                            if (object != null) {
                                for (var key in Object(object)) {
                                    result.push(key);
                                }
                            }
                            return result;
                        }
                        /**
                         * Converts `value` to a string using `Object.prototype.toString`.
                         *
                         * @private
                         * @param {*} value The value to convert.
                         * @returns {string} Returns the converted string.
                         */
                        function objectToString(value) {
                            return nativeObjectToString.call(value);
                        }
                        /**
                         * A specialized version of `baseRest` which transforms the rest array.
                         *
                         * @private
                         * @param {Function} func The function to apply a rest parameter to.
                         * @param {number} [start=func.length-1] The start position of the rest parameter.
                         * @param {Function} transform The rest array transform.
                         * @returns {Function} Returns the new function.
                         */
                        function overRest(func, start, transform) {
                            start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
                            return function () {
                                var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
                                while (++index < length) {
                                    array[index] = args[start + index];
                                }
                                index = -1;
                                var otherArgs = Array(start + 1);
                                while (++index < start) {
                                    otherArgs[index] = args[index];
                                }
                                otherArgs[start] = transform(array);
                                return apply(func, this, otherArgs);
                            };
                        }
                        /**
                         * Gets the parent value at `path` of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @param {Array} path The path to get the parent value of.
                         * @returns {*} Returns the parent value.
                         */
                        function parent(object, path) {
                            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
                        }
                        /**
                         * Reorder `array` according to the specified indexes where the element at
                         * the first index is assigned as the first element, the element at
                         * the second index is assigned as the second element, and so on.
                         *
                         * @private
                         * @param {Array} array The array to reorder.
                         * @param {Array} indexes The arranged array indexes.
                         * @returns {Array} Returns `array`.
                         */
                        function reorder(array, indexes) {
                            var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
                            while (length--) {
                                var index = indexes[length];
                                array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
                            }
                            return array;
                        }
                        /**
                         * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @param {string} key The key of the property to get.
                         * @returns {*} Returns the property value.
                         */
                        function safeGet(object, key) {
                            if (key === 'constructor' && typeof object[key] === 'function') {
                                return;
                            }
                            if (key == '__proto__') {
                                return;
                            }
                            return object[key];
                        }
                        /**
                         * Sets metadata for `func`.
                         *
                         * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
                         * period of time, it will trip its breaker and transition to an identity
                         * function to avoid garbage collection pauses in V8. See
                         * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
                         * for more details.
                         *
                         * @private
                         * @param {Function} func The function to associate metadata with.
                         * @param {*} data The metadata.
                         * @returns {Function} Returns `func`.
                         */
                        var setData = shortOut(baseSetData);
                        /**
                         * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
                         *
                         * @private
                         * @param {Function} func The function to delay.
                         * @param {number} wait The number of milliseconds to delay invocation.
                         * @returns {number|Object} Returns the timer id or timeout object.
                         */
                        var setTimeout = ctxSetTimeout || function (func, wait) {
                            return root.setTimeout(func, wait);
                        };
                        /**
                         * Sets the `toString` method of `func` to return `string`.
                         *
                         * @private
                         * @param {Function} func The function to modify.
                         * @param {Function} string The `toString` result.
                         * @returns {Function} Returns `func`.
                         */
                        var setToString = shortOut(baseSetToString);
                        /**
                         * Sets the `toString` method of `wrapper` to mimic the source of `reference`
                         * with wrapper details in a comment at the top of the source body.
                         *
                         * @private
                         * @param {Function} wrapper The function to modify.
                         * @param {Function} reference The reference function.
                         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
                         * @returns {Function} Returns `wrapper`.
                         */
                        function setWrapToString(wrapper, reference, bitmask) {
                            var source = (reference + '');
                            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
                        }
                        /**
                         * Creates a function that'll short out and invoke `identity` instead
                         * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
                         * milliseconds.
                         *
                         * @private
                         * @param {Function} func The function to restrict.
                         * @returns {Function} Returns the new shortable function.
                         */
                        function shortOut(func) {
                            var count = 0, lastCalled = 0;
                            return function () {
                                var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                                lastCalled = stamp;
                                if (remaining > 0) {
                                    if (++count >= HOT_COUNT) {
                                        return arguments[0];
                                    }
                                }
                                else {
                                    count = 0;
                                }
                                return func.apply(undefined, arguments);
                            };
                        }
                        /**
                         * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
                         *
                         * @private
                         * @param {Array} array The array to shuffle.
                         * @param {number} [size=array.length] The size of `array`.
                         * @returns {Array} Returns `array`.
                         */
                        function shuffleSelf(array, size) {
                            var index = -1, length = array.length, lastIndex = length - 1;
                            size = size === undefined ? length : size;
                            while (++index < size) {
                                var rand = baseRandom(index, lastIndex), value = array[rand];
                                array[rand] = array[index];
                                array[index] = value;
                            }
                            array.length = size;
                            return array;
                        }
                        /**
                         * Converts `string` to a property path array.
                         *
                         * @private
                         * @param {string} string The string to convert.
                         * @returns {Array} Returns the property path array.
                         */
                        var stringToPath = memoizeCapped(function (string) {
                            var result = [];
                            if (string.charCodeAt(0) === 46 /* . */) {
                                result.push('');
                            }
                            string.replace(rePropName, function (match, number, quote, subString) {
                                result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
                            });
                            return result;
                        });
                        /**
                         * Converts `value` to a string key if it's not a string or symbol.
                         *
                         * @private
                         * @param {*} value The value to inspect.
                         * @returns {string|symbol} Returns the key.
                         */
                        function toKey(value) {
                            if (typeof value == 'string' || isSymbol(value)) {
                                return value;
                            }
                            var result = (value + '');
                            return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
                        }
                        /**
                         * Converts `func` to its source code.
                         *
                         * @private
                         * @param {Function} func The function to convert.
                         * @returns {string} Returns the source code.
                         */
                        function toSource(func) {
                            if (func != null) {
                                try {
                                    return funcToString.call(func);
                                }
                                catch (e) { }
                                try {
                                    return (func + '');
                                }
                                catch (e) { }
                            }
                            return '';
                        }
                        /**
                         * Updates wrapper `details` based on `bitmask` flags.
                         *
                         * @private
                         * @returns {Array} details The details to modify.
                         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
                         * @returns {Array} Returns `details`.
                         */
                        function updateWrapDetails(details, bitmask) {
                            arrayEach(wrapFlags, function (pair) {
                                var value = '_.' + pair[0];
                                if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
                                    details.push(value);
                                }
                            });
                            return details.sort();
                        }
                        /**
                         * Creates a clone of `wrapper`.
                         *
                         * @private
                         * @param {Object} wrapper The wrapper to clone.
                         * @returns {Object} Returns the cloned wrapper.
                         */
                        function wrapperClone(wrapper) {
                            if (wrapper instanceof LazyWrapper) {
                                return wrapper.clone();
                            }
                            var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
                            result.__actions__ = copyArray(wrapper.__actions__);
                            result.__index__ = wrapper.__index__;
                            result.__values__ = wrapper.__values__;
                            return result;
                        }
                        /*------------------------------------------------------------------------*/
                        /**
                         * Creates an array of elements split into groups the length of `size`.
                         * If `array` can't be split evenly, the final chunk will be the remaining
                         * elements.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Array
                         * @param {Array} array The array to process.
                         * @param {number} [size=1] The length of each chunk
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {Array} Returns the new array of chunks.
                         * @example
                         *
                         * _.chunk(['a', 'b', 'c', 'd'], 2);
                         * // => [['a', 'b'], ['c', 'd']]
                         *
                         * _.chunk(['a', 'b', 'c', 'd'], 3);
                         * // => [['a', 'b', 'c'], ['d']]
                         */
                        function chunk(array, size, guard) {
                            if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
                                size = 1;
                            }
                            else {
                                size = nativeMax(toInteger(size), 0);
                            }
                            var length = array == null ? 0 : array.length;
                            if (!length || size < 1) {
                                return [];
                            }
                            var index = 0, resIndex = 0, result = Array(nativeCeil(length / size));
                            while (index < length) {
                                result[resIndex++] = baseSlice(array, index, (index += size));
                            }
                            return result;
                        }
                        /**
                         * Creates an array with all falsey values removed. The values `false`, `null`,
                         * `0`, `""`, `undefined`, and `NaN` are falsey.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {Array} array The array to compact.
                         * @returns {Array} Returns the new array of filtered values.
                         * @example
                         *
                         * _.compact([0, 1, false, 2, '', 3]);
                         * // => [1, 2, 3]
                         */
                        function compact(array) {
                            var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
                            while (++index < length) {
                                var value = array[index];
                                if (value) {
                                    result[resIndex++] = value;
                                }
                            }
                            return result;
                        }
                        /**
                         * Creates a new array concatenating `array` with any additional arrays
                         * and/or values.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to concatenate.
                         * @param {...*} [values] The values to concatenate.
                         * @returns {Array} Returns the new concatenated array.
                         * @example
                         *
                         * var array = [1];
                         * var other = _.concat(array, 2, [3], [[4]]);
                         *
                         * console.log(other);
                         * // => [1, 2, 3, [4]]
                         *
                         * console.log(array);
                         * // => [1]
                         */
                        function concat() {
                            var length = arguments.length;
                            if (!length) {
                                return [];
                            }
                            var args = Array(length - 1), array = arguments[0], index = length;
                            while (index--) {
                                args[index - 1] = arguments[index];
                            }
                            return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
                        }
                        /**
                         * Creates an array of `array` values not included in the other given arrays
                         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * for equality comparisons. The order and references of result values are
                         * determined by the first array.
                         *
                         * **Note:** Unlike `_.pullAll`, this method returns a new array.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {...Array} [values] The values to exclude.
                         * @returns {Array} Returns the new array of filtered values.
                         * @see _.without, _.xor
                         * @example
                         *
                         * _.difference([2, 1], [2, 3]);
                         * // => [1]
                         */
                        var difference = baseRest(function (array, values) {
                            return isArrayLikeObject(array)
                                ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
                                : [];
                        });
                        /**
                         * This method is like `_.difference` except that it accepts `iteratee` which
                         * is invoked for each element of `array` and `values` to generate the criterion
                         * by which they're compared. The order and references of result values are
                         * determined by the first array. The iteratee is invoked with one argument:
                         * (value).
                         *
                         * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {...Array} [values] The values to exclude.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {Array} Returns the new array of filtered values.
                         * @example
                         *
                         * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
                         * // => [1.2]
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
                         * // => [{ 'x': 2 }]
                         */
                        var differenceBy = baseRest(function (array, values) {
                            var iteratee = last(values);
                            if (isArrayLikeObject(iteratee)) {
                                iteratee = undefined;
                            }
                            return isArrayLikeObject(array)
                                ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
                                : [];
                        });
                        /**
                         * This method is like `_.difference` except that it accepts `comparator`
                         * which is invoked to compare elements of `array` to `values`. The order and
                         * references of result values are determined by the first array. The comparator
                         * is invoked with two arguments: (arrVal, othVal).
                         *
                         * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {...Array} [values] The values to exclude.
                         * @param {Function} [comparator] The comparator invoked per element.
                         * @returns {Array} Returns the new array of filtered values.
                         * @example
                         *
                         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
                         *
                         * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
                         * // => [{ 'x': 2, 'y': 1 }]
                         */
                        var differenceWith = baseRest(function (array, values) {
                            var comparator = last(values);
                            if (isArrayLikeObject(comparator)) {
                                comparator = undefined;
                            }
                            return isArrayLikeObject(array)
                                ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
                                : [];
                        });
                        /**
                         * Creates a slice of `array` with `n` elements dropped from the beginning.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.5.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @param {number} [n=1] The number of elements to drop.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {Array} Returns the slice of `array`.
                         * @example
                         *
                         * _.drop([1, 2, 3]);
                         * // => [2, 3]
                         *
                         * _.drop([1, 2, 3], 2);
                         * // => [3]
                         *
                         * _.drop([1, 2, 3], 5);
                         * // => []
                         *
                         * _.drop([1, 2, 3], 0);
                         * // => [1, 2, 3]
                         */
                        function drop(array, n, guard) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return [];
                            }
                            n = (guard || n === undefined) ? 1 : toInteger(n);
                            return baseSlice(array, n < 0 ? 0 : n, length);
                        }
                        /**
                         * Creates a slice of `array` with `n` elements dropped from the end.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @param {number} [n=1] The number of elements to drop.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {Array} Returns the slice of `array`.
                         * @example
                         *
                         * _.dropRight([1, 2, 3]);
                         * // => [1, 2]
                         *
                         * _.dropRight([1, 2, 3], 2);
                         * // => [1]
                         *
                         * _.dropRight([1, 2, 3], 5);
                         * // => []
                         *
                         * _.dropRight([1, 2, 3], 0);
                         * // => [1, 2, 3]
                         */
                        function dropRight(array, n, guard) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return [];
                            }
                            n = (guard || n === undefined) ? 1 : toInteger(n);
                            n = length - n;
                            return baseSlice(array, 0, n < 0 ? 0 : n);
                        }
                        /**
                         * Creates a slice of `array` excluding elements dropped from the end.
                         * Elements are dropped until `predicate` returns falsey. The predicate is
                         * invoked with three arguments: (value, index, array).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the slice of `array`.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney',  'active': true },
                         *   { 'user': 'fred',    'active': false },
                         *   { 'user': 'pebbles', 'active': false }
                         * ];
                         *
                         * _.dropRightWhile(users, function(o) { return !o.active; });
                         * // => objects for ['barney']
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
                         * // => objects for ['barney', 'fred']
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.dropRightWhile(users, ['active', false]);
                         * // => objects for ['barney']
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.dropRightWhile(users, 'active');
                         * // => objects for ['barney', 'fred', 'pebbles']
                         */
                        function dropRightWhile(array, predicate) {
                            return (array && array.length)
                                ? baseWhile(array, getIteratee(predicate, 3), true, true)
                                : [];
                        }
                        /**
                         * Creates a slice of `array` excluding elements dropped from the beginning.
                         * Elements are dropped until `predicate` returns falsey. The predicate is
                         * invoked with three arguments: (value, index, array).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the slice of `array`.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney',  'active': false },
                         *   { 'user': 'fred',    'active': false },
                         *   { 'user': 'pebbles', 'active': true }
                         * ];
                         *
                         * _.dropWhile(users, function(o) { return !o.active; });
                         * // => objects for ['pebbles']
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.dropWhile(users, { 'user': 'barney', 'active': false });
                         * // => objects for ['fred', 'pebbles']
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.dropWhile(users, ['active', false]);
                         * // => objects for ['pebbles']
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.dropWhile(users, 'active');
                         * // => objects for ['barney', 'fred', 'pebbles']
                         */
                        function dropWhile(array, predicate) {
                            return (array && array.length)
                                ? baseWhile(array, getIteratee(predicate, 3), true)
                                : [];
                        }
                        /**
                         * Fills elements of `array` with `value` from `start` up to, but not
                         * including, `end`.
                         *
                         * **Note:** This method mutates `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.2.0
                         * @category Array
                         * @param {Array} array The array to fill.
                         * @param {*} value The value to fill `array` with.
                         * @param {number} [start=0] The start position.
                         * @param {number} [end=array.length] The end position.
                         * @returns {Array} Returns `array`.
                         * @example
                         *
                         * var array = [1, 2, 3];
                         *
                         * _.fill(array, 'a');
                         * console.log(array);
                         * // => ['a', 'a', 'a']
                         *
                         * _.fill(Array(3), 2);
                         * // => [2, 2, 2]
                         *
                         * _.fill([4, 6, 8, 10], '*', 1, 3);
                         * // => [4, '*', '*', 10]
                         */
                        function fill(array, value, start, end) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return [];
                            }
                            if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
                                start = 0;
                                end = length;
                            }
                            return baseFill(array, value, start, end);
                        }
                        /**
                         * This method is like `_.find` except that it returns the index of the first
                         * element `predicate` returns truthy for instead of the element itself.
                         *
                         * @static
                         * @memberOf _
                         * @since 1.1.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @param {number} [fromIndex=0] The index to search from.
                         * @returns {number} Returns the index of the found element, else `-1`.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney',  'active': false },
                         *   { 'user': 'fred',    'active': false },
                         *   { 'user': 'pebbles', 'active': true }
                         * ];
                         *
                         * _.findIndex(users, function(o) { return o.user == 'barney'; });
                         * // => 0
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.findIndex(users, { 'user': 'fred', 'active': false });
                         * // => 1
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.findIndex(users, ['active', false]);
                         * // => 0
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.findIndex(users, 'active');
                         * // => 2
                         */
                        function findIndex(array, predicate, fromIndex) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return -1;
                            }
                            var index = fromIndex == null ? 0 : toInteger(fromIndex);
                            if (index < 0) {
                                index = nativeMax(length + index, 0);
                            }
                            return baseFindIndex(array, getIteratee(predicate, 3), index);
                        }
                        /**
                         * This method is like `_.findIndex` except that it iterates over elements
                         * of `collection` from right to left.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.0.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @param {number} [fromIndex=array.length-1] The index to search from.
                         * @returns {number} Returns the index of the found element, else `-1`.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney',  'active': true },
                         *   { 'user': 'fred',    'active': false },
                         *   { 'user': 'pebbles', 'active': false }
                         * ];
                         *
                         * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
                         * // => 2
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.findLastIndex(users, { 'user': 'barney', 'active': true });
                         * // => 0
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.findLastIndex(users, ['active', false]);
                         * // => 2
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.findLastIndex(users, 'active');
                         * // => 0
                         */
                        function findLastIndex(array, predicate, fromIndex) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return -1;
                            }
                            var index = length - 1;
                            if (fromIndex !== undefined) {
                                index = toInteger(fromIndex);
                                index = fromIndex < 0
                                    ? nativeMax(length + index, 0)
                                    : nativeMin(index, length - 1);
                            }
                            return baseFindIndex(array, getIteratee(predicate, 3), index, true);
                        }
                        /**
                         * Flattens `array` a single level deep.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {Array} array The array to flatten.
                         * @returns {Array} Returns the new flattened array.
                         * @example
                         *
                         * _.flatten([1, [2, [3, [4]], 5]]);
                         * // => [1, 2, [3, [4]], 5]
                         */
                        function flatten(array) {
                            var length = array == null ? 0 : array.length;
                            return length ? baseFlatten(array, 1) : [];
                        }
                        /**
                         * Recursively flattens `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Array
                         * @param {Array} array The array to flatten.
                         * @returns {Array} Returns the new flattened array.
                         * @example
                         *
                         * _.flattenDeep([1, [2, [3, [4]], 5]]);
                         * // => [1, 2, 3, 4, 5]
                         */
                        function flattenDeep(array) {
                            var length = array == null ? 0 : array.length;
                            return length ? baseFlatten(array, INFINITY) : [];
                        }
                        /**
                         * Recursively flatten `array` up to `depth` times.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.4.0
                         * @category Array
                         * @param {Array} array The array to flatten.
                         * @param {number} [depth=1] The maximum recursion depth.
                         * @returns {Array} Returns the new flattened array.
                         * @example
                         *
                         * var array = [1, [2, [3, [4]], 5]];
                         *
                         * _.flattenDepth(array, 1);
                         * // => [1, 2, [3, [4]], 5]
                         *
                         * _.flattenDepth(array, 2);
                         * // => [1, 2, 3, [4], 5]
                         */
                        function flattenDepth(array, depth) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return [];
                            }
                            depth = depth === undefined ? 1 : toInteger(depth);
                            return baseFlatten(array, depth);
                        }
                        /**
                         * The inverse of `_.toPairs`; this method returns an object composed
                         * from key-value `pairs`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} pairs The key-value pairs.
                         * @returns {Object} Returns the new object.
                         * @example
                         *
                         * _.fromPairs([['a', 1], ['b', 2]]);
                         * // => { 'a': 1, 'b': 2 }
                         */
                        function fromPairs(pairs) {
                            var index = -1, length = pairs == null ? 0 : pairs.length, result = {};
                            while (++index < length) {
                                var pair = pairs[index];
                                result[pair[0]] = pair[1];
                            }
                            return result;
                        }
                        /**
                         * Gets the first element of `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @alias first
                         * @category Array
                         * @param {Array} array The array to query.
                         * @returns {*} Returns the first element of `array`.
                         * @example
                         *
                         * _.head([1, 2, 3]);
                         * // => 1
                         *
                         * _.head([]);
                         * // => undefined
                         */
                        function head(array) {
                            return (array && array.length) ? array[0] : undefined;
                        }
                        /**
                         * Gets the index at which the first occurrence of `value` is found in `array`
                         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * for equality comparisons. If `fromIndex` is negative, it's used as the
                         * offset from the end of `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {*} value The value to search for.
                         * @param {number} [fromIndex=0] The index to search from.
                         * @returns {number} Returns the index of the matched value, else `-1`.
                         * @example
                         *
                         * _.indexOf([1, 2, 1, 2], 2);
                         * // => 1
                         *
                         * // Search from the `fromIndex`.
                         * _.indexOf([1, 2, 1, 2], 2, 2);
                         * // => 3
                         */
                        function indexOf(array, value, fromIndex) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return -1;
                            }
                            var index = fromIndex == null ? 0 : toInteger(fromIndex);
                            if (index < 0) {
                                index = nativeMax(length + index, 0);
                            }
                            return baseIndexOf(array, value, index);
                        }
                        /**
                         * Gets all but the last element of `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @returns {Array} Returns the slice of `array`.
                         * @example
                         *
                         * _.initial([1, 2, 3]);
                         * // => [1, 2]
                         */
                        function initial(array) {
                            var length = array == null ? 0 : array.length;
                            return length ? baseSlice(array, 0, -1) : [];
                        }
                        /**
                         * Creates an array of unique values that are included in all given arrays
                         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * for equality comparisons. The order and references of result values are
                         * determined by the first array.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {...Array} [arrays] The arrays to inspect.
                         * @returns {Array} Returns the new array of intersecting values.
                         * @example
                         *
                         * _.intersection([2, 1], [2, 3]);
                         * // => [2]
                         */
                        var intersection = baseRest(function (arrays) {
                            var mapped = arrayMap(arrays, castArrayLikeObject);
                            return (mapped.length && mapped[0] === arrays[0])
                                ? baseIntersection(mapped)
                                : [];
                        });
                        /**
                         * This method is like `_.intersection` except that it accepts `iteratee`
                         * which is invoked for each element of each `arrays` to generate the criterion
                         * by which they're compared. The order and references of result values are
                         * determined by the first array. The iteratee is invoked with one argument:
                         * (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {...Array} [arrays] The arrays to inspect.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {Array} Returns the new array of intersecting values.
                         * @example
                         *
                         * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
                         * // => [2.1]
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
                         * // => [{ 'x': 1 }]
                         */
                        var intersectionBy = baseRest(function (arrays) {
                            var iteratee = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                            if (iteratee === last(mapped)) {
                                iteratee = undefined;
                            }
                            else {
                                mapped.pop();
                            }
                            return (mapped.length && mapped[0] === arrays[0])
                                ? baseIntersection(mapped, getIteratee(iteratee, 2))
                                : [];
                        });
                        /**
                         * This method is like `_.intersection` except that it accepts `comparator`
                         * which is invoked to compare elements of `arrays`. The order and references
                         * of result values are determined by the first array. The comparator is
                         * invoked with two arguments: (arrVal, othVal).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {...Array} [arrays] The arrays to inspect.
                         * @param {Function} [comparator] The comparator invoked per element.
                         * @returns {Array} Returns the new array of intersecting values.
                         * @example
                         *
                         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
                         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
                         *
                         * _.intersectionWith(objects, others, _.isEqual);
                         * // => [{ 'x': 1, 'y': 2 }]
                         */
                        var intersectionWith = baseRest(function (arrays) {
                            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                            comparator = typeof comparator == 'function' ? comparator : undefined;
                            if (comparator) {
                                mapped.pop();
                            }
                            return (mapped.length && mapped[0] === arrays[0])
                                ? baseIntersection(mapped, undefined, comparator)
                                : [];
                        });
                        /**
                         * Converts all elements in `array` into a string separated by `separator`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to convert.
                         * @param {string} [separator=','] The element separator.
                         * @returns {string} Returns the joined string.
                         * @example
                         *
                         * _.join(['a', 'b', 'c'], '~');
                         * // => 'a~b~c'
                         */
                        function join(array, separator) {
                            return array == null ? '' : nativeJoin.call(array, separator);
                        }
                        /**
                         * Gets the last element of `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @returns {*} Returns the last element of `array`.
                         * @example
                         *
                         * _.last([1, 2, 3]);
                         * // => 3
                         */
                        function last(array) {
                            var length = array == null ? 0 : array.length;
                            return length ? array[length - 1] : undefined;
                        }
                        /**
                         * This method is like `_.indexOf` except that it iterates over elements of
                         * `array` from right to left.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {*} value The value to search for.
                         * @param {number} [fromIndex=array.length-1] The index to search from.
                         * @returns {number} Returns the index of the matched value, else `-1`.
                         * @example
                         *
                         * _.lastIndexOf([1, 2, 1, 2], 2);
                         * // => 3
                         *
                         * // Search from the `fromIndex`.
                         * _.lastIndexOf([1, 2, 1, 2], 2, 2);
                         * // => 1
                         */
                        function lastIndexOf(array, value, fromIndex) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return -1;
                            }
                            var index = length;
                            if (fromIndex !== undefined) {
                                index = toInteger(fromIndex);
                                index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
                            }
                            return value === value
                                ? strictLastIndexOf(array, value, index)
                                : baseFindIndex(array, baseIsNaN, index, true);
                        }
                        /**
                         * Gets the element at index `n` of `array`. If `n` is negative, the nth
                         * element from the end is returned.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.11.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @param {number} [n=0] The index of the element to return.
                         * @returns {*} Returns the nth element of `array`.
                         * @example
                         *
                         * var array = ['a', 'b', 'c', 'd'];
                         *
                         * _.nth(array, 1);
                         * // => 'b'
                         *
                         * _.nth(array, -2);
                         * // => 'c';
                         */
                        function nth(array, n) {
                            return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
                        }
                        /**
                         * Removes all given values from `array` using
                         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * for equality comparisons.
                         *
                         * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
                         * to remove elements from an array by predicate.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.0.0
                         * @category Array
                         * @param {Array} array The array to modify.
                         * @param {...*} [values] The values to remove.
                         * @returns {Array} Returns `array`.
                         * @example
                         *
                         * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
                         *
                         * _.pull(array, 'a', 'c');
                         * console.log(array);
                         * // => ['b', 'b']
                         */
                        var pull = baseRest(pullAll);
                        /**
                         * This method is like `_.pull` except that it accepts an array of values to remove.
                         *
                         * **Note:** Unlike `_.difference`, this method mutates `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to modify.
                         * @param {Array} values The values to remove.
                         * @returns {Array} Returns `array`.
                         * @example
                         *
                         * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
                         *
                         * _.pullAll(array, ['a', 'c']);
                         * console.log(array);
                         * // => ['b', 'b']
                         */
                        function pullAll(array, values) {
                            return (array && array.length && values && values.length)
                                ? basePullAll(array, values)
                                : array;
                        }
                        /**
                         * This method is like `_.pullAll` except that it accepts `iteratee` which is
                         * invoked for each element of `array` and `values` to generate the criterion
                         * by which they're compared. The iteratee is invoked with one argument: (value).
                         *
                         * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to modify.
                         * @param {Array} values The values to remove.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {Array} Returns `array`.
                         * @example
                         *
                         * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
                         *
                         * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
                         * console.log(array);
                         * // => [{ 'x': 2 }]
                         */
                        function pullAllBy(array, values, iteratee) {
                            return (array && array.length && values && values.length)
                                ? basePullAll(array, values, getIteratee(iteratee, 2))
                                : array;
                        }
                        /**
                         * This method is like `_.pullAll` except that it accepts `comparator` which
                         * is invoked to compare elements of `array` to `values`. The comparator is
                         * invoked with two arguments: (arrVal, othVal).
                         *
                         * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.6.0
                         * @category Array
                         * @param {Array} array The array to modify.
                         * @param {Array} values The values to remove.
                         * @param {Function} [comparator] The comparator invoked per element.
                         * @returns {Array} Returns `array`.
                         * @example
                         *
                         * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
                         *
                         * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
                         * console.log(array);
                         * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
                         */
                        function pullAllWith(array, values, comparator) {
                            return (array && array.length && values && values.length)
                                ? basePullAll(array, values, undefined, comparator)
                                : array;
                        }
                        /**
                         * Removes elements from `array` corresponding to `indexes` and returns an
                         * array of removed elements.
                         *
                         * **Note:** Unlike `_.at`, this method mutates `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Array
                         * @param {Array} array The array to modify.
                         * @param {...(number|number[])} [indexes] The indexes of elements to remove.
                         * @returns {Array} Returns the new array of removed elements.
                         * @example
                         *
                         * var array = ['a', 'b', 'c', 'd'];
                         * var pulled = _.pullAt(array, [1, 3]);
                         *
                         * console.log(array);
                         * // => ['a', 'c']
                         *
                         * console.log(pulled);
                         * // => ['b', 'd']
                         */
                        var pullAt = flatRest(function (array, indexes) {
                            var length = array == null ? 0 : array.length, result = baseAt(array, indexes);
                            basePullAt(array, arrayMap(indexes, function (index) {
                                return isIndex(index, length) ? +index : index;
                            }).sort(compareAscending));
                            return result;
                        });
                        /**
                         * Removes all elements from `array` that `predicate` returns truthy for
                         * and returns an array of the removed elements. The predicate is invoked
                         * with three arguments: (value, index, array).
                         *
                         * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
                         * to pull elements from an array by value.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.0.0
                         * @category Array
                         * @param {Array} array The array to modify.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the new array of removed elements.
                         * @example
                         *
                         * var array = [1, 2, 3, 4];
                         * var evens = _.remove(array, function(n) {
                         *   return n % 2 == 0;
                         * });
                         *
                         * console.log(array);
                         * // => [1, 3]
                         *
                         * console.log(evens);
                         * // => [2, 4]
                         */
                        function remove(array, predicate) {
                            var result = [];
                            if (!(array && array.length)) {
                                return result;
                            }
                            var index = -1, indexes = [], length = array.length;
                            predicate = getIteratee(predicate, 3);
                            while (++index < length) {
                                var value = array[index];
                                if (predicate(value, index, array)) {
                                    result.push(value);
                                    indexes.push(index);
                                }
                            }
                            basePullAt(array, indexes);
                            return result;
                        }
                        /**
                         * Reverses `array` so that the first element becomes the last, the second
                         * element becomes the second to last, and so on.
                         *
                         * **Note:** This method mutates `array` and is based on
                         * [`Array#reverse`](https://mdn.io/Array/reverse).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to modify.
                         * @returns {Array} Returns `array`.
                         * @example
                         *
                         * var array = [1, 2, 3];
                         *
                         * _.reverse(array);
                         * // => [3, 2, 1]
                         *
                         * console.log(array);
                         * // => [3, 2, 1]
                         */
                        function reverse(array) {
                            return array == null ? array : nativeReverse.call(array);
                        }
                        /**
                         * Creates a slice of `array` from `start` up to, but not including, `end`.
                         *
                         * **Note:** This method is used instead of
                         * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
                         * returned.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Array
                         * @param {Array} array The array to slice.
                         * @param {number} [start=0] The start position.
                         * @param {number} [end=array.length] The end position.
                         * @returns {Array} Returns the slice of `array`.
                         */
                        function slice(array, start, end) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return [];
                            }
                            if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
                                start = 0;
                                end = length;
                            }
                            else {
                                start = start == null ? 0 : toInteger(start);
                                end = end === undefined ? length : toInteger(end);
                            }
                            return baseSlice(array, start, end);
                        }
                        /**
                         * Uses a binary search to determine the lowest index at which `value`
                         * should be inserted into `array` in order to maintain its sort order.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {Array} array The sorted array to inspect.
                         * @param {*} value The value to evaluate.
                         * @returns {number} Returns the index at which `value` should be inserted
                         *  into `array`.
                         * @example
                         *
                         * _.sortedIndex([30, 50], 40);
                         * // => 1
                         */
                        function sortedIndex(array, value) {
                            return baseSortedIndex(array, value);
                        }
                        /**
                         * This method is like `_.sortedIndex` except that it accepts `iteratee`
                         * which is invoked for `value` and each element of `array` to compute their
                         * sort ranking. The iteratee is invoked with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The sorted array to inspect.
                         * @param {*} value The value to evaluate.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {number} Returns the index at which `value` should be inserted
                         *  into `array`.
                         * @example
                         *
                         * var objects = [{ 'x': 4 }, { 'x': 5 }];
                         *
                         * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
                         * // => 0
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
                         * // => 0
                         */
                        function sortedIndexBy(array, value, iteratee) {
                            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
                        }
                        /**
                         * This method is like `_.indexOf` except that it performs a binary
                         * search on a sorted `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {*} value The value to search for.
                         * @returns {number} Returns the index of the matched value, else `-1`.
                         * @example
                         *
                         * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
                         * // => 1
                         */
                        function sortedIndexOf(array, value) {
                            var length = array == null ? 0 : array.length;
                            if (length) {
                                var index = baseSortedIndex(array, value);
                                if (index < length && eq(array[index], value)) {
                                    return index;
                                }
                            }
                            return -1;
                        }
                        /**
                         * This method is like `_.sortedIndex` except that it returns the highest
                         * index at which `value` should be inserted into `array` in order to
                         * maintain its sort order.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Array
                         * @param {Array} array The sorted array to inspect.
                         * @param {*} value The value to evaluate.
                         * @returns {number} Returns the index at which `value` should be inserted
                         *  into `array`.
                         * @example
                         *
                         * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
                         * // => 4
                         */
                        function sortedLastIndex(array, value) {
                            return baseSortedIndex(array, value, true);
                        }
                        /**
                         * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
                         * which is invoked for `value` and each element of `array` to compute their
                         * sort ranking. The iteratee is invoked with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The sorted array to inspect.
                         * @param {*} value The value to evaluate.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {number} Returns the index at which `value` should be inserted
                         *  into `array`.
                         * @example
                         *
                         * var objects = [{ 'x': 4 }, { 'x': 5 }];
                         *
                         * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
                         * // => 1
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
                         * // => 1
                         */
                        function sortedLastIndexBy(array, value, iteratee) {
                            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
                        }
                        /**
                         * This method is like `_.lastIndexOf` except that it performs a binary
                         * search on a sorted `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {*} value The value to search for.
                         * @returns {number} Returns the index of the matched value, else `-1`.
                         * @example
                         *
                         * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
                         * // => 3
                         */
                        function sortedLastIndexOf(array, value) {
                            var length = array == null ? 0 : array.length;
                            if (length) {
                                var index = baseSortedIndex(array, value, true) - 1;
                                if (eq(array[index], value)) {
                                    return index;
                                }
                            }
                            return -1;
                        }
                        /**
                         * This method is like `_.uniq` except that it's designed and optimized
                         * for sorted arrays.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @returns {Array} Returns the new duplicate free array.
                         * @example
                         *
                         * _.sortedUniq([1, 1, 2]);
                         * // => [1, 2]
                         */
                        function sortedUniq(array) {
                            return (array && array.length)
                                ? baseSortedUniq(array)
                                : [];
                        }
                        /**
                         * This method is like `_.uniqBy` except that it's designed and optimized
                         * for sorted arrays.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {Function} [iteratee] The iteratee invoked per element.
                         * @returns {Array} Returns the new duplicate free array.
                         * @example
                         *
                         * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
                         * // => [1.1, 2.3]
                         */
                        function sortedUniqBy(array, iteratee) {
                            return (array && array.length)
                                ? baseSortedUniq(array, getIteratee(iteratee, 2))
                                : [];
                        }
                        /**
                         * Gets all but the first element of `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @returns {Array} Returns the slice of `array`.
                         * @example
                         *
                         * _.tail([1, 2, 3]);
                         * // => [2, 3]
                         */
                        function tail(array) {
                            var length = array == null ? 0 : array.length;
                            return length ? baseSlice(array, 1, length) : [];
                        }
                        /**
                         * Creates a slice of `array` with `n` elements taken from the beginning.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @param {number} [n=1] The number of elements to take.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {Array} Returns the slice of `array`.
                         * @example
                         *
                         * _.take([1, 2, 3]);
                         * // => [1]
                         *
                         * _.take([1, 2, 3], 2);
                         * // => [1, 2]
                         *
                         * _.take([1, 2, 3], 5);
                         * // => [1, 2, 3]
                         *
                         * _.take([1, 2, 3], 0);
                         * // => []
                         */
                        function take(array, n, guard) {
                            if (!(array && array.length)) {
                                return [];
                            }
                            n = (guard || n === undefined) ? 1 : toInteger(n);
                            return baseSlice(array, 0, n < 0 ? 0 : n);
                        }
                        /**
                         * Creates a slice of `array` with `n` elements taken from the end.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @param {number} [n=1] The number of elements to take.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {Array} Returns the slice of `array`.
                         * @example
                         *
                         * _.takeRight([1, 2, 3]);
                         * // => [3]
                         *
                         * _.takeRight([1, 2, 3], 2);
                         * // => [2, 3]
                         *
                         * _.takeRight([1, 2, 3], 5);
                         * // => [1, 2, 3]
                         *
                         * _.takeRight([1, 2, 3], 0);
                         * // => []
                         */
                        function takeRight(array, n, guard) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return [];
                            }
                            n = (guard || n === undefined) ? 1 : toInteger(n);
                            n = length - n;
                            return baseSlice(array, n < 0 ? 0 : n, length);
                        }
                        /**
                         * Creates a slice of `array` with elements taken from the end. Elements are
                         * taken until `predicate` returns falsey. The predicate is invoked with
                         * three arguments: (value, index, array).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the slice of `array`.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney',  'active': true },
                         *   { 'user': 'fred',    'active': false },
                         *   { 'user': 'pebbles', 'active': false }
                         * ];
                         *
                         * _.takeRightWhile(users, function(o) { return !o.active; });
                         * // => objects for ['fred', 'pebbles']
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
                         * // => objects for ['pebbles']
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.takeRightWhile(users, ['active', false]);
                         * // => objects for ['fred', 'pebbles']
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.takeRightWhile(users, 'active');
                         * // => []
                         */
                        function takeRightWhile(array, predicate) {
                            return (array && array.length)
                                ? baseWhile(array, getIteratee(predicate, 3), false, true)
                                : [];
                        }
                        /**
                         * Creates a slice of `array` with elements taken from the beginning. Elements
                         * are taken until `predicate` returns falsey. The predicate is invoked with
                         * three arguments: (value, index, array).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Array
                         * @param {Array} array The array to query.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the slice of `array`.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney',  'active': false },
                         *   { 'user': 'fred',    'active': false },
                         *   { 'user': 'pebbles', 'active': true }
                         * ];
                         *
                         * _.takeWhile(users, function(o) { return !o.active; });
                         * // => objects for ['barney', 'fred']
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.takeWhile(users, { 'user': 'barney', 'active': false });
                         * // => objects for ['barney']
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.takeWhile(users, ['active', false]);
                         * // => objects for ['barney', 'fred']
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.takeWhile(users, 'active');
                         * // => []
                         */
                        function takeWhile(array, predicate) {
                            return (array && array.length)
                                ? baseWhile(array, getIteratee(predicate, 3))
                                : [];
                        }
                        /**
                         * Creates an array of unique values, in order, from all given arrays using
                         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * for equality comparisons.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {...Array} [arrays] The arrays to inspect.
                         * @returns {Array} Returns the new array of combined values.
                         * @example
                         *
                         * _.union([2], [1, 2]);
                         * // => [2, 1]
                         */
                        var union = baseRest(function (arrays) {
                            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
                        });
                        /**
                         * This method is like `_.union` except that it accepts `iteratee` which is
                         * invoked for each element of each `arrays` to generate the criterion by
                         * which uniqueness is computed. Result values are chosen from the first
                         * array in which the value occurs. The iteratee is invoked with one argument:
                         * (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {...Array} [arrays] The arrays to inspect.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {Array} Returns the new array of combined values.
                         * @example
                         *
                         * _.unionBy([2.1], [1.2, 2.3], Math.floor);
                         * // => [2.1, 1.2]
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
                         * // => [{ 'x': 1 }, { 'x': 2 }]
                         */
                        var unionBy = baseRest(function (arrays) {
                            var iteratee = last(arrays);
                            if (isArrayLikeObject(iteratee)) {
                                iteratee = undefined;
                            }
                            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
                        });
                        /**
                         * This method is like `_.union` except that it accepts `comparator` which
                         * is invoked to compare elements of `arrays`. Result values are chosen from
                         * the first array in which the value occurs. The comparator is invoked
                         * with two arguments: (arrVal, othVal).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {...Array} [arrays] The arrays to inspect.
                         * @param {Function} [comparator] The comparator invoked per element.
                         * @returns {Array} Returns the new array of combined values.
                         * @example
                         *
                         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
                         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
                         *
                         * _.unionWith(objects, others, _.isEqual);
                         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
                         */
                        var unionWith = baseRest(function (arrays) {
                            var comparator = last(arrays);
                            comparator = typeof comparator == 'function' ? comparator : undefined;
                            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
                        });
                        /**
                         * Creates a duplicate-free version of an array, using
                         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * for equality comparisons, in which only the first occurrence of each element
                         * is kept. The order of result values is determined by the order they occur
                         * in the array.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @returns {Array} Returns the new duplicate free array.
                         * @example
                         *
                         * _.uniq([2, 1, 2]);
                         * // => [2, 1]
                         */
                        function uniq(array) {
                            return (array && array.length) ? baseUniq(array) : [];
                        }
                        /**
                         * This method is like `_.uniq` except that it accepts `iteratee` which is
                         * invoked for each element in `array` to generate the criterion by which
                         * uniqueness is computed. The order of result values is determined by the
                         * order they occur in the array. The iteratee is invoked with one argument:
                         * (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {Array} Returns the new duplicate free array.
                         * @example
                         *
                         * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
                         * // => [2.1, 1.2]
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
                         * // => [{ 'x': 1 }, { 'x': 2 }]
                         */
                        function uniqBy(array, iteratee) {
                            return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
                        }
                        /**
                         * This method is like `_.uniq` except that it accepts `comparator` which
                         * is invoked to compare elements of `array`. The order of result values is
                         * determined by the order they occur in the array.The comparator is invoked
                         * with two arguments: (arrVal, othVal).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {Function} [comparator] The comparator invoked per element.
                         * @returns {Array} Returns the new duplicate free array.
                         * @example
                         *
                         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
                         *
                         * _.uniqWith(objects, _.isEqual);
                         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
                         */
                        function uniqWith(array, comparator) {
                            comparator = typeof comparator == 'function' ? comparator : undefined;
                            return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
                        }
                        /**
                         * This method is like `_.zip` except that it accepts an array of grouped
                         * elements and creates an array regrouping the elements to their pre-zip
                         * configuration.
                         *
                         * @static
                         * @memberOf _
                         * @since 1.2.0
                         * @category Array
                         * @param {Array} array The array of grouped elements to process.
                         * @returns {Array} Returns the new array of regrouped elements.
                         * @example
                         *
                         * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
                         * // => [['a', 1, true], ['b', 2, false]]
                         *
                         * _.unzip(zipped);
                         * // => [['a', 'b'], [1, 2], [true, false]]
                         */
                        function unzip(array) {
                            if (!(array && array.length)) {
                                return [];
                            }
                            var length = 0;
                            array = arrayFilter(array, function (group) {
                                if (isArrayLikeObject(group)) {
                                    length = nativeMax(group.length, length);
                                    return true;
                                }
                            });
                            return baseTimes(length, function (index) {
                                return arrayMap(array, baseProperty(index));
                            });
                        }
                        /**
                         * This method is like `_.unzip` except that it accepts `iteratee` to specify
                         * how regrouped values should be combined. The iteratee is invoked with the
                         * elements of each group: (...group).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.8.0
                         * @category Array
                         * @param {Array} array The array of grouped elements to process.
                         * @param {Function} [iteratee=_.identity] The function to combine
                         *  regrouped values.
                         * @returns {Array} Returns the new array of regrouped elements.
                         * @example
                         *
                         * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
                         * // => [[1, 10, 100], [2, 20, 200]]
                         *
                         * _.unzipWith(zipped, _.add);
                         * // => [3, 30, 300]
                         */
                        function unzipWith(array, iteratee) {
                            if (!(array && array.length)) {
                                return [];
                            }
                            var result = unzip(array);
                            if (iteratee == null) {
                                return result;
                            }
                            return arrayMap(result, function (group) {
                                return apply(iteratee, undefined, group);
                            });
                        }
                        /**
                         * Creates an array excluding all given values using
                         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * for equality comparisons.
                         *
                         * **Note:** Unlike `_.pull`, this method returns a new array.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @param {...*} [values] The values to exclude.
                         * @returns {Array} Returns the new array of filtered values.
                         * @see _.difference, _.xor
                         * @example
                         *
                         * _.without([2, 1, 2, 3], 1, 2);
                         * // => [3]
                         */
                        var without = baseRest(function (array, values) {
                            return isArrayLikeObject(array)
                                ? baseDifference(array, values)
                                : [];
                        });
                        /**
                         * Creates an array of unique values that is the
                         * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
                         * of the given arrays. The order of result values is determined by the order
                         * they occur in the arrays.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.4.0
                         * @category Array
                         * @param {...Array} [arrays] The arrays to inspect.
                         * @returns {Array} Returns the new array of filtered values.
                         * @see _.difference, _.without
                         * @example
                         *
                         * _.xor([2, 1], [2, 3]);
                         * // => [1, 3]
                         */
                        var xor = baseRest(function (arrays) {
                            return baseXor(arrayFilter(arrays, isArrayLikeObject));
                        });
                        /**
                         * This method is like `_.xor` except that it accepts `iteratee` which is
                         * invoked for each element of each `arrays` to generate the criterion by
                         * which by which they're compared. The order of result values is determined
                         * by the order they occur in the arrays. The iteratee is invoked with one
                         * argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {...Array} [arrays] The arrays to inspect.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {Array} Returns the new array of filtered values.
                         * @example
                         *
                         * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
                         * // => [1.2, 3.4]
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
                         * // => [{ 'x': 2 }]
                         */
                        var xorBy = baseRest(function (arrays) {
                            var iteratee = last(arrays);
                            if (isArrayLikeObject(iteratee)) {
                                iteratee = undefined;
                            }
                            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
                        });
                        /**
                         * This method is like `_.xor` except that it accepts `comparator` which is
                         * invoked to compare elements of `arrays`. The order of result values is
                         * determined by the order they occur in the arrays. The comparator is invoked
                         * with two arguments: (arrVal, othVal).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Array
                         * @param {...Array} [arrays] The arrays to inspect.
                         * @param {Function} [comparator] The comparator invoked per element.
                         * @returns {Array} Returns the new array of filtered values.
                         * @example
                         *
                         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
                         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
                         *
                         * _.xorWith(objects, others, _.isEqual);
                         * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
                         */
                        var xorWith = baseRest(function (arrays) {
                            var comparator = last(arrays);
                            comparator = typeof comparator == 'function' ? comparator : undefined;
                            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
                        });
                        /**
                         * Creates an array of grouped elements, the first of which contains the
                         * first elements of the given arrays, the second of which contains the
                         * second elements of the given arrays, and so on.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {...Array} [arrays] The arrays to process.
                         * @returns {Array} Returns the new array of grouped elements.
                         * @example
                         *
                         * _.zip(['a', 'b'], [1, 2], [true, false]);
                         * // => [['a', 1, true], ['b', 2, false]]
                         */
                        var zip = baseRest(unzip);
                        /**
                         * This method is like `_.fromPairs` except that it accepts two arrays,
                         * one of property identifiers and one of corresponding values.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.4.0
                         * @category Array
                         * @param {Array} [props=[]] The property identifiers.
                         * @param {Array} [values=[]] The property values.
                         * @returns {Object} Returns the new object.
                         * @example
                         *
                         * _.zipObject(['a', 'b'], [1, 2]);
                         * // => { 'a': 1, 'b': 2 }
                         */
                        function zipObject(props, values) {
                            return baseZipObject(props || [], values || [], assignValue);
                        }
                        /**
                         * This method is like `_.zipObject` except that it supports property paths.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.1.0
                         * @category Array
                         * @param {Array} [props=[]] The property identifiers.
                         * @param {Array} [values=[]] The property values.
                         * @returns {Object} Returns the new object.
                         * @example
                         *
                         * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
                         * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
                         */
                        function zipObjectDeep(props, values) {
                            return baseZipObject(props || [], values || [], baseSet);
                        }
                        /**
                         * This method is like `_.zip` except that it accepts `iteratee` to specify
                         * how grouped values should be combined. The iteratee is invoked with the
                         * elements of each group: (...group).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.8.0
                         * @category Array
                         * @param {...Array} [arrays] The arrays to process.
                         * @param {Function} [iteratee=_.identity] The function to combine
                         *  grouped values.
                         * @returns {Array} Returns the new array of grouped elements.
                         * @example
                         *
                         * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
                         *   return a + b + c;
                         * });
                         * // => [111, 222]
                         */
                        var zipWith = baseRest(function (arrays) {
                            var length = arrays.length, iteratee = length > 1 ? arrays[length - 1] : undefined;
                            iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
                            return unzipWith(arrays, iteratee);
                        });
                        /*------------------------------------------------------------------------*/
                        /**
                         * Creates a `lodash` wrapper instance that wraps `value` with explicit method
                         * chain sequences enabled. The result of such sequences must be unwrapped
                         * with `_#value`.
                         *
                         * @static
                         * @memberOf _
                         * @since 1.3.0
                         * @category Seq
                         * @param {*} value The value to wrap.
                         * @returns {Object} Returns the new `lodash` wrapper instance.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney',  'age': 36 },
                         *   { 'user': 'fred',    'age': 40 },
                         *   { 'user': 'pebbles', 'age': 1 }
                         * ];
                         *
                         * var youngest = _
                         *   .chain(users)
                         *   .sortBy('age')
                         *   .map(function(o) {
                         *     return o.user + ' is ' + o.age;
                         *   })
                         *   .head()
                         *   .value();
                         * // => 'pebbles is 1'
                         */
                        function chain(value) {
                            var result = lodash(value);
                            result.__chain__ = true;
                            return result;
                        }
                        /**
                         * This method invokes `interceptor` and returns `value`. The interceptor
                         * is invoked with one argument; (value). The purpose of this method is to
                         * "tap into" a method chain sequence in order to modify intermediate results.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Seq
                         * @param {*} value The value to provide to `interceptor`.
                         * @param {Function} interceptor The function to invoke.
                         * @returns {*} Returns `value`.
                         * @example
                         *
                         * _([1, 2, 3])
                         *  .tap(function(array) {
                         *    // Mutate input array.
                         *    array.pop();
                         *  })
                         *  .reverse()
                         *  .value();
                         * // => [2, 1]
                         */
                        function tap(value, interceptor) {
                            interceptor(value);
                            return value;
                        }
                        /**
                         * This method is like `_.tap` except that it returns the result of `interceptor`.
                         * The purpose of this method is to "pass thru" values replacing intermediate
                         * results in a method chain sequence.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Seq
                         * @param {*} value The value to provide to `interceptor`.
                         * @param {Function} interceptor The function to invoke.
                         * @returns {*} Returns the result of `interceptor`.
                         * @example
                         *
                         * _('  abc  ')
                         *  .chain()
                         *  .trim()
                         *  .thru(function(value) {
                         *    return [value];
                         *  })
                         *  .value();
                         * // => ['abc']
                         */
                        function thru(value, interceptor) {
                            return interceptor(value);
                        }
                        /**
                         * This method is the wrapper version of `_.at`.
                         *
                         * @name at
                         * @memberOf _
                         * @since 1.0.0
                         * @category Seq
                         * @param {...(string|string[])} [paths] The property paths to pick.
                         * @returns {Object} Returns the new `lodash` wrapper instance.
                         * @example
                         *
                         * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
                         *
                         * _(object).at(['a[0].b.c', 'a[1]']).value();
                         * // => [3, 4]
                         */
                        var wrapperAt = flatRest(function (paths) {
                            var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function (object) { return baseAt(object, paths); };
                            if (length > 1 || this.__actions__.length ||
                                !(value instanceof LazyWrapper) || !isIndex(start)) {
                                return this.thru(interceptor);
                            }
                            value = value.slice(start, +start + (length ? 1 : 0));
                            value.__actions__.push({
                                'func': thru,
                                'args': [interceptor],
                                'thisArg': undefined
                            });
                            return new LodashWrapper(value, this.__chain__).thru(function (array) {
                                if (length && !array.length) {
                                    array.push(undefined);
                                }
                                return array;
                            });
                        });
                        /**
                         * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
                         *
                         * @name chain
                         * @memberOf _
                         * @since 0.1.0
                         * @category Seq
                         * @returns {Object} Returns the new `lodash` wrapper instance.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney', 'age': 36 },
                         *   { 'user': 'fred',   'age': 40 }
                         * ];
                         *
                         * // A sequence without explicit chaining.
                         * _(users).head();
                         * // => { 'user': 'barney', 'age': 36 }
                         *
                         * // A sequence with explicit chaining.
                         * _(users)
                         *   .chain()
                         *   .head()
                         *   .pick('user')
                         *   .value();
                         * // => { 'user': 'barney' }
                         */
                        function wrapperChain() {
                            return chain(this);
                        }
                        /**
                         * Executes the chain sequence and returns the wrapped result.
                         *
                         * @name commit
                         * @memberOf _
                         * @since 3.2.0
                         * @category Seq
                         * @returns {Object} Returns the new `lodash` wrapper instance.
                         * @example
                         *
                         * var array = [1, 2];
                         * var wrapped = _(array).push(3);
                         *
                         * console.log(array);
                         * // => [1, 2]
                         *
                         * wrapped = wrapped.commit();
                         * console.log(array);
                         * // => [1, 2, 3]
                         *
                         * wrapped.last();
                         * // => 3
                         *
                         * console.log(array);
                         * // => [1, 2, 3]
                         */
                        function wrapperCommit() {
                            return new LodashWrapper(this.value(), this.__chain__);
                        }
                        /**
                         * Gets the next value on a wrapped object following the
                         * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
                         *
                         * @name next
                         * @memberOf _
                         * @since 4.0.0
                         * @category Seq
                         * @returns {Object} Returns the next iterator value.
                         * @example
                         *
                         * var wrapped = _([1, 2]);
                         *
                         * wrapped.next();
                         * // => { 'done': false, 'value': 1 }
                         *
                         * wrapped.next();
                         * // => { 'done': false, 'value': 2 }
                         *
                         * wrapped.next();
                         * // => { 'done': true, 'value': undefined }
                         */
                        function wrapperNext() {
                            if (this.__values__ === undefined) {
                                this.__values__ = toArray(this.value());
                            }
                            var done = this.__index__ >= this.__values__.length, value = done ? undefined : this.__values__[this.__index__++];
                            return { 'done': done, 'value': value };
                        }
                        /**
                         * Enables the wrapper to be iterable.
                         *
                         * @name Symbol.iterator
                         * @memberOf _
                         * @since 4.0.0
                         * @category Seq
                         * @returns {Object} Returns the wrapper object.
                         * @example
                         *
                         * var wrapped = _([1, 2]);
                         *
                         * wrapped[Symbol.iterator]() === wrapped;
                         * // => true
                         *
                         * Array.from(wrapped);
                         * // => [1, 2]
                         */
                        function wrapperToIterator() {
                            return this;
                        }
                        /**
                         * Creates a clone of the chain sequence planting `value` as the wrapped value.
                         *
                         * @name plant
                         * @memberOf _
                         * @since 3.2.0
                         * @category Seq
                         * @param {*} value The value to plant.
                         * @returns {Object} Returns the new `lodash` wrapper instance.
                         * @example
                         *
                         * function square(n) {
                         *   return n * n;
                         * }
                         *
                         * var wrapped = _([1, 2]).map(square);
                         * var other = wrapped.plant([3, 4]);
                         *
                         * other.value();
                         * // => [9, 16]
                         *
                         * wrapped.value();
                         * // => [1, 4]
                         */
                        function wrapperPlant(value) {
                            var result, parent = this;
                            while (parent instanceof baseLodash) {
                                var clone = wrapperClone(parent);
                                clone.__index__ = 0;
                                clone.__values__ = undefined;
                                if (result) {
                                    previous.__wrapped__ = clone;
                                }
                                else {
                                    result = clone;
                                }
                                var previous = clone;
                                parent = parent.__wrapped__;
                            }
                            previous.__wrapped__ = value;
                            return result;
                        }
                        /**
                         * This method is the wrapper version of `_.reverse`.
                         *
                         * **Note:** This method mutates the wrapped array.
                         *
                         * @name reverse
                         * @memberOf _
                         * @since 0.1.0
                         * @category Seq
                         * @returns {Object} Returns the new `lodash` wrapper instance.
                         * @example
                         *
                         * var array = [1, 2, 3];
                         *
                         * _(array).reverse().value()
                         * // => [3, 2, 1]
                         *
                         * console.log(array);
                         * // => [3, 2, 1]
                         */
                        function wrapperReverse() {
                            var value = this.__wrapped__;
                            if (value instanceof LazyWrapper) {
                                var wrapped = value;
                                if (this.__actions__.length) {
                                    wrapped = new LazyWrapper(this);
                                }
                                wrapped = wrapped.reverse();
                                wrapped.__actions__.push({
                                    'func': thru,
                                    'args': [reverse],
                                    'thisArg': undefined
                                });
                                return new LodashWrapper(wrapped, this.__chain__);
                            }
                            return this.thru(reverse);
                        }
                        /**
                         * Executes the chain sequence to resolve the unwrapped value.
                         *
                         * @name value
                         * @memberOf _
                         * @since 0.1.0
                         * @alias toJSON, valueOf
                         * @category Seq
                         * @returns {*} Returns the resolved unwrapped value.
                         * @example
                         *
                         * _([1, 2, 3]).value();
                         * // => [1, 2, 3]
                         */
                        function wrapperValue() {
                            return baseWrapperValue(this.__wrapped__, this.__actions__);
                        }
                        /*------------------------------------------------------------------------*/
                        /**
                         * Creates an object composed of keys generated from the results of running
                         * each element of `collection` thru `iteratee`. The corresponding value of
                         * each key is the number of times the key was returned by `iteratee`. The
                         * iteratee is invoked with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 0.5.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
                         * @returns {Object} Returns the composed aggregate object.
                         * @example
                         *
                         * _.countBy([6.1, 4.2, 6.3], Math.floor);
                         * // => { '4': 1, '6': 2 }
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.countBy(['one', 'two', 'three'], 'length');
                         * // => { '3': 2, '5': 1 }
                         */
                        var countBy = createAggregator(function (result, value, key) {
                            if (hasOwnProperty.call(result, key)) {
                                ++result[key];
                            }
                            else {
                                baseAssignValue(result, key, 1);
                            }
                        });
                        /**
                         * Checks if `predicate` returns truthy for **all** elements of `collection`.
                         * Iteration is stopped once `predicate` returns falsey. The predicate is
                         * invoked with three arguments: (value, index|key, collection).
                         *
                         * **Note:** This method returns `true` for
                         * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
                         * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
                         * elements of empty collections.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {boolean} Returns `true` if all elements pass the predicate check,
                         *  else `false`.
                         * @example
                         *
                         * _.every([true, 1, null, 'yes'], Boolean);
                         * // => false
                         *
                         * var users = [
                         *   { 'user': 'barney', 'age': 36, 'active': false },
                         *   { 'user': 'fred',   'age': 40, 'active': false }
                         * ];
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.every(users, { 'user': 'barney', 'active': false });
                         * // => false
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.every(users, ['active', false]);
                         * // => true
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.every(users, 'active');
                         * // => false
                         */
                        function every(collection, predicate, guard) {
                            var func = isArray(collection) ? arrayEvery : baseEvery;
                            if (guard && isIterateeCall(collection, predicate, guard)) {
                                predicate = undefined;
                            }
                            return func(collection, getIteratee(predicate, 3));
                        }
                        /**
                         * Iterates over elements of `collection`, returning an array of all elements
                         * `predicate` returns truthy for. The predicate is invoked with three
                         * arguments: (value, index|key, collection).
                         *
                         * **Note:** Unlike `_.remove`, this method returns a new array.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the new filtered array.
                         * @see _.reject
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney', 'age': 36, 'active': true },
                         *   { 'user': 'fred',   'age': 40, 'active': false }
                         * ];
                         *
                         * _.filter(users, function(o) { return !o.active; });
                         * // => objects for ['fred']
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.filter(users, { 'age': 36, 'active': true });
                         * // => objects for ['barney']
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.filter(users, ['active', false]);
                         * // => objects for ['fred']
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.filter(users, 'active');
                         * // => objects for ['barney']
                         *
                         * // Combining several predicates using `_.overEvery` or `_.overSome`.
                         * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
                         * // => objects for ['fred', 'barney']
                         */
                        function filter(collection, predicate) {
                            var func = isArray(collection) ? arrayFilter : baseFilter;
                            return func(collection, getIteratee(predicate, 3));
                        }
                        /**
                         * Iterates over elements of `collection`, returning the first element
                         * `predicate` returns truthy for. The predicate is invoked with three
                         * arguments: (value, index|key, collection).
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to inspect.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @param {number} [fromIndex=0] The index to search from.
                         * @returns {*} Returns the matched element, else `undefined`.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney',  'age': 36, 'active': true },
                         *   { 'user': 'fred',    'age': 40, 'active': false },
                         *   { 'user': 'pebbles', 'age': 1,  'active': true }
                         * ];
                         *
                         * _.find(users, function(o) { return o.age < 40; });
                         * // => object for 'barney'
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.find(users, { 'age': 1, 'active': true });
                         * // => object for 'pebbles'
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.find(users, ['active', false]);
                         * // => object for 'fred'
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.find(users, 'active');
                         * // => object for 'barney'
                         */
                        var find = createFind(findIndex);
                        /**
                         * This method is like `_.find` except that it iterates over elements of
                         * `collection` from right to left.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.0.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to inspect.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @param {number} [fromIndex=collection.length-1] The index to search from.
                         * @returns {*} Returns the matched element, else `undefined`.
                         * @example
                         *
                         * _.findLast([1, 2, 3, 4], function(n) {
                         *   return n % 2 == 1;
                         * });
                         * // => 3
                         */
                        var findLast = createFind(findLastIndex);
                        /**
                         * Creates a flattened array of values by running each element in `collection`
                         * thru `iteratee` and flattening the mapped results. The iteratee is invoked
                         * with three arguments: (value, index|key, collection).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the new flattened array.
                         * @example
                         *
                         * function duplicate(n) {
                         *   return [n, n];
                         * }
                         *
                         * _.flatMap([1, 2], duplicate);
                         * // => [1, 1, 2, 2]
                         */
                        function flatMap(collection, iteratee) {
                            return baseFlatten(map(collection, iteratee), 1);
                        }
                        /**
                         * This method is like `_.flatMap` except that it recursively flattens the
                         * mapped results.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.7.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the new flattened array.
                         * @example
                         *
                         * function duplicate(n) {
                         *   return [[[n, n]]];
                         * }
                         *
                         * _.flatMapDeep([1, 2], duplicate);
                         * // => [1, 1, 2, 2]
                         */
                        function flatMapDeep(collection, iteratee) {
                            return baseFlatten(map(collection, iteratee), INFINITY);
                        }
                        /**
                         * This method is like `_.flatMap` except that it recursively flattens the
                         * mapped results up to `depth` times.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.7.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @param {number} [depth=1] The maximum recursion depth.
                         * @returns {Array} Returns the new flattened array.
                         * @example
                         *
                         * function duplicate(n) {
                         *   return [[[n, n]]];
                         * }
                         *
                         * _.flatMapDepth([1, 2], duplicate, 2);
                         * // => [[1, 1], [2, 2]]
                         */
                        function flatMapDepth(collection, iteratee, depth) {
                            depth = depth === undefined ? 1 : toInteger(depth);
                            return baseFlatten(map(collection, iteratee), depth);
                        }
                        /**
                         * Iterates over elements of `collection` and invokes `iteratee` for each element.
                         * The iteratee is invoked with three arguments: (value, index|key, collection).
                         * Iteratee functions may exit iteration early by explicitly returning `false`.
                         *
                         * **Note:** As with other "Collections" methods, objects with a "length"
                         * property are iterated like arrays. To avoid this behavior use `_.forIn`
                         * or `_.forOwn` for object iteration.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @alias each
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Array|Object} Returns `collection`.
                         * @see _.forEachRight
                         * @example
                         *
                         * _.forEach([1, 2], function(value) {
                         *   console.log(value);
                         * });
                         * // => Logs `1` then `2`.
                         *
                         * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
                         *   console.log(key);
                         * });
                         * // => Logs 'a' then 'b' (iteration order is not guaranteed).
                         */
                        function forEach(collection, iteratee) {
                            var func = isArray(collection) ? arrayEach : baseEach;
                            return func(collection, getIteratee(iteratee, 3));
                        }
                        /**
                         * This method is like `_.forEach` except that it iterates over elements of
                         * `collection` from right to left.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.0.0
                         * @alias eachRight
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Array|Object} Returns `collection`.
                         * @see _.forEach
                         * @example
                         *
                         * _.forEachRight([1, 2], function(value) {
                         *   console.log(value);
                         * });
                         * // => Logs `2` then `1`.
                         */
                        function forEachRight(collection, iteratee) {
                            var func = isArray(collection) ? arrayEachRight : baseEachRight;
                            return func(collection, getIteratee(iteratee, 3));
                        }
                        /**
                         * Creates an object composed of keys generated from the results of running
                         * each element of `collection` thru `iteratee`. The order of grouped values
                         * is determined by the order they occur in `collection`. The corresponding
                         * value of each key is an array of elements responsible for generating the
                         * key. The iteratee is invoked with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
                         * @returns {Object} Returns the composed aggregate object.
                         * @example
                         *
                         * _.groupBy([6.1, 4.2, 6.3], Math.floor);
                         * // => { '4': [4.2], '6': [6.1, 6.3] }
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.groupBy(['one', 'two', 'three'], 'length');
                         * // => { '3': ['one', 'two'], '5': ['three'] }
                         */
                        var groupBy = createAggregator(function (result, value, key) {
                            if (hasOwnProperty.call(result, key)) {
                                result[key].push(value);
                            }
                            else {
                                baseAssignValue(result, key, [value]);
                            }
                        });
                        /**
                         * Checks if `value` is in `collection`. If `collection` is a string, it's
                         * checked for a substring of `value`, otherwise
                         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * is used for equality comparisons. If `fromIndex` is negative, it's used as
                         * the offset from the end of `collection`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object|string} collection The collection to inspect.
                         * @param {*} value The value to search for.
                         * @param {number} [fromIndex=0] The index to search from.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
                         * @returns {boolean} Returns `true` if `value` is found, else `false`.
                         * @example
                         *
                         * _.includes([1, 2, 3], 1);
                         * // => true
                         *
                         * _.includes([1, 2, 3], 1, 2);
                         * // => false
                         *
                         * _.includes({ 'a': 1, 'b': 2 }, 1);
                         * // => true
                         *
                         * _.includes('abcd', 'bc');
                         * // => true
                         */
                        function includes(collection, value, fromIndex, guard) {
                            collection = isArrayLike(collection) ? collection : values(collection);
                            fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;
                            var length = collection.length;
                            if (fromIndex < 0) {
                                fromIndex = nativeMax(length + fromIndex, 0);
                            }
                            return isString(collection)
                                ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
                                : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
                        }
                        /**
                         * Invokes the method at `path` of each element in `collection`, returning
                         * an array of the results of each invoked method. Any additional arguments
                         * are provided to each invoked method. If `path` is a function, it's invoked
                         * for, and `this` bound to, each element in `collection`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Array|Function|string} path The path of the method to invoke or
                         *  the function invoked per iteration.
                         * @param {...*} [args] The arguments to invoke each method with.
                         * @returns {Array} Returns the array of results.
                         * @example
                         *
                         * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
                         * // => [[1, 5, 7], [1, 2, 3]]
                         *
                         * _.invokeMap([123, 456], String.prototype.split, '');
                         * // => [['1', '2', '3'], ['4', '5', '6']]
                         */
                        var invokeMap = baseRest(function (collection, path, args) {
                            var index = -1, isFunc = typeof path == 'function', result = isArrayLike(collection) ? Array(collection.length) : [];
                            baseEach(collection, function (value) {
                                result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
                            });
                            return result;
                        });
                        /**
                         * Creates an object composed of keys generated from the results of running
                         * each element of `collection` thru `iteratee`. The corresponding value of
                         * each key is the last element responsible for generating the key. The
                         * iteratee is invoked with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
                         * @returns {Object} Returns the composed aggregate object.
                         * @example
                         *
                         * var array = [
                         *   { 'dir': 'left', 'code': 97 },
                         *   { 'dir': 'right', 'code': 100 }
                         * ];
                         *
                         * _.keyBy(array, function(o) {
                         *   return String.fromCharCode(o.code);
                         * });
                         * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
                         *
                         * _.keyBy(array, 'dir');
                         * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
                         */
                        var keyBy = createAggregator(function (result, value, key) {
                            baseAssignValue(result, key, value);
                        });
                        /**
                         * Creates an array of values by running each element in `collection` thru
                         * `iteratee`. The iteratee is invoked with three arguments:
                         * (value, index|key, collection).
                         *
                         * Many lodash methods are guarded to work as iteratees for methods like
                         * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
                         *
                         * The guarded methods are:
                         * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
                         * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
                         * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
                         * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the new mapped array.
                         * @example
                         *
                         * function square(n) {
                         *   return n * n;
                         * }
                         *
                         * _.map([4, 8], square);
                         * // => [16, 64]
                         *
                         * _.map({ 'a': 4, 'b': 8 }, square);
                         * // => [16, 64] (iteration order is not guaranteed)
                         *
                         * var users = [
                         *   { 'user': 'barney' },
                         *   { 'user': 'fred' }
                         * ];
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.map(users, 'user');
                         * // => ['barney', 'fred']
                         */
                        function map(collection, iteratee) {
                            var func = isArray(collection) ? arrayMap : baseMap;
                            return func(collection, getIteratee(iteratee, 3));
                        }
                        /**
                         * This method is like `_.sortBy` except that it allows specifying the sort
                         * orders of the iteratees to sort by. If `orders` is unspecified, all values
                         * are sorted in ascending order. Otherwise, specify an order of "desc" for
                         * descending or "asc" for ascending sort order of corresponding values.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
                         *  The iteratees to sort by.
                         * @param {string[]} [orders] The sort orders of `iteratees`.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
                         * @returns {Array} Returns the new sorted array.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'fred',   'age': 48 },
                         *   { 'user': 'barney', 'age': 34 },
                         *   { 'user': 'fred',   'age': 40 },
                         *   { 'user': 'barney', 'age': 36 }
                         * ];
                         *
                         * // Sort by `user` in ascending order and by `age` in descending order.
                         * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
                         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
                         */
                        function orderBy(collection, iteratees, orders, guard) {
                            if (collection == null) {
                                return [];
                            }
                            if (!isArray(iteratees)) {
                                iteratees = iteratees == null ? [] : [iteratees];
                            }
                            orders = guard ? undefined : orders;
                            if (!isArray(orders)) {
                                orders = orders == null ? [] : [orders];
                            }
                            return baseOrderBy(collection, iteratees, orders);
                        }
                        /**
                         * Creates an array of elements split into two groups, the first of which
                         * contains elements `predicate` returns truthy for, the second of which
                         * contains elements `predicate` returns falsey for. The predicate is
                         * invoked with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the array of grouped elements.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney',  'age': 36, 'active': false },
                         *   { 'user': 'fred',    'age': 40, 'active': true },
                         *   { 'user': 'pebbles', 'age': 1,  'active': false }
                         * ];
                         *
                         * _.partition(users, function(o) { return o.active; });
                         * // => objects for [['fred'], ['barney', 'pebbles']]
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.partition(users, { 'age': 1, 'active': false });
                         * // => objects for [['pebbles'], ['barney', 'fred']]
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.partition(users, ['active', false]);
                         * // => objects for [['barney', 'pebbles'], ['fred']]
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.partition(users, 'active');
                         * // => objects for [['fred'], ['barney', 'pebbles']]
                         */
                        var partition = createAggregator(function (result, value, key) {
                            result[key ? 0 : 1].push(value);
                        }, function () { return [[], []]; });
                        /**
                         * Reduces `collection` to a value which is the accumulated result of running
                         * each element in `collection` thru `iteratee`, where each successive
                         * invocation is supplied the return value of the previous. If `accumulator`
                         * is not given, the first element of `collection` is used as the initial
                         * value. The iteratee is invoked with four arguments:
                         * (accumulator, value, index|key, collection).
                         *
                         * Many lodash methods are guarded to work as iteratees for methods like
                         * `_.reduce`, `_.reduceRight`, and `_.transform`.
                         *
                         * The guarded methods are:
                         * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
                         * and `sortBy`
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @param {*} [accumulator] The initial value.
                         * @returns {*} Returns the accumulated value.
                         * @see _.reduceRight
                         * @example
                         *
                         * _.reduce([1, 2], function(sum, n) {
                         *   return sum + n;
                         * }, 0);
                         * // => 3
                         *
                         * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
                         *   (result[value] || (result[value] = [])).push(key);
                         *   return result;
                         * }, {});
                         * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
                         */
                        function reduce(collection, iteratee, accumulator) {
                            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
                            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
                        }
                        /**
                         * This method is like `_.reduce` except that it iterates over elements of
                         * `collection` from right to left.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @param {*} [accumulator] The initial value.
                         * @returns {*} Returns the accumulated value.
                         * @see _.reduce
                         * @example
                         *
                         * var array = [[0, 1], [2, 3], [4, 5]];
                         *
                         * _.reduceRight(array, function(flattened, other) {
                         *   return flattened.concat(other);
                         * }, []);
                         * // => [4, 5, 2, 3, 0, 1]
                         */
                        function reduceRight(collection, iteratee, accumulator) {
                            var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
                            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
                        }
                        /**
                         * The opposite of `_.filter`; this method returns the elements of `collection`
                         * that `predicate` does **not** return truthy for.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the new filtered array.
                         * @see _.filter
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney', 'age': 36, 'active': false },
                         *   { 'user': 'fred',   'age': 40, 'active': true }
                         * ];
                         *
                         * _.reject(users, function(o) { return !o.active; });
                         * // => objects for ['fred']
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.reject(users, { 'age': 40, 'active': true });
                         * // => objects for ['barney']
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.reject(users, ['active', false]);
                         * // => objects for ['fred']
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.reject(users, 'active');
                         * // => objects for ['barney']
                         */
                        function reject(collection, predicate) {
                            var func = isArray(collection) ? arrayFilter : baseFilter;
                            return func(collection, negate(getIteratee(predicate, 3)));
                        }
                        /**
                         * Gets a random element from `collection`.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.0.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to sample.
                         * @returns {*} Returns the random element.
                         * @example
                         *
                         * _.sample([1, 2, 3, 4]);
                         * // => 2
                         */
                        function sample(collection) {
                            var func = isArray(collection) ? arraySample : baseSample;
                            return func(collection);
                        }
                        /**
                         * Gets `n` random elements at unique keys from `collection` up to the
                         * size of `collection`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to sample.
                         * @param {number} [n=1] The number of elements to sample.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {Array} Returns the random elements.
                         * @example
                         *
                         * _.sampleSize([1, 2, 3], 2);
                         * // => [3, 1]
                         *
                         * _.sampleSize([1, 2, 3], 4);
                         * // => [2, 3, 1]
                         */
                        function sampleSize(collection, n, guard) {
                            if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
                                n = 1;
                            }
                            else {
                                n = toInteger(n);
                            }
                            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
                            return func(collection, n);
                        }
                        /**
                         * Creates an array of shuffled values, using a version of the
                         * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to shuffle.
                         * @returns {Array} Returns the new shuffled array.
                         * @example
                         *
                         * _.shuffle([1, 2, 3, 4]);
                         * // => [4, 1, 3, 2]
                         */
                        function shuffle(collection) {
                            var func = isArray(collection) ? arrayShuffle : baseShuffle;
                            return func(collection);
                        }
                        /**
                         * Gets the size of `collection` by returning its length for array-like
                         * values or the number of own enumerable string keyed properties for objects.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object|string} collection The collection to inspect.
                         * @returns {number} Returns the collection size.
                         * @example
                         *
                         * _.size([1, 2, 3]);
                         * // => 3
                         *
                         * _.size({ 'a': 1, 'b': 2 });
                         * // => 2
                         *
                         * _.size('pebbles');
                         * // => 7
                         */
                        function size(collection) {
                            if (collection == null) {
                                return 0;
                            }
                            if (isArrayLike(collection)) {
                                return isString(collection) ? stringSize(collection) : collection.length;
                            }
                            var tag = getTag(collection);
                            if (tag == mapTag || tag == setTag) {
                                return collection.size;
                            }
                            return baseKeys(collection).length;
                        }
                        /**
                         * Checks if `predicate` returns truthy for **any** element of `collection`.
                         * Iteration is stopped once `predicate` returns truthy. The predicate is
                         * invoked with three arguments: (value, index|key, collection).
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {boolean} Returns `true` if any element passes the predicate check,
                         *  else `false`.
                         * @example
                         *
                         * _.some([null, 0, 'yes', false], Boolean);
                         * // => true
                         *
                         * var users = [
                         *   { 'user': 'barney', 'active': true },
                         *   { 'user': 'fred',   'active': false }
                         * ];
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.some(users, { 'user': 'barney', 'active': false });
                         * // => false
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.some(users, ['active', false]);
                         * // => true
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.some(users, 'active');
                         * // => true
                         */
                        function some(collection, predicate, guard) {
                            var func = isArray(collection) ? arraySome : baseSome;
                            if (guard && isIterateeCall(collection, predicate, guard)) {
                                predicate = undefined;
                            }
                            return func(collection, getIteratee(predicate, 3));
                        }
                        /**
                         * Creates an array of elements, sorted in ascending order by the results of
                         * running each element in a collection thru each iteratee. This method
                         * performs a stable sort, that is, it preserves the original sort order of
                         * equal elements. The iteratees are invoked with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Collection
                         * @param {Array|Object} collection The collection to iterate over.
                         * @param {...(Function|Function[])} [iteratees=[_.identity]]
                         *  The iteratees to sort by.
                         * @returns {Array} Returns the new sorted array.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'fred',   'age': 48 },
                         *   { 'user': 'barney', 'age': 36 },
                         *   { 'user': 'fred',   'age': 30 },
                         *   { 'user': 'barney', 'age': 34 }
                         * ];
                         *
                         * _.sortBy(users, [function(o) { return o.user; }]);
                         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
                         *
                         * _.sortBy(users, ['user', 'age']);
                         * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
                         */
                        var sortBy = baseRest(function (collection, iteratees) {
                            if (collection == null) {
                                return [];
                            }
                            var length = iteratees.length;
                            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
                                iteratees = [];
                            }
                            else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
                                iteratees = [iteratees[0]];
                            }
                            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
                        });
                        /*------------------------------------------------------------------------*/
                        /**
                         * Gets the timestamp of the number of milliseconds that have elapsed since
                         * the Unix epoch (1 January 1970 00:00:00 UTC).
                         *
                         * @static
                         * @memberOf _
                         * @since 2.4.0
                         * @category Date
                         * @returns {number} Returns the timestamp.
                         * @example
                         *
                         * _.defer(function(stamp) {
                         *   console.log(_.now() - stamp);
                         * }, _.now());
                         * // => Logs the number of milliseconds it took for the deferred invocation.
                         */
                        var now = ctxNow || function () {
                            return root.Date.now();
                        };
                        /*------------------------------------------------------------------------*/
                        /**
                         * The opposite of `_.before`; this method creates a function that invokes
                         * `func` once it's called `n` or more times.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Function
                         * @param {number} n The number of calls before `func` is invoked.
                         * @param {Function} func The function to restrict.
                         * @returns {Function} Returns the new restricted function.
                         * @example
                         *
                         * var saves = ['profile', 'settings'];
                         *
                         * var done = _.after(saves.length, function() {
                         *   console.log('done saving!');
                         * });
                         *
                         * _.forEach(saves, function(type) {
                         *   asyncSave({ 'type': type, 'complete': done });
                         * });
                         * // => Logs 'done saving!' after the two async saves have completed.
                         */
                        function after(n, func) {
                            if (typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            n = toInteger(n);
                            return function () {
                                if (--n < 1) {
                                    return func.apply(this, arguments);
                                }
                            };
                        }
                        /**
                         * Creates a function that invokes `func`, with up to `n` arguments,
                         * ignoring any additional arguments.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Function
                         * @param {Function} func The function to cap arguments for.
                         * @param {number} [n=func.length] The arity cap.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {Function} Returns the new capped function.
                         * @example
                         *
                         * _.map(['6', '8', '10'], _.ary(parseInt, 1));
                         * // => [6, 8, 10]
                         */
                        function ary(func, n, guard) {
                            n = guard ? undefined : n;
                            n = (func && n == null) ? func.length : n;
                            return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
                        }
                        /**
                         * Creates a function that invokes `func`, with the `this` binding and arguments
                         * of the created function, while it's called less than `n` times. Subsequent
                         * calls to the created function return the result of the last `func` invocation.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Function
                         * @param {number} n The number of calls at which `func` is no longer invoked.
                         * @param {Function} func The function to restrict.
                         * @returns {Function} Returns the new restricted function.
                         * @example
                         *
                         * jQuery(element).on('click', _.before(5, addContactToList));
                         * // => Allows adding up to 4 contacts to the list.
                         */
                        function before(n, func) {
                            var result;
                            if (typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            n = toInteger(n);
                            return function () {
                                if (--n > 0) {
                                    result = func.apply(this, arguments);
                                }
                                if (n <= 1) {
                                    func = undefined;
                                }
                                return result;
                            };
                        }
                        /**
                         * Creates a function that invokes `func` with the `this` binding of `thisArg`
                         * and `partials` prepended to the arguments it receives.
                         *
                         * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
                         * may be used as a placeholder for partially applied arguments.
                         *
                         * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
                         * property of bound functions.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Function
                         * @param {Function} func The function to bind.
                         * @param {*} thisArg The `this` binding of `func`.
                         * @param {...*} [partials] The arguments to be partially applied.
                         * @returns {Function} Returns the new bound function.
                         * @example
                         *
                         * function greet(greeting, punctuation) {
                         *   return greeting + ' ' + this.user + punctuation;
                         * }
                         *
                         * var object = { 'user': 'fred' };
                         *
                         * var bound = _.bind(greet, object, 'hi');
                         * bound('!');
                         * // => 'hi fred!'
                         *
                         * // Bound with placeholders.
                         * var bound = _.bind(greet, object, _, '!');
                         * bound('hi');
                         * // => 'hi fred!'
                         */
                        var bind = baseRest(function (func, thisArg, partials) {
                            var bitmask = WRAP_BIND_FLAG;
                            if (partials.length) {
                                var holders = replaceHolders(partials, getHolder(bind));
                                bitmask |= WRAP_PARTIAL_FLAG;
                            }
                            return createWrap(func, bitmask, thisArg, partials, holders);
                        });
                        /**
                         * Creates a function that invokes the method at `object[key]` with `partials`
                         * prepended to the arguments it receives.
                         *
                         * This method differs from `_.bind` by allowing bound functions to reference
                         * methods that may be redefined or don't yet exist. See
                         * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
                         * for more details.
                         *
                         * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
                         * builds, may be used as a placeholder for partially applied arguments.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.10.0
                         * @category Function
                         * @param {Object} object The object to invoke the method on.
                         * @param {string} key The key of the method.
                         * @param {...*} [partials] The arguments to be partially applied.
                         * @returns {Function} Returns the new bound function.
                         * @example
                         *
                         * var object = {
                         *   'user': 'fred',
                         *   'greet': function(greeting, punctuation) {
                         *     return greeting + ' ' + this.user + punctuation;
                         *   }
                         * };
                         *
                         * var bound = _.bindKey(object, 'greet', 'hi');
                         * bound('!');
                         * // => 'hi fred!'
                         *
                         * object.greet = function(greeting, punctuation) {
                         *   return greeting + 'ya ' + this.user + punctuation;
                         * };
                         *
                         * bound('!');
                         * // => 'hiya fred!'
                         *
                         * // Bound with placeholders.
                         * var bound = _.bindKey(object, 'greet', _, '!');
                         * bound('hi');
                         * // => 'hiya fred!'
                         */
                        var bindKey = baseRest(function (object, key, partials) {
                            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
                            if (partials.length) {
                                var holders = replaceHolders(partials, getHolder(bindKey));
                                bitmask |= WRAP_PARTIAL_FLAG;
                            }
                            return createWrap(key, bitmask, object, partials, holders);
                        });
                        /**
                         * Creates a function that accepts arguments of `func` and either invokes
                         * `func` returning its result, if at least `arity` number of arguments have
                         * been provided, or returns a function that accepts the remaining `func`
                         * arguments, and so on. The arity of `func` may be specified if `func.length`
                         * is not sufficient.
                         *
                         * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
                         * may be used as a placeholder for provided arguments.
                         *
                         * **Note:** This method doesn't set the "length" property of curried functions.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.0.0
                         * @category Function
                         * @param {Function} func The function to curry.
                         * @param {number} [arity=func.length] The arity of `func`.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {Function} Returns the new curried function.
                         * @example
                         *
                         * var abc = function(a, b, c) {
                         *   return [a, b, c];
                         * };
                         *
                         * var curried = _.curry(abc);
                         *
                         * curried(1)(2)(3);
                         * // => [1, 2, 3]
                         *
                         * curried(1, 2)(3);
                         * // => [1, 2, 3]
                         *
                         * curried(1, 2, 3);
                         * // => [1, 2, 3]
                         *
                         * // Curried with placeholders.
                         * curried(1)(_, 3)(2);
                         * // => [1, 2, 3]
                         */
                        function curry(func, arity, guard) {
                            arity = guard ? undefined : arity;
                            var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                            result.placeholder = curry.placeholder;
                            return result;
                        }
                        /**
                         * This method is like `_.curry` except that arguments are applied to `func`
                         * in the manner of `_.partialRight` instead of `_.partial`.
                         *
                         * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
                         * builds, may be used as a placeholder for provided arguments.
                         *
                         * **Note:** This method doesn't set the "length" property of curried functions.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Function
                         * @param {Function} func The function to curry.
                         * @param {number} [arity=func.length] The arity of `func`.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {Function} Returns the new curried function.
                         * @example
                         *
                         * var abc = function(a, b, c) {
                         *   return [a, b, c];
                         * };
                         *
                         * var curried = _.curryRight(abc);
                         *
                         * curried(3)(2)(1);
                         * // => [1, 2, 3]
                         *
                         * curried(2, 3)(1);
                         * // => [1, 2, 3]
                         *
                         * curried(1, 2, 3);
                         * // => [1, 2, 3]
                         *
                         * // Curried with placeholders.
                         * curried(3)(1, _)(2);
                         * // => [1, 2, 3]
                         */
                        function curryRight(func, arity, guard) {
                            arity = guard ? undefined : arity;
                            var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                            result.placeholder = curryRight.placeholder;
                            return result;
                        }
                        /**
                         * Creates a debounced function that delays invoking `func` until after `wait`
                         * milliseconds have elapsed since the last time the debounced function was
                         * invoked. The debounced function comes with a `cancel` method to cancel
                         * delayed `func` invocations and a `flush` method to immediately invoke them.
                         * Provide `options` to indicate whether `func` should be invoked on the
                         * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
                         * with the last arguments provided to the debounced function. Subsequent
                         * calls to the debounced function return the result of the last `func`
                         * invocation.
                         *
                         * **Note:** If `leading` and `trailing` options are `true`, `func` is
                         * invoked on the trailing edge of the timeout only if the debounced function
                         * is invoked more than once during the `wait` timeout.
                         *
                         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
                         * until to the next tick, similar to `setTimeout` with a timeout of `0`.
                         *
                         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
                         * for details over the differences between `_.debounce` and `_.throttle`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Function
                         * @param {Function} func The function to debounce.
                         * @param {number} [wait=0] The number of milliseconds to delay.
                         * @param {Object} [options={}] The options object.
                         * @param {boolean} [options.leading=false]
                         *  Specify invoking on the leading edge of the timeout.
                         * @param {number} [options.maxWait]
                         *  The maximum time `func` is allowed to be delayed before it's invoked.
                         * @param {boolean} [options.trailing=true]
                         *  Specify invoking on the trailing edge of the timeout.
                         * @returns {Function} Returns the new debounced function.
                         * @example
                         *
                         * // Avoid costly calculations while the window size is in flux.
                         * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
                         *
                         * // Invoke `sendMail` when clicked, debouncing subsequent calls.
                         * jQuery(element).on('click', _.debounce(sendMail, 300, {
                         *   'leading': true,
                         *   'trailing': false
                         * }));
                         *
                         * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
                         * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
                         * var source = new EventSource('/stream');
                         * jQuery(source).on('message', debounced);
                         *
                         * // Cancel the trailing debounced invocation.
                         * jQuery(window).on('popstate', debounced.cancel);
                         */
                        function debounce(func, wait, options) {
                            var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
                            if (typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            wait = toNumber(wait) || 0;
                            if (isObject(options)) {
                                leading = !!options.leading;
                                maxing = 'maxWait' in options;
                                maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                                trailing = 'trailing' in options ? !!options.trailing : trailing;
                            }
                            function invokeFunc(time) {
                                var args = lastArgs, thisArg = lastThis;
                                lastArgs = lastThis = undefined;
                                lastInvokeTime = time;
                                result = func.apply(thisArg, args);
                                return result;
                            }
                            function leadingEdge(time) {
                                // Reset any `maxWait` timer.
                                lastInvokeTime = time;
                                // Start the timer for the trailing edge.
                                timerId = setTimeout(timerExpired, wait);
                                // Invoke the leading edge.
                                return leading ? invokeFunc(time) : result;
                            }
                            function remainingWait(time) {
                                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
                                return maxing
                                    ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
                                    : timeWaiting;
                            }
                            function shouldInvoke(time) {
                                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                                // Either this is the first call, activity has stopped and we're at the
                                // trailing edge, the system time has gone backwards and we're treating
                                // it as the trailing edge, or we've hit the `maxWait` limit.
                                return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
                                    (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
                            }
                            function timerExpired() {
                                var time = now();
                                if (shouldInvoke(time)) {
                                    return trailingEdge(time);
                                }
                                // Restart the timer.
                                timerId = setTimeout(timerExpired, remainingWait(time));
                            }
                            function trailingEdge(time) {
                                timerId = undefined;
                                // Only invoke if we have `lastArgs` which means `func` has been
                                // debounced at least once.
                                if (trailing && lastArgs) {
                                    return invokeFunc(time);
                                }
                                lastArgs = lastThis = undefined;
                                return result;
                            }
                            function cancel() {
                                if (timerId !== undefined) {
                                    clearTimeout(timerId);
                                }
                                lastInvokeTime = 0;
                                lastArgs = lastCallTime = lastThis = timerId = undefined;
                            }
                            function flush() {
                                return timerId === undefined ? result : trailingEdge(now());
                            }
                            function debounced() {
                                var time = now(), isInvoking = shouldInvoke(time);
                                lastArgs = arguments;
                                lastThis = this;
                                lastCallTime = time;
                                if (isInvoking) {
                                    if (timerId === undefined) {
                                        return leadingEdge(lastCallTime);
                                    }
                                    if (maxing) {
                                        // Handle invocations in a tight loop.
                                        clearTimeout(timerId);
                                        timerId = setTimeout(timerExpired, wait);
                                        return invokeFunc(lastCallTime);
                                    }
                                }
                                if (timerId === undefined) {
                                    timerId = setTimeout(timerExpired, wait);
                                }
                                return result;
                            }
                            debounced.cancel = cancel;
                            debounced.flush = flush;
                            return debounced;
                        }
                        /**
                         * Defers invoking the `func` until the current call stack has cleared. Any
                         * additional arguments are provided to `func` when it's invoked.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Function
                         * @param {Function} func The function to defer.
                         * @param {...*} [args] The arguments to invoke `func` with.
                         * @returns {number} Returns the timer id.
                         * @example
                         *
                         * _.defer(function(text) {
                         *   console.log(text);
                         * }, 'deferred');
                         * // => Logs 'deferred' after one millisecond.
                         */
                        var defer = baseRest(function (func, args) {
                            return baseDelay(func, 1, args);
                        });
                        /**
                         * Invokes `func` after `wait` milliseconds. Any additional arguments are
                         * provided to `func` when it's invoked.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Function
                         * @param {Function} func The function to delay.
                         * @param {number} wait The number of milliseconds to delay invocation.
                         * @param {...*} [args] The arguments to invoke `func` with.
                         * @returns {number} Returns the timer id.
                         * @example
                         *
                         * _.delay(function(text) {
                         *   console.log(text);
                         * }, 1000, 'later');
                         * // => Logs 'later' after one second.
                         */
                        var delay = baseRest(function (func, wait, args) {
                            return baseDelay(func, toNumber(wait) || 0, args);
                        });
                        /**
                         * Creates a function that invokes `func` with arguments reversed.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Function
                         * @param {Function} func The function to flip arguments for.
                         * @returns {Function} Returns the new flipped function.
                         * @example
                         *
                         * var flipped = _.flip(function() {
                         *   return _.toArray(arguments);
                         * });
                         *
                         * flipped('a', 'b', 'c', 'd');
                         * // => ['d', 'c', 'b', 'a']
                         */
                        function flip(func) {
                            return createWrap(func, WRAP_FLIP_FLAG);
                        }
                        /**
                         * Creates a function that memoizes the result of `func`. If `resolver` is
                         * provided, it determines the cache key for storing the result based on the
                         * arguments provided to the memoized function. By default, the first argument
                         * provided to the memoized function is used as the map cache key. The `func`
                         * is invoked with the `this` binding of the memoized function.
                         *
                         * **Note:** The cache is exposed as the `cache` property on the memoized
                         * function. Its creation may be customized by replacing the `_.memoize.Cache`
                         * constructor with one whose instances implement the
                         * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
                         * method interface of `clear`, `delete`, `get`, `has`, and `set`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Function
                         * @param {Function} func The function to have its output memoized.
                         * @param {Function} [resolver] The function to resolve the cache key.
                         * @returns {Function} Returns the new memoized function.
                         * @example
                         *
                         * var object = { 'a': 1, 'b': 2 };
                         * var other = { 'c': 3, 'd': 4 };
                         *
                         * var values = _.memoize(_.values);
                         * values(object);
                         * // => [1, 2]
                         *
                         * values(other);
                         * // => [3, 4]
                         *
                         * object.a = 2;
                         * values(object);
                         * // => [1, 2]
                         *
                         * // Modify the result cache.
                         * values.cache.set(object, ['a', 'b']);
                         * values(object);
                         * // => ['a', 'b']
                         *
                         * // Replace `_.memoize.Cache`.
                         * _.memoize.Cache = WeakMap;
                         */
                        function memoize(func, resolver) {
                            if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            var memoized = function () {
                                var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                                if (cache.has(key)) {
                                    return cache.get(key);
                                }
                                var result = func.apply(this, args);
                                memoized.cache = cache.set(key, result) || cache;
                                return result;
                            };
                            memoized.cache = new (memoize.Cache || MapCache);
                            return memoized;
                        }
                        // Expose `MapCache`.
                        memoize.Cache = MapCache;
                        /**
                         * Creates a function that negates the result of the predicate `func`. The
                         * `func` predicate is invoked with the `this` binding and arguments of the
                         * created function.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Function
                         * @param {Function} predicate The predicate to negate.
                         * @returns {Function} Returns the new negated function.
                         * @example
                         *
                         * function isEven(n) {
                         *   return n % 2 == 0;
                         * }
                         *
                         * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
                         * // => [1, 3, 5]
                         */
                        function negate(predicate) {
                            if (typeof predicate != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            return function () {
                                var args = arguments;
                                switch (args.length) {
                                    case 0: return !predicate.call(this);
                                    case 1: return !predicate.call(this, args[0]);
                                    case 2: return !predicate.call(this, args[0], args[1]);
                                    case 3: return !predicate.call(this, args[0], args[1], args[2]);
                                }
                                return !predicate.apply(this, args);
                            };
                        }
                        /**
                         * Creates a function that is restricted to invoking `func` once. Repeat calls
                         * to the function return the value of the first invocation. The `func` is
                         * invoked with the `this` binding and arguments of the created function.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Function
                         * @param {Function} func The function to restrict.
                         * @returns {Function} Returns the new restricted function.
                         * @example
                         *
                         * var initialize = _.once(createApplication);
                         * initialize();
                         * initialize();
                         * // => `createApplication` is invoked once
                         */
                        function once(func) {
                            return before(2, func);
                        }
                        /**
                         * Creates a function that invokes `func` with its arguments transformed.
                         *
                         * @static
                         * @since 4.0.0
                         * @memberOf _
                         * @category Function
                         * @param {Function} func The function to wrap.
                         * @param {...(Function|Function[])} [transforms=[_.identity]]
                         *  The argument transforms.
                         * @returns {Function} Returns the new function.
                         * @example
                         *
                         * function doubled(n) {
                         *   return n * 2;
                         * }
                         *
                         * function square(n) {
                         *   return n * n;
                         * }
                         *
                         * var func = _.overArgs(function(x, y) {
                         *   return [x, y];
                         * }, [square, doubled]);
                         *
                         * func(9, 3);
                         * // => [81, 6]
                         *
                         * func(10, 5);
                         * // => [100, 10]
                         */
                        var overArgs = castRest(function (func, transforms) {
                            transforms = (transforms.length == 1 && isArray(transforms[0]))
                                ? arrayMap(transforms[0], baseUnary(getIteratee()))
                                : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
                            var funcsLength = transforms.length;
                            return baseRest(function (args) {
                                var index = -1, length = nativeMin(args.length, funcsLength);
                                while (++index < length) {
                                    args[index] = transforms[index].call(this, args[index]);
                                }
                                return apply(func, this, args);
                            });
                        });
                        /**
                         * Creates a function that invokes `func` with `partials` prepended to the
                         * arguments it receives. This method is like `_.bind` except it does **not**
                         * alter the `this` binding.
                         *
                         * The `_.partial.placeholder` value, which defaults to `_` in monolithic
                         * builds, may be used as a placeholder for partially applied arguments.
                         *
                         * **Note:** This method doesn't set the "length" property of partially
                         * applied functions.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.2.0
                         * @category Function
                         * @param {Function} func The function to partially apply arguments to.
                         * @param {...*} [partials] The arguments to be partially applied.
                         * @returns {Function} Returns the new partially applied function.
                         * @example
                         *
                         * function greet(greeting, name) {
                         *   return greeting + ' ' + name;
                         * }
                         *
                         * var sayHelloTo = _.partial(greet, 'hello');
                         * sayHelloTo('fred');
                         * // => 'hello fred'
                         *
                         * // Partially applied with placeholders.
                         * var greetFred = _.partial(greet, _, 'fred');
                         * greetFred('hi');
                         * // => 'hi fred'
                         */
                        var partial = baseRest(function (func, partials) {
                            var holders = replaceHolders(partials, getHolder(partial));
                            return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
                        });
                        /**
                         * This method is like `_.partial` except that partially applied arguments
                         * are appended to the arguments it receives.
                         *
                         * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
                         * builds, may be used as a placeholder for partially applied arguments.
                         *
                         * **Note:** This method doesn't set the "length" property of partially
                         * applied functions.
                         *
                         * @static
                         * @memberOf _
                         * @since 1.0.0
                         * @category Function
                         * @param {Function} func The function to partially apply arguments to.
                         * @param {...*} [partials] The arguments to be partially applied.
                         * @returns {Function} Returns the new partially applied function.
                         * @example
                         *
                         * function greet(greeting, name) {
                         *   return greeting + ' ' + name;
                         * }
                         *
                         * var greetFred = _.partialRight(greet, 'fred');
                         * greetFred('hi');
                         * // => 'hi fred'
                         *
                         * // Partially applied with placeholders.
                         * var sayHelloTo = _.partialRight(greet, 'hello', _);
                         * sayHelloTo('fred');
                         * // => 'hello fred'
                         */
                        var partialRight = baseRest(function (func, partials) {
                            var holders = replaceHolders(partials, getHolder(partialRight));
                            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
                        });
                        /**
                         * Creates a function that invokes `func` with arguments arranged according
                         * to the specified `indexes` where the argument value at the first index is
                         * provided as the first argument, the argument value at the second index is
                         * provided as the second argument, and so on.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Function
                         * @param {Function} func The function to rearrange arguments for.
                         * @param {...(number|number[])} indexes The arranged argument indexes.
                         * @returns {Function} Returns the new function.
                         * @example
                         *
                         * var rearged = _.rearg(function(a, b, c) {
                         *   return [a, b, c];
                         * }, [2, 0, 1]);
                         *
                         * rearged('b', 'c', 'a')
                         * // => ['a', 'b', 'c']
                         */
                        var rearg = flatRest(function (func, indexes) {
                            return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
                        });
                        /**
                         * Creates a function that invokes `func` with the `this` binding of the
                         * created function and arguments from `start` and beyond provided as
                         * an array.
                         *
                         * **Note:** This method is based on the
                         * [rest parameter](https://mdn.io/rest_parameters).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Function
                         * @param {Function} func The function to apply a rest parameter to.
                         * @param {number} [start=func.length-1] The start position of the rest parameter.
                         * @returns {Function} Returns the new function.
                         * @example
                         *
                         * var say = _.rest(function(what, names) {
                         *   return what + ' ' + _.initial(names).join(', ') +
                         *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
                         * });
                         *
                         * say('hello', 'fred', 'barney', 'pebbles');
                         * // => 'hello fred, barney, & pebbles'
                         */
                        function rest(func, start) {
                            if (typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            start = start === undefined ? start : toInteger(start);
                            return baseRest(func, start);
                        }
                        /**
                         * Creates a function that invokes `func` with the `this` binding of the
                         * create function and an array of arguments much like
                         * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
                         *
                         * **Note:** This method is based on the
                         * [spread operator](https://mdn.io/spread_operator).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.2.0
                         * @category Function
                         * @param {Function} func The function to spread arguments over.
                         * @param {number} [start=0] The start position of the spread.
                         * @returns {Function} Returns the new function.
                         * @example
                         *
                         * var say = _.spread(function(who, what) {
                         *   return who + ' says ' + what;
                         * });
                         *
                         * say(['fred', 'hello']);
                         * // => 'fred says hello'
                         *
                         * var numbers = Promise.all([
                         *   Promise.resolve(40),
                         *   Promise.resolve(36)
                         * ]);
                         *
                         * numbers.then(_.spread(function(x, y) {
                         *   return x + y;
                         * }));
                         * // => a Promise of 76
                         */
                        function spread(func, start) {
                            if (typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            start = start == null ? 0 : nativeMax(toInteger(start), 0);
                            return baseRest(function (args) {
                                var array = args[start], otherArgs = castSlice(args, 0, start);
                                if (array) {
                                    arrayPush(otherArgs, array);
                                }
                                return apply(func, this, otherArgs);
                            });
                        }
                        /**
                         * Creates a throttled function that only invokes `func` at most once per
                         * every `wait` milliseconds. The throttled function comes with a `cancel`
                         * method to cancel delayed `func` invocations and a `flush` method to
                         * immediately invoke them. Provide `options` to indicate whether `func`
                         * should be invoked on the leading and/or trailing edge of the `wait`
                         * timeout. The `func` is invoked with the last arguments provided to the
                         * throttled function. Subsequent calls to the throttled function return the
                         * result of the last `func` invocation.
                         *
                         * **Note:** If `leading` and `trailing` options are `true`, `func` is
                         * invoked on the trailing edge of the timeout only if the throttled function
                         * is invoked more than once during the `wait` timeout.
                         *
                         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
                         * until to the next tick, similar to `setTimeout` with a timeout of `0`.
                         *
                         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
                         * for details over the differences between `_.throttle` and `_.debounce`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Function
                         * @param {Function} func The function to throttle.
                         * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
                         * @param {Object} [options={}] The options object.
                         * @param {boolean} [options.leading=true]
                         *  Specify invoking on the leading edge of the timeout.
                         * @param {boolean} [options.trailing=true]
                         *  Specify invoking on the trailing edge of the timeout.
                         * @returns {Function} Returns the new throttled function.
                         * @example
                         *
                         * // Avoid excessively updating the position while scrolling.
                         * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
                         *
                         * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
                         * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
                         * jQuery(element).on('click', throttled);
                         *
                         * // Cancel the trailing throttled invocation.
                         * jQuery(window).on('popstate', throttled.cancel);
                         */
                        function throttle(func, wait, options) {
                            var leading = true, trailing = true;
                            if (typeof func != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            if (isObject(options)) {
                                leading = 'leading' in options ? !!options.leading : leading;
                                trailing = 'trailing' in options ? !!options.trailing : trailing;
                            }
                            return debounce(func, wait, {
                                'leading': leading,
                                'maxWait': wait,
                                'trailing': trailing
                            });
                        }
                        /**
                         * Creates a function that accepts up to one argument, ignoring any
                         * additional arguments.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Function
                         * @param {Function} func The function to cap arguments for.
                         * @returns {Function} Returns the new capped function.
                         * @example
                         *
                         * _.map(['6', '8', '10'], _.unary(parseInt));
                         * // => [6, 8, 10]
                         */
                        function unary(func) {
                            return ary(func, 1);
                        }
                        /**
                         * Creates a function that provides `value` to `wrapper` as its first
                         * argument. Any additional arguments provided to the function are appended
                         * to those provided to the `wrapper`. The wrapper is invoked with the `this`
                         * binding of the created function.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Function
                         * @param {*} value The value to wrap.
                         * @param {Function} [wrapper=identity] The wrapper function.
                         * @returns {Function} Returns the new function.
                         * @example
                         *
                         * var p = _.wrap(_.escape, function(func, text) {
                         *   return '<p>' + func(text) + '</p>';
                         * });
                         *
                         * p('fred, barney, & pebbles');
                         * // => '<p>fred, barney, &amp; pebbles</p>'
                         */
                        function wrap(value, wrapper) {
                            return partial(castFunction(wrapper), value);
                        }
                        /*------------------------------------------------------------------------*/
                        /**
                         * Casts `value` as an array if it's not one.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.4.0
                         * @category Lang
                         * @param {*} value The value to inspect.
                         * @returns {Array} Returns the cast array.
                         * @example
                         *
                         * _.castArray(1);
                         * // => [1]
                         *
                         * _.castArray({ 'a': 1 });
                         * // => [{ 'a': 1 }]
                         *
                         * _.castArray('abc');
                         * // => ['abc']
                         *
                         * _.castArray(null);
                         * // => [null]
                         *
                         * _.castArray(undefined);
                         * // => [undefined]
                         *
                         * _.castArray();
                         * // => []
                         *
                         * var array = [1, 2, 3];
                         * console.log(_.castArray(array) === array);
                         * // => true
                         */
                        function castArray() {
                            if (!arguments.length) {
                                return [];
                            }
                            var value = arguments[0];
                            return isArray(value) ? value : [value];
                        }
                        /**
                         * Creates a shallow clone of `value`.
                         *
                         * **Note:** This method is loosely based on the
                         * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
                         * and supports cloning arrays, array buffers, booleans, date objects, maps,
                         * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
                         * arrays. The own enumerable properties of `arguments` objects are cloned
                         * as plain objects. An empty object is returned for uncloneable values such
                         * as error objects, functions, DOM nodes, and WeakMaps.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to clone.
                         * @returns {*} Returns the cloned value.
                         * @see _.cloneDeep
                         * @example
                         *
                         * var objects = [{ 'a': 1 }, { 'b': 2 }];
                         *
                         * var shallow = _.clone(objects);
                         * console.log(shallow[0] === objects[0]);
                         * // => true
                         */
                        function clone(value) {
                            return baseClone(value, CLONE_SYMBOLS_FLAG);
                        }
                        /**
                         * This method is like `_.clone` except that it accepts `customizer` which
                         * is invoked to produce the cloned value. If `customizer` returns `undefined`,
                         * cloning is handled by the method instead. The `customizer` is invoked with
                         * up to four arguments; (value [, index|key, object, stack]).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to clone.
                         * @param {Function} [customizer] The function to customize cloning.
                         * @returns {*} Returns the cloned value.
                         * @see _.cloneDeepWith
                         * @example
                         *
                         * function customizer(value) {
                         *   if (_.isElement(value)) {
                         *     return value.cloneNode(false);
                         *   }
                         * }
                         *
                         * var el = _.cloneWith(document.body, customizer);
                         *
                         * console.log(el === document.body);
                         * // => false
                         * console.log(el.nodeName);
                         * // => 'BODY'
                         * console.log(el.childNodes.length);
                         * // => 0
                         */
                        function cloneWith(value, customizer) {
                            customizer = typeof customizer == 'function' ? customizer : undefined;
                            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
                        }
                        /**
                         * This method is like `_.clone` except that it recursively clones `value`.
                         *
                         * @static
                         * @memberOf _
                         * @since 1.0.0
                         * @category Lang
                         * @param {*} value The value to recursively clone.
                         * @returns {*} Returns the deep cloned value.
                         * @see _.clone
                         * @example
                         *
                         * var objects = [{ 'a': 1 }, { 'b': 2 }];
                         *
                         * var deep = _.cloneDeep(objects);
                         * console.log(deep[0] === objects[0]);
                         * // => false
                         */
                        function cloneDeep(value) {
                            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
                        }
                        /**
                         * This method is like `_.cloneWith` except that it recursively clones `value`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to recursively clone.
                         * @param {Function} [customizer] The function to customize cloning.
                         * @returns {*} Returns the deep cloned value.
                         * @see _.cloneWith
                         * @example
                         *
                         * function customizer(value) {
                         *   if (_.isElement(value)) {
                         *     return value.cloneNode(true);
                         *   }
                         * }
                         *
                         * var el = _.cloneDeepWith(document.body, customizer);
                         *
                         * console.log(el === document.body);
                         * // => false
                         * console.log(el.nodeName);
                         * // => 'BODY'
                         * console.log(el.childNodes.length);
                         * // => 20
                         */
                        function cloneDeepWith(value, customizer) {
                            customizer = typeof customizer == 'function' ? customizer : undefined;
                            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
                        }
                        /**
                         * Checks if `object` conforms to `source` by invoking the predicate
                         * properties of `source` with the corresponding property values of `object`.
                         *
                         * **Note:** This method is equivalent to `_.conforms` when `source` is
                         * partially applied.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.14.0
                         * @category Lang
                         * @param {Object} object The object to inspect.
                         * @param {Object} source The object of property predicates to conform to.
                         * @returns {boolean} Returns `true` if `object` conforms, else `false`.
                         * @example
                         *
                         * var object = { 'a': 1, 'b': 2 };
                         *
                         * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
                         * // => true
                         *
                         * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
                         * // => false
                         */
                        function conformsTo(object, source) {
                            return source == null || baseConformsTo(object, source, keys(source));
                        }
                        /**
                         * Performs a
                         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * comparison between two values to determine if they are equivalent.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                         * @example
                         *
                         * var object = { 'a': 1 };
                         * var other = { 'a': 1 };
                         *
                         * _.eq(object, object);
                         * // => true
                         *
                         * _.eq(object, other);
                         * // => false
                         *
                         * _.eq('a', 'a');
                         * // => true
                         *
                         * _.eq('a', Object('a'));
                         * // => false
                         *
                         * _.eq(NaN, NaN);
                         * // => true
                         */
                        function eq(value, other) {
                            return value === other || (value !== value && other !== other);
                        }
                        /**
                         * Checks if `value` is greater than `other`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.9.0
                         * @category Lang
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @returns {boolean} Returns `true` if `value` is greater than `other`,
                         *  else `false`.
                         * @see _.lt
                         * @example
                         *
                         * _.gt(3, 1);
                         * // => true
                         *
                         * _.gt(3, 3);
                         * // => false
                         *
                         * _.gt(1, 3);
                         * // => false
                         */
                        var gt = createRelationalOperation(baseGt);
                        /**
                         * Checks if `value` is greater than or equal to `other`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.9.0
                         * @category Lang
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @returns {boolean} Returns `true` if `value` is greater than or equal to
                         *  `other`, else `false`.
                         * @see _.lte
                         * @example
                         *
                         * _.gte(3, 1);
                         * // => true
                         *
                         * _.gte(3, 3);
                         * // => true
                         *
                         * _.gte(1, 3);
                         * // => false
                         */
                        var gte = createRelationalOperation(function (value, other) {
                            return value >= other;
                        });
                        /**
                         * Checks if `value` is likely an `arguments` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
                         *  else `false`.
                         * @example
                         *
                         * _.isArguments(function() { return arguments; }());
                         * // => true
                         *
                         * _.isArguments([1, 2, 3]);
                         * // => false
                         */
                        var isArguments = baseIsArguments(function () { return arguments; }()) ? baseIsArguments : function (value) {
                            return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
                                !propertyIsEnumerable.call(value, 'callee');
                        };
                        /**
                         * Checks if `value` is classified as an `Array` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an array, else `false`.
                         * @example
                         *
                         * _.isArray([1, 2, 3]);
                         * // => true
                         *
                         * _.isArray(document.body.children);
                         * // => false
                         *
                         * _.isArray('abc');
                         * // => false
                         *
                         * _.isArray(_.noop);
                         * // => false
                         */
                        var isArray = Array.isArray;
                        /**
                         * Checks if `value` is classified as an `ArrayBuffer` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.3.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
                         * @example
                         *
                         * _.isArrayBuffer(new ArrayBuffer(2));
                         * // => true
                         *
                         * _.isArrayBuffer(new Array(2));
                         * // => false
                         */
                        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
                        /**
                         * Checks if `value` is array-like. A value is considered array-like if it's
                         * not a function and has a `value.length` that's an integer greater than or
                         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
                         * @example
                         *
                         * _.isArrayLike([1, 2, 3]);
                         * // => true
                         *
                         * _.isArrayLike(document.body.children);
                         * // => true
                         *
                         * _.isArrayLike('abc');
                         * // => true
                         *
                         * _.isArrayLike(_.noop);
                         * // => false
                         */
                        function isArrayLike(value) {
                            return value != null && isLength(value.length) && !isFunction(value);
                        }
                        /**
                         * This method is like `_.isArrayLike` except that it also checks if `value`
                         * is an object.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an array-like object,
                         *  else `false`.
                         * @example
                         *
                         * _.isArrayLikeObject([1, 2, 3]);
                         * // => true
                         *
                         * _.isArrayLikeObject(document.body.children);
                         * // => true
                         *
                         * _.isArrayLikeObject('abc');
                         * // => false
                         *
                         * _.isArrayLikeObject(_.noop);
                         * // => false
                         */
                        function isArrayLikeObject(value) {
                            return isObjectLike(value) && isArrayLike(value);
                        }
                        /**
                         * Checks if `value` is classified as a boolean primitive or object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
                         * @example
                         *
                         * _.isBoolean(false);
                         * // => true
                         *
                         * _.isBoolean(null);
                         * // => false
                         */
                        function isBoolean(value) {
                            return value === true || value === false ||
                                (isObjectLike(value) && baseGetTag(value) == boolTag);
                        }
                        /**
                         * Checks if `value` is a buffer.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.3.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
                         * @example
                         *
                         * _.isBuffer(new Buffer(2));
                         * // => true
                         *
                         * _.isBuffer(new Uint8Array(2));
                         * // => false
                         */
                        var isBuffer = nativeIsBuffer || stubFalse;
                        /**
                         * Checks if `value` is classified as a `Date` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
                         * @example
                         *
                         * _.isDate(new Date);
                         * // => true
                         *
                         * _.isDate('Mon April 23 2012');
                         * // => false
                         */
                        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
                        /**
                         * Checks if `value` is likely a DOM element.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
                         * @example
                         *
                         * _.isElement(document.body);
                         * // => true
                         *
                         * _.isElement('<body>');
                         * // => false
                         */
                        function isElement(value) {
                            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
                        }
                        /**
                         * Checks if `value` is an empty object, collection, map, or set.
                         *
                         * Objects are considered empty if they have no own enumerable string keyed
                         * properties.
                         *
                         * Array-like values such as `arguments` objects, arrays, buffers, strings, or
                         * jQuery-like collections are considered empty if they have a `length` of `0`.
                         * Similarly, maps and sets are considered empty if they have a `size` of `0`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is empty, else `false`.
                         * @example
                         *
                         * _.isEmpty(null);
                         * // => true
                         *
                         * _.isEmpty(true);
                         * // => true
                         *
                         * _.isEmpty(1);
                         * // => true
                         *
                         * _.isEmpty([1, 2, 3]);
                         * // => false
                         *
                         * _.isEmpty({ 'a': 1 });
                         * // => false
                         */
                        function isEmpty(value) {
                            if (value == null) {
                                return true;
                            }
                            if (isArrayLike(value) &&
                                (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
                                    isBuffer(value) || isTypedArray(value) || isArguments(value))) {
                                return !value.length;
                            }
                            var tag = getTag(value);
                            if (tag == mapTag || tag == setTag) {
                                return !value.size;
                            }
                            if (isPrototype(value)) {
                                return !baseKeys(value).length;
                            }
                            for (var key in value) {
                                if (hasOwnProperty.call(value, key)) {
                                    return false;
                                }
                            }
                            return true;
                        }
                        /**
                         * Performs a deep comparison between two values to determine if they are
                         * equivalent.
                         *
                         * **Note:** This method supports comparing arrays, array buffers, booleans,
                         * date objects, error objects, maps, numbers, `Object` objects, regexes,
                         * sets, strings, symbols, and typed arrays. `Object` objects are compared
                         * by their own, not inherited, enumerable properties. Functions and DOM
                         * nodes are compared by strict equality, i.e. `===`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                         * @example
                         *
                         * var object = { 'a': 1 };
                         * var other = { 'a': 1 };
                         *
                         * _.isEqual(object, other);
                         * // => true
                         *
                         * object === other;
                         * // => false
                         */
                        function isEqual(value, other) {
                            return baseIsEqual(value, other);
                        }
                        /**
                         * This method is like `_.isEqual` except that it accepts `customizer` which
                         * is invoked to compare values. If `customizer` returns `undefined`, comparisons
                         * are handled by the method instead. The `customizer` is invoked with up to
                         * six arguments: (objValue, othValue [, index|key, object, other, stack]).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @param {Function} [customizer] The function to customize comparisons.
                         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                         * @example
                         *
                         * function isGreeting(value) {
                         *   return /^h(?:i|ello)$/.test(value);
                         * }
                         *
                         * function customizer(objValue, othValue) {
                         *   if (isGreeting(objValue) && isGreeting(othValue)) {
                         *     return true;
                         *   }
                         * }
                         *
                         * var array = ['hello', 'goodbye'];
                         * var other = ['hi', 'goodbye'];
                         *
                         * _.isEqualWith(array, other, customizer);
                         * // => true
                         */
                        function isEqualWith(value, other, customizer) {
                            customizer = typeof customizer == 'function' ? customizer : undefined;
                            var result = customizer ? customizer(value, other) : undefined;
                            return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
                        }
                        /**
                         * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
                         * `SyntaxError`, `TypeError`, or `URIError` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
                         * @example
                         *
                         * _.isError(new Error);
                         * // => true
                         *
                         * _.isError(Error);
                         * // => false
                         */
                        function isError(value) {
                            if (!isObjectLike(value)) {
                                return false;
                            }
                            var tag = baseGetTag(value);
                            return tag == errorTag || tag == domExcTag ||
                                (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
                        }
                        /**
                         * Checks if `value` is a finite primitive number.
                         *
                         * **Note:** This method is based on
                         * [`Number.isFinite`](https://mdn.io/Number/isFinite).
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
                         * @example
                         *
                         * _.isFinite(3);
                         * // => true
                         *
                         * _.isFinite(Number.MIN_VALUE);
                         * // => true
                         *
                         * _.isFinite(Infinity);
                         * // => false
                         *
                         * _.isFinite('3');
                         * // => false
                         */
                        function isFinite(value) {
                            return typeof value == 'number' && nativeIsFinite(value);
                        }
                        /**
                         * Checks if `value` is classified as a `Function` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a function, else `false`.
                         * @example
                         *
                         * _.isFunction(_);
                         * // => true
                         *
                         * _.isFunction(/abc/);
                         * // => false
                         */
                        function isFunction(value) {
                            if (!isObject(value)) {
                                return false;
                            }
                            // The use of `Object#toString` avoids issues with the `typeof` operator
                            // in Safari 9 which returns 'object' for typed arrays and other constructors.
                            var tag = baseGetTag(value);
                            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
                        }
                        /**
                         * Checks if `value` is an integer.
                         *
                         * **Note:** This method is based on
                         * [`Number.isInteger`](https://mdn.io/Number/isInteger).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
                         * @example
                         *
                         * _.isInteger(3);
                         * // => true
                         *
                         * _.isInteger(Number.MIN_VALUE);
                         * // => false
                         *
                         * _.isInteger(Infinity);
                         * // => false
                         *
                         * _.isInteger('3');
                         * // => false
                         */
                        function isInteger(value) {
                            return typeof value == 'number' && value == toInteger(value);
                        }
                        /**
                         * Checks if `value` is a valid array-like length.
                         *
                         * **Note:** This method is loosely based on
                         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
                         * @example
                         *
                         * _.isLength(3);
                         * // => true
                         *
                         * _.isLength(Number.MIN_VALUE);
                         * // => false
                         *
                         * _.isLength(Infinity);
                         * // => false
                         *
                         * _.isLength('3');
                         * // => false
                         */
                        function isLength(value) {
                            return typeof value == 'number' &&
                                value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
                        }
                        /**
                         * Checks if `value` is the
                         * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
                         * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
                         * @example
                         *
                         * _.isObject({});
                         * // => true
                         *
                         * _.isObject([1, 2, 3]);
                         * // => true
                         *
                         * _.isObject(_.noop);
                         * // => true
                         *
                         * _.isObject(null);
                         * // => false
                         */
                        function isObject(value) {
                            var type = typeof value;
                            return value != null && (type == 'object' || type == 'function');
                        }
                        /**
                         * Checks if `value` is object-like. A value is object-like if it's not `null`
                         * and has a `typeof` result of "object".
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
                         * @example
                         *
                         * _.isObjectLike({});
                         * // => true
                         *
                         * _.isObjectLike([1, 2, 3]);
                         * // => true
                         *
                         * _.isObjectLike(_.noop);
                         * // => false
                         *
                         * _.isObjectLike(null);
                         * // => false
                         */
                        function isObjectLike(value) {
                            return value != null && typeof value == 'object';
                        }
                        /**
                         * Checks if `value` is classified as a `Map` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.3.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a map, else `false`.
                         * @example
                         *
                         * _.isMap(new Map);
                         * // => true
                         *
                         * _.isMap(new WeakMap);
                         * // => false
                         */
                        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
                        /**
                         * Performs a partial deep comparison between `object` and `source` to
                         * determine if `object` contains equivalent property values.
                         *
                         * **Note:** This method is equivalent to `_.matches` when `source` is
                         * partially applied.
                         *
                         * Partial comparisons will match empty array and empty object `source`
                         * values against any array or object value, respectively. See `_.isEqual`
                         * for a list of supported value comparisons.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Lang
                         * @param {Object} object The object to inspect.
                         * @param {Object} source The object of property values to match.
                         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
                         * @example
                         *
                         * var object = { 'a': 1, 'b': 2 };
                         *
                         * _.isMatch(object, { 'b': 2 });
                         * // => true
                         *
                         * _.isMatch(object, { 'b': 1 });
                         * // => false
                         */
                        function isMatch(object, source) {
                            return object === source || baseIsMatch(object, source, getMatchData(source));
                        }
                        /**
                         * This method is like `_.isMatch` except that it accepts `customizer` which
                         * is invoked to compare values. If `customizer` returns `undefined`, comparisons
                         * are handled by the method instead. The `customizer` is invoked with five
                         * arguments: (objValue, srcValue, index|key, object, source).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {Object} object The object to inspect.
                         * @param {Object} source The object of property values to match.
                         * @param {Function} [customizer] The function to customize comparisons.
                         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
                         * @example
                         *
                         * function isGreeting(value) {
                         *   return /^h(?:i|ello)$/.test(value);
                         * }
                         *
                         * function customizer(objValue, srcValue) {
                         *   if (isGreeting(objValue) && isGreeting(srcValue)) {
                         *     return true;
                         *   }
                         * }
                         *
                         * var object = { 'greeting': 'hello' };
                         * var source = { 'greeting': 'hi' };
                         *
                         * _.isMatchWith(object, source, customizer);
                         * // => true
                         */
                        function isMatchWith(object, source, customizer) {
                            customizer = typeof customizer == 'function' ? customizer : undefined;
                            return baseIsMatch(object, source, getMatchData(source), customizer);
                        }
                        /**
                         * Checks if `value` is `NaN`.
                         *
                         * **Note:** This method is based on
                         * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
                         * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
                         * `undefined` and other non-number values.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
                         * @example
                         *
                         * _.isNaN(NaN);
                         * // => true
                         *
                         * _.isNaN(new Number(NaN));
                         * // => true
                         *
                         * isNaN(undefined);
                         * // => true
                         *
                         * _.isNaN(undefined);
                         * // => false
                         */
                        function isNaN(value) {
                            // An `NaN` primitive is the only value that is not equal to itself.
                            // Perform the `toStringTag` check first to avoid errors with some
                            // ActiveX objects in IE.
                            return isNumber(value) && value != +value;
                        }
                        /**
                         * Checks if `value` is a pristine native function.
                         *
                         * **Note:** This method can't reliably detect native functions in the presence
                         * of the core-js package because core-js circumvents this kind of detection.
                         * Despite multiple requests, the core-js maintainer has made it clear: any
                         * attempt to fix the detection will be obstructed. As a result, we're left
                         * with little choice but to throw an error. Unfortunately, this also affects
                         * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
                         * which rely on core-js.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a native function,
                         *  else `false`.
                         * @example
                         *
                         * _.isNative(Array.prototype.push);
                         * // => true
                         *
                         * _.isNative(_);
                         * // => false
                         */
                        function isNative(value) {
                            if (isMaskable(value)) {
                                throw new Error(CORE_ERROR_TEXT);
                            }
                            return baseIsNative(value);
                        }
                        /**
                         * Checks if `value` is `null`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
                         * @example
                         *
                         * _.isNull(null);
                         * // => true
                         *
                         * _.isNull(void 0);
                         * // => false
                         */
                        function isNull(value) {
                            return value === null;
                        }
                        /**
                         * Checks if `value` is `null` or `undefined`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
                         * @example
                         *
                         * _.isNil(null);
                         * // => true
                         *
                         * _.isNil(void 0);
                         * // => true
                         *
                         * _.isNil(NaN);
                         * // => false
                         */
                        function isNil(value) {
                            return value == null;
                        }
                        /**
                         * Checks if `value` is classified as a `Number` primitive or object.
                         *
                         * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
                         * classified as numbers, use the `_.isFinite` method.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a number, else `false`.
                         * @example
                         *
                         * _.isNumber(3);
                         * // => true
                         *
                         * _.isNumber(Number.MIN_VALUE);
                         * // => true
                         *
                         * _.isNumber(Infinity);
                         * // => true
                         *
                         * _.isNumber('3');
                         * // => false
                         */
                        function isNumber(value) {
                            return typeof value == 'number' ||
                                (isObjectLike(value) && baseGetTag(value) == numberTag);
                        }
                        /**
                         * Checks if `value` is a plain object, that is, an object created by the
                         * `Object` constructor or one with a `[[Prototype]]` of `null`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.8.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         * }
                         *
                         * _.isPlainObject(new Foo);
                         * // => false
                         *
                         * _.isPlainObject([1, 2, 3]);
                         * // => false
                         *
                         * _.isPlainObject({ 'x': 0, 'y': 0 });
                         * // => true
                         *
                         * _.isPlainObject(Object.create(null));
                         * // => true
                         */
                        function isPlainObject(value) {
                            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
                                return false;
                            }
                            var proto = getPrototype(value);
                            if (proto === null) {
                                return true;
                            }
                            var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
                            return typeof Ctor == 'function' && Ctor instanceof Ctor &&
                                funcToString.call(Ctor) == objectCtorString;
                        }
                        /**
                         * Checks if `value` is classified as a `RegExp` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
                         * @example
                         *
                         * _.isRegExp(/abc/);
                         * // => true
                         *
                         * _.isRegExp('/abc/');
                         * // => false
                         */
                        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
                        /**
                         * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
                         * double precision number which isn't the result of a rounded unsafe integer.
                         *
                         * **Note:** This method is based on
                         * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
                         * @example
                         *
                         * _.isSafeInteger(3);
                         * // => true
                         *
                         * _.isSafeInteger(Number.MIN_VALUE);
                         * // => false
                         *
                         * _.isSafeInteger(Infinity);
                         * // => false
                         *
                         * _.isSafeInteger('3');
                         * // => false
                         */
                        function isSafeInteger(value) {
                            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
                        }
                        /**
                         * Checks if `value` is classified as a `Set` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.3.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a set, else `false`.
                         * @example
                         *
                         * _.isSet(new Set);
                         * // => true
                         *
                         * _.isSet(new WeakSet);
                         * // => false
                         */
                        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
                        /**
                         * Checks if `value` is classified as a `String` primitive or object.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a string, else `false`.
                         * @example
                         *
                         * _.isString('abc');
                         * // => true
                         *
                         * _.isString(1);
                         * // => false
                         */
                        function isString(value) {
                            return typeof value == 'string' ||
                                (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
                        }
                        /**
                         * Checks if `value` is classified as a `Symbol` primitive or object.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
                         * @example
                         *
                         * _.isSymbol(Symbol.iterator);
                         * // => true
                         *
                         * _.isSymbol('abc');
                         * // => false
                         */
                        function isSymbol(value) {
                            return typeof value == 'symbol' ||
                                (isObjectLike(value) && baseGetTag(value) == symbolTag);
                        }
                        /**
                         * Checks if `value` is classified as a typed array.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
                         * @example
                         *
                         * _.isTypedArray(new Uint8Array);
                         * // => true
                         *
                         * _.isTypedArray([]);
                         * // => false
                         */
                        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
                        /**
                         * Checks if `value` is `undefined`.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
                         * @example
                         *
                         * _.isUndefined(void 0);
                         * // => true
                         *
                         * _.isUndefined(null);
                         * // => false
                         */
                        function isUndefined(value) {
                            return value === undefined;
                        }
                        /**
                         * Checks if `value` is classified as a `WeakMap` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.3.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
                         * @example
                         *
                         * _.isWeakMap(new WeakMap);
                         * // => true
                         *
                         * _.isWeakMap(new Map);
                         * // => false
                         */
                        function isWeakMap(value) {
                            return isObjectLike(value) && getTag(value) == weakMapTag;
                        }
                        /**
                         * Checks if `value` is classified as a `WeakSet` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.3.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
                         * @example
                         *
                         * _.isWeakSet(new WeakSet);
                         * // => true
                         *
                         * _.isWeakSet(new Set);
                         * // => false
                         */
                        function isWeakSet(value) {
                            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
                        }
                        /**
                         * Checks if `value` is less than `other`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.9.0
                         * @category Lang
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @returns {boolean} Returns `true` if `value` is less than `other`,
                         *  else `false`.
                         * @see _.gt
                         * @example
                         *
                         * _.lt(1, 3);
                         * // => true
                         *
                         * _.lt(3, 3);
                         * // => false
                         *
                         * _.lt(3, 1);
                         * // => false
                         */
                        var lt = createRelationalOperation(baseLt);
                        /**
                         * Checks if `value` is less than or equal to `other`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.9.0
                         * @category Lang
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @returns {boolean} Returns `true` if `value` is less than or equal to
                         *  `other`, else `false`.
                         * @see _.gte
                         * @example
                         *
                         * _.lte(1, 3);
                         * // => true
                         *
                         * _.lte(3, 3);
                         * // => true
                         *
                         * _.lte(3, 1);
                         * // => false
                         */
                        var lte = createRelationalOperation(function (value, other) {
                            return value <= other;
                        });
                        /**
                         * Converts `value` to an array.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Lang
                         * @param {*} value The value to convert.
                         * @returns {Array} Returns the converted array.
                         * @example
                         *
                         * _.toArray({ 'a': 1, 'b': 2 });
                         * // => [1, 2]
                         *
                         * _.toArray('abc');
                         * // => ['a', 'b', 'c']
                         *
                         * _.toArray(1);
                         * // => []
                         *
                         * _.toArray(null);
                         * // => []
                         */
                        function toArray(value) {
                            if (!value) {
                                return [];
                            }
                            if (isArrayLike(value)) {
                                return isString(value) ? stringToArray(value) : copyArray(value);
                            }
                            if (symIterator && value[symIterator]) {
                                return iteratorToArray(value[symIterator]());
                            }
                            var tag = getTag(value), func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);
                            return func(value);
                        }
                        /**
                         * Converts `value` to a finite number.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.12.0
                         * @category Lang
                         * @param {*} value The value to convert.
                         * @returns {number} Returns the converted number.
                         * @example
                         *
                         * _.toFinite(3.2);
                         * // => 3.2
                         *
                         * _.toFinite(Number.MIN_VALUE);
                         * // => 5e-324
                         *
                         * _.toFinite(Infinity);
                         * // => 1.7976931348623157e+308
                         *
                         * _.toFinite('3.2');
                         * // => 3.2
                         */
                        function toFinite(value) {
                            if (!value) {
                                return value === 0 ? value : 0;
                            }
                            value = toNumber(value);
                            if (value === INFINITY || value === -INFINITY) {
                                var sign = (value < 0 ? -1 : 1);
                                return sign * MAX_INTEGER;
                            }
                            return value === value ? value : 0;
                        }
                        /**
                         * Converts `value` to an integer.
                         *
                         * **Note:** This method is loosely based on
                         * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to convert.
                         * @returns {number} Returns the converted integer.
                         * @example
                         *
                         * _.toInteger(3.2);
                         * // => 3
                         *
                         * _.toInteger(Number.MIN_VALUE);
                         * // => 0
                         *
                         * _.toInteger(Infinity);
                         * // => 1.7976931348623157e+308
                         *
                         * _.toInteger('3.2');
                         * // => 3
                         */
                        function toInteger(value) {
                            var result = toFinite(value), remainder = result % 1;
                            return result === result ? (remainder ? result - remainder : result) : 0;
                        }
                        /**
                         * Converts `value` to an integer suitable for use as the length of an
                         * array-like object.
                         *
                         * **Note:** This method is based on
                         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to convert.
                         * @returns {number} Returns the converted integer.
                         * @example
                         *
                         * _.toLength(3.2);
                         * // => 3
                         *
                         * _.toLength(Number.MIN_VALUE);
                         * // => 0
                         *
                         * _.toLength(Infinity);
                         * // => 4294967295
                         *
                         * _.toLength('3.2');
                         * // => 3
                         */
                        function toLength(value) {
                            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
                        }
                        /**
                         * Converts `value` to a number.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to process.
                         * @returns {number} Returns the number.
                         * @example
                         *
                         * _.toNumber(3.2);
                         * // => 3.2
                         *
                         * _.toNumber(Number.MIN_VALUE);
                         * // => 5e-324
                         *
                         * _.toNumber(Infinity);
                         * // => Infinity
                         *
                         * _.toNumber('3.2');
                         * // => 3.2
                         */
                        function toNumber(value) {
                            if (typeof value == 'number') {
                                return value;
                            }
                            if (isSymbol(value)) {
                                return NAN;
                            }
                            if (isObject(value)) {
                                var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
                                value = isObject(other) ? (other + '') : other;
                            }
                            if (typeof value != 'string') {
                                return value === 0 ? value : +value;
                            }
                            value = baseTrim(value);
                            var isBinary = reIsBinary.test(value);
                            return (isBinary || reIsOctal.test(value))
                                ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
                                : (reIsBadHex.test(value) ? NAN : +value);
                        }
                        /**
                         * Converts `value` to a plain object flattening inherited enumerable string
                         * keyed properties of `value` to own properties of the plain object.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Lang
                         * @param {*} value The value to convert.
                         * @returns {Object} Returns the converted plain object.
                         * @example
                         *
                         * function Foo() {
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.assign({ 'a': 1 }, new Foo);
                         * // => { 'a': 1, 'b': 2 }
                         *
                         * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
                         * // => { 'a': 1, 'b': 2, 'c': 3 }
                         */
                        function toPlainObject(value) {
                            return copyObject(value, keysIn(value));
                        }
                        /**
                         * Converts `value` to a safe integer. A safe integer can be compared and
                         * represented correctly.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to convert.
                         * @returns {number} Returns the converted integer.
                         * @example
                         *
                         * _.toSafeInteger(3.2);
                         * // => 3
                         *
                         * _.toSafeInteger(Number.MIN_VALUE);
                         * // => 0
                         *
                         * _.toSafeInteger(Infinity);
                         * // => 9007199254740991
                         *
                         * _.toSafeInteger('3.2');
                         * // => 3
                         */
                        function toSafeInteger(value) {
                            return value
                                ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
                                : (value === 0 ? value : 0);
                        }
                        /**
                         * Converts `value` to a string. An empty string is returned for `null`
                         * and `undefined` values. The sign of `-0` is preserved.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to convert.
                         * @returns {string} Returns the converted string.
                         * @example
                         *
                         * _.toString(null);
                         * // => ''
                         *
                         * _.toString(-0);
                         * // => '-0'
                         *
                         * _.toString([1, 2, 3]);
                         * // => '1,2,3'
                         */
                        function toString(value) {
                            return value == null ? '' : baseToString(value);
                        }
                        /*------------------------------------------------------------------------*/
                        /**
                         * Assigns own enumerable string keyed properties of source objects to the
                         * destination object. Source objects are applied from left to right.
                         * Subsequent sources overwrite property assignments of previous sources.
                         *
                         * **Note:** This method mutates `object` and is loosely based on
                         * [`Object.assign`](https://mdn.io/Object/assign).
                         *
                         * @static
                         * @memberOf _
                         * @since 0.10.0
                         * @category Object
                         * @param {Object} object The destination object.
                         * @param {...Object} [sources] The source objects.
                         * @returns {Object} Returns `object`.
                         * @see _.assignIn
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         * }
                         *
                         * function Bar() {
                         *   this.c = 3;
                         * }
                         *
                         * Foo.prototype.b = 2;
                         * Bar.prototype.d = 4;
                         *
                         * _.assign({ 'a': 0 }, new Foo, new Bar);
                         * // => { 'a': 1, 'c': 3 }
                         */
                        var assign = createAssigner(function (object, source) {
                            if (isPrototype(source) || isArrayLike(source)) {
                                copyObject(source, keys(source), object);
                                return;
                            }
                            for (var key in source) {
                                if (hasOwnProperty.call(source, key)) {
                                    assignValue(object, key, source[key]);
                                }
                            }
                        });
                        /**
                         * This method is like `_.assign` except that it iterates over own and
                         * inherited source properties.
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @alias extend
                         * @category Object
                         * @param {Object} object The destination object.
                         * @param {...Object} [sources] The source objects.
                         * @returns {Object} Returns `object`.
                         * @see _.assign
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         * }
                         *
                         * function Bar() {
                         *   this.c = 3;
                         * }
                         *
                         * Foo.prototype.b = 2;
                         * Bar.prototype.d = 4;
                         *
                         * _.assignIn({ 'a': 0 }, new Foo, new Bar);
                         * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
                         */
                        var assignIn = createAssigner(function (object, source) {
                            copyObject(source, keysIn(source), object);
                        });
                        /**
                         * This method is like `_.assignIn` except that it accepts `customizer`
                         * which is invoked to produce the assigned values. If `customizer` returns
                         * `undefined`, assignment is handled by the method instead. The `customizer`
                         * is invoked with five arguments: (objValue, srcValue, key, object, source).
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @alias extendWith
                         * @category Object
                         * @param {Object} object The destination object.
                         * @param {...Object} sources The source objects.
                         * @param {Function} [customizer] The function to customize assigned values.
                         * @returns {Object} Returns `object`.
                         * @see _.assignWith
                         * @example
                         *
                         * function customizer(objValue, srcValue) {
                         *   return _.isUndefined(objValue) ? srcValue : objValue;
                         * }
                         *
                         * var defaults = _.partialRight(_.assignInWith, customizer);
                         *
                         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
                         * // => { 'a': 1, 'b': 2 }
                         */
                        var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
                            copyObject(source, keysIn(source), object, customizer);
                        });
                        /**
                         * This method is like `_.assign` except that it accepts `customizer`
                         * which is invoked to produce the assigned values. If `customizer` returns
                         * `undefined`, assignment is handled by the method instead. The `customizer`
                         * is invoked with five arguments: (objValue, srcValue, key, object, source).
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Object
                         * @param {Object} object The destination object.
                         * @param {...Object} sources The source objects.
                         * @param {Function} [customizer] The function to customize assigned values.
                         * @returns {Object} Returns `object`.
                         * @see _.assignInWith
                         * @example
                         *
                         * function customizer(objValue, srcValue) {
                         *   return _.isUndefined(objValue) ? srcValue : objValue;
                         * }
                         *
                         * var defaults = _.partialRight(_.assignWith, customizer);
                         *
                         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
                         * // => { 'a': 1, 'b': 2 }
                         */
                        var assignWith = createAssigner(function (object, source, srcIndex, customizer) {
                            copyObject(source, keys(source), object, customizer);
                        });
                        /**
                         * Creates an array of values corresponding to `paths` of `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 1.0.0
                         * @category Object
                         * @param {Object} object The object to iterate over.
                         * @param {...(string|string[])} [paths] The property paths to pick.
                         * @returns {Array} Returns the picked values.
                         * @example
                         *
                         * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
                         *
                         * _.at(object, ['a[0].b.c', 'a[1]']);
                         * // => [3, 4]
                         */
                        var at = flatRest(baseAt);
                        /**
                         * Creates an object that inherits from the `prototype` object. If a
                         * `properties` object is given, its own enumerable string keyed properties
                         * are assigned to the created object.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.3.0
                         * @category Object
                         * @param {Object} prototype The object to inherit from.
                         * @param {Object} [properties] The properties to assign to the object.
                         * @returns {Object} Returns the new object.
                         * @example
                         *
                         * function Shape() {
                         *   this.x = 0;
                         *   this.y = 0;
                         * }
                         *
                         * function Circle() {
                         *   Shape.call(this);
                         * }
                         *
                         * Circle.prototype = _.create(Shape.prototype, {
                         *   'constructor': Circle
                         * });
                         *
                         * var circle = new Circle;
                         * circle instanceof Circle;
                         * // => true
                         *
                         * circle instanceof Shape;
                         * // => true
                         */
                        function create(prototype, properties) {
                            var result = baseCreate(prototype);
                            return properties == null ? result : baseAssign(result, properties);
                        }
                        /**
                         * Assigns own and inherited enumerable string keyed properties of source
                         * objects to the destination object for all destination properties that
                         * resolve to `undefined`. Source objects are applied from left to right.
                         * Once a property is set, additional values of the same property are ignored.
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Object
                         * @param {Object} object The destination object.
                         * @param {...Object} [sources] The source objects.
                         * @returns {Object} Returns `object`.
                         * @see _.defaultsDeep
                         * @example
                         *
                         * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
                         * // => { 'a': 1, 'b': 2 }
                         */
                        var defaults = baseRest(function (object, sources) {
                            object = Object(object);
                            var index = -1;
                            var length = sources.length;
                            var guard = length > 2 ? sources[2] : undefined;
                            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                                length = 1;
                            }
                            while (++index < length) {
                                var source = sources[index];
                                var props = keysIn(source);
                                var propsIndex = -1;
                                var propsLength = props.length;
                                while (++propsIndex < propsLength) {
                                    var key = props[propsIndex];
                                    var value = object[key];
                                    if (value === undefined ||
                                        (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
                                        object[key] = source[key];
                                    }
                                }
                            }
                            return object;
                        });
                        /**
                         * This method is like `_.defaults` except that it recursively assigns
                         * default properties.
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.10.0
                         * @category Object
                         * @param {Object} object The destination object.
                         * @param {...Object} [sources] The source objects.
                         * @returns {Object} Returns `object`.
                         * @see _.defaults
                         * @example
                         *
                         * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
                         * // => { 'a': { 'b': 2, 'c': 3 } }
                         */
                        var defaultsDeep = baseRest(function (args) {
                            args.push(undefined, customDefaultsMerge);
                            return apply(mergeWith, undefined, args);
                        });
                        /**
                         * This method is like `_.find` except that it returns the key of the first
                         * element `predicate` returns truthy for instead of the element itself.
                         *
                         * @static
                         * @memberOf _
                         * @since 1.1.0
                         * @category Object
                         * @param {Object} object The object to inspect.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @returns {string|undefined} Returns the key of the matched element,
                         *  else `undefined`.
                         * @example
                         *
                         * var users = {
                         *   'barney':  { 'age': 36, 'active': true },
                         *   'fred':    { 'age': 40, 'active': false },
                         *   'pebbles': { 'age': 1,  'active': true }
                         * };
                         *
                         * _.findKey(users, function(o) { return o.age < 40; });
                         * // => 'barney' (iteration order is not guaranteed)
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.findKey(users, { 'age': 1, 'active': true });
                         * // => 'pebbles'
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.findKey(users, ['active', false]);
                         * // => 'fred'
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.findKey(users, 'active');
                         * // => 'barney'
                         */
                        function findKey(object, predicate) {
                            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
                        }
                        /**
                         * This method is like `_.findKey` except that it iterates over elements of
                         * a collection in the opposite order.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.0.0
                         * @category Object
                         * @param {Object} object The object to inspect.
                         * @param {Function} [predicate=_.identity] The function invoked per iteration.
                         * @returns {string|undefined} Returns the key of the matched element,
                         *  else `undefined`.
                         * @example
                         *
                         * var users = {
                         *   'barney':  { 'age': 36, 'active': true },
                         *   'fred':    { 'age': 40, 'active': false },
                         *   'pebbles': { 'age': 1,  'active': true }
                         * };
                         *
                         * _.findLastKey(users, function(o) { return o.age < 40; });
                         * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.findLastKey(users, { 'age': 36, 'active': true });
                         * // => 'barney'
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.findLastKey(users, ['active', false]);
                         * // => 'fred'
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.findLastKey(users, 'active');
                         * // => 'pebbles'
                         */
                        function findLastKey(object, predicate) {
                            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
                        }
                        /**
                         * Iterates over own and inherited enumerable string keyed properties of an
                         * object and invokes `iteratee` for each property. The iteratee is invoked
                         * with three arguments: (value, key, object). Iteratee functions may exit
                         * iteration early by explicitly returning `false`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.3.0
                         * @category Object
                         * @param {Object} object The object to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Object} Returns `object`.
                         * @see _.forInRight
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.forIn(new Foo, function(value, key) {
                         *   console.log(key);
                         * });
                         * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
                         */
                        function forIn(object, iteratee) {
                            return object == null
                                ? object
                                : baseFor(object, getIteratee(iteratee, 3), keysIn);
                        }
                        /**
                         * This method is like `_.forIn` except that it iterates over properties of
                         * `object` in the opposite order.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.0.0
                         * @category Object
                         * @param {Object} object The object to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Object} Returns `object`.
                         * @see _.forIn
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.forInRight(new Foo, function(value, key) {
                         *   console.log(key);
                         * });
                         * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
                         */
                        function forInRight(object, iteratee) {
                            return object == null
                                ? object
                                : baseForRight(object, getIteratee(iteratee, 3), keysIn);
                        }
                        /**
                         * Iterates over own enumerable string keyed properties of an object and
                         * invokes `iteratee` for each property. The iteratee is invoked with three
                         * arguments: (value, key, object). Iteratee functions may exit iteration
                         * early by explicitly returning `false`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.3.0
                         * @category Object
                         * @param {Object} object The object to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Object} Returns `object`.
                         * @see _.forOwnRight
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.forOwn(new Foo, function(value, key) {
                         *   console.log(key);
                         * });
                         * // => Logs 'a' then 'b' (iteration order is not guaranteed).
                         */
                        function forOwn(object, iteratee) {
                            return object && baseForOwn(object, getIteratee(iteratee, 3));
                        }
                        /**
                         * This method is like `_.forOwn` except that it iterates over properties of
                         * `object` in the opposite order.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.0.0
                         * @category Object
                         * @param {Object} object The object to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Object} Returns `object`.
                         * @see _.forOwn
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.forOwnRight(new Foo, function(value, key) {
                         *   console.log(key);
                         * });
                         * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
                         */
                        function forOwnRight(object, iteratee) {
                            return object && baseForOwnRight(object, getIteratee(iteratee, 3));
                        }
                        /**
                         * Creates an array of function property names from own enumerable properties
                         * of `object`.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Object
                         * @param {Object} object The object to inspect.
                         * @returns {Array} Returns the function names.
                         * @see _.functionsIn
                         * @example
                         *
                         * function Foo() {
                         *   this.a = _.constant('a');
                         *   this.b = _.constant('b');
                         * }
                         *
                         * Foo.prototype.c = _.constant('c');
                         *
                         * _.functions(new Foo);
                         * // => ['a', 'b']
                         */
                        function functions(object) {
                            return object == null ? [] : baseFunctions(object, keys(object));
                        }
                        /**
                         * Creates an array of function property names from own and inherited
                         * enumerable properties of `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Object
                         * @param {Object} object The object to inspect.
                         * @returns {Array} Returns the function names.
                         * @see _.functions
                         * @example
                         *
                         * function Foo() {
                         *   this.a = _.constant('a');
                         *   this.b = _.constant('b');
                         * }
                         *
                         * Foo.prototype.c = _.constant('c');
                         *
                         * _.functionsIn(new Foo);
                         * // => ['a', 'b', 'c']
                         */
                        function functionsIn(object) {
                            return object == null ? [] : baseFunctions(object, keysIn(object));
                        }
                        /**
                         * Gets the value at `path` of `object`. If the resolved value is
                         * `undefined`, the `defaultValue` is returned in its place.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.7.0
                         * @category Object
                         * @param {Object} object The object to query.
                         * @param {Array|string} path The path of the property to get.
                         * @param {*} [defaultValue] The value returned for `undefined` resolved values.
                         * @returns {*} Returns the resolved value.
                         * @example
                         *
                         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
                         *
                         * _.get(object, 'a[0].b.c');
                         * // => 3
                         *
                         * _.get(object, ['a', '0', 'b', 'c']);
                         * // => 3
                         *
                         * _.get(object, 'a.b.c', 'default');
                         * // => 'default'
                         */
                        function get(object, path, defaultValue) {
                            var result = object == null ? undefined : baseGet(object, path);
                            return result === undefined ? defaultValue : result;
                        }
                        /**
                         * Checks if `path` is a direct property of `object`.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Object
                         * @param {Object} object The object to query.
                         * @param {Array|string} path The path to check.
                         * @returns {boolean} Returns `true` if `path` exists, else `false`.
                         * @example
                         *
                         * var object = { 'a': { 'b': 2 } };
                         * var other = _.create({ 'a': _.create({ 'b': 2 }) });
                         *
                         * _.has(object, 'a');
                         * // => true
                         *
                         * _.has(object, 'a.b');
                         * // => true
                         *
                         * _.has(object, ['a', 'b']);
                         * // => true
                         *
                         * _.has(other, 'a');
                         * // => false
                         */
                        function has(object, path) {
                            return object != null && hasPath(object, path, baseHas);
                        }
                        /**
                         * Checks if `path` is a direct or inherited property of `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Object
                         * @param {Object} object The object to query.
                         * @param {Array|string} path The path to check.
                         * @returns {boolean} Returns `true` if `path` exists, else `false`.
                         * @example
                         *
                         * var object = _.create({ 'a': _.create({ 'b': 2 }) });
                         *
                         * _.hasIn(object, 'a');
                         * // => true
                         *
                         * _.hasIn(object, 'a.b');
                         * // => true
                         *
                         * _.hasIn(object, ['a', 'b']);
                         * // => true
                         *
                         * _.hasIn(object, 'b');
                         * // => false
                         */
                        function hasIn(object, path) {
                            return object != null && hasPath(object, path, baseHasIn);
                        }
                        /**
                         * Creates an object composed of the inverted keys and values of `object`.
                         * If `object` contains duplicate values, subsequent values overwrite
                         * property assignments of previous values.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.7.0
                         * @category Object
                         * @param {Object} object The object to invert.
                         * @returns {Object} Returns the new inverted object.
                         * @example
                         *
                         * var object = { 'a': 1, 'b': 2, 'c': 1 };
                         *
                         * _.invert(object);
                         * // => { '1': 'c', '2': 'b' }
                         */
                        var invert = createInverter(function (result, value, key) {
                            if (value != null &&
                                typeof value.toString != 'function') {
                                value = nativeObjectToString.call(value);
                            }
                            result[value] = key;
                        }, constant(identity));
                        /**
                         * This method is like `_.invert` except that the inverted object is generated
                         * from the results of running each element of `object` thru `iteratee`. The
                         * corresponding inverted value of each inverted key is an array of keys
                         * responsible for generating the inverted value. The iteratee is invoked
                         * with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.1.0
                         * @category Object
                         * @param {Object} object The object to invert.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {Object} Returns the new inverted object.
                         * @example
                         *
                         * var object = { 'a': 1, 'b': 2, 'c': 1 };
                         *
                         * _.invertBy(object);
                         * // => { '1': ['a', 'c'], '2': ['b'] }
                         *
                         * _.invertBy(object, function(value) {
                         *   return 'group' + value;
                         * });
                         * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
                         */
                        var invertBy = createInverter(function (result, value, key) {
                            if (value != null &&
                                typeof value.toString != 'function') {
                                value = nativeObjectToString.call(value);
                            }
                            if (hasOwnProperty.call(result, value)) {
                                result[value].push(key);
                            }
                            else {
                                result[value] = [key];
                            }
                        }, getIteratee);
                        /**
                         * Invokes the method at `path` of `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Object
                         * @param {Object} object The object to query.
                         * @param {Array|string} path The path of the method to invoke.
                         * @param {...*} [args] The arguments to invoke the method with.
                         * @returns {*} Returns the result of the invoked method.
                         * @example
                         *
                         * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
                         *
                         * _.invoke(object, 'a[0].b.c.slice', 1, 3);
                         * // => [2, 3]
                         */
                        var invoke = baseRest(baseInvoke);
                        /**
                         * Creates an array of the own enumerable property names of `object`.
                         *
                         * **Note:** Non-object values are coerced to objects. See the
                         * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
                         * for more details.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Object
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property names.
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.keys(new Foo);
                         * // => ['a', 'b'] (iteration order is not guaranteed)
                         *
                         * _.keys('hi');
                         * // => ['0', '1']
                         */
                        function keys(object) {
                            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
                        }
                        /**
                         * Creates an array of the own and inherited enumerable property names of `object`.
                         *
                         * **Note:** Non-object values are coerced to objects.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Object
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property names.
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.keysIn(new Foo);
                         * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
                         */
                        function keysIn(object) {
                            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
                        }
                        /**
                         * The opposite of `_.mapValues`; this method creates an object with the
                         * same values as `object` and keys generated by running each own enumerable
                         * string keyed property of `object` thru `iteratee`. The iteratee is invoked
                         * with three arguments: (value, key, object).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.8.0
                         * @category Object
                         * @param {Object} object The object to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Object} Returns the new mapped object.
                         * @see _.mapValues
                         * @example
                         *
                         * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
                         *   return key + value;
                         * });
                         * // => { 'a1': 1, 'b2': 2 }
                         */
                        function mapKeys(object, iteratee) {
                            var result = {};
                            iteratee = getIteratee(iteratee, 3);
                            baseForOwn(object, function (value, key, object) {
                                baseAssignValue(result, iteratee(value, key, object), value);
                            });
                            return result;
                        }
                        /**
                         * Creates an object with the same keys as `object` and values generated
                         * by running each own enumerable string keyed property of `object` thru
                         * `iteratee`. The iteratee is invoked with three arguments:
                         * (value, key, object).
                         *
                         * @static
                         * @memberOf _
                         * @since 2.4.0
                         * @category Object
                         * @param {Object} object The object to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Object} Returns the new mapped object.
                         * @see _.mapKeys
                         * @example
                         *
                         * var users = {
                         *   'fred':    { 'user': 'fred',    'age': 40 },
                         *   'pebbles': { 'user': 'pebbles', 'age': 1 }
                         * };
                         *
                         * _.mapValues(users, function(o) { return o.age; });
                         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.mapValues(users, 'age');
                         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
                         */
                        function mapValues(object, iteratee) {
                            var result = {};
                            iteratee = getIteratee(iteratee, 3);
                            baseForOwn(object, function (value, key, object) {
                                baseAssignValue(result, key, iteratee(value, key, object));
                            });
                            return result;
                        }
                        /**
                         * This method is like `_.assign` except that it recursively merges own and
                         * inherited enumerable string keyed properties of source objects into the
                         * destination object. Source properties that resolve to `undefined` are
                         * skipped if a destination value exists. Array and plain object properties
                         * are merged recursively. Other objects and value types are overridden by
                         * assignment. Source objects are applied from left to right. Subsequent
                         * sources overwrite property assignments of previous sources.
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.5.0
                         * @category Object
                         * @param {Object} object The destination object.
                         * @param {...Object} [sources] The source objects.
                         * @returns {Object} Returns `object`.
                         * @example
                         *
                         * var object = {
                         *   'a': [{ 'b': 2 }, { 'd': 4 }]
                         * };
                         *
                         * var other = {
                         *   'a': [{ 'c': 3 }, { 'e': 5 }]
                         * };
                         *
                         * _.merge(object, other);
                         * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
                         */
                        var merge = createAssigner(function (object, source, srcIndex) {
                            baseMerge(object, source, srcIndex);
                        });
                        /**
                         * This method is like `_.merge` except that it accepts `customizer` which
                         * is invoked to produce the merged values of the destination and source
                         * properties. If `customizer` returns `undefined`, merging is handled by the
                         * method instead. The `customizer` is invoked with six arguments:
                         * (objValue, srcValue, key, object, source, stack).
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Object
                         * @param {Object} object The destination object.
                         * @param {...Object} sources The source objects.
                         * @param {Function} customizer The function to customize assigned values.
                         * @returns {Object} Returns `object`.
                         * @example
                         *
                         * function customizer(objValue, srcValue) {
                         *   if (_.isArray(objValue)) {
                         *     return objValue.concat(srcValue);
                         *   }
                         * }
                         *
                         * var object = { 'a': [1], 'b': [2] };
                         * var other = { 'a': [3], 'b': [4] };
                         *
                         * _.mergeWith(object, other, customizer);
                         * // => { 'a': [1, 3], 'b': [2, 4] }
                         */
                        var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
                            baseMerge(object, source, srcIndex, customizer);
                        });
                        /**
                         * The opposite of `_.pick`; this method creates an object composed of the
                         * own and inherited enumerable property paths of `object` that are not omitted.
                         *
                         * **Note:** This method is considerably slower than `_.pick`.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Object
                         * @param {Object} object The source object.
                         * @param {...(string|string[])} [paths] The property paths to omit.
                         * @returns {Object} Returns the new object.
                         * @example
                         *
                         * var object = { 'a': 1, 'b': '2', 'c': 3 };
                         *
                         * _.omit(object, ['a', 'c']);
                         * // => { 'b': '2' }
                         */
                        var omit = flatRest(function (object, paths) {
                            var result = {};
                            if (object == null) {
                                return result;
                            }
                            var isDeep = false;
                            paths = arrayMap(paths, function (path) {
                                path = castPath(path, object);
                                isDeep || (isDeep = path.length > 1);
                                return path;
                            });
                            copyObject(object, getAllKeysIn(object), result);
                            if (isDeep) {
                                result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
                            }
                            var length = paths.length;
                            while (length--) {
                                baseUnset(result, paths[length]);
                            }
                            return result;
                        });
                        /**
                         * The opposite of `_.pickBy`; this method creates an object composed of
                         * the own and inherited enumerable string keyed properties of `object` that
                         * `predicate` doesn't return truthy for. The predicate is invoked with two
                         * arguments: (value, key).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Object
                         * @param {Object} object The source object.
                         * @param {Function} [predicate=_.identity] The function invoked per property.
                         * @returns {Object} Returns the new object.
                         * @example
                         *
                         * var object = { 'a': 1, 'b': '2', 'c': 3 };
                         *
                         * _.omitBy(object, _.isNumber);
                         * // => { 'b': '2' }
                         */
                        function omitBy(object, predicate) {
                            return pickBy(object, negate(getIteratee(predicate)));
                        }
                        /**
                         * Creates an object composed of the picked `object` properties.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Object
                         * @param {Object} object The source object.
                         * @param {...(string|string[])} [paths] The property paths to pick.
                         * @returns {Object} Returns the new object.
                         * @example
                         *
                         * var object = { 'a': 1, 'b': '2', 'c': 3 };
                         *
                         * _.pick(object, ['a', 'c']);
                         * // => { 'a': 1, 'c': 3 }
                         */
                        var pick = flatRest(function (object, paths) {
                            return object == null ? {} : basePick(object, paths);
                        });
                        /**
                         * Creates an object composed of the `object` properties `predicate` returns
                         * truthy for. The predicate is invoked with two arguments: (value, key).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Object
                         * @param {Object} object The source object.
                         * @param {Function} [predicate=_.identity] The function invoked per property.
                         * @returns {Object} Returns the new object.
                         * @example
                         *
                         * var object = { 'a': 1, 'b': '2', 'c': 3 };
                         *
                         * _.pickBy(object, _.isNumber);
                         * // => { 'a': 1, 'c': 3 }
                         */
                        function pickBy(object, predicate) {
                            if (object == null) {
                                return {};
                            }
                            var props = arrayMap(getAllKeysIn(object), function (prop) {
                                return [prop];
                            });
                            predicate = getIteratee(predicate);
                            return basePickBy(object, props, function (value, path) {
                                return predicate(value, path[0]);
                            });
                        }
                        /**
                         * This method is like `_.get` except that if the resolved value is a
                         * function it's invoked with the `this` binding of its parent object and
                         * its result is returned.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Object
                         * @param {Object} object The object to query.
                         * @param {Array|string} path The path of the property to resolve.
                         * @param {*} [defaultValue] The value returned for `undefined` resolved values.
                         * @returns {*} Returns the resolved value.
                         * @example
                         *
                         * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
                         *
                         * _.result(object, 'a[0].b.c1');
                         * // => 3
                         *
                         * _.result(object, 'a[0].b.c2');
                         * // => 4
                         *
                         * _.result(object, 'a[0].b.c3', 'default');
                         * // => 'default'
                         *
                         * _.result(object, 'a[0].b.c3', _.constant('default'));
                         * // => 'default'
                         */
                        function result(object, path, defaultValue) {
                            path = castPath(path, object);
                            var index = -1, length = path.length;
                            // Ensure the loop is entered when path is empty.
                            if (!length) {
                                length = 1;
                                object = undefined;
                            }
                            while (++index < length) {
                                var value = object == null ? undefined : object[toKey(path[index])];
                                if (value === undefined) {
                                    index = length;
                                    value = defaultValue;
                                }
                                object = isFunction(value) ? value.call(object) : value;
                            }
                            return object;
                        }
                        /**
                         * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
                         * it's created. Arrays are created for missing index properties while objects
                         * are created for all other missing properties. Use `_.setWith` to customize
                         * `path` creation.
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.7.0
                         * @category Object
                         * @param {Object} object The object to modify.
                         * @param {Array|string} path The path of the property to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns `object`.
                         * @example
                         *
                         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
                         *
                         * _.set(object, 'a[0].b.c', 4);
                         * console.log(object.a[0].b.c);
                         * // => 4
                         *
                         * _.set(object, ['x', '0', 'y', 'z'], 5);
                         * console.log(object.x[0].y.z);
                         * // => 5
                         */
                        function set(object, path, value) {
                            return object == null ? object : baseSet(object, path, value);
                        }
                        /**
                         * This method is like `_.set` except that it accepts `customizer` which is
                         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
                         * path creation is handled by the method instead. The `customizer` is invoked
                         * with three arguments: (nsValue, key, nsObject).
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Object
                         * @param {Object} object The object to modify.
                         * @param {Array|string} path The path of the property to set.
                         * @param {*} value The value to set.
                         * @param {Function} [customizer] The function to customize assigned values.
                         * @returns {Object} Returns `object`.
                         * @example
                         *
                         * var object = {};
                         *
                         * _.setWith(object, '[0][1]', 'a', Object);
                         * // => { '0': { '1': 'a' } }
                         */
                        function setWith(object, path, value, customizer) {
                            customizer = typeof customizer == 'function' ? customizer : undefined;
                            return object == null ? object : baseSet(object, path, value, customizer);
                        }
                        /**
                         * Creates an array of own enumerable string keyed-value pairs for `object`
                         * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
                         * entries are returned.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @alias entries
                         * @category Object
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the key-value pairs.
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.toPairs(new Foo);
                         * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
                         */
                        var toPairs = createToPairs(keys);
                        /**
                         * Creates an array of own and inherited enumerable string keyed-value pairs
                         * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
                         * or set, its entries are returned.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @alias entriesIn
                         * @category Object
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the key-value pairs.
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.toPairsIn(new Foo);
                         * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
                         */
                        var toPairsIn = createToPairs(keysIn);
                        /**
                         * An alternative to `_.reduce`; this method transforms `object` to a new
                         * `accumulator` object which is the result of running each of its own
                         * enumerable string keyed properties thru `iteratee`, with each invocation
                         * potentially mutating the `accumulator` object. If `accumulator` is not
                         * provided, a new object with the same `[[Prototype]]` will be used. The
                         * iteratee is invoked with four arguments: (accumulator, value, key, object).
                         * Iteratee functions may exit iteration early by explicitly returning `false`.
                         *
                         * @static
                         * @memberOf _
                         * @since 1.3.0
                         * @category Object
                         * @param {Object} object The object to iterate over.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @param {*} [accumulator] The custom accumulator value.
                         * @returns {*} Returns the accumulated value.
                         * @example
                         *
                         * _.transform([2, 3, 4], function(result, n) {
                         *   result.push(n *= n);
                         *   return n % 2 == 0;
                         * }, []);
                         * // => [4, 9]
                         *
                         * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
                         *   (result[value] || (result[value] = [])).push(key);
                         * }, {});
                         * // => { '1': ['a', 'c'], '2': ['b'] }
                         */
                        function transform(object, iteratee, accumulator) {
                            var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
                            iteratee = getIteratee(iteratee, 4);
                            if (accumulator == null) {
                                var Ctor = object && object.constructor;
                                if (isArrLike) {
                                    accumulator = isArr ? new Ctor : [];
                                }
                                else if (isObject(object)) {
                                    accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
                                }
                                else {
                                    accumulator = {};
                                }
                            }
                            (isArrLike ? arrayEach : baseForOwn)(object, function (value, index, object) {
                                return iteratee(accumulator, value, index, object);
                            });
                            return accumulator;
                        }
                        /**
                         * Removes the property at `path` of `object`.
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Object
                         * @param {Object} object The object to modify.
                         * @param {Array|string} path The path of the property to unset.
                         * @returns {boolean} Returns `true` if the property is deleted, else `false`.
                         * @example
                         *
                         * var object = { 'a': [{ 'b': { 'c': 7 } }] };
                         * _.unset(object, 'a[0].b.c');
                         * // => true
                         *
                         * console.log(object);
                         * // => { 'a': [{ 'b': {} }] };
                         *
                         * _.unset(object, ['a', '0', 'b', 'c']);
                         * // => true
                         *
                         * console.log(object);
                         * // => { 'a': [{ 'b': {} }] };
                         */
                        function unset(object, path) {
                            return object == null ? true : baseUnset(object, path);
                        }
                        /**
                         * This method is like `_.set` except that accepts `updater` to produce the
                         * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
                         * is invoked with one argument: (value).
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.6.0
                         * @category Object
                         * @param {Object} object The object to modify.
                         * @param {Array|string} path The path of the property to set.
                         * @param {Function} updater The function to produce the updated value.
                         * @returns {Object} Returns `object`.
                         * @example
                         *
                         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
                         *
                         * _.update(object, 'a[0].b.c', function(n) { return n * n; });
                         * console.log(object.a[0].b.c);
                         * // => 9
                         *
                         * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
                         * console.log(object.x[0].y.z);
                         * // => 0
                         */
                        function update(object, path, updater) {
                            return object == null ? object : baseUpdate(object, path, castFunction(updater));
                        }
                        /**
                         * This method is like `_.update` except that it accepts `customizer` which is
                         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
                         * path creation is handled by the method instead. The `customizer` is invoked
                         * with three arguments: (nsValue, key, nsObject).
                         *
                         * **Note:** This method mutates `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.6.0
                         * @category Object
                         * @param {Object} object The object to modify.
                         * @param {Array|string} path The path of the property to set.
                         * @param {Function} updater The function to produce the updated value.
                         * @param {Function} [customizer] The function to customize assigned values.
                         * @returns {Object} Returns `object`.
                         * @example
                         *
                         * var object = {};
                         *
                         * _.updateWith(object, '[0][1]', _.constant('a'), Object);
                         * // => { '0': { '1': 'a' } }
                         */
                        function updateWith(object, path, updater, customizer) {
                            customizer = typeof customizer == 'function' ? customizer : undefined;
                            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
                        }
                        /**
                         * Creates an array of the own enumerable string keyed property values of `object`.
                         *
                         * **Note:** Non-object values are coerced to objects.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Object
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property values.
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.values(new Foo);
                         * // => [1, 2] (iteration order is not guaranteed)
                         *
                         * _.values('hi');
                         * // => ['h', 'i']
                         */
                        function values(object) {
                            return object == null ? [] : baseValues(object, keys(object));
                        }
                        /**
                         * Creates an array of the own and inherited enumerable string keyed property
                         * values of `object`.
                         *
                         * **Note:** Non-object values are coerced to objects.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Object
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property values.
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.valuesIn(new Foo);
                         * // => [1, 2, 3] (iteration order is not guaranteed)
                         */
                        function valuesIn(object) {
                            return object == null ? [] : baseValues(object, keysIn(object));
                        }
                        /*------------------------------------------------------------------------*/
                        /**
                         * Clamps `number` within the inclusive `lower` and `upper` bounds.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Number
                         * @param {number} number The number to clamp.
                         * @param {number} [lower] The lower bound.
                         * @param {number} upper The upper bound.
                         * @returns {number} Returns the clamped number.
                         * @example
                         *
                         * _.clamp(-10, -5, 5);
                         * // => -5
                         *
                         * _.clamp(10, -5, 5);
                         * // => 5
                         */
                        function clamp(number, lower, upper) {
                            if (upper === undefined) {
                                upper = lower;
                                lower = undefined;
                            }
                            if (upper !== undefined) {
                                upper = toNumber(upper);
                                upper = upper === upper ? upper : 0;
                            }
                            if (lower !== undefined) {
                                lower = toNumber(lower);
                                lower = lower === lower ? lower : 0;
                            }
                            return baseClamp(toNumber(number), lower, upper);
                        }
                        /**
                         * Checks if `n` is between `start` and up to, but not including, `end`. If
                         * `end` is not specified, it's set to `start` with `start` then set to `0`.
                         * If `start` is greater than `end` the params are swapped to support
                         * negative ranges.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.3.0
                         * @category Number
                         * @param {number} number The number to check.
                         * @param {number} [start=0] The start of the range.
                         * @param {number} end The end of the range.
                         * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
                         * @see _.range, _.rangeRight
                         * @example
                         *
                         * _.inRange(3, 2, 4);
                         * // => true
                         *
                         * _.inRange(4, 8);
                         * // => true
                         *
                         * _.inRange(4, 2);
                         * // => false
                         *
                         * _.inRange(2, 2);
                         * // => false
                         *
                         * _.inRange(1.2, 2);
                         * // => true
                         *
                         * _.inRange(5.2, 4);
                         * // => false
                         *
                         * _.inRange(-3, -2, -6);
                         * // => true
                         */
                        function inRange(number, start, end) {
                            start = toFinite(start);
                            if (end === undefined) {
                                end = start;
                                start = 0;
                            }
                            else {
                                end = toFinite(end);
                            }
                            number = toNumber(number);
                            return baseInRange(number, start, end);
                        }
                        /**
                         * Produces a random number between the inclusive `lower` and `upper` bounds.
                         * If only one argument is provided a number between `0` and the given number
                         * is returned. If `floating` is `true`, or either `lower` or `upper` are
                         * floats, a floating-point number is returned instead of an integer.
                         *
                         * **Note:** JavaScript follows the IEEE-754 standard for resolving
                         * floating-point values which can produce unexpected results.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.7.0
                         * @category Number
                         * @param {number} [lower=0] The lower bound.
                         * @param {number} [upper=1] The upper bound.
                         * @param {boolean} [floating] Specify returning a floating-point number.
                         * @returns {number} Returns the random number.
                         * @example
                         *
                         * _.random(0, 5);
                         * // => an integer between 0 and 5
                         *
                         * _.random(5);
                         * // => also an integer between 0 and 5
                         *
                         * _.random(5, true);
                         * // => a floating-point number between 0 and 5
                         *
                         * _.random(1.2, 5.2);
                         * // => a floating-point number between 1.2 and 5.2
                         */
                        function random(lower, upper, floating) {
                            if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
                                upper = floating = undefined;
                            }
                            if (floating === undefined) {
                                if (typeof upper == 'boolean') {
                                    floating = upper;
                                    upper = undefined;
                                }
                                else if (typeof lower == 'boolean') {
                                    floating = lower;
                                    lower = undefined;
                                }
                            }
                            if (lower === undefined && upper === undefined) {
                                lower = 0;
                                upper = 1;
                            }
                            else {
                                lower = toFinite(lower);
                                if (upper === undefined) {
                                    upper = lower;
                                    lower = 0;
                                }
                                else {
                                    upper = toFinite(upper);
                                }
                            }
                            if (lower > upper) {
                                var temp = lower;
                                lower = upper;
                                upper = temp;
                            }
                            if (floating || lower % 1 || upper % 1) {
                                var rand = nativeRandom();
                                return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
                            }
                            return baseRandom(lower, upper);
                        }
                        /*------------------------------------------------------------------------*/
                        /**
                         * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to convert.
                         * @returns {string} Returns the camel cased string.
                         * @example
                         *
                         * _.camelCase('Foo Bar');
                         * // => 'fooBar'
                         *
                         * _.camelCase('--foo-bar--');
                         * // => 'fooBar'
                         *
                         * _.camelCase('__FOO_BAR__');
                         * // => 'fooBar'
                         */
                        var camelCase = createCompounder(function (result, word, index) {
                            word = word.toLowerCase();
                            return result + (index ? capitalize(word) : word);
                        });
                        /**
                         * Converts the first character of `string` to upper case and the remaining
                         * to lower case.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to capitalize.
                         * @returns {string} Returns the capitalized string.
                         * @example
                         *
                         * _.capitalize('FRED');
                         * // => 'Fred'
                         */
                        function capitalize(string) {
                            return upperFirst(toString(string).toLowerCase());
                        }
                        /**
                         * Deburrs `string` by converting
                         * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
                         * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
                         * letters to basic Latin letters and removing
                         * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to deburr.
                         * @returns {string} Returns the deburred string.
                         * @example
                         *
                         * _.deburr('dj vu');
                         * // => 'deja vu'
                         */
                        function deburr(string) {
                            string = toString(string);
                            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
                        }
                        /**
                         * Checks if `string` ends with the given target string.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to inspect.
                         * @param {string} [target] The string to search for.
                         * @param {number} [position=string.length] The position to search up to.
                         * @returns {boolean} Returns `true` if `string` ends with `target`,
                         *  else `false`.
                         * @example
                         *
                         * _.endsWith('abc', 'c');
                         * // => true
                         *
                         * _.endsWith('abc', 'b');
                         * // => false
                         *
                         * _.endsWith('abc', 'b', 2);
                         * // => true
                         */
                        function endsWith(string, target, position) {
                            string = toString(string);
                            target = baseToString(target);
                            var length = string.length;
                            position = position === undefined
                                ? length
                                : baseClamp(toInteger(position), 0, length);
                            var end = position;
                            position -= target.length;
                            return position >= 0 && string.slice(position, end) == target;
                        }
                        /**
                         * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
                         * corresponding HTML entities.
                         *
                         * **Note:** No other characters are escaped. To escape additional
                         * characters use a third-party library like [_he_](https://mths.be/he).
                         *
                         * Though the ">" character is escaped for symmetry, characters like
                         * ">" and "/" don't need escaping in HTML and have no special meaning
                         * unless they're part of a tag or unquoted attribute value. See
                         * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
                         * (under "semi-related fun fact") for more details.
                         *
                         * When working with HTML you should always
                         * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
                         * XSS vectors.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category String
                         * @param {string} [string=''] The string to escape.
                         * @returns {string} Returns the escaped string.
                         * @example
                         *
                         * _.escape('fred, barney, & pebbles');
                         * // => 'fred, barney, &amp; pebbles'
                         */
                        function escape(string) {
                            string = toString(string);
                            return (string && reHasUnescapedHtml.test(string))
                                ? string.replace(reUnescapedHtml, escapeHtmlChar)
                                : string;
                        }
                        /**
                         * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
                         * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to escape.
                         * @returns {string} Returns the escaped string.
                         * @example
                         *
                         * _.escapeRegExp('[lodash](https://lodash.com/)');
                         * // => '\[lodash\]\(https://lodash\.com/\)'
                         */
                        function escapeRegExp(string) {
                            string = toString(string);
                            return (string && reHasRegExpChar.test(string))
                                ? string.replace(reRegExpChar, '\\$&')
                                : string;
                        }
                        /**
                         * Converts `string` to
                         * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to convert.
                         * @returns {string} Returns the kebab cased string.
                         * @example
                         *
                         * _.kebabCase('Foo Bar');
                         * // => 'foo-bar'
                         *
                         * _.kebabCase('fooBar');
                         * // => 'foo-bar'
                         *
                         * _.kebabCase('__FOO_BAR__');
                         * // => 'foo-bar'
                         */
                        var kebabCase = createCompounder(function (result, word, index) {
                            return result + (index ? '-' : '') + word.toLowerCase();
                        });
                        /**
                         * Converts `string`, as space separated words, to lower case.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to convert.
                         * @returns {string} Returns the lower cased string.
                         * @example
                         *
                         * _.lowerCase('--Foo-Bar--');
                         * // => 'foo bar'
                         *
                         * _.lowerCase('fooBar');
                         * // => 'foo bar'
                         *
                         * _.lowerCase('__FOO_BAR__');
                         * // => 'foo bar'
                         */
                        var lowerCase = createCompounder(function (result, word, index) {
                            return result + (index ? ' ' : '') + word.toLowerCase();
                        });
                        /**
                         * Converts the first character of `string` to lower case.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to convert.
                         * @returns {string} Returns the converted string.
                         * @example
                         *
                         * _.lowerFirst('Fred');
                         * // => 'fred'
                         *
                         * _.lowerFirst('FRED');
                         * // => 'fRED'
                         */
                        var lowerFirst = createCaseFirst('toLowerCase');
                        /**
                         * Pads `string` on the left and right sides if it's shorter than `length`.
                         * Padding characters are truncated if they can't be evenly divided by `length`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to pad.
                         * @param {number} [length=0] The padding length.
                         * @param {string} [chars=' '] The string used as padding.
                         * @returns {string} Returns the padded string.
                         * @example
                         *
                         * _.pad('abc', 8);
                         * // => '  abc   '
                         *
                         * _.pad('abc', 8, '_-');
                         * // => '_-abc_-_'
                         *
                         * _.pad('abc', 3);
                         * // => 'abc'
                         */
                        function pad(string, length, chars) {
                            string = toString(string);
                            length = toInteger(length);
                            var strLength = length ? stringSize(string) : 0;
                            if (!length || strLength >= length) {
                                return string;
                            }
                            var mid = (length - strLength) / 2;
                            return (createPadding(nativeFloor(mid), chars) +
                                string +
                                createPadding(nativeCeil(mid), chars));
                        }
                        /**
                         * Pads `string` on the right side if it's shorter than `length`. Padding
                         * characters are truncated if they exceed `length`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to pad.
                         * @param {number} [length=0] The padding length.
                         * @param {string} [chars=' '] The string used as padding.
                         * @returns {string} Returns the padded string.
                         * @example
                         *
                         * _.padEnd('abc', 6);
                         * // => 'abc   '
                         *
                         * _.padEnd('abc', 6, '_-');
                         * // => 'abc_-_'
                         *
                         * _.padEnd('abc', 3);
                         * // => 'abc'
                         */
                        function padEnd(string, length, chars) {
                            string = toString(string);
                            length = toInteger(length);
                            var strLength = length ? stringSize(string) : 0;
                            return (length && strLength < length)
                                ? (string + createPadding(length - strLength, chars))
                                : string;
                        }
                        /**
                         * Pads `string` on the left side if it's shorter than `length`. Padding
                         * characters are truncated if they exceed `length`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to pad.
                         * @param {number} [length=0] The padding length.
                         * @param {string} [chars=' '] The string used as padding.
                         * @returns {string} Returns the padded string.
                         * @example
                         *
                         * _.padStart('abc', 6);
                         * // => '   abc'
                         *
                         * _.padStart('abc', 6, '_-');
                         * // => '_-_abc'
                         *
                         * _.padStart('abc', 3);
                         * // => 'abc'
                         */
                        function padStart(string, length, chars) {
                            string = toString(string);
                            length = toInteger(length);
                            var strLength = length ? stringSize(string) : 0;
                            return (length && strLength < length)
                                ? (createPadding(length - strLength, chars) + string)
                                : string;
                        }
                        /**
                         * Converts `string` to an integer of the specified radix. If `radix` is
                         * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
                         * hexadecimal, in which case a `radix` of `16` is used.
                         *
                         * **Note:** This method aligns with the
                         * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
                         *
                         * @static
                         * @memberOf _
                         * @since 1.1.0
                         * @category String
                         * @param {string} string The string to convert.
                         * @param {number} [radix=10] The radix to interpret `value` by.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {number} Returns the converted integer.
                         * @example
                         *
                         * _.parseInt('08');
                         * // => 8
                         *
                         * _.map(['6', '08', '10'], _.parseInt);
                         * // => [6, 8, 10]
                         */
                        function parseInt(string, radix, guard) {
                            if (guard || radix == null) {
                                radix = 0;
                            }
                            else if (radix) {
                                radix = +radix;
                            }
                            return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
                        }
                        /**
                         * Repeats the given string `n` times.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to repeat.
                         * @param {number} [n=1] The number of times to repeat the string.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {string} Returns the repeated string.
                         * @example
                         *
                         * _.repeat('*', 3);
                         * // => '***'
                         *
                         * _.repeat('abc', 2);
                         * // => 'abcabc'
                         *
                         * _.repeat('abc', 0);
                         * // => ''
                         */
                        function repeat(string, n, guard) {
                            if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
                                n = 1;
                            }
                            else {
                                n = toInteger(n);
                            }
                            return baseRepeat(toString(string), n);
                        }
                        /**
                         * Replaces matches for `pattern` in `string` with `replacement`.
                         *
                         * **Note:** This method is based on
                         * [`String#replace`](https://mdn.io/String/replace).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to modify.
                         * @param {RegExp|string} pattern The pattern to replace.
                         * @param {Function|string} replacement The match replacement.
                         * @returns {string} Returns the modified string.
                         * @example
                         *
                         * _.replace('Hi Fred', 'Fred', 'Barney');
                         * // => 'Hi Barney'
                         */
                        function replace() {
                            var args = arguments, string = toString(args[0]);
                            return args.length < 3 ? string : string.replace(args[1], args[2]);
                        }
                        /**
                         * Converts `string` to
                         * [snake case](https://en.wikipedia.org/wiki/Snake_case).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to convert.
                         * @returns {string} Returns the snake cased string.
                         * @example
                         *
                         * _.snakeCase('Foo Bar');
                         * // => 'foo_bar'
                         *
                         * _.snakeCase('fooBar');
                         * // => 'foo_bar'
                         *
                         * _.snakeCase('--FOO-BAR--');
                         * // => 'foo_bar'
                         */
                        var snakeCase = createCompounder(function (result, word, index) {
                            return result + (index ? '_' : '') + word.toLowerCase();
                        });
                        /**
                         * Splits `string` by `separator`.
                         *
                         * **Note:** This method is based on
                         * [`String#split`](https://mdn.io/String/split).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to split.
                         * @param {RegExp|string} separator The separator pattern to split by.
                         * @param {number} [limit] The length to truncate results to.
                         * @returns {Array} Returns the string segments.
                         * @example
                         *
                         * _.split('a-b-c', '-', 2);
                         * // => ['a', 'b']
                         */
                        function split(string, separator, limit) {
                            if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
                                separator = limit = undefined;
                            }
                            limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
                            if (!limit) {
                                return [];
                            }
                            string = toString(string);
                            if (string && (typeof separator == 'string' ||
                                (separator != null && !isRegExp(separator)))) {
                                separator = baseToString(separator);
                                if (!separator && hasUnicode(string)) {
                                    return castSlice(stringToArray(string), 0, limit);
                                }
                            }
                            return string.split(separator, limit);
                        }
                        /**
                         * Converts `string` to
                         * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
                         *
                         * @static
                         * @memberOf _
                         * @since 3.1.0
                         * @category String
                         * @param {string} [string=''] The string to convert.
                         * @returns {string} Returns the start cased string.
                         * @example
                         *
                         * _.startCase('--foo-bar--');
                         * // => 'Foo Bar'
                         *
                         * _.startCase('fooBar');
                         * // => 'Foo Bar'
                         *
                         * _.startCase('__FOO_BAR__');
                         * // => 'FOO BAR'
                         */
                        var startCase = createCompounder(function (result, word, index) {
                            return result + (index ? ' ' : '') + upperFirst(word);
                        });
                        /**
                         * Checks if `string` starts with the given target string.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to inspect.
                         * @param {string} [target] The string to search for.
                         * @param {number} [position=0] The position to search from.
                         * @returns {boolean} Returns `true` if `string` starts with `target`,
                         *  else `false`.
                         * @example
                         *
                         * _.startsWith('abc', 'a');
                         * // => true
                         *
                         * _.startsWith('abc', 'b');
                         * // => false
                         *
                         * _.startsWith('abc', 'b', 1);
                         * // => true
                         */
                        function startsWith(string, target, position) {
                            string = toString(string);
                            position = position == null
                                ? 0
                                : baseClamp(toInteger(position), 0, string.length);
                            target = baseToString(target);
                            return string.slice(position, position + target.length) == target;
                        }
                        /**
                         * Creates a compiled template function that can interpolate data properties
                         * in "interpolate" delimiters, HTML-escape interpolated data properties in
                         * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
                         * properties may be accessed as free variables in the template. If a setting
                         * object is given, it takes precedence over `_.templateSettings` values.
                         *
                         * **Note:** In the development build `_.template` utilizes
                         * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
                         * for easier debugging.
                         *
                         * For more information on precompiling templates see
                         * [lodash's custom builds documentation](https://lodash.com/custom-builds).
                         *
                         * For more information on Chrome extension sandboxes see
                         * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category String
                         * @param {string} [string=''] The template string.
                         * @param {Object} [options={}] The options object.
                         * @param {RegExp} [options.escape=_.templateSettings.escape]
                         *  The HTML "escape" delimiter.
                         * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
                         *  The "evaluate" delimiter.
                         * @param {Object} [options.imports=_.templateSettings.imports]
                         *  An object to import into the template as free variables.
                         * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
                         *  The "interpolate" delimiter.
                         * @param {string} [options.sourceURL='lodash.templateSources[n]']
                         *  The sourceURL of the compiled template.
                         * @param {string} [options.variable='obj']
                         *  The data object variable name.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {Function} Returns the compiled template function.
                         * @example
                         *
                         * // Use the "interpolate" delimiter to create a compiled template.
                         * var compiled = _.template('hello <%= user %>!');
                         * compiled({ 'user': 'fred' });
                         * // => 'hello fred!'
                         *
                         * // Use the HTML "escape" delimiter to escape data property values.
                         * var compiled = _.template('<b><%- value %></b>');
                         * compiled({ 'value': '<script>' });
                         * // => '<b>&lt;script&gt;</b>'
                         *
                         * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
                         * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
                         * compiled({ 'users': ['fred', 'barney'] });
                         * // => '<li>fred</li><li>barney</li>'
                         *
                         * // Use the internal `print` function in "evaluate" delimiters.
                         * var compiled = _.template('<% print("hello " + user); %>!');
                         * compiled({ 'user': 'barney' });
                         * // => 'hello barney!'
                         *
                         * // Use the ES template literal delimiter as an "interpolate" delimiter.
                         * // Disable support by replacing the "interpolate" delimiter.
                         * var compiled = _.template('hello ${ user }!');
                         * compiled({ 'user': 'pebbles' });
                         * // => 'hello pebbles!'
                         *
                         * // Use backslashes to treat delimiters as plain text.
                         * var compiled = _.template('<%= "\\<%- value %\\>" %>');
                         * compiled({ 'value': 'ignored' });
                         * // => '<%- value %>'
                         *
                         * // Use the `imports` option to import `jQuery` as `jq`.
                         * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
                         * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
                         * compiled({ 'users': ['fred', 'barney'] });
                         * // => '<li>fred</li><li>barney</li>'
                         *
                         * // Use the `sourceURL` option to specify a custom sourceURL for the template.
                         * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
                         * compiled(data);
                         * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
                         *
                         * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
                         * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
                         * compiled.source;
                         * // => function(data) {
                         * //   var __t, __p = '';
                         * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
                         * //   return __p;
                         * // }
                         *
                         * // Use custom template delimiters.
                         * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
                         * var compiled = _.template('hello {{ user }}!');
                         * compiled({ 'user': 'mustache' });
                         * // => 'hello mustache!'
                         *
                         * // Use the `source` property to inline compiled templates for meaningful
                         * // line numbers in error messages and stack traces.
                         * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
                         *   var JST = {\
                         *     "main": ' + _.template(mainText).source + '\
                         *   };\
                         * ');
                         */
                        function template(string, options, guard) {
                            // Based on John Resig's `tmpl` implementation
                            // (http://ejohn.org/blog/javascript-micro-templating/)
                            // and Laura Doktorova's doT.js (https://github.com/olado/doT).
                            var settings = lodash.templateSettings;
                            if (guard && isIterateeCall(string, options, guard)) {
                                options = undefined;
                            }
                            string = toString(string);
                            options = assignInWith({}, options, settings, customDefaultsAssignIn);
                            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
                            var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
                            // Compile the regexp to match each delimiter.
                            var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' +
                                interpolate.source + '|' +
                                (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
                                (options.evaluate || reNoMatch).source + '|$', 'g');
                            // Use a sourceURL for easier debugging.
                            // The sourceURL gets injected into the source that's eval-ed, so be careful
                            // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
                            // and escape the comment, thus injecting code that gets evaled.
                            var sourceURL = '//# sourceURL=' +
                                (hasOwnProperty.call(options, 'sourceURL')
                                    ? (options.sourceURL + '').replace(/\s/g, ' ')
                                    : ('lodash.templateSources[' + (++templateCounter) + ']')) + '\n';
                            string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                                interpolateValue || (interpolateValue = esTemplateValue);
                                // Escape characters that can't be included in string literals.
                                source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                                // Replace delimiters with snippets.
                                if (escapeValue) {
                                    isEscaping = true;
                                    source += "' +\n__e(" + escapeValue + ") +\n'";
                                }
                                if (evaluateValue) {
                                    isEvaluating = true;
                                    source += "';\n" + evaluateValue + ";\n__p += '";
                                }
                                if (interpolateValue) {
                                    source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                                }
                                index = offset + match.length;
                                // The JS engine embedded in Adobe products needs `match` returned in
                                // order to produce the correct `offset` value.
                                return match;
                            });
                            source += "';\n";
                            // If `variable` is not specified wrap a with-statement around the generated
                            // code to add the data object to the top of the scope chain.
                            var variable = hasOwnProperty.call(options, 'variable') && options.variable;
                            if (!variable) {
                                source = 'with (obj) {\n' + source + '\n}\n';
                            }
                            // Throw an error if a forbidden character was found in `variable`, to prevent
                            // potential command injection attacks.
                            else if (reForbiddenIdentifierChars.test(variable)) {
                                throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
                            }
                            // Cleanup code by stripping empty strings.
                            source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
                                .replace(reEmptyStringMiddle, '$1')
                                .replace(reEmptyStringTrailing, '$1;');
                            // Frame code as the function body.
                            source = 'function(' + (variable || 'obj') + ') {\n' +
                                (variable
                                    ? ''
                                    : 'obj || (obj = {});\n') +
                                "var __t, __p = ''" +
                                (isEscaping
                                    ? ', __e = _.escape'
                                    : '') +
                                (isEvaluating
                                    ? ', __j = Array.prototype.join;\n' +
                                        "function print() { __p += __j.call(arguments, '') }\n"
                                    : ';\n') +
                                source +
                                'return __p\n}';
                            var result = attempt(function () {
                                return Function(importsKeys, sourceURL + 'return ' + source)
                                    .apply(undefined, importsValues);
                            });
                            // Provide the compiled function's source by its `toString` method or
                            // the `source` property as a convenience for inlining compiled templates.
                            result.source = source;
                            if (isError(result)) {
                                throw result;
                            }
                            return result;
                        }
                        /**
                         * Converts `string`, as a whole, to lower case just like
                         * [String#toLowerCase](https://mdn.io/toLowerCase).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to convert.
                         * @returns {string} Returns the lower cased string.
                         * @example
                         *
                         * _.toLower('--Foo-Bar--');
                         * // => '--foo-bar--'
                         *
                         * _.toLower('fooBar');
                         * // => 'foobar'
                         *
                         * _.toLower('__FOO_BAR__');
                         * // => '__foo_bar__'
                         */
                        function toLower(value) {
                            return toString(value).toLowerCase();
                        }
                        /**
                         * Converts `string`, as a whole, to upper case just like
                         * [String#toUpperCase](https://mdn.io/toUpperCase).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to convert.
                         * @returns {string} Returns the upper cased string.
                         * @example
                         *
                         * _.toUpper('--foo-bar--');
                         * // => '--FOO-BAR--'
                         *
                         * _.toUpper('fooBar');
                         * // => 'FOOBAR'
                         *
                         * _.toUpper('__foo_bar__');
                         * // => '__FOO_BAR__'
                         */
                        function toUpper(value) {
                            return toString(value).toUpperCase();
                        }
                        /**
                         * Removes leading and trailing whitespace or specified characters from `string`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to trim.
                         * @param {string} [chars=whitespace] The characters to trim.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {string} Returns the trimmed string.
                         * @example
                         *
                         * _.trim('  abc  ');
                         * // => 'abc'
                         *
                         * _.trim('-_-abc-_-', '_-');
                         * // => 'abc'
                         *
                         * _.map(['  foo  ', '  bar  '], _.trim);
                         * // => ['foo', 'bar']
                         */
                        function trim(string, chars, guard) {
                            string = toString(string);
                            if (string && (guard || chars === undefined)) {
                                return baseTrim(string);
                            }
                            if (!string || !(chars = baseToString(chars))) {
                                return string;
                            }
                            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
                            return castSlice(strSymbols, start, end).join('');
                        }
                        /**
                         * Removes trailing whitespace or specified characters from `string`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to trim.
                         * @param {string} [chars=whitespace] The characters to trim.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {string} Returns the trimmed string.
                         * @example
                         *
                         * _.trimEnd('  abc  ');
                         * // => '  abc'
                         *
                         * _.trimEnd('-_-abc-_-', '_-');
                         * // => '-_-abc'
                         */
                        function trimEnd(string, chars, guard) {
                            string = toString(string);
                            if (string && (guard || chars === undefined)) {
                                return string.slice(0, trimmedEndIndex(string) + 1);
                            }
                            if (!string || !(chars = baseToString(chars))) {
                                return string;
                            }
                            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
                            return castSlice(strSymbols, 0, end).join('');
                        }
                        /**
                         * Removes leading whitespace or specified characters from `string`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to trim.
                         * @param {string} [chars=whitespace] The characters to trim.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {string} Returns the trimmed string.
                         * @example
                         *
                         * _.trimStart('  abc  ');
                         * // => 'abc  '
                         *
                         * _.trimStart('-_-abc-_-', '_-');
                         * // => 'abc-_-'
                         */
                        function trimStart(string, chars, guard) {
                            string = toString(string);
                            if (string && (guard || chars === undefined)) {
                                return string.replace(reTrimStart, '');
                            }
                            if (!string || !(chars = baseToString(chars))) {
                                return string;
                            }
                            var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
                            return castSlice(strSymbols, start).join('');
                        }
                        /**
                         * Truncates `string` if it's longer than the given maximum string length.
                         * The last characters of the truncated string are replaced with the omission
                         * string which defaults to "...".
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to truncate.
                         * @param {Object} [options={}] The options object.
                         * @param {number} [options.length=30] The maximum string length.
                         * @param {string} [options.omission='...'] The string to indicate text is omitted.
                         * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
                         * @returns {string} Returns the truncated string.
                         * @example
                         *
                         * _.truncate('hi-diddly-ho there, neighborino');
                         * // => 'hi-diddly-ho there, neighbo...'
                         *
                         * _.truncate('hi-diddly-ho there, neighborino', {
                         *   'length': 24,
                         *   'separator': ' '
                         * });
                         * // => 'hi-diddly-ho there,...'
                         *
                         * _.truncate('hi-diddly-ho there, neighborino', {
                         *   'length': 24,
                         *   'separator': /,? +/
                         * });
                         * // => 'hi-diddly-ho there...'
                         *
                         * _.truncate('hi-diddly-ho there, neighborino', {
                         *   'omission': ' [...]'
                         * });
                         * // => 'hi-diddly-ho there, neig [...]'
                         */
                        function truncate(string, options) {
                            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
                            if (isObject(options)) {
                                var separator = 'separator' in options ? options.separator : separator;
                                length = 'length' in options ? toInteger(options.length) : length;
                                omission = 'omission' in options ? baseToString(options.omission) : omission;
                            }
                            string = toString(string);
                            var strLength = string.length;
                            if (hasUnicode(string)) {
                                var strSymbols = stringToArray(string);
                                strLength = strSymbols.length;
                            }
                            if (length >= strLength) {
                                return string;
                            }
                            var end = length - stringSize(omission);
                            if (end < 1) {
                                return omission;
                            }
                            var result = strSymbols
                                ? castSlice(strSymbols, 0, end).join('')
                                : string.slice(0, end);
                            if (separator === undefined) {
                                return result + omission;
                            }
                            if (strSymbols) {
                                end += (result.length - end);
                            }
                            if (isRegExp(separator)) {
                                if (string.slice(end).search(separator)) {
                                    var match, substring = result;
                                    if (!separator.global) {
                                        separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
                                    }
                                    separator.lastIndex = 0;
                                    while ((match = separator.exec(substring))) {
                                        var newEnd = match.index;
                                    }
                                    result = result.slice(0, newEnd === undefined ? end : newEnd);
                                }
                            }
                            else if (string.indexOf(baseToString(separator), end) != end) {
                                var index = result.lastIndexOf(separator);
                                if (index > -1) {
                                    result = result.slice(0, index);
                                }
                            }
                            return result + omission;
                        }
                        /**
                         * The inverse of `_.escape`; this method converts the HTML entities
                         * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
                         * their corresponding characters.
                         *
                         * **Note:** No other HTML entities are unescaped. To unescape additional
                         * HTML entities use a third-party library like [_he_](https://mths.be/he).
                         *
                         * @static
                         * @memberOf _
                         * @since 0.6.0
                         * @category String
                         * @param {string} [string=''] The string to unescape.
                         * @returns {string} Returns the unescaped string.
                         * @example
                         *
                         * _.unescape('fred, barney, &amp; pebbles');
                         * // => 'fred, barney, & pebbles'
                         */
                        function unescape(string) {
                            string = toString(string);
                            return (string && reHasEscapedHtml.test(string))
                                ? string.replace(reEscapedHtml, unescapeHtmlChar)
                                : string;
                        }
                        /**
                         * Converts `string`, as space separated words, to upper case.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to convert.
                         * @returns {string} Returns the upper cased string.
                         * @example
                         *
                         * _.upperCase('--foo-bar');
                         * // => 'FOO BAR'
                         *
                         * _.upperCase('fooBar');
                         * // => 'FOO BAR'
                         *
                         * _.upperCase('__foo_bar__');
                         * // => 'FOO BAR'
                         */
                        var upperCase = createCompounder(function (result, word, index) {
                            return result + (index ? ' ' : '') + word.toUpperCase();
                        });
                        /**
                         * Converts the first character of `string` to upper case.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category String
                         * @param {string} [string=''] The string to convert.
                         * @returns {string} Returns the converted string.
                         * @example
                         *
                         * _.upperFirst('fred');
                         * // => 'Fred'
                         *
                         * _.upperFirst('FRED');
                         * // => 'FRED'
                         */
                        var upperFirst = createCaseFirst('toUpperCase');
                        /**
                         * Splits `string` into an array of its words.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category String
                         * @param {string} [string=''] The string to inspect.
                         * @param {RegExp|string} [pattern] The pattern to match words.
                         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
                         * @returns {Array} Returns the words of `string`.
                         * @example
                         *
                         * _.words('fred, barney, & pebbles');
                         * // => ['fred', 'barney', 'pebbles']
                         *
                         * _.words('fred, barney, & pebbles', /[^, ]+/g);
                         * // => ['fred', 'barney', '&', 'pebbles']
                         */
                        function words(string, pattern, guard) {
                            string = toString(string);
                            pattern = guard ? undefined : pattern;
                            if (pattern === undefined) {
                                return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
                            }
                            return string.match(pattern) || [];
                        }
                        /*------------------------------------------------------------------------*/
                        /**
                         * Attempts to invoke `func`, returning either the result or the caught error
                         * object. Any additional arguments are provided to `func` when it's invoked.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Util
                         * @param {Function} func The function to attempt.
                         * @param {...*} [args] The arguments to invoke `func` with.
                         * @returns {*} Returns the `func` result or error object.
                         * @example
                         *
                         * // Avoid throwing errors for invalid selectors.
                         * var elements = _.attempt(function(selector) {
                         *   return document.querySelectorAll(selector);
                         * }, '>_>');
                         *
                         * if (_.isError(elements)) {
                         *   elements = [];
                         * }
                         */
                        var attempt = baseRest(function (func, args) {
                            try {
                                return apply(func, undefined, args);
                            }
                            catch (e) {
                                return isError(e) ? e : new Error(e);
                            }
                        });
                        /**
                         * Binds methods of an object to the object itself, overwriting the existing
                         * method.
                         *
                         * **Note:** This method doesn't set the "length" property of bound functions.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Util
                         * @param {Object} object The object to bind and assign the bound methods to.
                         * @param {...(string|string[])} methodNames The object method names to bind.
                         * @returns {Object} Returns `object`.
                         * @example
                         *
                         * var view = {
                         *   'label': 'docs',
                         *   'click': function() {
                         *     console.log('clicked ' + this.label);
                         *   }
                         * };
                         *
                         * _.bindAll(view, ['click']);
                         * jQuery(element).on('click', view.click);
                         * // => Logs 'clicked docs' when clicked.
                         */
                        var bindAll = flatRest(function (object, methodNames) {
                            arrayEach(methodNames, function (key) {
                                key = toKey(key);
                                baseAssignValue(object, key, bind(object[key], object));
                            });
                            return object;
                        });
                        /**
                         * Creates a function that iterates over `pairs` and invokes the corresponding
                         * function of the first predicate to return truthy. The predicate-function
                         * pairs are invoked with the `this` binding and arguments of the created
                         * function.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Util
                         * @param {Array} pairs The predicate-function pairs.
                         * @returns {Function} Returns the new composite function.
                         * @example
                         *
                         * var func = _.cond([
                         *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
                         *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
                         *   [_.stubTrue,                      _.constant('no match')]
                         * ]);
                         *
                         * func({ 'a': 1, 'b': 2 });
                         * // => 'matches A'
                         *
                         * func({ 'a': 0, 'b': 1 });
                         * // => 'matches B'
                         *
                         * func({ 'a': '1', 'b': '2' });
                         * // => 'no match'
                         */
                        function cond(pairs) {
                            var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
                            pairs = !length ? [] : arrayMap(pairs, function (pair) {
                                if (typeof pair[1] != 'function') {
                                    throw new TypeError(FUNC_ERROR_TEXT);
                                }
                                return [toIteratee(pair[0]), pair[1]];
                            });
                            return baseRest(function (args) {
                                var index = -1;
                                while (++index < length) {
                                    var pair = pairs[index];
                                    if (apply(pair[0], this, args)) {
                                        return apply(pair[1], this, args);
                                    }
                                }
                            });
                        }
                        /**
                         * Creates a function that invokes the predicate properties of `source` with
                         * the corresponding property values of a given object, returning `true` if
                         * all predicates return truthy, else `false`.
                         *
                         * **Note:** The created function is equivalent to `_.conformsTo` with
                         * `source` partially applied.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Util
                         * @param {Object} source The object of property predicates to conform to.
                         * @returns {Function} Returns the new spec function.
                         * @example
                         *
                         * var objects = [
                         *   { 'a': 2, 'b': 1 },
                         *   { 'a': 1, 'b': 2 }
                         * ];
                         *
                         * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
                         * // => [{ 'a': 1, 'b': 2 }]
                         */
                        function conforms(source) {
                            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
                        }
                        /**
                         * Creates a function that returns `value`.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.4.0
                         * @category Util
                         * @param {*} value The value to return from the new function.
                         * @returns {Function} Returns the new constant function.
                         * @example
                         *
                         * var objects = _.times(2, _.constant({ 'a': 1 }));
                         *
                         * console.log(objects);
                         * // => [{ 'a': 1 }, { 'a': 1 }]
                         *
                         * console.log(objects[0] === objects[1]);
                         * // => true
                         */
                        function constant(value) {
                            return function () {
                                return value;
                            };
                        }
                        /**
                         * Checks `value` to determine whether a default value should be returned in
                         * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
                         * or `undefined`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.14.0
                         * @category Util
                         * @param {*} value The value to check.
                         * @param {*} defaultValue The default value.
                         * @returns {*} Returns the resolved value.
                         * @example
                         *
                         * _.defaultTo(1, 10);
                         * // => 1
                         *
                         * _.defaultTo(undefined, 10);
                         * // => 10
                         */
                        function defaultTo(value, defaultValue) {
                            return (value == null || value !== value) ? defaultValue : value;
                        }
                        /**
                         * Creates a function that returns the result of invoking the given functions
                         * with the `this` binding of the created function, where each successive
                         * invocation is supplied the return value of the previous.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Util
                         * @param {...(Function|Function[])} [funcs] The functions to invoke.
                         * @returns {Function} Returns the new composite function.
                         * @see _.flowRight
                         * @example
                         *
                         * function square(n) {
                         *   return n * n;
                         * }
                         *
                         * var addSquare = _.flow([_.add, square]);
                         * addSquare(1, 2);
                         * // => 9
                         */
                        var flow = createFlow();
                        /**
                         * This method is like `_.flow` except that it creates a function that
                         * invokes the given functions from right to left.
                         *
                         * @static
                         * @since 3.0.0
                         * @memberOf _
                         * @category Util
                         * @param {...(Function|Function[])} [funcs] The functions to invoke.
                         * @returns {Function} Returns the new composite function.
                         * @see _.flow
                         * @example
                         *
                         * function square(n) {
                         *   return n * n;
                         * }
                         *
                         * var addSquare = _.flowRight([square, _.add]);
                         * addSquare(1, 2);
                         * // => 9
                         */
                        var flowRight = createFlow(true);
                        /**
                         * This method returns the first argument it receives.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Util
                         * @param {*} value Any value.
                         * @returns {*} Returns `value`.
                         * @example
                         *
                         * var object = { 'a': 1 };
                         *
                         * console.log(_.identity(object) === object);
                         * // => true
                         */
                        function identity(value) {
                            return value;
                        }
                        /**
                         * Creates a function that invokes `func` with the arguments of the created
                         * function. If `func` is a property name, the created function returns the
                         * property value for a given element. If `func` is an array or object, the
                         * created function returns `true` for elements that contain the equivalent
                         * source properties, otherwise it returns `false`.
                         *
                         * @static
                         * @since 4.0.0
                         * @memberOf _
                         * @category Util
                         * @param {*} [func=_.identity] The value to convert to a callback.
                         * @returns {Function} Returns the callback.
                         * @example
                         *
                         * var users = [
                         *   { 'user': 'barney', 'age': 36, 'active': true },
                         *   { 'user': 'fred',   'age': 40, 'active': false }
                         * ];
                         *
                         * // The `_.matches` iteratee shorthand.
                         * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
                         * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
                         *
                         * // The `_.matchesProperty` iteratee shorthand.
                         * _.filter(users, _.iteratee(['user', 'fred']));
                         * // => [{ 'user': 'fred', 'age': 40 }]
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.map(users, _.iteratee('user'));
                         * // => ['barney', 'fred']
                         *
                         * // Create custom iteratee shorthands.
                         * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
                         *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
                         *     return func.test(string);
                         *   };
                         * });
                         *
                         * _.filter(['abc', 'def'], /ef/);
                         * // => ['def']
                         */
                        function iteratee(func) {
                            return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
                        }
                        /**
                         * Creates a function that performs a partial deep comparison between a given
                         * object and `source`, returning `true` if the given object has equivalent
                         * property values, else `false`.
                         *
                         * **Note:** The created function is equivalent to `_.isMatch` with `source`
                         * partially applied.
                         *
                         * Partial comparisons will match empty array and empty object `source`
                         * values against any array or object value, respectively. See `_.isEqual`
                         * for a list of supported value comparisons.
                         *
                         * **Note:** Multiple values can be checked by combining several matchers
                         * using `_.overSome`
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Util
                         * @param {Object} source The object of property values to match.
                         * @returns {Function} Returns the new spec function.
                         * @example
                         *
                         * var objects = [
                         *   { 'a': 1, 'b': 2, 'c': 3 },
                         *   { 'a': 4, 'b': 5, 'c': 6 }
                         * ];
                         *
                         * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
                         * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
                         *
                         * // Checking for several possible values
                         * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
                         * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
                         */
                        function matches(source) {
                            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
                        }
                        /**
                         * Creates a function that performs a partial deep comparison between the
                         * value at `path` of a given object to `srcValue`, returning `true` if the
                         * object value is equivalent, else `false`.
                         *
                         * **Note:** Partial comparisons will match empty array and empty object
                         * `srcValue` values against any array or object value, respectively. See
                         * `_.isEqual` for a list of supported value comparisons.
                         *
                         * **Note:** Multiple values can be checked by combining several matchers
                         * using `_.overSome`
                         *
                         * @static
                         * @memberOf _
                         * @since 3.2.0
                         * @category Util
                         * @param {Array|string} path The path of the property to get.
                         * @param {*} srcValue The value to match.
                         * @returns {Function} Returns the new spec function.
                         * @example
                         *
                         * var objects = [
                         *   { 'a': 1, 'b': 2, 'c': 3 },
                         *   { 'a': 4, 'b': 5, 'c': 6 }
                         * ];
                         *
                         * _.find(objects, _.matchesProperty('a', 4));
                         * // => { 'a': 4, 'b': 5, 'c': 6 }
                         *
                         * // Checking for several possible values
                         * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
                         * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
                         */
                        function matchesProperty(path, srcValue) {
                            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
                        }
                        /**
                         * Creates a function that invokes the method at `path` of a given object.
                         * Any additional arguments are provided to the invoked method.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.7.0
                         * @category Util
                         * @param {Array|string} path The path of the method to invoke.
                         * @param {...*} [args] The arguments to invoke the method with.
                         * @returns {Function} Returns the new invoker function.
                         * @example
                         *
                         * var objects = [
                         *   { 'a': { 'b': _.constant(2) } },
                         *   { 'a': { 'b': _.constant(1) } }
                         * ];
                         *
                         * _.map(objects, _.method('a.b'));
                         * // => [2, 1]
                         *
                         * _.map(objects, _.method(['a', 'b']));
                         * // => [2, 1]
                         */
                        var method = baseRest(function (path, args) {
                            return function (object) {
                                return baseInvoke(object, path, args);
                            };
                        });
                        /**
                         * The opposite of `_.method`; this method creates a function that invokes
                         * the method at a given path of `object`. Any additional arguments are
                         * provided to the invoked method.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.7.0
                         * @category Util
                         * @param {Object} object The object to query.
                         * @param {...*} [args] The arguments to invoke the method with.
                         * @returns {Function} Returns the new invoker function.
                         * @example
                         *
                         * var array = _.times(3, _.constant),
                         *     object = { 'a': array, 'b': array, 'c': array };
                         *
                         * _.map(['a[2]', 'c[0]'], _.methodOf(object));
                         * // => [2, 0]
                         *
                         * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
                         * // => [2, 0]
                         */
                        var methodOf = baseRest(function (object, args) {
                            return function (path) {
                                return baseInvoke(object, path, args);
                            };
                        });
                        /**
                         * Adds all own enumerable string keyed function properties of a source
                         * object to the destination object. If `object` is a function, then methods
                         * are added to its prototype as well.
                         *
                         * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
                         * avoid conflicts caused by modifying the original.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Util
                         * @param {Function|Object} [object=lodash] The destination object.
                         * @param {Object} source The object of functions to add.
                         * @param {Object} [options={}] The options object.
                         * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
                         * @returns {Function|Object} Returns `object`.
                         * @example
                         *
                         * function vowels(string) {
                         *   return _.filter(string, function(v) {
                         *     return /[aeiou]/i.test(v);
                         *   });
                         * }
                         *
                         * _.mixin({ 'vowels': vowels });
                         * _.vowels('fred');
                         * // => ['e']
                         *
                         * _('fred').vowels().value();
                         * // => ['e']
                         *
                         * _.mixin({ 'vowels': vowels }, { 'chain': false });
                         * _('fred').vowels();
                         * // => ['e']
                         */
                        function mixin(object, source, options) {
                            var props = keys(source), methodNames = baseFunctions(source, props);
                            if (options == null &&
                                !(isObject(source) && (methodNames.length || !props.length))) {
                                options = source;
                                source = object;
                                object = this;
                                methodNames = baseFunctions(source, keys(source));
                            }
                            var chain = !(isObject(options) && 'chain' in options) || !!options.chain, isFunc = isFunction(object);
                            arrayEach(methodNames, function (methodName) {
                                var func = source[methodName];
                                object[methodName] = func;
                                if (isFunc) {
                                    object.prototype[methodName] = function () {
                                        var chainAll = this.__chain__;
                                        if (chain || chainAll) {
                                            var result = object(this.__wrapped__), actions = result.__actions__ = copyArray(this.__actions__);
                                            actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                                            result.__chain__ = chainAll;
                                            return result;
                                        }
                                        return func.apply(object, arrayPush([this.value()], arguments));
                                    };
                                }
                            });
                            return object;
                        }
                        /**
                         * Reverts the `_` variable to its previous value and returns a reference to
                         * the `lodash` function.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Util
                         * @returns {Function} Returns the `lodash` function.
                         * @example
                         *
                         * var lodash = _.noConflict();
                         */
                        function noConflict() {
                            if (root._ === this) {
                                root._ = oldDash;
                            }
                            return this;
                        }
                        /**
                         * This method returns `undefined`.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.3.0
                         * @category Util
                         * @example
                         *
                         * _.times(2, _.noop);
                         * // => [undefined, undefined]
                         */
                        function noop() {
                            // No operation performed.
                        }
                        /**
                         * Creates a function that gets the argument at index `n`. If `n` is negative,
                         * the nth argument from the end is returned.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Util
                         * @param {number} [n=0] The index of the argument to return.
                         * @returns {Function} Returns the new pass-thru function.
                         * @example
                         *
                         * var func = _.nthArg(1);
                         * func('a', 'b', 'c', 'd');
                         * // => 'b'
                         *
                         * var func = _.nthArg(-2);
                         * func('a', 'b', 'c', 'd');
                         * // => 'c'
                         */
                        function nthArg(n) {
                            n = toInteger(n);
                            return baseRest(function (args) {
                                return baseNth(args, n);
                            });
                        }
                        /**
                         * Creates a function that invokes `iteratees` with the arguments it receives
                         * and returns their results.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Util
                         * @param {...(Function|Function[])} [iteratees=[_.identity]]
                         *  The iteratees to invoke.
                         * @returns {Function} Returns the new function.
                         * @example
                         *
                         * var func = _.over([Math.max, Math.min]);
                         *
                         * func(1, 2, 3, 4);
                         * // => [4, 1]
                         */
                        var over = createOver(arrayMap);
                        /**
                         * Creates a function that checks if **all** of the `predicates` return
                         * truthy when invoked with the arguments it receives.
                         *
                         * Following shorthands are possible for providing predicates.
                         * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
                         * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Util
                         * @param {...(Function|Function[])} [predicates=[_.identity]]
                         *  The predicates to check.
                         * @returns {Function} Returns the new function.
                         * @example
                         *
                         * var func = _.overEvery([Boolean, isFinite]);
                         *
                         * func('1');
                         * // => true
                         *
                         * func(null);
                         * // => false
                         *
                         * func(NaN);
                         * // => false
                         */
                        var overEvery = createOver(arrayEvery);
                        /**
                         * Creates a function that checks if **any** of the `predicates` return
                         * truthy when invoked with the arguments it receives.
                         *
                         * Following shorthands are possible for providing predicates.
                         * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
                         * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Util
                         * @param {...(Function|Function[])} [predicates=[_.identity]]
                         *  The predicates to check.
                         * @returns {Function} Returns the new function.
                         * @example
                         *
                         * var func = _.overSome([Boolean, isFinite]);
                         *
                         * func('1');
                         * // => true
                         *
                         * func(null);
                         * // => true
                         *
                         * func(NaN);
                         * // => false
                         *
                         * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
                         * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
                         */
                        var overSome = createOver(arraySome);
                        /**
                         * Creates a function that returns the value at `path` of a given object.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.4.0
                         * @category Util
                         * @param {Array|string} path The path of the property to get.
                         * @returns {Function} Returns the new accessor function.
                         * @example
                         *
                         * var objects = [
                         *   { 'a': { 'b': 2 } },
                         *   { 'a': { 'b': 1 } }
                         * ];
                         *
                         * _.map(objects, _.property('a.b'));
                         * // => [2, 1]
                         *
                         * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
                         * // => [1, 2]
                         */
                        function property(path) {
                            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
                        }
                        /**
                         * The opposite of `_.property`; this method creates a function that returns
                         * the value at a given path of `object`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Util
                         * @param {Object} object The object to query.
                         * @returns {Function} Returns the new accessor function.
                         * @example
                         *
                         * var array = [0, 1, 2],
                         *     object = { 'a': array, 'b': array, 'c': array };
                         *
                         * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
                         * // => [2, 0]
                         *
                         * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
                         * // => [2, 0]
                         */
                        function propertyOf(object) {
                            return function (path) {
                                return object == null ? undefined : baseGet(object, path);
                            };
                        }
                        /**
                         * Creates an array of numbers (positive and/or negative) progressing from
                         * `start` up to, but not including, `end`. A step of `-1` is used if a negative
                         * `start` is specified without an `end` or `step`. If `end` is not specified,
                         * it's set to `start` with `start` then set to `0`.
                         *
                         * **Note:** JavaScript follows the IEEE-754 standard for resolving
                         * floating-point values which can produce unexpected results.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Util
                         * @param {number} [start=0] The start of the range.
                         * @param {number} end The end of the range.
                         * @param {number} [step=1] The value to increment or decrement by.
                         * @returns {Array} Returns the range of numbers.
                         * @see _.inRange, _.rangeRight
                         * @example
                         *
                         * _.range(4);
                         * // => [0, 1, 2, 3]
                         *
                         * _.range(-4);
                         * // => [0, -1, -2, -3]
                         *
                         * _.range(1, 5);
                         * // => [1, 2, 3, 4]
                         *
                         * _.range(0, 20, 5);
                         * // => [0, 5, 10, 15]
                         *
                         * _.range(0, -4, -1);
                         * // => [0, -1, -2, -3]
                         *
                         * _.range(1, 4, 0);
                         * // => [1, 1, 1]
                         *
                         * _.range(0);
                         * // => []
                         */
                        var range = createRange();
                        /**
                         * This method is like `_.range` except that it populates values in
                         * descending order.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Util
                         * @param {number} [start=0] The start of the range.
                         * @param {number} end The end of the range.
                         * @param {number} [step=1] The value to increment or decrement by.
                         * @returns {Array} Returns the range of numbers.
                         * @see _.inRange, _.range
                         * @example
                         *
                         * _.rangeRight(4);
                         * // => [3, 2, 1, 0]
                         *
                         * _.rangeRight(-4);
                         * // => [-3, -2, -1, 0]
                         *
                         * _.rangeRight(1, 5);
                         * // => [4, 3, 2, 1]
                         *
                         * _.rangeRight(0, 20, 5);
                         * // => [15, 10, 5, 0]
                         *
                         * _.rangeRight(0, -4, -1);
                         * // => [-3, -2, -1, 0]
                         *
                         * _.rangeRight(1, 4, 0);
                         * // => [1, 1, 1]
                         *
                         * _.rangeRight(0);
                         * // => []
                         */
                        var rangeRight = createRange(true);
                        /**
                         * This method returns a new empty array.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.13.0
                         * @category Util
                         * @returns {Array} Returns the new empty array.
                         * @example
                         *
                         * var arrays = _.times(2, _.stubArray);
                         *
                         * console.log(arrays);
                         * // => [[], []]
                         *
                         * console.log(arrays[0] === arrays[1]);
                         * // => false
                         */
                        function stubArray() {
                            return [];
                        }
                        /**
                         * This method returns `false`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.13.0
                         * @category Util
                         * @returns {boolean} Returns `false`.
                         * @example
                         *
                         * _.times(2, _.stubFalse);
                         * // => [false, false]
                         */
                        function stubFalse() {
                            return false;
                        }
                        /**
                         * This method returns a new empty object.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.13.0
                         * @category Util
                         * @returns {Object} Returns the new empty object.
                         * @example
                         *
                         * var objects = _.times(2, _.stubObject);
                         *
                         * console.log(objects);
                         * // => [{}, {}]
                         *
                         * console.log(objects[0] === objects[1]);
                         * // => false
                         */
                        function stubObject() {
                            return {};
                        }
                        /**
                         * This method returns an empty string.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.13.0
                         * @category Util
                         * @returns {string} Returns the empty string.
                         * @example
                         *
                         * _.times(2, _.stubString);
                         * // => ['', '']
                         */
                        function stubString() {
                            return '';
                        }
                        /**
                         * This method returns `true`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.13.0
                         * @category Util
                         * @returns {boolean} Returns `true`.
                         * @example
                         *
                         * _.times(2, _.stubTrue);
                         * // => [true, true]
                         */
                        function stubTrue() {
                            return true;
                        }
                        /**
                         * Invokes the iteratee `n` times, returning an array of the results of
                         * each invocation. The iteratee is invoked with one argument; (index).
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Util
                         * @param {number} n The number of times to invoke `iteratee`.
                         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                         * @returns {Array} Returns the array of results.
                         * @example
                         *
                         * _.times(3, String);
                         * // => ['0', '1', '2']
                         *
                         *  _.times(4, _.constant(0));
                         * // => [0, 0, 0, 0]
                         */
                        function times(n, iteratee) {
                            n = toInteger(n);
                            if (n < 1 || n > MAX_SAFE_INTEGER) {
                                return [];
                            }
                            var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
                            iteratee = getIteratee(iteratee);
                            n -= MAX_ARRAY_LENGTH;
                            var result = baseTimes(length, iteratee);
                            while (++index < n) {
                                iteratee(index);
                            }
                            return result;
                        }
                        /**
                         * Converts `value` to a property path array.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Util
                         * @param {*} value The value to convert.
                         * @returns {Array} Returns the new property path array.
                         * @example
                         *
                         * _.toPath('a.b.c');
                         * // => ['a', 'b', 'c']
                         *
                         * _.toPath('a[0].b.c');
                         * // => ['a', '0', 'b', 'c']
                         */
                        function toPath(value) {
                            if (isArray(value)) {
                                return arrayMap(value, toKey);
                            }
                            return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
                        }
                        /**
                         * Generates a unique ID. If `prefix` is given, the ID is appended to it.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Util
                         * @param {string} [prefix=''] The value to prefix the ID with.
                         * @returns {string} Returns the unique ID.
                         * @example
                         *
                         * _.uniqueId('contact_');
                         * // => 'contact_104'
                         *
                         * _.uniqueId();
                         * // => '105'
                         */
                        function uniqueId(prefix) {
                            var id = ++idCounter;
                            return toString(prefix) + id;
                        }
                        /*------------------------------------------------------------------------*/
                        /**
                         * Adds two numbers.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.4.0
                         * @category Math
                         * @param {number} augend The first number in an addition.
                         * @param {number} addend The second number in an addition.
                         * @returns {number} Returns the total.
                         * @example
                         *
                         * _.add(6, 4);
                         * // => 10
                         */
                        var add = createMathOperation(function (augend, addend) {
                            return augend + addend;
                        }, 0);
                        /**
                         * Computes `number` rounded up to `precision`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.10.0
                         * @category Math
                         * @param {number} number The number to round up.
                         * @param {number} [precision=0] The precision to round up to.
                         * @returns {number} Returns the rounded up number.
                         * @example
                         *
                         * _.ceil(4.006);
                         * // => 5
                         *
                         * _.ceil(6.004, 2);
                         * // => 6.01
                         *
                         * _.ceil(6040, -2);
                         * // => 6100
                         */
                        var ceil = createRound('ceil');
                        /**
                         * Divide two numbers.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.7.0
                         * @category Math
                         * @param {number} dividend The first number in a division.
                         * @param {number} divisor The second number in a division.
                         * @returns {number} Returns the quotient.
                         * @example
                         *
                         * _.divide(6, 4);
                         * // => 1.5
                         */
                        var divide = createMathOperation(function (dividend, divisor) {
                            return dividend / divisor;
                        }, 1);
                        /**
                         * Computes `number` rounded down to `precision`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.10.0
                         * @category Math
                         * @param {number} number The number to round down.
                         * @param {number} [precision=0] The precision to round down to.
                         * @returns {number} Returns the rounded down number.
                         * @example
                         *
                         * _.floor(4.006);
                         * // => 4
                         *
                         * _.floor(0.046, 2);
                         * // => 0.04
                         *
                         * _.floor(4060, -2);
                         * // => 4000
                         */
                        var floor = createRound('floor');
                        /**
                         * Computes the maximum value of `array`. If `array` is empty or falsey,
                         * `undefined` is returned.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Math
                         * @param {Array} array The array to iterate over.
                         * @returns {*} Returns the maximum value.
                         * @example
                         *
                         * _.max([4, 2, 8, 6]);
                         * // => 8
                         *
                         * _.max([]);
                         * // => undefined
                         */
                        function max(array) {
                            return (array && array.length)
                                ? baseExtremum(array, identity, baseGt)
                                : undefined;
                        }
                        /**
                         * This method is like `_.max` except that it accepts `iteratee` which is
                         * invoked for each element in `array` to generate the criterion by which
                         * the value is ranked. The iteratee is invoked with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Math
                         * @param {Array} array The array to iterate over.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {*} Returns the maximum value.
                         * @example
                         *
                         * var objects = [{ 'n': 1 }, { 'n': 2 }];
                         *
                         * _.maxBy(objects, function(o) { return o.n; });
                         * // => { 'n': 2 }
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.maxBy(objects, 'n');
                         * // => { 'n': 2 }
                         */
                        function maxBy(array, iteratee) {
                            return (array && array.length)
                                ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
                                : undefined;
                        }
                        /**
                         * Computes the mean of the values in `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Math
                         * @param {Array} array The array to iterate over.
                         * @returns {number} Returns the mean.
                         * @example
                         *
                         * _.mean([4, 2, 8, 6]);
                         * // => 5
                         */
                        function mean(array) {
                            return baseMean(array, identity);
                        }
                        /**
                         * This method is like `_.mean` except that it accepts `iteratee` which is
                         * invoked for each element in `array` to generate the value to be averaged.
                         * The iteratee is invoked with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.7.0
                         * @category Math
                         * @param {Array} array The array to iterate over.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {number} Returns the mean.
                         * @example
                         *
                         * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
                         *
                         * _.meanBy(objects, function(o) { return o.n; });
                         * // => 5
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.meanBy(objects, 'n');
                         * // => 5
                         */
                        function meanBy(array, iteratee) {
                            return baseMean(array, getIteratee(iteratee, 2));
                        }
                        /**
                         * Computes the minimum value of `array`. If `array` is empty or falsey,
                         * `undefined` is returned.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Math
                         * @param {Array} array The array to iterate over.
                         * @returns {*} Returns the minimum value.
                         * @example
                         *
                         * _.min([4, 2, 8, 6]);
                         * // => 2
                         *
                         * _.min([]);
                         * // => undefined
                         */
                        function min(array) {
                            return (array && array.length)
                                ? baseExtremum(array, identity, baseLt)
                                : undefined;
                        }
                        /**
                         * This method is like `_.min` except that it accepts `iteratee` which is
                         * invoked for each element in `array` to generate the criterion by which
                         * the value is ranked. The iteratee is invoked with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Math
                         * @param {Array} array The array to iterate over.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {*} Returns the minimum value.
                         * @example
                         *
                         * var objects = [{ 'n': 1 }, { 'n': 2 }];
                         *
                         * _.minBy(objects, function(o) { return o.n; });
                         * // => { 'n': 1 }
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.minBy(objects, 'n');
                         * // => { 'n': 1 }
                         */
                        function minBy(array, iteratee) {
                            return (array && array.length)
                                ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
                                : undefined;
                        }
                        /**
                         * Multiply two numbers.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.7.0
                         * @category Math
                         * @param {number} multiplier The first number in a multiplication.
                         * @param {number} multiplicand The second number in a multiplication.
                         * @returns {number} Returns the product.
                         * @example
                         *
                         * _.multiply(6, 4);
                         * // => 24
                         */
                        var multiply = createMathOperation(function (multiplier, multiplicand) {
                            return multiplier * multiplicand;
                        }, 1);
                        /**
                         * Computes `number` rounded to `precision`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.10.0
                         * @category Math
                         * @param {number} number The number to round.
                         * @param {number} [precision=0] The precision to round to.
                         * @returns {number} Returns the rounded number.
                         * @example
                         *
                         * _.round(4.006);
                         * // => 4
                         *
                         * _.round(4.006, 2);
                         * // => 4.01
                         *
                         * _.round(4060, -2);
                         * // => 4100
                         */
                        var round = createRound('round');
                        /**
                         * Subtract two numbers.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Math
                         * @param {number} minuend The first number in a subtraction.
                         * @param {number} subtrahend The second number in a subtraction.
                         * @returns {number} Returns the difference.
                         * @example
                         *
                         * _.subtract(6, 4);
                         * // => 2
                         */
                        var subtract = createMathOperation(function (minuend, subtrahend) {
                            return minuend - subtrahend;
                        }, 0);
                        /**
                         * Computes the sum of the values in `array`.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.4.0
                         * @category Math
                         * @param {Array} array The array to iterate over.
                         * @returns {number} Returns the sum.
                         * @example
                         *
                         * _.sum([4, 2, 8, 6]);
                         * // => 20
                         */
                        function sum(array) {
                            return (array && array.length)
                                ? baseSum(array, identity)
                                : 0;
                        }
                        /**
                         * This method is like `_.sum` except that it accepts `iteratee` which is
                         * invoked for each element in `array` to generate the value to be summed.
                         * The iteratee is invoked with one argument: (value).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Math
                         * @param {Array} array The array to iterate over.
                         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
                         * @returns {number} Returns the sum.
                         * @example
                         *
                         * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
                         *
                         * _.sumBy(objects, function(o) { return o.n; });
                         * // => 20
                         *
                         * // The `_.property` iteratee shorthand.
                         * _.sumBy(objects, 'n');
                         * // => 20
                         */
                        function sumBy(array, iteratee) {
                            return (array && array.length)
                                ? baseSum(array, getIteratee(iteratee, 2))
                                : 0;
                        }
                        /*------------------------------------------------------------------------*/
                        // Add methods that return wrapped values in chain sequences.
                        lodash.after = after;
                        lodash.ary = ary;
                        lodash.assign = assign;
                        lodash.assignIn = assignIn;
                        lodash.assignInWith = assignInWith;
                        lodash.assignWith = assignWith;
                        lodash.at = at;
                        lodash.before = before;
                        lodash.bind = bind;
                        lodash.bindAll = bindAll;
                        lodash.bindKey = bindKey;
                        lodash.castArray = castArray;
                        lodash.chain = chain;
                        lodash.chunk = chunk;
                        lodash.compact = compact;
                        lodash.concat = concat;
                        lodash.cond = cond;
                        lodash.conforms = conforms;
                        lodash.constant = constant;
                        lodash.countBy = countBy;
                        lodash.create = create;
                        lodash.curry = curry;
                        lodash.curryRight = curryRight;
                        lodash.debounce = debounce;
                        lodash.defaults = defaults;
                        lodash.defaultsDeep = defaultsDeep;
                        lodash.defer = defer;
                        lodash.delay = delay;
                        lodash.difference = difference;
                        lodash.differenceBy = differenceBy;
                        lodash.differenceWith = differenceWith;
                        lodash.drop = drop;
                        lodash.dropRight = dropRight;
                        lodash.dropRightWhile = dropRightWhile;
                        lodash.dropWhile = dropWhile;
                        lodash.fill = fill;
                        lodash.filter = filter;
                        lodash.flatMap = flatMap;
                        lodash.flatMapDeep = flatMapDeep;
                        lodash.flatMapDepth = flatMapDepth;
                        lodash.flatten = flatten;
                        lodash.flattenDeep = flattenDeep;
                        lodash.flattenDepth = flattenDepth;
                        lodash.flip = flip;
                        lodash.flow = flow;
                        lodash.flowRight = flowRight;
                        lodash.fromPairs = fromPairs;
                        lodash.functions = functions;
                        lodash.functionsIn = functionsIn;
                        lodash.groupBy = groupBy;
                        lodash.initial = initial;
                        lodash.intersection = intersection;
                        lodash.intersectionBy = intersectionBy;
                        lodash.intersectionWith = intersectionWith;
                        lodash.invert = invert;
                        lodash.invertBy = invertBy;
                        lodash.invokeMap = invokeMap;
                        lodash.iteratee = iteratee;
                        lodash.keyBy = keyBy;
                        lodash.keys = keys;
                        lodash.keysIn = keysIn;
                        lodash.map = map;
                        lodash.mapKeys = mapKeys;
                        lodash.mapValues = mapValues;
                        lodash.matches = matches;
                        lodash.matchesProperty = matchesProperty;
                        lodash.memoize = memoize;
                        lodash.merge = merge;
                        lodash.mergeWith = mergeWith;
                        lodash.method = method;
                        lodash.methodOf = methodOf;
                        lodash.mixin = mixin;
                        lodash.negate = negate;
                        lodash.nthArg = nthArg;
                        lodash.omit = omit;
                        lodash.omitBy = omitBy;
                        lodash.once = once;
                        lodash.orderBy = orderBy;
                        lodash.over = over;
                        lodash.overArgs = overArgs;
                        lodash.overEvery = overEvery;
                        lodash.overSome = overSome;
                        lodash.partial = partial;
                        lodash.partialRight = partialRight;
                        lodash.partition = partition;
                        lodash.pick = pick;
                        lodash.pickBy = pickBy;
                        lodash.property = property;
                        lodash.propertyOf = propertyOf;
                        lodash.pull = pull;
                        lodash.pullAll = pullAll;
                        lodash.pullAllBy = pullAllBy;
                        lodash.pullAllWith = pullAllWith;
                        lodash.pullAt = pullAt;
                        lodash.range = range;
                        lodash.rangeRight = rangeRight;
                        lodash.rearg = rearg;
                        lodash.reject = reject;
                        lodash.remove = remove;
                        lodash.rest = rest;
                        lodash.reverse = reverse;
                        lodash.sampleSize = sampleSize;
                        lodash.set = set;
                        lodash.setWith = setWith;
                        lodash.shuffle = shuffle;
                        lodash.slice = slice;
                        lodash.sortBy = sortBy;
                        lodash.sortedUniq = sortedUniq;
                        lodash.sortedUniqBy = sortedUniqBy;
                        lodash.split = split;
                        lodash.spread = spread;
                        lodash.tail = tail;
                        lodash.take = take;
                        lodash.takeRight = takeRight;
                        lodash.takeRightWhile = takeRightWhile;
                        lodash.takeWhile = takeWhile;
                        lodash.tap = tap;
                        lodash.throttle = throttle;
                        lodash.thru = thru;
                        lodash.toArray = toArray;
                        lodash.toPairs = toPairs;
                        lodash.toPairsIn = toPairsIn;
                        lodash.toPath = toPath;
                        lodash.toPlainObject = toPlainObject;
                        lodash.transform = transform;
                        lodash.unary = unary;
                        lodash.union = union;
                        lodash.unionBy = unionBy;
                        lodash.unionWith = unionWith;
                        lodash.uniq = uniq;
                        lodash.uniqBy = uniqBy;
                        lodash.uniqWith = uniqWith;
                        lodash.unset = unset;
                        lodash.unzip = unzip;
                        lodash.unzipWith = unzipWith;
                        lodash.update = update;
                        lodash.updateWith = updateWith;
                        lodash.values = values;
                        lodash.valuesIn = valuesIn;
                        lodash.without = without;
                        lodash.words = words;
                        lodash.wrap = wrap;
                        lodash.xor = xor;
                        lodash.xorBy = xorBy;
                        lodash.xorWith = xorWith;
                        lodash.zip = zip;
                        lodash.zipObject = zipObject;
                        lodash.zipObjectDeep = zipObjectDeep;
                        lodash.zipWith = zipWith;
                        // Add aliases.
                        lodash.entries = toPairs;
                        lodash.entriesIn = toPairsIn;
                        lodash.extend = assignIn;
                        lodash.extendWith = assignInWith;
                        // Add methods to `lodash.prototype`.
                        mixin(lodash, lodash);
                        /*------------------------------------------------------------------------*/
                        // Add methods that return unwrapped values in chain sequences.
                        lodash.add = add;
                        lodash.attempt = attempt;
                        lodash.camelCase = camelCase;
                        lodash.capitalize = capitalize;
                        lodash.ceil = ceil;
                        lodash.clamp = clamp;
                        lodash.clone = clone;
                        lodash.cloneDeep = cloneDeep;
                        lodash.cloneDeepWith = cloneDeepWith;
                        lodash.cloneWith = cloneWith;
                        lodash.conformsTo = conformsTo;
                        lodash.deburr = deburr;
                        lodash.defaultTo = defaultTo;
                        lodash.divide = divide;
                        lodash.endsWith = endsWith;
                        lodash.eq = eq;
                        lodash.escape = escape;
                        lodash.escapeRegExp = escapeRegExp;
                        lodash.every = every;
                        lodash.find = find;
                        lodash.findIndex = findIndex;
                        lodash.findKey = findKey;
                        lodash.findLast = findLast;
                        lodash.findLastIndex = findLastIndex;
                        lodash.findLastKey = findLastKey;
                        lodash.floor = floor;
                        lodash.forEach = forEach;
                        lodash.forEachRight = forEachRight;
                        lodash.forIn = forIn;
                        lodash.forInRight = forInRight;
                        lodash.forOwn = forOwn;
                        lodash.forOwnRight = forOwnRight;
                        lodash.get = get;
                        lodash.gt = gt;
                        lodash.gte = gte;
                        lodash.has = has;
                        lodash.hasIn = hasIn;
                        lodash.head = head;
                        lodash.identity = identity;
                        lodash.includes = includes;
                        lodash.indexOf = indexOf;
                        lodash.inRange = inRange;
                        lodash.invoke = invoke;
                        lodash.isArguments = isArguments;
                        lodash.isArray = isArray;
                        lodash.isArrayBuffer = isArrayBuffer;
                        lodash.isArrayLike = isArrayLike;
                        lodash.isArrayLikeObject = isArrayLikeObject;
                        lodash.isBoolean = isBoolean;
                        lodash.isBuffer = isBuffer;
                        lodash.isDate = isDate;
                        lodash.isElement = isElement;
                        lodash.isEmpty = isEmpty;
                        lodash.isEqual = isEqual;
                        lodash.isEqualWith = isEqualWith;
                        lodash.isError = isError;
                        lodash.isFinite = isFinite;
                        lodash.isFunction = isFunction;
                        lodash.isInteger = isInteger;
                        lodash.isLength = isLength;
                        lodash.isMap = isMap;
                        lodash.isMatch = isMatch;
                        lodash.isMatchWith = isMatchWith;
                        lodash.isNaN = isNaN;
                        lodash.isNative = isNative;
                        lodash.isNil = isNil;
                        lodash.isNull = isNull;
                        lodash.isNumber = isNumber;
                        lodash.isObject = isObject;
                        lodash.isObjectLike = isObjectLike;
                        lodash.isPlainObject = isPlainObject;
                        lodash.isRegExp = isRegExp;
                        lodash.isSafeInteger = isSafeInteger;
                        lodash.isSet = isSet;
                        lodash.isString = isString;
                        lodash.isSymbol = isSymbol;
                        lodash.isTypedArray = isTypedArray;
                        lodash.isUndefined = isUndefined;
                        lodash.isWeakMap = isWeakMap;
                        lodash.isWeakSet = isWeakSet;
                        lodash.join = join;
                        lodash.kebabCase = kebabCase;
                        lodash.last = last;
                        lodash.lastIndexOf = lastIndexOf;
                        lodash.lowerCase = lowerCase;
                        lodash.lowerFirst = lowerFirst;
                        lodash.lt = lt;
                        lodash.lte = lte;
                        lodash.max = max;
                        lodash.maxBy = maxBy;
                        lodash.mean = mean;
                        lodash.meanBy = meanBy;
                        lodash.min = min;
                        lodash.minBy = minBy;
                        lodash.stubArray = stubArray;
                        lodash.stubFalse = stubFalse;
                        lodash.stubObject = stubObject;
                        lodash.stubString = stubString;
                        lodash.stubTrue = stubTrue;
                        lodash.multiply = multiply;
                        lodash.nth = nth;
                        lodash.noConflict = noConflict;
                        lodash.noop = noop;
                        lodash.now = now;
                        lodash.pad = pad;
                        lodash.padEnd = padEnd;
                        lodash.padStart = padStart;
                        lodash.parseInt = parseInt;
                        lodash.random = random;
                        lodash.reduce = reduce;
                        lodash.reduceRight = reduceRight;
                        lodash.repeat = repeat;
                        lodash.replace = replace;
                        lodash.result = result;
                        lodash.round = round;
                        lodash.runInContext = runInContext;
                        lodash.sample = sample;
                        lodash.size = size;
                        lodash.snakeCase = snakeCase;
                        lodash.some = some;
                        lodash.sortedIndex = sortedIndex;
                        lodash.sortedIndexBy = sortedIndexBy;
                        lodash.sortedIndexOf = sortedIndexOf;
                        lodash.sortedLastIndex = sortedLastIndex;
                        lodash.sortedLastIndexBy = sortedLastIndexBy;
                        lodash.sortedLastIndexOf = sortedLastIndexOf;
                        lodash.startCase = startCase;
                        lodash.startsWith = startsWith;
                        lodash.subtract = subtract;
                        lodash.sum = sum;
                        lodash.sumBy = sumBy;
                        lodash.template = template;
                        lodash.times = times;
                        lodash.toFinite = toFinite;
                        lodash.toInteger = toInteger;
                        lodash.toLength = toLength;
                        lodash.toLower = toLower;
                        lodash.toNumber = toNumber;
                        lodash.toSafeInteger = toSafeInteger;
                        lodash.toString = toString;
                        lodash.toUpper = toUpper;
                        lodash.trim = trim;
                        lodash.trimEnd = trimEnd;
                        lodash.trimStart = trimStart;
                        lodash.truncate = truncate;
                        lodash.unescape = unescape;
                        lodash.uniqueId = uniqueId;
                        lodash.upperCase = upperCase;
                        lodash.upperFirst = upperFirst;
                        // Add aliases.
                        lodash.each = forEach;
                        lodash.eachRight = forEachRight;
                        lodash.first = head;
                        mixin(lodash, (function () {
                            var source = {};
                            baseForOwn(lodash, function (func, methodName) {
                                if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                                    source[methodName] = func;
                                }
                            });
                            return source;
                        }()), { 'chain': false });
                        /*------------------------------------------------------------------------*/
                        /**
                         * The semantic version number.
                         *
                         * @static
                         * @memberOf _
                         * @type {string}
                         */
                        lodash.VERSION = VERSION;
                        // Assign default placeholders.
                        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function (methodName) {
                            lodash[methodName].placeholder = lodash;
                        });
                        // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
                        arrayEach(['drop', 'take'], function (methodName, index) {
                            LazyWrapper.prototype[methodName] = function (n) {
                                n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
                                var result = (this.__filtered__ && !index)
                                    ? new LazyWrapper(this)
                                    : this.clone();
                                if (result.__filtered__) {
                                    result.__takeCount__ = nativeMin(n, result.__takeCount__);
                                }
                                else {
                                    result.__views__.push({
                                        'size': nativeMin(n, MAX_ARRAY_LENGTH),
                                        'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
                                    });
                                }
                                return result;
                            };
                            LazyWrapper.prototype[methodName + 'Right'] = function (n) {
                                return this.reverse()[methodName](n).reverse();
                            };
                        });
                        // Add `LazyWrapper` methods that accept an `iteratee` value.
                        arrayEach(['filter', 'map', 'takeWhile'], function (methodName, index) {
                            var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
                            LazyWrapper.prototype[methodName] = function (iteratee) {
                                var result = this.clone();
                                result.__iteratees__.push({
                                    'iteratee': getIteratee(iteratee, 3),
                                    'type': type
                                });
                                result.__filtered__ = result.__filtered__ || isFilter;
                                return result;
                            };
                        });
                        // Add `LazyWrapper` methods for `_.head` and `_.last`.
                        arrayEach(['head', 'last'], function (methodName, index) {
                            var takeName = 'take' + (index ? 'Right' : '');
                            LazyWrapper.prototype[methodName] = function () {
                                return this[takeName](1).value()[0];
                            };
                        });
                        // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
                        arrayEach(['initial', 'tail'], function (methodName, index) {
                            var dropName = 'drop' + (index ? '' : 'Right');
                            LazyWrapper.prototype[methodName] = function () {
                                return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                            };
                        });
                        LazyWrapper.prototype.compact = function () {
                            return this.filter(identity);
                        };
                        LazyWrapper.prototype.find = function (predicate) {
                            return this.filter(predicate).head();
                        };
                        LazyWrapper.prototype.findLast = function (predicate) {
                            return this.reverse().find(predicate);
                        };
                        LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {
                            if (typeof path == 'function') {
                                return new LazyWrapper(this);
                            }
                            return this.map(function (value) {
                                return baseInvoke(value, path, args);
                            });
                        });
                        LazyWrapper.prototype.reject = function (predicate) {
                            return this.filter(negate(getIteratee(predicate)));
                        };
                        LazyWrapper.prototype.slice = function (start, end) {
                            start = toInteger(start);
                            var result = this;
                            if (result.__filtered__ && (start > 0 || end < 0)) {
                                return new LazyWrapper(result);
                            }
                            if (start < 0) {
                                result = result.takeRight(-start);
                            }
                            else if (start) {
                                result = result.drop(start);
                            }
                            if (end !== undefined) {
                                end = toInteger(end);
                                result = end < 0 ? result.dropRight(-end) : result.take(end - start);
                            }
                            return result;
                        };
                        LazyWrapper.prototype.takeRightWhile = function (predicate) {
                            return this.reverse().takeWhile(predicate).reverse();
                        };
                        LazyWrapper.prototype.toArray = function () {
                            return this.take(MAX_ARRAY_LENGTH);
                        };
                        // Add `LazyWrapper` methods to `lodash.prototype`.
                        baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
                            if (!lodashFunc) {
                                return;
                            }
                            lodash.prototype[methodName] = function () {
                                var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value);
                                var interceptor = function (value) {
                                    var result = lodashFunc.apply(lodash, arrayPush([value], args));
                                    return (isTaker && chainAll) ? result[0] : result;
                                };
                                if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
                                    // Avoid lazy use if the iteratee has a "length" value other than `1`.
                                    isLazy = useLazy = false;
                                }
                                var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
                                if (!retUnwrapped && useLazy) {
                                    value = onlyLazy ? value : new LazyWrapper(this);
                                    var result = func.apply(value, args);
                                    result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
                                    return new LodashWrapper(result, chainAll);
                                }
                                if (isUnwrapped && onlyLazy) {
                                    return func.apply(this, args);
                                }
                                result = this.thru(interceptor);
                                return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
                            };
                        });
                        // Add `Array` methods to `lodash.prototype`.
                        arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function (methodName) {
                            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru', retUnwrapped = /^(?:pop|shift)$/.test(methodName);
                            lodash.prototype[methodName] = function () {
                                var args = arguments;
                                if (retUnwrapped && !this.__chain__) {
                                    var value = this.value();
                                    return func.apply(isArray(value) ? value : [], args);
                                }
                                return this[chainName](function (value) {
                                    return func.apply(isArray(value) ? value : [], args);
                                });
                            };
                        });
                        // Map minified method names to their real names.
                        baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                            var lodashFunc = lodash[methodName];
                            if (lodashFunc) {
                                var key = lodashFunc.name + '';
                                if (!hasOwnProperty.call(realNames, key)) {
                                    realNames[key] = [];
                                }
                                realNames[key].push({ 'name': methodName, 'func': lodashFunc });
                            }
                        });
                        realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
                                'name': 'wrapper',
                                'func': undefined
                            }];
                        // Add methods to `LazyWrapper`.
                        LazyWrapper.prototype.clone = lazyClone;
                        LazyWrapper.prototype.reverse = lazyReverse;
                        LazyWrapper.prototype.value = lazyValue;
                        // Add chain sequence methods to the `lodash` wrapper.
                        lodash.prototype.at = wrapperAt;
                        lodash.prototype.chain = wrapperChain;
                        lodash.prototype.commit = wrapperCommit;
                        lodash.prototype.next = wrapperNext;
                        lodash.prototype.plant = wrapperPlant;
                        lodash.prototype.reverse = wrapperReverse;
                        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
                        // Add lazy aliases.
                        lodash.prototype.first = lodash.prototype.head;
                        if (symIterator) {
                            lodash.prototype[symIterator] = wrapperToIterator;
                        }
                        return lodash;
                    });
                    /*--------------------------------------------------------------------------*/
                    // Export lodash.
                    var _ = runInContext();
                    // Some AMD build optimizers, like r.js, check for condition patterns like:
                    if (true) {
                        // Expose Lodash on the global object to prevent errors when Lodash is
                        // loaded by a script tag in the presence of an AMD loader.
                        // See http://requirejs.org/docs/errors.html#mismatch for more details.
                        // Use `_.noConflict` to remove Lodash from the global object.
                        root._ = _;
                        // Define as an anonymous module so, through path mapping, it can be
                        // referenced as the "underscore" module.
                        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
                            return _;
                        }).call(exports, __webpack_require__, exports, module),
                            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                    }
                    // Check for `exports` after `define` in case a build optimizer adds it.
                    else { }
                }.call(this));
                /***/ 
            }),
            /***/ "./src/constants/variables.constants.ts": 
            /*!**********************************************!*\
              !*** ./src/constants/variables.constants.ts ***!
              \**********************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "$rootScope": function () { return ( /* binding */$rootScope); },
                    /* harmony export */ "CONSTANTS": function () { return ( /* binding */CONSTANTS); },
                    /* harmony export */ "DB_CONSTANTS": function () { return ( /* binding */DB_CONSTANTS); },
                    /* harmony export */ "SWAGGER_CONSTANTS": function () { return ( /* binding */SWAGGER_CONSTANTS); },
                    /* harmony export */ "VARIABLE_CONSTANTS": function () { return ( /* binding */VARIABLE_CONSTANTS); },
                    /* harmony export */ "VARIABLE_URLS": function () { return ( /* binding */VARIABLE_URLS); },
                    /* harmony export */ "WS_CONSTANTS": function () { return ( /* binding */WS_CONSTANTS); }
                    /* harmony export */ 
                });
                // ToDo - variable seperation
                var CONSTANTS = {
                    // hasCordova: window['cordova'] !== undefined,
                    // isWaveLens: window['WaveLens'] !== undefined,
                    isStudioMode: false,
                    isRunMode: true,
                    XSRF_COOKIE_NAME: 'wm_xsrf_token',
                    DEFAULT_TIMER_DELAY: 500,
                    WIDGET_DOESNT_EXIST: 'The widget you\'re trying to navigate to doesn\'t exist on this page'
                };
                var VARIABLE_CONSTANTS = {
                    CATEGORY: {
                        MODEL: 'wm.Variable',
                        LIVE: 'wm.LiveVariable',
                        CRUD: 'wm.CrudVariable',
                        SERVICE: 'wm.ServiceVariable',
                        WEBSOCKET: 'wm.WebSocketVariable',
                        NAVIGATION: 'wm.NavigationVariable',
                        NOTIFICATION: 'wm.NotificationVariable',
                        TIMER: 'wm.TimerVariable',
                        LOGIN: 'wm.LoginVariable',
                        LOGOUT: 'wm.LogoutVariable',
                        DEVICE: 'wm.DeviceVariable'
                    },
                    EVENTS: ['onBefore',
                        'onBeforeUpdate',
                        'onResult',
                        'onBeforeOpen',
                        'onOpen',
                        'onBeforeMessageSend',
                        'onMessageReceive',
                        'onProgress',
                        'onError',
                        'onBeforeDatasetReady',
                        'onCanUpdate',
                        'onClick',
                        'onHide',
                        'onOk',
                        'onCancel',
                        'onBeforeClose',
                        'onClose',
                        'onTimerFire',
                        'onSuccess',
                        'onOnline',
                        'onOffline'],
                    EVENT: {
                        'CAN_UPDATE': 'onCanUpdate',
                        'BEFORE': 'onBefore',
                        'BEFORE_UPDATE': 'onBeforeUpdate',
                        'PREPARE_SETDATA': 'onBeforeDatasetReady',
                        'RESULT': 'onResult',
                        'ERROR': 'onError',
                        'ABORT': 'onAbort',
                        'PROGRESS': 'onProgress',
                        'CLICK': 'onClick',
                        'HIDE': 'onHide',
                        'OK': 'onOk',
                        'CANCEL': 'onCancel',
                        'CLOSE': 'onClose',
                        'TIMER_FIRE': 'onTimerFire',
                        'SUCCESS': 'onSuccess',
                        'BEFORE_OPEN': 'onBeforeOpen',
                        'OPEN': 'onOpen',
                        'BEFORE_SEND': 'onBeforeMessageSend',
                        'MESSAGE_RECEIVE': 'onMessageReceive',
                        'BEFORE_CLOSE': 'onBeforeClose'
                    },
                    OWNER: {
                        'APP': 'App',
                        'PAGE': 'Page'
                    },
                    REST_SUPPORTED_SERVICES: ['JavaService', 'SoapService', 'FeedService', 'RestService', 'SecurityServiceType', 'DataService', 'WebSocketService', 'OpenAPIService'],
                    PAGINATION_PARAMS: ['page', 'size', 'sort'],
                    REST_SERVICE: {
                        'BASE_PATH_KEY': 'x-WM-BASE_PATH',
                        'RELATIVE_PATH_KEY': 'x-WM-RELATIVE_PATH',
                        'OAUTH_PROVIDER_KEY': 'x-WM-PROVIDER_ID',
                        'AUTH_HDR_KEY': 'Authorization',
                        'SECURITY_DEFN': {
                            'BASIC': 'basic',
                            'OAUTH2': 'oauth2',
                        },
                        'AUTH_TYPE': {
                            'BASIC': 'BASIC',
                            'OAUTH': 'OAUTH2',
                            'NONE': 'NONE',
                        },
                        'CONTENT_TYPE_KEY': 'x-WM-CONTENT_TYPE',
                        'ACCESSTOKEN_PLACEHOLDER': {
                            'LEFT': '',
                            'RIGHT': '.access_token'
                        },
                        ERR_TYPE: {
                            NO_ACCESSTOKEN: 'missing_accesstoken',
                            NO_CREDENTIALS: 'no_credentials',
                            METADATA_MISSING: 'metadata_missing',
                            CRUD_OPERATION_MISSING: 'crud_operation_missing',
                            USER_UNAUTHORISED: 'user_unauthorised',
                            REQUIRED_FIELD_MISSING: 'required_field_missing',
                        },
                        ERR_MSG: {
                            NO_ACCESSTOKEN: 'Access token missing',
                            NO_CREDENTIALS: 'No credentials present',
                            METADATA_MISSING: 'Metadata missing for "$variable"',
                            USER_UNAUTHORISED: 'Unauthorized User',
                            CRUD_OPERATION_MISSING: 'Operation "$operation" not allowed for "$variable"',
                            REQUIRED_FIELD_MISSING: 'Required field(s) missing: "${0}"'
                        },
                        UNCLOAKED_HEADERS: ['CONTENT-TYPE', 'ACCEPT', 'CONTENT-LENGTH', 'ACCEPT-ENCODING', 'ACCEPT-LANGUAGE'],
                        PREFIX: {
                            AUTH_HDR_VAL: {
                                BASIC: 'Basic',
                                OAUTH: 'Bearer'
                            },
                            CLOAK_HEADER_KEY: 'X-WM-'
                        }
                    },
                    SERVICE_TYPE: {
                        JAVA: 'JavaService',
                        REST: 'RestService',
                        SOAP: 'SoapService',
                        FEED: 'FeedService',
                        DATA: 'DataService',
                        SECURITY: 'SecurityServiceType',
                        WEBSOCKET: 'WebSocketService',
                        OPENAPI: 'OpenAPIService'
                    },
                    CONTROLLER_TYPE: {
                        QUERY: 'QueryExecution',
                        PROCEDURE: 'ProcedureExecution'
                    },
                    HTTP_STATUS_CODE: {
                        CORS_FAILURE: -1,
                        UNAUTHORIZED: 401,
                        FORBIDDEN: 403
                    },
                    EXPORT_TYPES_MAP: {
                        'EXCEL': '.xlsx',
                        'CSV': '.csv'
                    },
                    DEFAULT_VAR: {
                        'NOTIFICATION': 'appNotification'
                    }
                };
                var WS_CONSTANTS = {
                    NON_BODY_HTTP_METHODS: ['GET', 'HEAD'],
                    CONTENT_TYPES: {
                        FORM_URL_ENCODED: 'application/x-www-form-urlencoded',
                        MULTIPART_FORMDATA: 'multipart/form-data',
                        OCTET_STREAM: 'application/octet-stream'
                    }
                };
                var DB_CONSTANTS = {
                    'DATABASE_MATCH_MODES': {
                        'like': 'LIKE',
                        'start': 'STARTING_WITH',
                        'startignorecase': 'STARTING_WITH_IGNORECASE',
                        'end': 'ENDING_WITH',
                        'endignorecase': 'ENDING_WITH_IGNORECASE',
                        'anywhere': 'CONTAINING',
                        'anywhereignorecase': 'CONTAINING_IGNORECASE',
                        'nowhere': 'DOES_NOT_CONTAIN',
                        'nowhereignorecase': 'DOES_NOT_CONTAIN_IGNORECASE',
                        'exact': 'EQUALS',
                        'exactignorecase': 'EQUALS_IGNORECASE',
                        'notequals': 'NOT_EQUALS',
                        "notequalsignorecase": "NOT_EQUALS_IGNORECASE",
                        'between': 'BETWEEN',
                        'in': 'IN',
                        "notin": "NOTIN",
                        'lessthan': 'LESS_THAN',
                        'lessthanequal': 'LESS_THAN_OR_EQUALS',
                        'greaterthan': 'GREATER_THAN',
                        'greaterthanequal': 'GREATER_THAN_OR_EQUALS',
                        'null': 'NULL',
                        'isnotnull': 'IS_NOT_NULL',
                        'empty': 'EMPTY',
                        'isnotempty': 'IS_NOT_EMPTY',
                        'nullorempty': 'NULL_OR_EMPTY'
                    },
                    'DATABASE_EMPTY_MATCH_MODES': ['NULL', 'IS_NOT_NULL', 'EMPTY', 'IS_NOT_EMPTY', 'NULL_OR_EMPTY'],
                    'DATABASE_RANGE_MATCH_MODES': ['IN', 'NOTIN', 'BETWEEN', 'LESS_THAN', 'LESS_THAN_OR_EQUALS', 'GREATER_THAN', 'GREATER_THAN_OR_EQUALS', 'NOT_EQUALS'],
                    'DATABASE_NULL_EMPTY_MATCH': {
                        'NULL': 'NULL',
                        'IS_NOT_NULL': 'IS_NOT_NULL',
                        'EMPTY': 'NULL',
                        'IS_NOT_EMPTY': 'IS_NOT_NULL',
                        'NULL_OR_EMPTY': 'NULL'
                    },
                    'DATABASE_MATCH_MODES_WITH_QUERY': {
                        'LIKE': '${0} like ${1}',
                        'STARTING_WITH': '${0} like ${1}',
                        'STARTING_WITH_IGNORECASE': '${0} like ${1}',
                        'ENDING_WITH': '${0} like ${1}',
                        'ENDING_WITH_IGNORECASE': '${0} like ${1}',
                        'CONTAINING': '${0} like ${1}',
                        'CONTAINING_IGNORECASE': '${0} like ${1}',
                        'DOES_NOT_CONTAIN': '${0} not like ${1}',
                        'DOES_NOT_CONTAIN_IGNORECASE': '${0} not like ${1}',
                        'EQUALS': '${0}=${1}',
                        'EQUALS_IGNORECASE': '${0}=${1}',
                        'NOT_EQUALS': '${0}!=${1}',
                        "NOT_EQUALS_IGNORECASE": "${0}!=${1}",
                        'BETWEEN': '${0} between ${1}',
                        'IN': '${0} in ${1}',
                        'NOTIN': "${0} not in ${1}",
                        'LESS_THAN': '${0}<${1}',
                        'LESS_THAN_OR_EQUALS': '${0}<=${1}',
                        'GREATER_THAN': '${0}>${1}',
                        'GREATER_THAN_OR_EQUALS': '${0}>=${1}',
                        'NULL': '${0} is null',
                        'IS_NOT_NULL': '${0} is not null',
                        'EMPTY': '${0}=\'\'',
                        'IS_NOT_EMPTY': '${0}<>\'\'',
                        'NULL_OR_EMPTY': '${0} is null or ${0}=\'\''
                    },
                    'DATABASE_STRING_MODES': ['LIKE', 'STARTING_WITH', 'STARTING_WITH_IGNORECASE', 'ENDING_WITH', 'ENDING_WITH_IGNORECASE', 'CONTAINING', 'CONTAINING_IGNORECASE', 'DOES_NOT_CONTAIN', 'DOES_NOT_CONTAIN_IGNORECASE', 'EQUALS', 'EQUALS_IGNORECASE', 'NOT_EQUALS', "NOT_EQUALS_IGNORECASE"]
                };
                var SWAGGER_CONSTANTS = {
                    WM_DATA_JSON: 'wm_data_json',
                    WM_HTTP_JSON: 'wm_httpRequestDetails'
                };
                var VARIABLE_URLS = {
                    DATABASE: {
                        searchTableData: {
                            url: '/:service/:dataModelName/:entityName/search?page=:page&size=:size&:sort',
                            method: 'POST'
                        },
                        searchTableDataWithQuery: {
                            url: '/:service/:dataModelName/:entityName/filter?page=:page&size=:size&:sort',
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded'
                            }
                        },
                        readTableData: {
                            url: '/:service/:dataModelName/:entityName?page=:page&size=:size&:sort',
                            method: 'GET'
                        },
                        insertTableData: {
                            url: '/:service/:dataModelName/:entityName',
                            method: 'POST'
                        },
                        insertMultiPartTableData: {
                            url: '/:service/:dataModelName/:entityName',
                            method: 'POST',
                            headers: {}
                            // ,transformRequest: WM.identity
                        },
                        updateTableData: {
                            url: '/:service/:dataModelName/:entityName/:id',
                            method: 'PUT'
                        },
                        updateMultiPartTableData: {
                            url: '/:service/:dataModelName/:entityName/:id',
                            method: 'POST',
                            headers: {}
                            // ,transformRequest: WM.identity
                        },
                        deleteTableData: {
                            url: '/:service/:dataModelName/:entityName/:id',
                            method: 'DELETE'
                        },
                        updateCompositeTableData: {
                            url: '/:service/:dataModelName/:entityName/composite-id?:id',
                            method: 'PUT'
                        },
                        periodUpdateCompositeTableData: {
                            url: '/:service/:dataModelName/:entityName/composite-id/periods?:id',
                            method: 'PUT'
                        },
                        updateMultiPartCompositeTableData: {
                            url: '/:service/:dataModelName/:entityName/composite-id?:id',
                            method: 'POST',
                            headers: {}
                            // , transformRequest: WM.identity
                        },
                        deleteCompositeTableData: {
                            url: '/:service/:dataModelName/:entityName/composite-id?:id',
                            method: 'DELETE'
                        },
                        periodDeleteCompositeTableData: {
                            url: '/:service/:dataModelName/:entityName/composite-id/periods?:id',
                            method: 'DELETE'
                        },
                        getDistinctDataByFields: {
                            url: '/:service/:dataModelName/:entityName/aggregations?page=:page&size=:size&:sort',
                            method: 'POST'
                        },
                        exportTableData: {
                            url: '/services/:dataModelName/:entityName/export?:sort',
                            method: 'POST'
                        },
                        readTableRelatedData: {
                            url: '/:service/:dataModelName/:entityName/:id/:relatedFieldName?page=:page&size=:size&:sort',
                            method: 'GET'
                        },
                        executeNamedQuery: {
                            url: '/:service/:dataModelName/queryExecutor/queries/:queryName?page=:page&size=:size&:queryParams',
                            method: 'GET'
                        },
                        executeCustomQuery: {
                            url: '/:service/:dataModelName/queries/execute?page=:page&size=:size',
                            method: 'POST'
                        },
                        executeAggregateQuery: {
                            url: '/services/:dataModelName/:entityName/aggregations?page=:page&size=:size&sort=:sort',
                            method: 'POST'
                        },
                        executeNamedProcedure: {
                            url: '/:service/:dataModelName/procedureExecutor/procedure/execute/:procedureName?page=:page&size=:size&:procedureParams',
                            method: 'GET'
                        },
                        countTableDataWithQuery: {
                            url: '/:service/:dataModelName/:entityName/count?:queryParams',
                            method: 'GET'
                        }
                    },
                    oauthConfiguration: {
                        getAuthorizationUrl: {
                            url: 'services/oauth2/:providerId/authorizationUrl',
                            method: 'GET'
                        }
                    }
                };
                var $rootScope = {
                    project: {
                        deployedUrl: './',
                        id: 'temp_id'
                    },
                    projectName: 'test_project_name',
                    isApplicationType: true
                };
                /***/ 
            }),
            /***/ "./src/factory/variable-manager.factory.ts": 
            /*!*************************************************!*\
              !*** ./src/factory/variable-manager.factory.ts ***!
              \*************************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "VariableManagerFactory": function () { return ( /* binding */VariableManagerFactory); }
                    /* harmony export */ 
                });
                /* harmony import */ var _manager_variable_service_variable_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../manager/variable/service-variable.manager */ "./src/manager/variable/service-variable.manager.ts");
                /* harmony import */ var _manager_variable_model_variable_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../manager/variable/model-variable.manager */ "./src/manager/variable/model-variable.manager.ts");
                /* harmony import */ var _manager_variable_live_variable_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../manager/variable/live-variable.manager */ "./src/manager/variable/live-variable.manager.ts");
                /* harmony import */ var _manager_variable_crud_variable_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../manager/variable/crud-variable.manager */ "./src/manager/variable/crud-variable.manager.ts");
                /* harmony import */ var _manager_variable_base_variable_manager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../manager/variable/base-variable.manager */ "./src/manager/variable/base-variable.manager.ts");
                /* harmony import */ var _manager_action_timer_action_manager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../manager/action/timer-action.manager */ "./src/manager/action/timer-action.manager.ts");
                var managerMap = new Map(), typeToManagerMap = {
                    'Variable': _manager_variable_base_variable_manager__WEBPACK_IMPORTED_MODULE_4__.BaseVariableManager,
                    'wm.Variable': _manager_variable_model_variable_manager__WEBPACK_IMPORTED_MODULE_1__.ModelVariableManager,
                    'wm.ServiceVariable': _manager_variable_service_variable_manager__WEBPACK_IMPORTED_MODULE_0__.ServiceVariableManager,
                    'wm.LiveVariable': _manager_variable_live_variable_manager__WEBPACK_IMPORTED_MODULE_2__.LiveVariableManager,
                    'wm.CrudVariable': _manager_variable_crud_variable_manager__WEBPACK_IMPORTED_MODULE_3__.CrudVariableManager,
                    'wm.TimerVariable': _manager_action_timer_action_manager__WEBPACK_IMPORTED_MODULE_5__.TimerActionManager,
                };
                var VariableManagerFactory = /** @class */ (function () {
                    function VariableManagerFactory() {
                    }
                    VariableManagerFactory.get = function (type) {
                        return managerMap.has(type) ?
                            managerMap.get(type) :
                            managerMap.set(type, new typeToManagerMap[type]()).get(type);
                    };
                    return VariableManagerFactory;
                }());
                /***/ 
            }),
            /***/ "./src/manager/action/timer-action.manager.ts": 
            /*!****************************************************!*\
              !*** ./src/manager/action/timer-action.manager.ts ***!
              \****************************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "TimerActionManager": function () { return ( /* binding */TimerActionManager); }
                    /* harmony export */ 
                });
                /* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/utils */ "./src/util/utils.ts");
                /* harmony import */ var _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/variable/variables.utils */ "./src/util/variable/variables.utils.ts");
                /* harmony import */ var _constants_variables_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../constants/variables.constants */ "./src/constants/variables.constants.ts");
                var TimerActionManager = /** @class */ (function () {
                    function TimerActionManager() {
                    }
                    TimerActionManager.prototype.trigger = function (variable, options, success, error) {
                        if ((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isDefined)(variable._promise) || _constants_variables_constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.isStudioMode) {
                            return;
                        }
                        var repeatTimer = variable.repeating, delay = variable.delay || _constants_variables_constants__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.DEFAULT_TIMER_DELAY, event = 'onTimerFire', exec = function () {
                            (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.initiateCallback)(event, variable, {});
                        };
                        variable._promise = repeatTimer ? setInterval(exec, delay) : setTimeout(function () {
                            exec();
                            variable._promise = undefined;
                        }, delay);
                        /*// destroy the timer on scope destruction
                        callBackScope.$on('$destroy', function () {
                            variable.cancel(variable._promise);
                        });*/
                        return variable._promise;
                    };
                    TimerActionManager.prototype.cancel = function (variable) {
                        if ((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isDefined)(variable._promise)) {
                            if (variable.repeating) {
                                clearInterval(variable._promise);
                            }
                            else {
                                clearTimeout(variable._promise);
                            }
                            variable._promise = undefined;
                        }
                    };
                    return TimerActionManager;
                }());
                /***/ 
            }),
            /***/ "./src/manager/variable/base-variable.manager.ts": 
            /*!*******************************************************!*\
              !*** ./src/manager/variable/base-variable.manager.ts ***!
              \*******************************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "BaseVariableManager": function () { return ( /* binding */BaseVariableManager); }
                    /* harmony export */ 
                });
                /* harmony import */ var _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../../util/variable/variables.utils */ "./src/util/variable/variables.utils.ts");
                /* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
                /* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
                // declare const _: any;
                var BaseVariableManager = /** @class */ (function () {
                    function BaseVariableManager() {
                    }
                    BaseVariableManager.prototype.initBinding = function (variable, bindSource, bindTarget) {
                        // processBinding(variable, variable._context, bindSource, bindTarget);
                        // ToDo - variable seperation
                    };
                    BaseVariableManager.prototype.notifyInflight = function (variable, status, data, options) {
                        // ToDo - variable seperation
                        _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_0__.appManager && _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_0__.appManager.notify('toggle-variable-state', {
                            variable: variable,
                            active: status,
                            data: data,
                            options: options
                        });
                    };
                    /**
                     * This method sets the variable parameter requestTrackId to X-WM-Request-Track-Id which is received in the response headers.
                     * @param response
                     */
                    BaseVariableManager.prototype.setRequestTrackId = function (response, variable) {
                        var _a;
                        var requestTrackId = (_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a.get('x-wm-request-track-id');
                        if (requestTrackId) {
                            variable._requestTrackId = requestTrackId;
                        }
                    };
                    /**
                     * This method makes the final angular http call that returns an observable.
                     * We attach this observable to variable to cancel a network call
                     * @param requestParams
                     * @param variable
                     * @param dbOperation
                     */
                    // ToDo - variable seperation
                    BaseVariableManager.prototype.httpCall = function (requestParams, variable, params) {
                        var _this = this;
                        return new Promise(function (resolve, reject) {
                            variable._observable = variable.httpService.sendCallAsObservable(requestParams, params).subscribe(function (response) {
                                if (response && response.type) {
                                    _this.setRequestTrackId(response, variable);
                                    resolve(response);
                                }
                            }, function (err) {
                                _this.setRequestTrackId(err, variable);
                                if (variable.httpService.isPlatformSessionTimeout(err)) {
                                    // send the notification manually to hide any context spinners on page.
                                    // [TODO]: any spinners on widget listening on this variable will also go off. Need to see an approach to sovle that.
                                    _this.notifyInflight(variable, false, err);
                                    err._401Subscriber.asObservable().subscribe(function (response) { return resolve(response); }, function (e) { return reject(e); });
                                }
                                else {
                                    reject(err);
                                }
                            });
                        });
                    };
                    /**
                     * This method prepares the options parameter for variable callbacks.
                     * @param xhrObj, The xhrObj to be passed
                     * @param moreOptions, any other info to be passed in the options param
                     */
                    BaseVariableManager.prototype.prepareCallbackOptions = function (xhrObj, moreOptions) {
                        var options = {};
                        options['xhrObj'] = xhrObj;
                        if (moreOptions) {
                            lodash__WEBPACK_IMPORTED_MODULE_1___default().extend(options, moreOptions);
                        }
                        return options;
                    };
                    return BaseVariableManager;
                }());
                /***/ 
            }),
            /***/ "./src/manager/variable/crud-variable.manager.ts": 
            /*!*******************************************************!*\
              !*** ./src/manager/variable/crud-variable.manager.ts ***!
              \*******************************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "CrudVariableManager": function () { return ( /* binding */CrudVariableManager); }
                    /* harmony export */ 
                });
                /* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/utils */ "./src/util/utils.ts");
                /* harmony import */ var _util_variable_service_variable_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/variable/service-variable.utils */ "./src/util/variable/service-variable.utils.ts");
                /* harmony import */ var _util_inflight_queue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/inflight-queue */ "./src/util/inflight-queue.ts");
                /* harmony import */ var _constants_variables_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../constants/variables.constants */ "./src/constants/variables.constants.ts");
                /* harmony import */ var _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/variable/variables.utils */ "./src/util/variable/variables.utils.ts");
                /* harmony import */ var _util_oAuth_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/oAuth.utils */ "./src/util/oAuth.utils.ts");
                /* harmony import */ var _service_variable_manager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./service-variable.manager */ "./src/manager/variable/service-variable.manager.ts");
                var __extends = (undefined && undefined.__extends) || (function () {
                    var extendStatics = function (d, b) {
                        extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b)
                                if (Object.prototype.hasOwnProperty.call(b, p))
                                    d[p] = b[p]; };
                        return extendStatics(d, b);
                    };
                    return function (d, b) {
                        if (typeof b !== "function" && b !== null)
                            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
                // import { $invokeWatchers, getClonedObject, getValidJSON, isDefined, isPageable, isValidWebURL, noop, triggerFn, xmlToJson } from '@wm/core';
                var CrudVariableManager = /** @class */ (function (_super) {
                    __extends(CrudVariableManager, _super);
                    function CrudVariableManager() {
                        var _this = _super !== null && _super.apply(this, arguments) || this;
                        _this.fileUploadResponse = [];
                        _this.fileUploadCount = 0;
                        _this.totalFilesCount = 0;
                        _this.successFileUploadCount = 0;
                        _this.failedFileUploadCount = 0;
                        return _this;
                    }
                    CrudVariableManager.prototype.getPaginationInfo = function (variable, inputFields, options) {
                        if (!options || !options.operation) {
                            options.operation = 'list';
                        }
                        var serviceDef = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_4__.metadataService.getByCrudId(variable.crudOperationId, variable.getPrefabName()));
                        var methodInfo = serviceDef === null ? null : _.get(serviceDef, 'wmServiceOperationInfo');
                        methodInfo = serviceDef.filter(function (item) {
                            return options.operation === item.operationType;
                        })[0];
                        if (!methodInfo) {
                            return methodInfo;
                        }
                        // methodInfo.paginationInfo = {
                        //                                 "contentMapping": "content",
                        //                                 "ascSortExpression": "{{fieldName}} a",
                        //                                 "descSortExpression": "{{fieldName}} d",
                        //                                 //"defaultSortExpression": "id",
                        //                                 "totalMapping": "totalElements",
                        //                                 "pageMapping": {
                        //                                     "in": "query",
                        //                                     "name": "pageNum",
                        //                                     "description": "the existing id",
                        //                                     "type": "integer",
                        //                                     "required": true
                        //                                 },
                        //                                 "sizeMapping": {
                        //                                     "in": "query",
                        //                                     "name": "limit",
                        //                                     "description": "the existing id",
                        //                                     "type": "integer",
                        //                                     "required": true
                        //                                 },
                        //                                 "sortMapping": {
                        //                                     "name": "sortInfo",
                        //                                     "in": "query",
                        //                                     "description": "the sorting criteria",
                        //                                     "required": true,
                        //                                     "type": "integer"
                        //                                 }
                        //                             };
                        methodInfo.paginationInfo = null;
                        return methodInfo.paginationInfo;
                    };
                    CrudVariableManager.prototype.getOperationInfo = function (variable, options) {
                        var serviceDef = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_4__.metadataService.getByCrudId(variable.crudOperationId, variable.getPrefabName()));
                        var methodInfo;
                        // fallback if there is no operation
                        if (options && !options.operation) {
                            options.operation = 'list';
                        }
                        if (!serviceDef.length) {
                            return;
                        }
                        methodInfo = serviceDef.filter(function (item) {
                            return options.operation === item.operationType;
                        })[0];
                        return methodInfo ? methodInfo.wmServiceOperationInfo : { invalid: true };
                    };
                    /**
                     * gets the service operation info against a service variable
                     * this is extracted from the metadataservice
                     * @param variable
                     * @param inputFields: sample values, if provided, will be set against params in the definition
                     * @param options
                     * @returns {any}
                     */
                    CrudVariableManager.prototype.getMethodInfoForCrud = function (variable, inputFields, options) {
                        var methodInfo = this.getOperationInfo(variable, options);
                        if (!methodInfo || methodInfo.invalid) {
                            return methodInfo;
                        }
                        var securityDefnObj = _.get(methodInfo.securityDefinitions, '0'), isOAuthTypeService = securityDefnObj && (securityDefnObj.type === _constants_variables_constants__WEBPACK_IMPORTED_MODULE_3__.VARIABLE_CONSTANTS.REST_SERVICE.SECURITY_DEFN.OAUTH2);
                        if (methodInfo.parameters) {
                            methodInfo.parameters.forEach(function (param) {
                                // Ignore readOnly params in case of formData file params will be duplicated
                                if (param.readOnly) {
                                    return;
                                }
                                param.sampleValue = inputFields[param.name];
                                /* supporting pagination for query service variable */
                                if (_constants_variables_constants__WEBPACK_IMPORTED_MODULE_3__.VARIABLE_CONSTANTS.PAGINATION_PARAMS.indexOf(param.name) !== -1) {
                                    if (param.name === 'size') {
                                        param.sampleValue = options.size || param.sampleValue || parseInt(variable.maxResults, 10);
                                    }
                                    else if (param.name === 'page') {
                                        param.sampleValue = options.page || param.sampleValue || 1;
                                    }
                                    else if (param.name === 'sort') {
                                        param.sampleValue = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_4__.getEvaluatedOrderBy)(variable.orderBy, options.orderBy) || param.sampleValue || '';
                                    }
                                }
                                else if (param.name === 'access_token' && isOAuthTypeService) {
                                    param.sampleValue = (0, _util_oAuth_utils__WEBPACK_IMPORTED_MODULE_5__.getAccessToken)(securityDefnObj[_constants_variables_constants__WEBPACK_IMPORTED_MODULE_3__.VARIABLE_CONSTANTS.REST_SERVICE.OAUTH_PROVIDER_KEY], null);
                                }
                            });
                        }
                        return methodInfo;
                    };
                    /**
                     * proxy for the invoke call
                     * Request Info is constructed
                     * if error found, error is thrown
                     * else, call is made
                     * @param {CrudVariable} variable
                     * @param options
                     * @param {Function} success
                     * @param {Function} error
                     * @returns {any}
                     * @private
                     */
                    CrudVariableManager.prototype._invoke = function (variable, options, success, error) {
                        var _this = this;
                        var inputFields = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(options.inputFields || {});
                        if (options.operation === 'delete') {
                            inputFields = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(options.row || inputFields.row || options.inputFields || variable.dataBinding);
                        }
                        else if (options.operation === 'create' && options.row) {
                            inputFields = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(options.row);
                        }
                        else if (options.operation === 'update' && options.row) {
                            inputFields = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(options.row);
                        }
                        // EVENT: ON_BEFORE_UPDATE
                        var output = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_4__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_3__.VARIABLE_CONSTANTS.EVENT.BEFORE_UPDATE, variable, inputFields, options);
                        var successHandler;
                        var errorHandler;
                        if (output === false) {
                            _util_inflight_queue__WEBPACK_IMPORTED_MODULE_2__.$queue.process(variable);
                            (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(error);
                            return;
                        }
                        if (_.isObject(output)) {
                            inputFields = output;
                        }
                        var opInfo = this.getOperationInfo(variable, options);
                        var bodyParam;
                        if (opInfo && opInfo.parameters) {
                            bodyParam = opInfo.parameters.filter(function (op) {
                                return op.parameterType === 'body' || op.parameterType === 'formData';
                            })[0];
                        }
                        // merge fields with bindings
                        var bindingFields = _.get(variable.dataBinding, options.operation) || {};
                        // bindings from setInput can come along with the body param, so employee.age will have to be converted to age
                        if (bodyParam && bindingFields[bodyParam.name]) {
                            _.forEach(bindingFields, function (bindingFieldVal, bindingFieldKey) {
                                if (bindingFieldKey === bodyParam.name) {
                                    _.merge(inputFields, bindingFieldVal);
                                }
                                else {
                                    inputFields[bindingFieldKey] = bindingFieldVal;
                                }
                            });
                        }
                        else {
                            _.merge(inputFields, bindingFields);
                        }
                        if ((options.operation === 'create' || options.operation === 'update') && (!bodyParam || !inputFields[bodyParam.name])) {
                            var bodyTypeKeys = [], nonBodyParam = void 0;
                            var _loop_1 = function (fieldName) {
                                nonBodyParam = opInfo.parameters.filter(function (param) {
                                    return param.name === fieldName && param.parameterType !== 'body' && param.parameterType !== 'formData';
                                });
                                if (nonBodyParam.length) {
                                    bodyTypeKeys.push(fieldName);
                                }
                            };
                            // only merge body/formData type params to the requestBody.
                            for (var fieldName in inputFields) {
                                _loop_1(fieldName);
                            }
                            var reqBodyFields = _.omit(inputFields, bodyTypeKeys);
                            if (bodyParam) {
                                inputFields[bodyParam.name] = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(reqBodyFields);
                            }
                            else {
                                inputFields.RequestBody = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(reqBodyFields);
                            }
                        }
                        var paginationInfo;
                        var operationInfo = this.getMethodInfoForCrud(variable, inputFields, options);
                        var pathParam, bodyTypeParam;
                        if (!variable.paginationTransformationRequired && operationInfo && !operationInfo.invalid) {
                            if (operationInfo.parameters) {
                                operationInfo.parameters.forEach(function (parameter) {
                                    if (parameter.parameterType === 'path') {
                                        pathParam = parameter.name;
                                    }
                                    else if (parameter.parameterType === 'body') {
                                        bodyTypeParam = parameter.name;
                                        inputFields[bodyTypeParam] = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(inputFields);
                                    }
                                });
                            }
                            for (var key in inputFields) {
                                if (key !== bodyTypeParam) {
                                    delete inputFields[key];
                                }
                            }
                            if (pathParam && inputFields[bodyTypeParam]) {
                                inputFields[pathParam] = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(inputFields[bodyTypeParam][pathParam]);
                            }
                        }
                        // else {
                        //     inputFields.totalMapping = paginationInfo && paginationInfo.totalMapping;
                        // }
                        var requestParams = _util_variable_service_variable_utils__WEBPACK_IMPORTED_MODULE_1__.ServiceVariableUtils.constructRequestParams(variable, operationInfo, inputFields);
                        inputFields.sortInfo = options.orderBy;
                        // check errors
                        if (requestParams.error) {
                            if (requestParams.error.type === _constants_variables_constants__WEBPACK_IMPORTED_MODULE_3__.VARIABLE_CONSTANTS.REST_SERVICE.ERR_TYPE.CRUD_OPERATION_MISSING) {
                                requestParams.error.message = requestParams.error.message.replace('$operation', options.operation);
                            }
                            if (options.preventMissingOpMsg) {
                                _util_inflight_queue__WEBPACK_IMPORTED_MODULE_2__.$queue.process(variable);
                                return Promise.resolve('');
                            }
                            var info = this.handleRequestMetaError(requestParams, variable, success, error, options);
                            var reason = (_.get(info, 'error.message') || 'An error occurred while triggering the variable');
                            (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(error);
                            return Promise.reject(reason);
                        }
                        // file upload
                        if (_util_variable_service_variable_utils__WEBPACK_IMPORTED_MODULE_1__.ServiceVariableUtils.isFileUploadRequest(variable)) {
                            var uploadPromise = this.uploadFile(variable, options, success, error, inputFields, requestParams);
                            if (uploadPromise) {
                                return uploadPromise;
                            }
                        }
                        // file download
                        if (operationInfo && _.isArray(operationInfo.produces) && _.includes(operationInfo.produces, _constants_variables_constants__WEBPACK_IMPORTED_MODULE_3__.WS_CONSTANTS.CONTENT_TYPES.OCTET_STREAM)) {
                            // ToDo - variable seperation
                            return variable.simulateFileDownload(requestParams, variable.dataBinding.file || variable.name, variable.dataBinding.exportType, function () {
                                (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_4__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_3__.VARIABLE_CONSTANTS.EVENT.SUCCESS, variable, null, null, null);
                                _util_inflight_queue__WEBPACK_IMPORTED_MODULE_2__.$queue.process(variable);
                                (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(success);
                            }, function () {
                                (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_4__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_3__.VARIABLE_CONSTANTS.EVENT.ERROR, variable, null, null, null);
                                _util_inflight_queue__WEBPACK_IMPORTED_MODULE_2__.$queue.process(variable);
                                (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(error);
                            });
                        }
                        // notify variable progress
                        this.notifyInflight(variable, !options.skipToggleState);
                        successHandler = function (response, resolve, inputObj) {
                            if (response && response.type) {
                                if (variable.paginationTransformationRequired) {
                                    var json = JSON.parse(response.body);
                                    var pageable = {
                                        'content': json[paginationInfo.contentMapping],
                                        'first': inputObj[paginationInfo.pageMapping.name] === 1 ? true : false,
                                        'last': inputObj[paginationInfo.pageMapping.name] === json[inputFields.totalMapping] ? true : false,
                                        'number': inputObj[paginationInfo.pageMapping.name] - 1,
                                        'numberOfElements': inputObj[paginationInfo.sizeMapping.name],
                                        'size': inputObj[paginationInfo.sizeMapping.name],
                                        'sort': null,
                                        'totalElements': json[inputFields.totalMapping],
                                        'totalPages': Math.ceil(json[inputFields.totalMapping] / inputObj[paginationInfo.sizeMapping.name])
                                    };
                                    if (inputObj.sortInfo) {
                                        pageable.sort = [{ direction: inputObj.sortInfo.split(' ')[1].toUpperCase(), property: inputObj.sortInfo.split(' ')[0], ignoreCase: false, nullHandling: "NATIVE", ascending: inputObj.sortInfo.split(' ')[1] === 'asc' ? true : false }];
                                    }
                                    json = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(pageable);
                                    response.body = JSON.stringify(json);
                                }
                                var data = _this.processSuccessResponse(response.body, variable, _.extend(options, { 'xhrObj': response }), success, response.headers, operationInfo);
                                // notify variable success
                                _this.notifyInflight(variable, false, data);
                                resolve(response);
                            }
                        };
                        errorHandler = function (err, reject) {
                            var errMsg = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_4__.getErrMessage)(err, variable.httpService.getLocale());
                            // notify variable error
                            _this.notifyInflight(variable, false);
                            _this.processErrorResponse(variable, errMsg, error, err, options.skipNotification);
                            reject({
                                error: errMsg,
                                details: err
                            });
                        };
                        // make the call and return a promise to the user to support script calls made by users
                        return new Promise(function (resolve, reject) {
                            requestParams.responseType = 'text'; // this is to return text response. JSON & XML-to-JSON parsing is handled in success handler.
                            _this.httpCall(requestParams, variable).then(function (response) {
                                successHandler(response, resolve, inputFields);
                            }, function (err) {
                                errorHandler(err, reject);
                            });
                            // the _observable property on variable is used store the observable using which the network call is made
                            // this can be used to cancel the variable calls.
                        });
                    };
                    // *********************************************************** PUBLIC ***********************************************************//
                    CrudVariableManager.prototype.invoke = function (variable, options, success, error) {
                        options = options || {};
                        _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_4__.appManager.notify('check-state-persistence-options', {
                            options: options,
                            variable: variable
                        });
                        options.operation = options.operation || 'list';
                        options.inputFields = options.inputFields || (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(variable.dataBinding[options.operation]);
                        return _util_inflight_queue__WEBPACK_IMPORTED_MODULE_2__.$queue.submit(variable).then(this._invoke.bind(this, variable, options, success, error), error);
                    };
                    CrudVariableManager.prototype.getInputParms = function (variable) {
                        var wmServiceOperationInfo = _.get(_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_4__.metadataService.getByOperationId(variable.operationId, variable.getPrefabName()), 'wmServiceOperationInfo');
                        return _.get(wmServiceOperationInfo, 'parameters');
                    };
                    CrudVariableManager.prototype.setInput = function (variable, key, val, options, type) {
                        type = type || 'list';
                        if (_.isEmpty(variable.dataBinding[type])) {
                            variable.dataBinding[type] = {};
                        }
                        return (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_4__.setInput)(variable.dataBinding[type], key, val, options);
                    };
                    /**
                     * Initializes the bindings for the CRUD variable
                     * flatten the bindings (categorised by operation name) to a list of bindings
                     * each binding object's target is changed appended with the operation type
                     * E.g. Input binding will be like:
                     {
                       "list": [
                         {
                           "target": "q",
                           "type": "string",
                           "value": "X"
                         }
                       ],
                       "update": [
                         {
                           "target": "id",
                           "value": "bind:Widgets.UserControllerTable2.selecteditem.userId",
                           "type": "integer"
                         }
                       ]
                     }
                
                     * This function will convert it to
                     [
                         {
                           "target": "list.q",
                           "type": "string",
                           "value": "X"
                         },
                         {
                           "target": "update.id",
                           "value": "bind:Widgets.UserControllerTable2.selecteditem.userId",
                           "type": "integer"
                         }
                     ]
                
                     * The bindings will be evaluated through the base-manager initBinding method and will
                     * be stored in variable.dataBinding as follows:
                     {
                        list: {
                            q: "X"
                        },
                        update: {
                            id: "evaluated value"
                        }
                     }
                     * @param variable
                     */
                    CrudVariableManager.prototype.initBinding = function (variable) {
                        var crudBindInfo = variable.dataBinding || {}, flattenedBindInfo = [];
                        _.forEach(crudBindInfo, function (bindNodes, operationType) {
                            bindNodes = bindNodes || [];
                            bindNodes.forEach(function (bindNode) {
                                bindNode.target = operationType + '.' + bindNode.target;
                                flattenedBindInfo.push(bindNode);
                            });
                        });
                        variable.dataBinding = flattenedBindInfo;
                        _super.prototype.initBinding.call(this, variable);
                    };
                    return CrudVariableManager;
                }(_service_variable_manager__WEBPACK_IMPORTED_MODULE_6__.ServiceVariableManager));
                /***/ 
            }),
            /***/ "./src/manager/variable/live-variable.manager.ts": 
            /*!*******************************************************!*\
              !*** ./src/manager/variable/live-variable.manager.ts ***!
              \*******************************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "LiveVariableManager": function () { return ( /* binding */LiveVariableManager); }
                    /* harmony export */ 
                });
                /* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/utils */ "./src/util/utils.ts");
                /* harmony import */ var _base_variable_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base-variable.manager */ "./src/manager/variable/base-variable.manager.ts");
                /* harmony import */ var _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./../../util/variable/variables.utils */ "./src/util/variable/variables.utils.ts");
                /* harmony import */ var _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/variable/live-variable.utils */ "./src/util/variable/live-variable.utils.ts");
                /* harmony import */ var _util_inflight_queue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/inflight-queue */ "./src/util/inflight-queue.ts");
                /* harmony import */ var _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../constants/variables.constants */ "./src/constants/variables.constants.ts");
                /* harmony import */ var _util_variable_live_variable_http_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/variable/live-variable.http.utils */ "./src/util/variable/live-variable.http.utils.ts");
                /* harmony import */ var _model_base_variable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../model/base-variable */ "./src/model/base-variable.ts");
                var __extends = (undefined && undefined.__extends) || (function () {
                    var extendStatics = function (d, b) {
                        extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b)
                                if (Object.prototype.hasOwnProperty.call(b, p))
                                    d[p] = b[p]; };
                        return extendStatics(d, b);
                    };
                    return function (d, b) {
                        if (typeof b !== "function" && b !== null)
                            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
                // import { $invokeWatchers, processFilterExpBindNode } from '@wm/core';
                var emptyArr = [];
                var LiveVariableManager = /** @class */ (function (_super) {
                    __extends(LiveVariableManager, _super);
                    function LiveVariableManager() {
                        var _this = _super !== null && _super.apply(this, arguments) || this;
                        /**
                         * Traverses recursively the filterExpressions object and if there is any required field present with no value,
                         * then we will return without proceeding further. Its upto the developer to provide the mandatory value,
                         * if he wants to assign it in teh onbefore<delete/insert/update>function then make that field in
                         * the filter query section as optional
                         * @param filterExpressions - recursive rule Object
                         * @returns {Object} object or boolean. Object if everything gets validated or else just boolean indicating failure in the validations
                         */
                        _this.getFilterExprFields = function (filterExpressions) {
                            var isRequiredFieldAbsent = false;
                            var traverseCallbackFn = function (parentFilExpObj, filExpObj) {
                                if (filExpObj
                                    && filExpObj.required
                                    && ((_.indexOf(['null', 'isnotnull', 'empty', 'isnotempty', 'nullorempty'], filExpObj.matchMode) === -1) && filExpObj.value === '')) {
                                    isRequiredFieldAbsent = true;
                                    return false;
                                }
                            };
                            _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.traverseFilterExpressions(filterExpressions, traverseCallbackFn);
                            return isRequiredFieldAbsent ? !isRequiredFieldAbsent : filterExpressions;
                        };
                        /**
                         * Allows the user to get the criteria of filtering and the filter fields, based on the method called
                         */
                        _this.getDataFilterObj = function (clonedFilterFields) {
                            return (function (clonedFields) {
                                function getCriteria(filterField) {
                                    var criterian = [];
                                    _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.traverseFilterExpressions(clonedFields, function (filterExpressions, criteria) {
                                        if (filterField === criteria.target) {
                                            criterian.push(criteria);
                                        }
                                    });
                                    return criterian;
                                }
                                function getFilterFields() {
                                    return clonedFields;
                                }
                                return {
                                    getFilterFields: getFilterFields,
                                    getCriteria: getCriteria
                                };
                            }(clonedFilterFields));
                        };
                        return _this;
                    }
                    LiveVariableManager.prototype.initFilterExpressionBinding = function (variable) {
                        var context = variable._context;
                        var destroyFn = context.registerDestroyListener ? context.registerDestroyListener.bind(context) : _.noop;
                        // ToDo - variable seperation
                        // const filterSubscription = processFilterExpBindNode(context, variable.filterExpressions).subscribe((response: any) => {
                        //     if (variable.operation === 'read') {
                        //         /* if auto-update set for the variable with read operation only, get its data */
                        //         if (variable.autoUpdate && !_.isUndefined(response.newVal) && _.isFunction(variable.update)) {
                        //             debounceVariableCall(variable, 'update');
                        //         }
                        //     } else {
                        //         /* if auto-update set for the variable with read operation only, get its data */
                        //         if (variable.autoUpdate && !_.isUndefined(response.newVal) && _.isFunction(variable[variable.operation + 'Record'])) {
                        //             debounceVariableCall(variable, variable.operation + 'Record');
                        //         }
                        //     }
                        // });
                        //  destroyFn(() => filterSubscription.unsubscribe());
                    };
                    LiveVariableManager.prototype.updateDataset = function (variable, data, propertiesMap, pagination) {
                        variable.pagination = pagination;
                        variable.dataSet = data;
                        // legacy properties in dataSet, [data, pagination]
                        Object.defineProperty(variable.dataSet, 'data', {
                            get: function () {
                                return variable.dataSet;
                            }
                        });
                        Object.defineProperty(variable.dataSet, 'pagination', {
                            get: function () {
                                return variable.pagination;
                            }
                        });
                    };
                    // Set the _options on variable which can be used by the widgets
                    LiveVariableManager.prototype.setVariableOptions = function (variable, options) {
                        variable._options = variable._options || {};
                        variable._options.orderBy = options && options.orderBy;
                        variable._options.filterFields = options && options.filterFields;
                        variable._options.logicalOp = options && options.logicalOp;
                    };
                    LiveVariableManager.prototype.handleError = function (variable, errorCB, response, options, advancedOptions) {
                        var opt;
                        /* If callback function is provided, send the data to the callback.
                         * The same callback if triggered in case of error also. The error-handling is done in grid.js*/
                        (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(errorCB, response);
                        //  EVENT: ON_RESULT
                        (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.RESULT, variable, response, advancedOptions);
                        /* update the dataSet against the variable */
                        if (!options.skipDataSetUpdate) {
                            this.updateDataset(variable, emptyArr, variable.propertiesMap, null);
                        }
                        //  EVENT: ON_ERROR
                        opt = this.prepareCallbackOptions(options.errorDetails);
                        (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.ERROR, variable, response, opt);
                        //  EVENT: ON_CAN_UPDATE
                        variable.canUpdate = true;
                        (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.CAN_UPDATE, variable, response, advancedOptions);
                    };
                    LiveVariableManager.prototype.makeCall = function (variable, dbOperation, params) {
                        var _this = this;
                        var successHandler = function (response, resolve) {
                            if (response && response.type) {
                                resolve(response);
                            }
                        };
                        var errorHandler = function (error, reject) {
                            var errMsg = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.getErrMessage)(error, variable.httpService.getLocale());
                            // notify variable error
                            _this.notifyInflight(variable, false);
                            reject({
                                error: errMsg,
                                details: error
                            });
                        };
                        return new Promise(function (resolve, reject) {
                            var reqParams = (0, _util_variable_live_variable_http_utils__WEBPACK_IMPORTED_MODULE_6__.generateConnectionParams)(params, dbOperation);
                            reqParams = {
                                url: reqParams.url,
                                method: reqParams.method,
                                data: reqParams.data,
                                headers: reqParams.headers
                            };
                            params.operation = dbOperation;
                            _this.httpCall(reqParams, variable, params).then(function (response) {
                                successHandler(response, resolve);
                            }, function (e) {
                                errorHandler(e, reject);
                            });
                        });
                    };
                    LiveVariableManager.prototype.getEntityData = function (variable, options, success, error) {
                        var _this = this;
                        var dataObj = {};
                        var tableOptions, dbOperation, output, newDataSet, clonedFields, requestData, dbOperationOptions, getEntitySuccess, getEntityError;
                        // empty array kept (if variable is not of read type filterExpressions will be undefined)
                        clonedFields = this.getFilterExprFields((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(variable.filterExpressions || {}));
                        // clonedFields = getClonedObject(variable.filterFields);
                        //  EVENT: ON_BEFORE_UPDATE
                        output = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.BEFORE_UPDATE, variable, this.getDataFilterObj(clonedFields), options);
                        // if filterFields are updated or modified inside the onBeforeUpdate event then in device use these fields to filter.
                        var updateFilterFields = _.isObject(output) ? (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(output) : undefined;
                        if (output === false) {
                            _util_inflight_queue__WEBPACK_IMPORTED_MODULE_4__.$queue.process(variable);
                            // $rootScope.$emit('toggle-variable-state', variable, false);
                            (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(error, 'Call stopped from the event: ' + _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.BEFORE_UPDATE);
                            return Promise.reject('Call stopped from the event: ' + _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.BEFORE_UPDATE);
                        }
                        variable.canUpdate = false;
                        tableOptions = _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.prepareTableOptions(variable, options, _.isObject(output) ? output : clonedFields);
                        //  if tableOptions object has query then set the dbOperation to 'searchTableDataWithQuery'
                        if (options.searchWithQuery) {
                            dbOperation = 'searchTableDataWithQuery';
                            requestData = tableOptions.query ? ('q=' + tableOptions.query) : '';
                        }
                        else {
                            dbOperation = (tableOptions.filter && tableOptions.filter.length) ? 'searchTableData' : 'readTableData';
                            requestData = tableOptions.filter;
                        }
                        dbOperationOptions = {
                            'projectID': _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.$rootScope.project.id,
                            'service': variable.getPrefabName() ? '' : 'services',
                            'dataModelName': variable.liveSource,
                            'entityName': variable.type,
                            'page': options.page || 1,
                            'size': options.pagesize || (_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.CONSTANTS.isRunMode ? (variable.maxResults || 20) : (variable.designMaxResults || 20)),
                            'sort': tableOptions.sort,
                            'data': requestData,
                            'filter': _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.getWhereClauseGenerator(variable, options, updateFilterFields),
                            // 'filterMeta': tableOptions.filter,
                            'url': variable.getPrefabName() ? (_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.$rootScope.project.deployedUrl + '/prefabs/' + variable.getPrefabName()) : _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.$rootScope.project.deployedUrl
                        };
                        getEntitySuccess = function (response, resolve) {
                            if (response && response.type) {
                                response = response.body;
                                dataObj.data = response.content;
                                dataObj.pagination = _.omit(response, 'content');
                                var advancedOptions_1 = _this.prepareCallbackOptions(response, { pagination: dataObj.pagination });
                                if ((response && response.error) || !response || !_.isArray(response.content)) {
                                    _this.handleError(variable, error, response.error, options, advancedOptions_1);
                                    return Promise.reject(response.error);
                                }
                                (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.decodeData)(response.content);
                                _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.processBlobColumns(response.content, variable);
                                if (!options.skipDataSetUpdate) {
                                    //  EVENT: ON_RESULT
                                    (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.RESULT, variable, dataObj.data, advancedOptions_1);
                                    //  EVENT: ON_PREPARESETDATA
                                    newDataSet = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.PREPARE_SETDATA, variable, dataObj.data, advancedOptions_1);
                                    if (newDataSet) {
                                        // setting newDataSet as the response to service variable onPrepareSetData
                                        dataObj.data = newDataSet;
                                    }
                                    /* update the dataSet against the variable */
                                    _this.updateDataset(variable, dataObj.data, variable.propertiesMap, dataObj.pagination);
                                    _this.setVariableOptions(variable, options);
                                    // watchers should get triggered before calling onSuccess event.
                                    // so that any variable/widget depending on this variable's data is updated
                                    variable.notify(_model_base_variable__WEBPACK_IMPORTED_MODULE_7__.VariableEvents.AFTER_INVOKE, [_this, dataObj.data]);
                                    setTimeout(function () {
                                        // if callback function is provided, send the data to the callback
                                        (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(success, dataObj.data, variable.propertiesMap, dataObj.pagination);
                                        //  EVENT: ON_SUCCESS
                                        (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.SUCCESS, variable, dataObj.data, advancedOptions_1);
                                        //  EVENT: ON_CAN_UPDATE
                                        variable.canUpdate = true;
                                        (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.CAN_UPDATE, variable, dataObj.data, advancedOptions_1);
                                    });
                                }
                                return resolve({ data: dataObj.data, pagination: dataObj.pagination });
                            }
                        };
                        getEntityError = function (e, reject) {
                            _this.setVariableOptions(variable, options);
                            _this.handleError(variable, error, e.error, _.extend(options, { errorDetails: e.details }));
                            return reject(e.error);
                        };
                        /* if it is a prefab variable (used in a normal project), modify the url */
                        /*Fetch the table data*/
                        return new Promise(function (resolve, reject) {
                            _this.makeCall(variable, dbOperation, dbOperationOptions).then(function (response) {
                                getEntitySuccess(response, resolve);
                            }, function (err) {
                                getEntityError(err, reject);
                            });
                        });
                    };
                    LiveVariableManager.prototype.performCUD = function (operation, variable, options, success, error) {
                        var _this = this;
                        options = options || {};
                        options.inputFields = options.inputFields || (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(variable.inputFields);
                        return _util_inflight_queue__WEBPACK_IMPORTED_MODULE_4__.$queue.submit(variable).then(function () {
                            _this.notifyInflight(variable, !options.skipToggleState);
                            return _this.doCUD(operation, variable, options, success, error)
                                .then(function (response) {
                                _util_inflight_queue__WEBPACK_IMPORTED_MODULE_4__.$queue.process(variable);
                                _this.notifyInflight(variable, false, response);
                                return Promise.resolve(response);
                            }, function (err) {
                                _util_inflight_queue__WEBPACK_IMPORTED_MODULE_4__.$queue.process(variable);
                                _this.notifyInflight(variable, false, err);
                                return Promise.reject(err);
                            });
                        }, error);
                    };
                    LiveVariableManager.prototype.doCUD = function (action, variable, options, success, error) {
                        var _this = this;
                        var projectID = _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.$rootScope.project.id || _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.$rootScope.projectName, primaryKey = _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.getPrimaryKey(variable), isFormDataSupported = (window.File && window.FileReader && window.FileList && window.Blob);
                        var dbName, compositeId = '', rowObject = {}, prevData, compositeKeysData = {}, prevCompositeKeysData = {}, id, columnName, clonedFields, output, onCUDerror, onCUDsuccess, inputFields = options.inputFields || variable.inputFields;
                        // EVENT: ON_BEFORE_UPDATE
                        clonedFields = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(inputFields);
                        output = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.BEFORE_UPDATE, variable, clonedFields, options);
                        if (output === false) {
                            // $rootScope.$emit('toggle-variable-state', variable, false);
                            (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(error);
                            return Promise.reject('Call stopped from the event: ' + _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.BEFORE_UPDATE);
                        }
                        inputFields = _.isObject(output) ? output : clonedFields;
                        variable.canUpdate = false;
                        if (options.row) {
                            rowObject = options.row;
                            // For datetime types, convert the value to the format accepted by backend
                            _.forEach(rowObject, function (value, key) {
                                var fieldType = _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.getFieldType(key, variable);
                                var fieldValue;
                                if ((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isDateTimeType)(fieldType)) {
                                    // ToDo - variable seperation
                                    fieldValue = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.formatDate)(value, fieldType);
                                    rowObject[key] = fieldValue;
                                }
                                else if (_.isArray(value) && _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.isStringType(fieldType)) {
                                    // Construct ',' separated string if param is not array type but value is an array
                                    fieldValue = _.join(value, ',');
                                    rowObject[key] = fieldValue;
                                }
                            });
                            // Merge inputFields along with dataObj while making Insert/Update/Delete
                            _.forEach(inputFields, function (attrValue, attrName) {
                                if (((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isDefined)(attrValue) && attrValue !== '') && (!(0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isDefined)(rowObject[attrName]) || rowObject[attrName] === '')) {
                                    rowObject[attrName] = attrValue;
                                }
                            });
                        }
                        else {
                            _.forEach(inputFields, function (fieldValue, fieldName) {
                                var fieldType;
                                var primaryKeys = variable.propertiesMap.primaryFields || variable.propertiesMap.primaryKeys;
                                if (!_.isUndefined(fieldValue) && fieldValue !== '') {
                                    /*For delete action, the inputFields need to be set in the request URL. Hence compositeId is set.
                                     * For insert action inputFields need to be set in the request data. Hence rowObject is set.
                                     * For update action, both need to be set.*/
                                    if (action === 'deleteTableData') {
                                        compositeId = fieldValue;
                                    }
                                    if (action === 'updateTableData') {
                                        primaryKeys.forEach(function (key) {
                                            if (fieldName === key) {
                                                compositeId = fieldValue;
                                            }
                                        });
                                    }
                                    if (action !== 'deleteTableData' || _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.isCompositeKey(primaryKey)) {
                                        fieldType = _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.getFieldType(fieldName, variable);
                                        if ((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isDateTimeType)(fieldType)) {
                                            // ToDo - variable seperation
                                            fieldValue = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.formatDate)(fieldValue, fieldType);
                                        }
                                        else if (_.isArray(fieldValue) && _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.isStringType(fieldType)) {
                                            // Construct ',' separated string if param is not array type but value is an array
                                            fieldValue = _.join(fieldValue, ',');
                                        }
                                        rowObject[fieldName] = fieldValue;
                                    }
                                    // for related entities, clear the blob type fields
                                    if (_.isObject(fieldValue) && !_.isArray(fieldValue)) {
                                        _.forEach(fieldValue, function (val, key) {
                                            if (_util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.getFieldType(fieldName, variable, key) === 'blob') {
                                                fieldValue[key] = val === null ? val : '';
                                            }
                                        });
                                    }
                                }
                            });
                        }
                        switch (action) {
                            case 'updateTableData':
                                prevData = options.prevData || {};
                                /*Construct the "requestData" based on whether the table associated with the live-variable has a composite key or not.*/
                                if (_util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.isCompositeKey(primaryKey)) {
                                    if (_util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.isNoPrimaryKey(primaryKey)) {
                                        prevCompositeKeysData = prevData || options.rowData || rowObject;
                                        compositeKeysData = rowObject;
                                    }
                                    else {
                                        primaryKey.forEach(function (key) {
                                            compositeKeysData[key] = rowObject[key];
                                            // In case of periodic update for Business temporal fields, passing updated field data.
                                            if (options.period) {
                                                prevCompositeKeysData[key] = rowObject[key];
                                            }
                                            else {
                                                prevCompositeKeysData[key] = prevData[key] || (options.rowData && options.rowData[key]) || rowObject[key];
                                            }
                                        });
                                    }
                                    options.row = compositeKeysData;
                                    options.compositeKeysData = prevCompositeKeysData;
                                }
                                else {
                                    primaryKey.forEach(function (key) {
                                        if (key.indexOf('.') === -1) {
                                            id = prevData[key] || (options.rowData && options.rowData[key]) || rowObject[key];
                                        }
                                        else {
                                            columnName = key.split('.');
                                            id = prevData[columnName[0]][columnName[1]];
                                        }
                                    });
                                    options.id = id;
                                    options.row = rowObject;
                                }
                                break;
                            case 'deleteTableData':
                                /*Construct the "requestData" based on whether the table associated with the live-variable has a composite key or not.*/
                                if (_util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.isCompositeKey(primaryKey)) {
                                    if (_util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.isNoPrimaryKey(primaryKey)) {
                                        compositeKeysData = rowObject;
                                    }
                                    else {
                                        primaryKey.forEach(function (key) {
                                            compositeKeysData[key] = rowObject[key];
                                        });
                                    }
                                    options.compositeKeysData = compositeKeysData;
                                }
                                else if (!_.isEmpty(rowObject)) {
                                    primaryKey.forEach(function (key) {
                                        if (key.indexOf('.') === -1) {
                                            id = rowObject[key];
                                        }
                                        else {
                                            columnName = key.split('.');
                                            id = rowObject[columnName[0]][columnName[1]];
                                        }
                                    });
                                    options.id = id;
                                }
                                break;
                            default:
                                break;
                        }
                        // If table has blob column then send multipart data
                        if ((action === 'updateTableData' || action === 'insertTableData') && _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.hasBlob(variable) && isFormDataSupported) {
                            if (action === 'updateTableData') {
                                action = 'updateMultiPartTableData';
                            }
                            else {
                                action = 'insertMultiPartTableData';
                            }
                            rowObject = _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.prepareFormData(variable, rowObject);
                        }
                        /*Check if "options" have the "compositeKeysData" property.*/
                        if (options.compositeKeysData) {
                            switch (action) {
                                case 'updateTableData':
                                    action = 'updateCompositeTableData';
                                    break;
                                case 'deleteTableData':
                                    action = 'deleteCompositeTableData';
                                    break;
                                case 'updateMultiPartTableData':
                                    action = 'updateMultiPartCompositeTableData';
                                    break;
                                default:
                                    break;
                            }
                            compositeId = _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.getCompositeIDURL(options.compositeKeysData);
                        }
                        dbName = variable.liveSource;
                        /*Set the "data" in the request to "undefined" if there is no data.
                        * This handles cases such as "Delete" requests where data should not be passed.*/
                        if (_.isEmpty(rowObject) && action === 'deleteTableData') {
                            rowObject = undefined;
                        }
                        if ((action === 'updateCompositeTableData' || action === 'deleteCompositeTableData') && options.period) {
                            // capitalize first character
                            action = 'period' + action.charAt(0).toUpperCase() + action.substr(1);
                        }
                        var dbOperations = {
                            'projectID': projectID,
                            'service': variable._prefabName ? '' : 'services',
                            'dataModelName': dbName,
                            'entityName': variable.type,
                            'id': !_.isUndefined(options.id) ? encodeURIComponent(options.id) : compositeId,
                            'data': rowObject,
                            'url': variable._prefabName ? (_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.$rootScope.project.deployedUrl + '/prefabs/' + variable._prefabName) : _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.$rootScope.project.deployedUrl
                        };
                        onCUDerror = function (response, reject) {
                            var errMsg = response.error;
                            var advancedOptions = _this.prepareCallbackOptions(response);
                            // EVENT: ON_RESULT
                            (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.RESULT, variable, errMsg, advancedOptions);
                            // EVENT: ON_ERROR
                            if (!options.skipNotification) {
                                (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.ERROR, variable, errMsg, advancedOptions);
                            }
                            // EVENT: ON_CAN_UPDATE
                            variable.canUpdate = true;
                            (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.CAN_UPDATE, variable, errMsg, advancedOptions);
                            (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(error, errMsg);
                            reject(errMsg);
                        };
                        onCUDsuccess = function (data, resolve) {
                            var response = data.body;
                            var advancedOptions = _this.prepareCallbackOptions(data);
                            _util_inflight_queue__WEBPACK_IMPORTED_MODULE_4__.$queue.process(variable);
                            /* if error received on making call, call error callback */
                            if (response && response.error) {
                                // EVENT: ON_RESULT
                                (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.RESULT, variable, response, advancedOptions);
                                // EVENT: ON_ERROR
                                (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.ERROR, variable, response.error, advancedOptions);
                                // EVENT: ON_CAN_UPDATE
                                variable.canUpdate = true;
                                (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.CAN_UPDATE, variable, response.error, advancedOptions);
                                (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(error, response.error);
                                return Promise.reject(response.error);
                            }
                            // EVENT: ON_RESULT
                            (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.RESULT, variable, response, advancedOptions);
                            if (variable.operation !== 'read') {
                                // EVENT: ON_PREPARESETDATA
                                var newDataSet = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.PREPARE_SETDATA, variable, response, advancedOptions);
                                if (newDataSet) {
                                    // setting newDataSet as the response to service variable onPrepareSetData
                                    response = newDataSet;
                                }
                                variable.dataSet = response;
                            }
                            // watchers should get triggered before calling onSuccess event.
                            // so that any variable/widget depending on this variable's data is updated
                            variable.notify(_model_base_variable__WEBPACK_IMPORTED_MODULE_7__.VariableEvents.AFTER_INVOKE, [_this, response]);
                            setTimeout(function () {
                                // EVENT: ON_SUCCESS
                                (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.SUCCESS, variable, response, advancedOptions);
                                // EVENT: ON_CAN_UPDATE
                                variable.canUpdate = true;
                                (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.CAN_UPDATE, variable, response, advancedOptions);
                            });
                            (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(success, response);
                            resolve(response);
                        };
                        return new Promise(function (resolve, reject) {
                            _this.makeCall(variable, action, dbOperations).then(function (data) {
                                onCUDsuccess(data, resolve);
                            }, function (response) {
                                onCUDerror(response, reject);
                            });
                        });
                    };
                    LiveVariableManager.prototype.aggregateData = function (deployedUrl, variable, options, success, error) {
                        var _this = this;
                        var tableOptions, dbOperationOptions, aggregateDataSuccess, aggregateDataError;
                        var dbOperation = 'executeAggregateQuery';
                        options = options || {};
                        options.skipEncode = true;
                        if (variable.filterFields) {
                            tableOptions = _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.prepareTableOptions(variable, options);
                            options.aggregations.filter = tableOptions.query;
                        }
                        dbOperationOptions = {
                            'dataModelName': variable.liveSource,
                            'entityName': variable.type,
                            'page': options.page || 1,
                            'size': options.size || variable.maxResults,
                            'sort': options.sort || '',
                            'url': deployedUrl,
                            'data': options.aggregations
                        };
                        aggregateDataSuccess = function (response, resolve) {
                            if (response && response.type) {
                                if ((response && response.error) || !response) {
                                    (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(error, response.error);
                                    return;
                                }
                                (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(success, response);
                                resolve(response);
                            }
                        };
                        aggregateDataError = function (errorMsg, reject) {
                            (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(error, errorMsg);
                            reject(errorMsg);
                        };
                        return new Promise(function (resolve, reject) {
                            _this.makeCall(variable, dbOperation, dbOperationOptions).then(function (response) {
                                aggregateDataSuccess(response, resolve);
                            }, function (err) {
                                aggregateDataError(err, reject);
                            });
                        });
                    };
                    // *********************************************************** PUBLIC ***********************************************************//
                    /**
                     * Makes http call for a Live Variable against the configured DB Entity.
                     * Gets the paginated records against the entity
                     * @param variable
                     * @param options
                     * @param success
                     * @param error
                     * @returns {Promise<any>}: will be resolved on successful data fetch
                     */
                    LiveVariableManager.prototype.listRecords = function (variable, options, success, error) {
                        var _this = this;
                        options = options || {};
                        options.filterFields = options.filterFields || (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(variable.filterFields);
                        return _util_inflight_queue__WEBPACK_IMPORTED_MODULE_4__.$queue.submit(variable).then(function () {
                            _this.notifyInflight(variable, !options.skipToggleState, undefined, options);
                            return _this.getEntityData(variable, options, success, error)
                                .then(function (response) {
                                _util_inflight_queue__WEBPACK_IMPORTED_MODULE_4__.$queue.process(variable);
                                _this.notifyInflight(variable, false, response);
                                return Promise.resolve(response);
                            }, function (err) {
                                _util_inflight_queue__WEBPACK_IMPORTED_MODULE_4__.$queue.process(variable);
                                _this.notifyInflight(variable, false, err);
                                return Promise.reject(err);
                            });
                        }, error);
                    };
                    /**
                     * Makes a POST http call for a Live Variable against the configured DB Entity.
                     * Sends a Table record object with the request body
                     * the record is inserted into the entity at the backend
                     * @param variable
                     * @param options
                     * @param success
                     * @param error
                     * @returns {Promise<any>}: will be resolved on successful data fetch
                     */
                    LiveVariableManager.prototype.insertRecord = function (variable, options, success, error) {
                        return this.performCUD('insertTableData', variable, options, success, error);
                    };
                    /**
                     * Makes a PUT http call for a Live Variable against the configured DB Entity.
                     * Sends a Table record object with the request body against the primary key of an existing record
                     * the record is updated into the entity at the backend
                     * @param variable
                     * @param options
                     * @param success
                     * @param error
                     * @returns {Promise<any>}: will be resolved on successful data fetch
                     */
                    LiveVariableManager.prototype.updateRecord = function (variable, options, success, error) {
                        return this.performCUD('updateTableData', variable, options, success, error);
                    };
                    /**
                     * Makes a DELETE http call for a Live Variable against the configured DB Entity.
                     * Sends the primary key of an existing record
                     * the record is deleted from the entity at the backend
                     * @param variable
                     * @param options
                     * @param success
                     * @param error
                     * @returns {Promise<any>}: will be resolved on successful data fetch
                     */
                    LiveVariableManager.prototype.deleteRecord = function (variable, options, success, error) {
                        return this.performCUD('deleteTableData', variable, options, success, error);
                    };
                    /**
                     * sets the value against passed key on the "inputFields" object in the variable
                     * @param variable
                     * @param key: can be:
                     *  - a string e.g. "username"
                     *  - an object, e.g. {"username": "john", "ssn": "11111"}
                     * @param val
                     * - if key is string, the value against it (for that data type)
                     * - if key is object, not required
                     * @param options
                     * @returns {any}
                     */
                    LiveVariableManager.prototype.setInput = function (variable, key, val, options) {
                        variable.inputFields = variable.inputFields || {};
                        return (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.setInput)(variable.inputFields, key, val, options);
                    };
                    /**
                     * sets the value against passed key on the "filterFields" object in the variable
                     * @param variable
                     * @param key: can be:
                     *  - a string e.g. "username"
                     *  - an object, e.g. {"username": "john", "ssn": "11111"}
                     * @param val
                     * - if key is string, the value against it (for that data type)
                     * - if key is object, not required
                     * @param options
                     * @returns {any}
                     */
                    LiveVariableManager.prototype.setFilter = function (variable, key, val) {
                        var paramObj = {}, targetObj = {};
                        if (_.isObject(key)) {
                            paramObj = key;
                        }
                        else {
                            paramObj[key] = val;
                        }
                        if (!variable.filterExpressions || _.isEmpty(variable.filterExpressions)) {
                            variable.filterExpressions = { 'condition': 'AND', 'rules': [] };
                        }
                        targetObj = variable.filterExpressions;
                        // find the existing criteria if present or else return null. Find the first one and return.
                        // If the user wants to set a different object, then he has to use the getCriteria API defined
                        // on the dataFilter object passed to the onBeforeListRecords
                        function getExistingCriteria(filterField) {
                            var existingCriteria = null;
                            _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.traverseFilterExpressions(targetObj, function (filterExpressions, criteria) {
                                if (filterField === criteria.target) {
                                    return existingCriteria = criteria;
                                }
                            });
                            return existingCriteria;
                        }
                        _.forEach(paramObj, function (paramVal, paramKey) {
                            var existingCriteria = getExistingCriteria(paramKey);
                            if (existingCriteria !== null) {
                                existingCriteria.value = paramVal;
                            }
                            else {
                                targetObj.rules.push({
                                    target: paramKey,
                                    type: '',
                                    matchMode: '',
                                    value: paramVal,
                                    required: false
                                });
                            }
                        });
                        return targetObj;
                    };
                    /**
                     * Makes a file download call for a table
                     * @param variable
                     * @param options
                     */
                    LiveVariableManager.prototype.download = function (variable, options, successHandler, errorHandler) {
                        var _this = this;
                        options = options || {};
                        var tableOptions, dbOperationOptions, downloadSuccess, downloadError;
                        var data = {};
                        var dbOperation = 'exportTableData';
                        var projectID = _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.$rootScope.project.id || _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.$rootScope.projectName;
                        options.data.searchWithQuery = true; // For export, query api is used. So set this flag to true
                        options.data.skipEncode = true;
                        tableOptions = _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.prepareTableOptions(variable, options.data, undefined);
                        data.query = tableOptions.query ? tableOptions.query : '';
                        data.exportSize = options.data.exportSize;
                        data.exportType = options.data.exportType;
                        data.fields = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.formatExportExpression)(options.data.fields);
                        if (options.data.fileName) {
                            data.fileName = options.data.fileName;
                        }
                        dbOperationOptions = {
                            'projectID': projectID,
                            'service': variable.getPrefabName() ? '' : 'services',
                            'dataModelName': variable.liveSource,
                            'entityName': variable.type,
                            'sort': tableOptions.sort,
                            'url': variable.getPrefabName() ? (_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.$rootScope.project.deployedUrl + '/prefabs/' + variable.getPrefabName()) : _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.$rootScope.project.deployedUrl,
                            'data': data,
                            'filter': _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.getWhereClauseGenerator(variable, options)
                            // 'filterMeta'    : tableOptions.filter
                        };
                        downloadSuccess = function (response, resolve) {
                            if (response && response.type) {
                                window.location.href = response.body.result;
                                (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(successHandler, response);
                                resolve(response);
                            }
                        };
                        downloadError = function (err, reject) {
                            var opt = _this.prepareCallbackOptions(err.details);
                            (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.ERROR, variable, err.error, opt);
                            (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(errorHandler, err.error);
                            reject(err);
                        };
                        return new Promise(function (resolve, reject) {
                            _this.makeCall(variable, dbOperation, dbOperationOptions).then(function (response) {
                                downloadSuccess(response, resolve);
                            }, function (error) {
                                downloadError(error, reject);
                            });
                        });
                    };
                    /**
                     * gets primary keys against the passed related Table
                     * @param variable
                     * @param relatedField
                     * @returns {any}
                     */
                    LiveVariableManager.prototype.getRelatedTablePrimaryKeys = function (variable, relatedField) {
                        var primaryKeys, result, relatedCols;
                        if (!variable.propertiesMap) {
                            return;
                        }
                        result = _.find(variable.propertiesMap.columns || [], { 'fieldName': relatedField });
                        // if related field name passed, get its type from columns inside the current field
                        if (result) {
                            relatedCols = result.columns;
                            primaryKeys = _.map(_.filter(relatedCols, 'isPrimaryKey'), 'fieldName');
                            if (primaryKeys.length) {
                                return primaryKeys;
                            }
                            if (relatedCols && relatedCols.length) {
                                relatedCols = _.find(relatedCols, { 'isRelated': false });
                                return relatedCols && relatedCols.fieldName;
                            }
                        }
                    };
                    /**
                     * Makes HTTP call to get the data for related entity of a field in an entity
                     * @param variable
                     * @param columnName
                     * @param options
                     * @param success
                     * @param error
                     */
                    LiveVariableManager.prototype.getRelatedTableData = function (variable, columnName, options, success, error) {
                        var _this = this;
                        var projectID = _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.$rootScope.project.id || _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.$rootScope.projectName;
                        var relatedTable = _.find(variable.relatedTables, function (table) { return table.relationName === columnName || table.columnName === columnName; }); // Comparing column name to support the old projects
                        var selfRelatedCols = _.map(_.filter(variable.relatedTables, function (o) { return o.type === variable.type; }), 'relationName');
                        var filterFields = [];
                        var orderBy, filterOptions, query, action, dbOperationOptions, getRelatedTableDataSuccess, getRelatedTableDataError;
                        _.forEach(options.filterFields, function (value, key) {
                            value.fieldName = key;
                            value.type = _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.getFieldType(columnName, variable, key);
                            /**
                             * for 'in' mode we are taking the input as comma separated values and for between in ui there are two different fields
                             * but these are processed and merged into a single value with comma as separator. For these conditions like 'in' and 'between',
                             * for building the query, the function expects the values to be an array
                             */
                            if (value.filterCondition === _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.DB_CONSTANTS.DATABASE_MATCH_MODES["in"].toLowerCase() || value.filterCondition === _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.DB_CONSTANTS.DATABASE_MATCH_MODES.between.toLowerCase()) {
                                value.value = value.value.split(',');
                            }
                            filterFields.push(value);
                        });
                        filterOptions = _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.getFilterOptions(variable, filterFields, options);
                        query = _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.getSearchQuery(filterOptions, ' ' + (options.logicalOp || 'AND') + ' ', variable.ignoreCase);
                        if (options.filterExpr) {
                            var _clonedFields = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(_.isObject(options.filterExpr) ? options.filterExpr : JSON.parse(options.filterExpr));
                            _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.processFilterFields(_clonedFields.rules, variable, options);
                            var filterExpQuery = _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.generateSearchQuery(_clonedFields.rules, _clonedFields.condition, variable.ignoreCase, options.skipEncode);
                            if (query !== '') {
                                if (filterExpQuery !== '') {
                                    query = '(' + query + ') AND (' + filterExpQuery + ')';
                                }
                            }
                            else if (filterExpQuery !== '') {
                                query = filterExpQuery;
                            }
                        }
                        query = query ? ('q=' + query) : '';
                        action = 'searchTableDataWithQuery';
                        orderBy = _.isEmpty(options.orderBy) ? '' : 'sort=' + options.orderBy;
                        dbOperationOptions = {
                            projectID: projectID,
                            service: variable.getPrefabName() ? '' : 'services',
                            dataModelName: variable.liveSource,
                            entityName: relatedTable ? relatedTable.type : '',
                            page: options.page || 1,
                            size: options.pagesize || undefined,
                            url: variable.getPrefabName() ? (_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.$rootScope.project.deployedUrl + '/prefabs/' + variable.getPrefabName()) : _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.$rootScope.project.deployedUrl,
                            data: query || '',
                            filter: _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.getWhereClauseGenerator(variable, options),
                            sort: orderBy
                        };
                        getRelatedTableDataSuccess = function (res, resolve) {
                            if (res && res.type) {
                                var response = res.body;
                                /*Remove the self related columns from the data. As backend is restricting the self related column to one level, In liveform select, dataset and datavalue object
                                 * equality does not work. So, removing the self related columns to acheive the quality*/
                                var data = _.map(response.content, function (o) { return _.omit(o, selfRelatedCols); });
                                var pagination = Object.assign({}, response);
                                delete pagination.content;
                                (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.decodeData)(data);
                                var result = { data: data, pagination: pagination };
                                (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(success, result);
                                resolve(result);
                            }
                        };
                        getRelatedTableDataError = function (errMsg, reject) {
                            (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(error, errMsg);
                            reject(errMsg);
                        };
                        return new Promise(function (resolve, reject) {
                            _this.makeCall(variable, action, dbOperationOptions).then(function (response) {
                                getRelatedTableDataSuccess(response, resolve);
                            }, function (err) {
                                getRelatedTableDataError(err, reject);
                            });
                        });
                    };
                    /**
                     * Gets the distinct records for an entity
                     * @param variable
                     * @param options
                     * @param success
                     * @param error
                     */
                    LiveVariableManager.prototype.getDistinctDataByFields = function (variable, options, success, error) {
                        var _this = this;
                        var dbOperation = 'getDistinctDataByFields';
                        var projectID = _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.$rootScope.project.id || _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.$rootScope.projectName;
                        var requestData = {};
                        var sort;
                        var tableOptions, dbOperationOptions, getDistinctDataByFieldsSuccess, getDistinctDataByFieldsError;
                        options.skipEncode = true;
                        options.operation = 'read';
                        options = options || {};
                        tableOptions = _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.prepareTableOptions(variable, options);
                        if (tableOptions.query) {
                            requestData.filter = tableOptions.query;
                        }
                        requestData.groupByFields = _.isArray(options.fields) ? options.fields : [options.fields];
                        sort = options.sort || requestData.groupByFields[0] + ' asc';
                        sort = sort ? 'sort=' + sort : '';
                        dbOperationOptions = {
                            'projectID': projectID,
                            'service': variable.getPrefabName() ? '' : 'services',
                            'dataModelName': variable.liveSource,
                            'entityName': options.entityName || variable.type,
                            'page': options.page || 1,
                            'size': options.pagesize,
                            'sort': sort,
                            'data': requestData,
                            'filter': _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.getWhereClauseGenerator(variable, options),
                            'url': variable.getPrefabName() ? (_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.$rootScope.project.deployedUrl + '/prefabs/' + variable.getPrefabName()) : _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.$rootScope.project.deployedUrl
                        };
                        getDistinctDataByFieldsSuccess = function (response, resolve) {
                            if (response && response.type) {
                                if ((response && response.error) || !response) {
                                    (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(error, response.error);
                                    return Promise.reject(response.error);
                                }
                                var result = response.body;
                                var pagination = Object.assign({}, response.body);
                                delete pagination.content;
                                result = { data: result.content, pagination: pagination };
                                (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(success, result);
                                resolve(result);
                            }
                        };
                        getDistinctDataByFieldsError = function (errorMsg, reject) {
                            (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(error, errorMsg);
                            reject(errorMsg);
                        };
                        return new Promise(function (resolve, reject) {
                            _this.makeCall(variable, dbOperation, dbOperationOptions).then(function (response) {
                                getDistinctDataByFieldsSuccess(response, resolve);
                            }, function () {
                                getDistinctDataByFieldsError(error, reject);
                            });
                        });
                    };
                    /*Function to get the aggregated data based on the fields chosen*/
                    LiveVariableManager.prototype.getAggregatedData = function (variable, options, success, error) {
                        var deployedURL = _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.appManager.getDeployedURL();
                        if (deployedURL) {
                            return this.aggregateData(deployedURL, variable, options, success, error);
                        }
                    };
                    LiveVariableManager.prototype.defineFirstLastRecord = function (variable) {
                        if (variable.operation === 'read') {
                            Object.defineProperty(variable, 'firstRecord', {
                                'configurable': true,
                                'get': function () {
                                    return _.get(variable.dataSet, 'data[0]', {});
                                }
                            });
                            Object.defineProperty(variable, 'lastRecord', {
                                'configurable': true,
                                'get': function () {
                                    var data = _.get(variable.dataSet, 'data', []);
                                    return data[data.length - 1];
                                }
                            });
                        }
                    };
                    LiveVariableManager.prototype.getPrimaryKey = function (variable) {
                        return _util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_3__.LiveVariableUtils.getPrimaryKey(variable);
                    };
                    // Returns the search query params.
                    LiveVariableManager.prototype.prepareRequestParams = function (options) {
                        var requestParams;
                        var searchKeys = _.split(options.searchKey, ','), matchModes = _.split(options.matchMode, ','), formFields = {};
                        _.forEach(searchKeys, function (colName, index) {
                            formFields[colName] = {
                                value: options.query,
                                logicalOp: 'AND',
                                matchMode: matchModes[index] || matchModes[0] || 'startignorecase'
                            };
                        });
                        requestParams = {
                            filterFields: formFields,
                            page: options.page,
                            pagesize: options.limit || options.pagesize,
                            skipDataSetUpdate: true,
                            skipToggleState: true,
                            inFlightBehavior: 'executeAll',
                            logicalOp: 'OR',
                            orderBy: options.orderby ? _.replace(options.orderby, /:/g, ' ') : ''
                        };
                        if (options.onBeforeservicecall) {
                            options.onBeforeservicecall(formFields);
                        }
                        return requestParams;
                    };
                    /**
                     * Gets the filtered records based on searchKey
                     * @param variable
                     * @param options contains the searchKey and queryText
                     * @param success
                     * @param error
                     * @returns {Promise<any>}
                     */
                    LiveVariableManager.prototype.searchRecords = function (variable, options, success, error) {
                        var requestParams = this.prepareRequestParams(options);
                        return this.listRecords(variable, requestParams, success, error);
                    };
                    /**
                     * used in onBeforeUpdate call - called last in the function - used in old Variables using dataBinding.
                     * This function migrates the old data dataBinding to filterExpressions equivalent format
                     * @param variable
                     * @param inputData
                     * @private
                     */
                    LiveVariableManager.prototype.upgradeInputDataToFilterExpressions = function (variable, response, inputData) {
                        if (_.isObject(response)) {
                            inputData = response;
                            inputData.condition = 'AND';
                            inputData.rules = [];
                        }
                        /**
                         * if the user deletes a particular criteria, we need to remove this form our data aswell.
                         * so we are keeping a copy of it and the emptying the existing object and now fill it with the
                         * user set criteria. If its just modified, change the data and push it tohe rules or else just add a new criteria
                         */
                        var clonedRules = _.cloneDeep(inputData.rules);
                        inputData.rules = [];
                        _.forEach(inputData, function (valueObj, key) {
                            if (key !== 'condition' && key !== 'rules') {
                                var filteredObj = _.find(clonedRules, function (o) { return o.target === key; });
                                // if the key is found update the value, else create a new rule obj and add it to the existing rules
                                if (filteredObj) {
                                    filteredObj.value = valueObj.value;
                                    filteredObj.matchMode = valueObj.matchMode || valueObj.filterCondition || filteredObj.matchMode || '';
                                    inputData.rules.push(filteredObj);
                                }
                                else {
                                    inputData.rules.push({
                                        'target': key,
                                        'type': '',
                                        'matchMode': valueObj.matchMode || valueObj.filterCondition || '',
                                        'value': valueObj.value,
                                        'required': false
                                    });
                                }
                                delete inputData[key];
                            }
                        });
                        return inputData;
                    };
                    /**
                     * used in onBeforeUpdate call - called first in the function - used in old Variables using dataBinding.
                     * This function migrates the filterExpressions object to flat map structure
                     * @param variable
                     * @param inputData
                     * @private
                     */
                    LiveVariableManager.prototype.downgradeFilterExpressionsToInputData = function (variable, inputData) {
                        if (inputData.hasOwnProperty('getFilterFields')) {
                            inputData = inputData.getFilterFields();
                        }
                        _.forEach(inputData.rules, function (ruleObj) {
                            if (!_.isNil(ruleObj.target) && ruleObj.target !== '') {
                                inputData[ruleObj.target] = {
                                    'value': ruleObj.value,
                                    'matchMode': ruleObj.matchMode
                                };
                            }
                        });
                        return inputData;
                    };
                    LiveVariableManager.prototype.cancel = function (variable, options) {
                        if (_util_inflight_queue__WEBPACK_IMPORTED_MODULE_4__.$queue.requestsQueue.has(variable) && variable._observable) {
                            variable._observable.unsubscribe();
                            _util_inflight_queue__WEBPACK_IMPORTED_MODULE_4__.$queue.process(variable);
                            // notify inflight variable
                            this.notifyInflight(variable, false);
                        }
                    };
                    return LiveVariableManager;
                }(_base_variable_manager__WEBPACK_IMPORTED_MODULE_1__.BaseVariableManager));
                /***/ 
            }),
            /***/ "./src/manager/variable/model-variable.manager.ts": 
            /*!********************************************************!*\
              !*** ./src/manager/variable/model-variable.manager.ts ***!
              \********************************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "ModelVariableManager": function () { return ( /* binding */ModelVariableManager); }
                    /* harmony export */ 
                });
                /* harmony import */ var _base_variable_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base-variable.manager */ "./src/manager/variable/base-variable.manager.ts");
                var __extends = (undefined && undefined.__extends) || (function () {
                    var extendStatics = function (d, b) {
                        extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b)
                                if (Object.prototype.hasOwnProperty.call(b, p))
                                    d[p] = b[p]; };
                        return extendStatics(d, b);
                    };
                    return function (d, b) {
                        if (typeof b !== "function" && b !== null)
                            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
                var checkEmptyObject = function (obj) {
                    var isEmpty = true;
                    _.forEach(obj, function (value) {
                        if (_.isEmpty(value) && !_.isBoolean(value) && !_.isNumber(value)) {
                            return;
                        }
                        if (!_.isObject(value)) {
                            isEmpty = false;
                        }
                        else if (_.isArray(value)) {
                            // If array, check if array is empty or if it has only one value and the value is empty
                            isEmpty = _.isEmpty(value) || (value.length === 1 ? _.isEmpty(value[0]) : false);
                        }
                        else {
                            // If object, loop over the object to check if it is empty or not
                            isEmpty = checkEmptyObject(value);
                        }
                        return isEmpty; // isEmpty false will break the loop
                    });
                    return isEmpty;
                };
                var ModelVariableManager = /** @class */ (function (_super) {
                    __extends(ModelVariableManager, _super);
                    function ModelVariableManager() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    /*
                    * Case: a LIST type static variable having only one object
                    * and the object has all fields empty, remove that object
                    */
                    ModelVariableManager.prototype.removeFirstEmptyObject = function (variable) {
                        if (_.isArray(variable.dataSet) && variable.dataSet.length === 1 && checkEmptyObject(variable.dataSet[0])) {
                            variable.dataSet = [];
                        }
                    };
                    return ModelVariableManager;
                }(_base_variable_manager__WEBPACK_IMPORTED_MODULE_0__.BaseVariableManager));
                /***/ 
            }),
            /***/ "./src/manager/variable/service-variable.manager.ts": 
            /*!**********************************************************!*\
              !*** ./src/manager/variable/service-variable.manager.ts ***!
              \**********************************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "ServiceVariableManager": function () { return ( /* binding */ServiceVariableManager); }
                    /* harmony export */ 
                });
                /* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/utils */ "./src/util/utils.ts");
                /* harmony import */ var _util_file_upload_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/file-upload.util */ "./src/util/file-upload.util.ts");
                /* harmony import */ var _util_variable_service_variable_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/variable/service-variable.utils */ "./src/util/variable/service-variable.utils.ts");
                /* harmony import */ var _util_inflight_queue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/inflight-queue */ "./src/util/inflight-queue.ts");
                /* harmony import */ var _base_variable_manager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./base-variable.manager */ "./src/manager/variable/base-variable.manager.ts");
                /* harmony import */ var _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../constants/variables.constants */ "./src/constants/variables.constants.ts");
                /* harmony import */ var _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/variable/variables.utils */ "./src/util/variable/variables.utils.ts");
                /* harmony import */ var _util_oAuth_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/oAuth.utils */ "./src/util/oAuth.utils.ts");
                /* harmony import */ var _util_variable_pagination_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/variable/pagination.utils */ "./src/util/variable/pagination.utils.ts");
                /* harmony import */ var _model_base_variable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../model/base-variable */ "./src/model/base-variable.ts");
                /* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
                /* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/ __webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_10__);
                var __extends = (undefined && undefined.__extends) || (function () {
                    var extendStatics = function (d, b) {
                        extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b)
                                if (Object.prototype.hasOwnProperty.call(b, p))
                                    d[p] = b[p]; };
                        return extendStatics(d, b);
                    };
                    return function (d, b) {
                        if (typeof b !== "function" && b !== null)
                            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
                var ServiceVariableManager = /** @class */ (function (_super) {
                    __extends(ServiceVariableManager, _super);
                    function ServiceVariableManager() {
                        var _this = _super !== null && _super.apply(this, arguments) || this;
                        _this.fileUploadResponse = [];
                        _this.fileUploadCount = 0;
                        _this.totalFilesCount = 0;
                        _this.successFileUploadCount = 0;
                        _this.failedFileUploadCount = 0;
                        return _this;
                    }
                    /**
                     * function to process error response from a service
                     * @param {ServiceVariable} variable
                     * @param {string} errMsg
                     * @param {Function} errorCB
                     * @param xhrObj
                     * @param {boolean} skipNotification
                     * @param {boolean} skipDefaultNotification
                     */
                    ServiceVariableManager.prototype.processErrorResponse = function (variable, errMsg, errorCB, xhrObj, skipNotification, skipDefaultNotification) {
                        var methodInfo = this.getMethodInfo(variable, {}, {});
                        var securityDefnObj = lodash__WEBPACK_IMPORTED_MODULE_10___default().get(methodInfo, 'securityDefinitions.0');
                        var advancedOptions = this.prepareCallbackOptions(xhrObj);
                        // EVENT: ON_ERROR
                        if (!skipNotification) {
                            (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.ERROR, variable, errMsg, advancedOptions, skipDefaultNotification);
                        }
                        if (lodash__WEBPACK_IMPORTED_MODULE_10___default().get(securityDefnObj, 'type') === _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.REST_SERVICE.SECURITY_DEFN.OAUTH2
                            && lodash__WEBPACK_IMPORTED_MODULE_10___default().includes([_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.HTTP_STATUS_CODE.UNAUTHORIZED, _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.HTTP_STATUS_CODE.FORBIDDEN], lodash__WEBPACK_IMPORTED_MODULE_10___default().get(xhrObj, 'status'))) {
                            (0, _util_oAuth_utils__WEBPACK_IMPORTED_MODULE_7__.removeAccessToken)(securityDefnObj['x-WM-PROVIDER_ID']);
                        }
                        /* trigger error callback */
                        (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(errorCB, errMsg);
                        if (!_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.CONSTANTS.isStudioMode) {
                            /* process next requests in the queue */
                            variable.canUpdate = true;
                            _util_inflight_queue__WEBPACK_IMPORTED_MODULE_3__.$queue.process(variable);
                            // EVENT: ON_CAN_UPDATE
                            (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.CAN_UPDATE, variable, errMsg, advancedOptions);
                        }
                    };
                    /**
                     * function to process success response from a service
                     * @param response
                     * @param variable
                     * @param options
                     * @param success
                     */
                    ServiceVariableManager.prototype.processSuccessResponse = function (response, variable, options, success, resHeaders, operationInf) {
                        var dataSet;
                        var newDataSet;
                        var pagination = {};
                        var advancedOptions;
                        var jsonParsedResponse = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getValidJSON)(response);
                        response = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isDefined)(jsonParsedResponse) ? jsonParsedResponse : ((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.xmlToJson)(response) || response);
                        var isResponsePageable = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isPageable)(response);
                        if (variable.serviceType === 'DataService' || variable.serviceType === 'JavaService') {
                            var decodedData = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.decodeData)(response);
                            if (lodash__WEBPACK_IMPORTED_MODULE_10___default().isString(response)) {
                                response = decodedData;
                            }
                        }
                        if (isResponsePageable) {
                            dataSet = response.content;
                            pagination = lodash__WEBPACK_IMPORTED_MODULE_10___default().omit(response, 'content');
                        }
                        else {
                            dataSet = response;
                        }
                        /**
                         * send pagination object with advancedOptions all the time.
                         * With this, user can provide pagination option, even if it is not there.
                         * applicable to 3rd party services that do not support pagination out of the box.
                         */
                        advancedOptions = this.prepareCallbackOptions(options.xhrObj, { pagination: pagination, rawData: dataSet });
                        // EVENT: ON_RESULT
                        (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.RESULT, variable, response, advancedOptions);
                        // trigger success callback, pass data received from server as it is.
                        (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(success, response, pagination);
                        /* if dataTransformation enabled, transform the data */
                        if (variable.transformationColumns) {
                            this.transformData(response, variable);
                        }
                        // if a primitive type response is returned, wrap it in an object
                        dataSet = (!lodash__WEBPACK_IMPORTED_MODULE_10___default().isObject(dataSet)) ? { 'value': dataSet } : dataSet;
                        // EVENT: ON_PREPARE_SETDATA
                        newDataSet = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.PREPARE_SETDATA, variable, dataSet, advancedOptions);
                        if ((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isDefined)(newDataSet)) {
                            // setting newDataSet as the response to service variable onPrepareSetData
                            dataSet = newDataSet;
                        }
                        var inputFields = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(options.inputFields || variable.dataBinding);
                        // WMS-22361 : For crud variable, apply operation info recived else deduce for service variables
                        var operationInfo = operationInf ? operationInf : this.getMethodInfo(variable, inputFields, options);
                        var paginationInfo = _util_variable_pagination_utils__WEBPACK_IMPORTED_MODULE_8__.PaginationUtils.getPaginationInfo(operationInfo, variable);
                        if (paginationInfo) {
                            var res = _util_variable_pagination_utils__WEBPACK_IMPORTED_MODULE_8__.PaginationUtils.generatePaginationRes(operationInfo, paginationInfo, response, resHeaders, options, variable);
                            if (!lodash__WEBPACK_IMPORTED_MODULE_10___default().isEmpty(res)) {
                                _util_variable_pagination_utils__WEBPACK_IMPORTED_MODULE_8__.PaginationUtils.setVariablePagination(variable, res, options);
                            }
                        }
                        /* update the dataset against the variable, if response is non-object, insert the response in 'value' field of dataSet */
                        if (!options.forceRunMode && !options.skipDataSetUpdate) {
                            if (!variable._paginationConfig) {
                                variable.pagination = pagination;
                            }
                            variable.dataSet = dataSet;
                            // legacy properties in dataSet, [content]
                            if (isResponsePageable) {
                                Object.defineProperty(variable.dataSet, 'content', {
                                    get: function () {
                                        return variable.dataSet;
                                    }
                                });
                            }
                        }
                        variable.notify(_model_base_variable__WEBPACK_IMPORTED_MODULE_9__.VariableEvents.AFTER_INVOKE, [this, dataSet]);
                        setTimeout(function () {
                            // EVENT: ON_SUCCESS
                            (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.SUCCESS, variable, dataSet, advancedOptions);
                            if (!_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.CONSTANTS.isStudioMode) {
                                /* process next requests in the queue */
                                variable.canUpdate = true;
                                _util_inflight_queue__WEBPACK_IMPORTED_MODULE_3__.$queue.process(variable);
                            }
                            // EVENT: ON_CAN_UPDATE
                            (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.CAN_UPDATE, variable, dataSet, advancedOptions);
                        });
                        return {
                            data: variable.dataSet,
                            pagination: variable.pagination
                        };
                    };
                    ServiceVariableManager.prototype.uploadFileInFormData = function (variable, options, success, error, file, requestParams) {
                        var _this = this;
                        var promise = (0, _util_file_upload_util__WEBPACK_IMPORTED_MODULE_1__.upload)(file, variable, requestParams.data, {
                            fileParamName: 'files',
                            url: requestParams.url
                        });
                        promise.then(function (data) {
                            _this.fileUploadCount++;
                            _this.successFileUploadCount++;
                            _this.fileUploadResponse.push(data[0]);
                            if (_this.totalFilesCount === _this.fileUploadCount) {
                                if (_this.failedFileUploadCount === 0) {
                                    _this.processSuccessResponse(_this.fileUploadResponse, variable, options, success);
                                    _this.fileUploadResponse = [];
                                    if (!variable.onSuccess) {
                                        _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.appManager && _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.appManager.notifyApp(_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.appManager.getAppLocale().MESSAGE_FILE_UPLOAD_SUCCESS, 'success');
                                    }
                                }
                                else {
                                    (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.ERROR, variable, _this.fileUploadResponse);
                                    _this.fileUploadResponse = [];
                                    _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.appManager && _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.appManager.notifyApp(_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.appManager.getAppLocale().MESSAGE_FILE_UPLOAD_ERROR, 'error');
                                }
                                _this.fileUploadCount = 0;
                                _this.successFileUploadCount = 0;
                                _this.totalFilesCount = 0;
                            }
                            return data;
                        }, function (e) {
                            _this.fileUploadCount++;
                            _this.failedFileUploadCount++;
                            _this.fileUploadResponse.push(e);
                            var errMsg = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.getErrMessage)(e, variable.httpService.getLocale());
                            // if a file upload failed, notify the progress listener to take action
                            if (variable._progressObservable) {
                                variable._progressObservable.next({
                                    'status': "error",
                                    'fileName': file.name,
                                    'errMsg': errMsg
                                });
                            }
                            if (_this.totalFilesCount === _this.fileUploadCount) {
                                _this.processErrorResponse(variable, errMsg, error, e, options.skipNotification);
                                _this.fileUploadResponse = [];
                                _this.fileUploadCount = 0;
                                _this.failedFileUploadCount = 0;
                                _this.totalFilesCount = 0;
                            }
                            return e;
                        }, function (data) {
                            if (variable._progressObservable) {
                                variable._progressObservable.next({
                                    'progress': data,
                                    'status': _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.PROGRESS,
                                    'fileName': file.name
                                });
                            }
                            (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.PROGRESS, variable, data);
                            return data;
                        });
                        return promise;
                    };
                    /**
                     * Checks if the user is logged in or not and returns appropriate error
                     * If user is not logged in, Session timeout logic is run, for user to login
                     * @param variable
                     * @returns {any}
                     */
                    ServiceVariableManager.prototype.handleAuthError = function (variable, success, errorCB, options) {
                        var isUserAuthenticated = lodash__WEBPACK_IMPORTED_MODULE_10___default().get(_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.securityService.get(), 'authenticated');
                        var info;
                        if (isUserAuthenticated) {
                            info = {
                                error: {
                                    message: 'You\'re not authorised to access the resource "' + variable.service + '".'
                                }
                            };
                        }
                        else {
                            info = {
                                error: {
                                    message: 'You\'re not authenticated to access the resource "' + variable.service + '".',
                                    skipDefaultNotification: true
                                }
                            };
                            _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.appManager.pushToSessionFailureRequests(variable.invoke.bind(variable, options, success, errorCB));
                            _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.appManager.handle401();
                        }
                        console.warn(variable.name + ': ' + info.error.message);
                        return info;
                    };
                    /**
                     * Handles error, when variable's metadata is not found. The reason for this can be:
                     *  - API is secure and user is not logged in
                     *  - API is secure and user is logged in but not authorized
                     *  - The servicedefs are not generated properly at the back end (need to edit the variable and re-run the project)
                     * @param info
                     * @param variable
                     * @param errorCB
                     * @param options
                     */
                    ServiceVariableManager.prototype.handleRequestMetaError = function (info, variable, success, errorCB, options) {
                        var err_type = lodash__WEBPACK_IMPORTED_MODULE_10___default().get(info, 'error.type');
                        switch (err_type) {
                            case _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.REST_SERVICE.ERR_TYPE.NO_ACCESSTOKEN:
                                (0, _util_oAuth_utils__WEBPACK_IMPORTED_MODULE_7__.performAuthorization)(undefined, info.securityDefnObj[_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.REST_SERVICE.OAUTH_PROVIDER_KEY], this.invoke.bind(this, variable, options, success, errorCB), null, this.getProviderInfo(variable, info.securityDefnObj['x-WM-PROVIDER_ID']));
                                this.processErrorResponse(variable, info.error.message, errorCB, options.xhrObj, true, true);
                                break;
                            case _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.REST_SERVICE.ERR_TYPE.USER_UNAUTHORISED:
                                info = this.handleAuthError(variable, success, errorCB, options);
                                this.processErrorResponse(variable, info.error.message, errorCB, options.xhrObj, options.skipNotification, info.error.skipDefaultNotification);
                                break;
                            case _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.REST_SERVICE.ERR_TYPE.METADATA_MISSING:
                            case _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.REST_SERVICE.ERR_TYPE.CRUD_OPERATION_MISSING:
                                if (info.error.message) {
                                    info.error.message = info.error.message.replace('$variable', variable.name);
                                    var reasons = void 0;
                                    if (err_type === _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.REST_SERVICE.ERR_TYPE.METADATA_MISSING) {
                                        reasons = ['1. You did not Preview the app after creating a Variable for the imported service.', '2. You deleted the imported service this Variable is linked to.'];
                                    }
                                    else {
                                        reasons = ['1. You haven\'t chosen an endpoint for ' + options.operation + ' operation for this Entity.'];
                                    }
                                    console.warn(info.error.message + '\n Possible reasons for this:\n ' + reasons.join('\n '));
                                }
                                this.processErrorResponse(variable, info.error.message, errorCB, options.xhrObj, options.skipNotification, info.error.skipDefaultNotification);
                                break;
                            default:
                                if (info.error.message) {
                                    console.warn(info.error.message, variable.name);
                                    this.processErrorResponse(variable, info.error.message, errorCB, options.xhrObj, options.skipNotification, info.error.skipDefaultNotification);
                                }
                        }
                        return info;
                    };
                    /**
                     * function to transform the service data as according to the variable configuration
                     * this is used when 'transformationColumns' property is set on the variable
                     * @param data: data returned from the service
                     * @variable: variable object triggering the service
                     */
                    ServiceVariableManager.prototype.transformData = function (data, variable) {
                        data.wmTransformedData = [];
                        var columnsArray = variable.transformationColumns, dataArray = lodash__WEBPACK_IMPORTED_MODULE_10___default().get(data, variable.dataField) || [], transformedData = data.wmTransformedData;
                        lodash__WEBPACK_IMPORTED_MODULE_10___default().forEach(dataArray, function (datum, index) {
                            transformedData[index] = {};
                            lodash__WEBPACK_IMPORTED_MODULE_10___default().forEach(columnsArray, function (column, columnIndex) {
                                transformedData[index][column] = datum[columnIndex];
                            });
                        });
                    };
                    /**
                     * gets the service operation info against a service variable
                     * this is extracted from the metadataservice
                     * @param variable
                     * @param inputFields: sample values, if provided, will be set against params in the definition
                     * @param options
                     * @returns {any}
                     */
                    ServiceVariableManager.prototype.getMethodInfo = function (variable, inputFields, options) {
                        var methodInfo;
                        if (!lodash__WEBPACK_IMPORTED_MODULE_10___default().isEmpty(_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.metadataService)) {
                            var serviceDef = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.metadataService.getByOperationId(variable.operationId, variable.getPrefabName()));
                            methodInfo = serviceDef === null ? null : lodash__WEBPACK_IMPORTED_MODULE_10___default().get(serviceDef, 'wmServiceOperationInfo');
                        }
                        else {
                            methodInfo = variable.serviceInfo;
                        }
                        if (!methodInfo) {
                            return methodInfo;
                        }
                        var securityDefnObj = lodash__WEBPACK_IMPORTED_MODULE_10___default().get(methodInfo.securityDefinitions, '0'), isOAuthTypeService = securityDefnObj && (securityDefnObj.type === _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.REST_SERVICE.SECURITY_DEFN.OAUTH2);
                        if (methodInfo.parameters) {
                            methodInfo.parameters.forEach(function (param) {
                                // Ignore readOnly params in case of formData file params will be duplicated
                                if (param.readOnly) {
                                    return;
                                }
                                param.sampleValue = inputFields[param.name];
                                /* supporting pagination for query service variable */
                                if (_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.PAGINATION_PARAMS.indexOf(param.name) !== -1) {
                                    if (param.name === 'size') {
                                        param.sampleValue = options.size || param.sampleValue || parseInt(variable.maxResults, 10);
                                    }
                                    else if (param.name === 'page') {
                                        param.sampleValue = options.page || param.sampleValue || 1;
                                    }
                                    else if (param.name === 'sort') {
                                        param.sampleValue = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.getEvaluatedOrderBy)(variable.orderBy, options.orderBy) || param.sampleValue || '';
                                    }
                                }
                                else if (param.name === 'access_token' && isOAuthTypeService) {
                                    param.sampleValue = (0, _util_oAuth_utils__WEBPACK_IMPORTED_MODULE_7__.getAccessToken)(securityDefnObj[_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.REST_SERVICE.OAUTH_PROVIDER_KEY], null);
                                }
                            });
                        }
                        return methodInfo;
                    };
                    /**
                     * gets the provider info against a service variable's provider
                     * this is extracted from the metadataservice
                     * @param variable
                     * @param providerId
                     * @returns {any}
                     */
                    ServiceVariableManager.prototype.getProviderInfo = function (variable, providerId) {
                        return (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.metadataService === null || _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.metadataService === void 0 ? void 0 : _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.metadataService.getByProviderId(providerId, variable.getPrefabName()));
                    };
                    /**
                     * Returns true if any of the files are in onProgress state
                     */
                    ServiceVariableManager.prototype.isFileUploadInProgress = function (dataBindings) {
                        var filesStatus = false;
                        lodash__WEBPACK_IMPORTED_MODULE_10___default().forEach(dataBindings, function (dataBinding) {
                            if (lodash__WEBPACK_IMPORTED_MODULE_10___default().isArray(dataBinding) && dataBinding[0] instanceof File) {
                                lodash__WEBPACK_IMPORTED_MODULE_10___default().forEach(dataBinding, function (file) {
                                    if (file.status === 'onProgress') {
                                        filesStatus = true;
                                        return;
                                    }
                                });
                            }
                        });
                        return filesStatus;
                    };
                    // Makes the call for Uploading file/ files
                    ServiceVariableManager.prototype.uploadFile = function (variable, options, success, error, inputFields, requestParams) {
                        var _this = this;
                        var fileParamCount = 0;
                        var fileArr = [], promArr = [];
                        lodash__WEBPACK_IMPORTED_MODULE_10___default().forEach(inputFields, function (inputField) {
                            if (lodash__WEBPACK_IMPORTED_MODULE_10___default().isArray(inputField)) {
                                if (inputField[0] instanceof File) {
                                    fileParamCount++;
                                }
                                lodash__WEBPACK_IMPORTED_MODULE_10___default().forEach(inputField, function (input) {
                                    if (input instanceof File || lodash__WEBPACK_IMPORTED_MODULE_10___default().find(lodash__WEBPACK_IMPORTED_MODULE_10___default().values(input), function (o) { return o instanceof Blob; })) {
                                        fileArr.push(input);
                                        _this.totalFilesCount++;
                                        fileParamCount = fileParamCount || 1;
                                    }
                                });
                            }
                            else {
                                if (inputField instanceof File) {
                                    fileParamCount++;
                                    _this.totalFilesCount++;
                                    fileArr.push(inputField);
                                }
                            }
                        });
                        if (fileParamCount === 1) {
                            if (inputFields.files.length > 1) {
                                lodash__WEBPACK_IMPORTED_MODULE_10___default().forEach(fileArr, function (file) {
                                    promArr.push(_this.uploadFileInFormData(variable, options, success, error, file, requestParams));
                                });
                                return Promise.all(promArr);
                            }
                            else {
                                return this.uploadFileInFormData(variable, options, success, error, fileArr[0], requestParams);
                            }
                        }
                    };
                    /**
                     * proxy for the invoke call
                     * Request Info is constructed
                     * if error found, error is thrown
                     * else, call is made
                     * @param {ServiceVariable} variable
                     * @param options
                     * @param {Function} success
                     * @param {Function} error
                     * @returns {any}
                     * @private
                     */
                    ServiceVariableManager.prototype._invoke = function (variable, options, success, error) {
                        var _this = this;
                        var inputFields = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(options.inputFields || variable.dataBinding);
                        // EVENT: ON_BEFORE_UPDATE
                        var output = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.BEFORE_UPDATE, variable, inputFields, options);
                        var successHandler;
                        var errorHandler;
                        if (output === false) {
                            _util_inflight_queue__WEBPACK_IMPORTED_MODULE_3__.$queue.process(variable);
                            (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(error);
                            return;
                        }
                        if (lodash__WEBPACK_IMPORTED_MODULE_10___default().isObject(output)) {
                            inputFields = output;
                        }
                        var operationInfo = this.getMethodInfo(variable, inputFields, options);
                        var requestParams = _util_variable_service_variable_utils__WEBPACK_IMPORTED_MODULE_2__.ServiceVariableUtils.constructRequestParams(variable, operationInfo, inputFields, options);
                        // check errors
                        if (requestParams.error) {
                            var info = this.handleRequestMetaError(requestParams, variable, success, error, options);
                            var reason = (lodash__WEBPACK_IMPORTED_MODULE_10___default().get(info, 'error.message') || 'An error occurred while triggering the variable: ') + ': ' + variable.name;
                            (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(error);
                            return Promise.reject(reason);
                        }
                        // file upload
                        if (_util_variable_service_variable_utils__WEBPACK_IMPORTED_MODULE_2__.ServiceVariableUtils.isFileUploadRequest(variable)) {
                            var uploadPromise = this.uploadFile(variable, options, success, error, inputFields, requestParams);
                            if (uploadPromise) {
                                return uploadPromise;
                            }
                        }
                        // file download
                        if (operationInfo && lodash__WEBPACK_IMPORTED_MODULE_10___default().isArray(operationInfo.produces) && lodash__WEBPACK_IMPORTED_MODULE_10___default().includes(operationInfo.produces, _constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.WS_CONSTANTS.CONTENT_TYPES.OCTET_STREAM)) {
                            // ToDo - variable seperation
                            return variable.simulateFileDownload(requestParams, variable.dataBinding.file || variable.name, variable.dataBinding.exportType, function () {
                                (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.SUCCESS, variable, null, null, null);
                                _util_inflight_queue__WEBPACK_IMPORTED_MODULE_3__.$queue.process(variable);
                                (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(success);
                            }, function () {
                                (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.ERROR, variable, null, null, null);
                                _util_inflight_queue__WEBPACK_IMPORTED_MODULE_3__.$queue.process(variable);
                                (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(error);
                            });
                        }
                        // notify variable progress
                        this.notifyInflight(variable, !options.skipToggleState);
                        successHandler = function (response, resolve) {
                            if (response && response.type || response && response.status) {
                                var res = response.body || response.data;
                                var data = _this.processSuccessResponse(res, variable, lodash__WEBPACK_IMPORTED_MODULE_10___default().extend(options, { 'xhrObj': response }), success, response.headers);
                                // notify variable success
                                _this.notifyInflight(variable, false, data);
                                resolve(response);
                            }
                        };
                        errorHandler = function (err, reject) {
                            var errMsg = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.getErrMessage)(err, variable.httpService.getLocale());
                            // notify variable error
                            _this.notifyInflight(variable, false);
                            _this.processErrorResponse(variable, errMsg, error, err, options.skipNotification);
                            reject({
                                error: errMsg,
                                details: err
                            });
                        };
                        // make the call and return a promise to the user to support script calls made by users
                        return new Promise(function (resolve, reject) {
                            requestParams.responseType = 'text'; // this is to return text response. JSON & XML-to-JSON parsing is handled in success handler.
                            // ToDo - variable seperation
                            // this.httpCall(requestParams, variable).then((response) => {
                            //     successHandler(response, resolve);
                            // }, err => {
                            //     const validJSON = getValidJSON(err.error);
                            //     err.error = isDefined(validJSON) ? validJSON : err.error;
                            //     errorHandler(err, reject);
                            // });
                            // the _observable property on variable is used store the observable using which the network call is made
                            // this can be used to cancel the variable calls.
                            variable.httpService.sendCall(requestParams, variable).then(function (response) {
                                successHandler(response, resolve);
                            }, function (err) {
                                var validJSON = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getValidJSON)(err.error);
                                err.error = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isDefined)(validJSON) ? validJSON : err.error;
                                errorHandler(err, reject);
                            });
                        });
                    };
                    // *********************************************************** PUBLIC ***********************************************************//
                    ServiceVariableManager.prototype.invoke = function (variable, options, success, error) {
                        options = options || {};
                        // appManager.notify('check-state-persistence-options', {
                        //     options: options,
                        //     variable: variable
                        // });
                        options.inputFields = options.inputFields || (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(variable.dataBinding);
                        return _util_inflight_queue__WEBPACK_IMPORTED_MODULE_3__.$queue.submit(variable).then(this._invoke.bind(this, variable, options, success, error), error);
                    };
                    ServiceVariableManager.prototype.setPagination = function (variable, data) {
                        variable._paginationConfig = data;
                    };
                    ServiceVariableManager.prototype.download = function (variable, options, successHandler, errorHandler) {
                        options = options || {};
                        var inputParams = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(variable.dataBinding);
                        var inputData = options.data || {};
                        var methodInfo = this.getMethodInfo(variable, inputParams, options);
                        var requestParams;
                        methodInfo.relativePath += '/export';
                        requestParams = _util_variable_service_variable_utils__WEBPACK_IMPORTED_MODULE_2__.ServiceVariableUtils.constructRequestParams(variable, methodInfo, inputParams);
                        requestParams.data = inputData;
                        requestParams.data.fields = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.formatExportExpression)(inputData.fields || []);
                        // extra options provided, these may be used in future for integrating export feature with ext. services
                        requestParams.method = options.httpMethod || 'POST';
                        requestParams.url = options.url || requestParams.url;
                        // If request params returns error then show an error toaster
                        if (lodash__WEBPACK_IMPORTED_MODULE_10___default().hasIn(requestParams, 'error.message')) {
                            (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(errorHandler, requestParams.error.message);
                            return Promise.reject(requestParams.error.message);
                        }
                        return variable.httpService.send(requestParams).then(function (response) {
                            if (response && (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isValidWebURL)(response.body.result)) {
                                window.location.href = response.body.result;
                                (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(successHandler, response);
                            }
                            else {
                                (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.ERROR, variable, response);
                                (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(errorHandler, response);
                            }
                        }, function (response, xhrObj) {
                            (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.ERROR, variable, response, xhrObj);
                            (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(errorHandler, response);
                        });
                    };
                    ServiceVariableManager.prototype.getInputParms = function (variable) {
                        var wmServiceOperationInfo;
                        if (!lodash__WEBPACK_IMPORTED_MODULE_10___default().isEmpty(_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.metadataService)) {
                            wmServiceOperationInfo = lodash__WEBPACK_IMPORTED_MODULE_10___default().get(_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.metadataService.getByOperationId(variable.operationId, variable.getPrefabName()), 'wmServiceOperationInfo');
                        }
                        else {
                            wmServiceOperationInfo = variable.serviceInfo;
                        }
                        return lodash__WEBPACK_IMPORTED_MODULE_10___default().get(wmServiceOperationInfo, 'parameters');
                    };
                    ServiceVariableManager.prototype.setInput = function (variable, key, val, options) {
                        return (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.setInput)(variable.dataBinding, key, val, options);
                    };
                    /**
                     * Cancels an on going service request
                     * @param variable
                     * @param $file
                     */
                    ServiceVariableManager.prototype.cancel = function (variable, $file) {
                        // CHecks if there is any pending requests in the queue
                        if (_util_inflight_queue__WEBPACK_IMPORTED_MODULE_3__.$queue.requestsQueue.has(variable)) {
                            // If the request is a File upload request then modify the elements associated with file upload
                            // else unsubscribe from the observable on the variable.
                            if (_util_variable_service_variable_utils__WEBPACK_IMPORTED_MODULE_2__.ServiceVariableUtils.isFileUploadRequest(variable)) {
                                variable.httpService.cancel(variable, $file);
                                $file.status = 'abort';
                                this.totalFilesCount--;
                                (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_6__.initiateCallback)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_5__.VARIABLE_CONSTANTS.EVENT.ABORT, variable, $file);
                                if (!this.isFileUploadInProgress(variable.dataBinding) && this.totalFilesCount === 0) {
                                    _util_inflight_queue__WEBPACK_IMPORTED_MODULE_3__.$queue.process(variable);
                                    // notify inflight variable
                                    this.notifyInflight(variable, false);
                                }
                            }
                            else {
                                if (variable.httpService.cancel) {
                                    variable.httpService.cancel(variable);
                                    _util_inflight_queue__WEBPACK_IMPORTED_MODULE_3__.$queue.process(variable);
                                    // notify inflight variable
                                    this.notifyInflight(variable, false);
                                }
                            }
                        }
                    };
                    ServiceVariableManager.prototype.defineFirstLastRecord = function (variable) {
                        if (variable.isList) {
                            Object.defineProperty(variable, 'firstRecord', {
                                'configurable': true,
                                'get': function () {
                                    var dataSet = variable.dataSet;
                                    // For procedure(v1) data doesn't come under content
                                    return lodash__WEBPACK_IMPORTED_MODULE_10___default().head(dataSet && dataSet.content) || lodash__WEBPACK_IMPORTED_MODULE_10___default().head(dataSet) || {};
                                }
                            });
                            Object.defineProperty(variable, 'lastRecord', {
                                'configurable': true,
                                'get': function () {
                                    var dataSet = variable.dataSet;
                                    // For procedure(v1) data doesn't come under content
                                    return lodash__WEBPACK_IMPORTED_MODULE_10___default().last(dataSet && dataSet.content) || lodash__WEBPACK_IMPORTED_MODULE_10___default().last(dataSet) || {};
                                }
                            });
                        }
                    };
                    // Gets the input params of the service variable and also add params from the searchKeys (filterfields)
                    ServiceVariableManager.prototype.getQueryParams = function (filterFields, searchValue, variable) {
                        var inputParams = this.getInputParms(variable);
                        var queryParams = _util_variable_service_variable_utils__WEBPACK_IMPORTED_MODULE_2__.ServiceVariableUtils.excludePaginationParams(inputParams);
                        var inputFields = {};
                        // check if some param value is already available in databinding and update the inputFields accordingly
                        lodash__WEBPACK_IMPORTED_MODULE_10___default().map(variable.dataBinding, function (value, key) {
                            inputFields[key] = value;
                        });
                        // add the query params mentioned in the searchkey to inputFields
                        lodash__WEBPACK_IMPORTED_MODULE_10___default().forEach(filterFields, function (value) {
                            if (lodash__WEBPACK_IMPORTED_MODULE_10___default().includes(queryParams, value)) {
                                inputFields[value] = searchValue;
                            }
                        });
                        return inputFields;
                    };
                    /**
                     * This method returns filtered records based on searchKey and queryText.
                     * @param variable
                     * @param options
                     * @param success
                     * @param error
                     * @returns {Promise<any>}
                     */
                    ServiceVariableManager.prototype.searchRecords = function (variable, options, success, error) {
                        var inputFields = this.getQueryParams(lodash__WEBPACK_IMPORTED_MODULE_10___default().split(options.searchKey, ','), options.query, variable);
                        var requestParams = {
                            page: options.page,
                            pagesize: options.pagesize,
                            skipDataSetUpdate: true,
                            skipToggleState: true,
                            inFlightBehavior: 'executeAll',
                            inputFields: inputFields
                        };
                        if (options.onBeforeservicecall) {
                            options.onBeforeservicecall(inputFields);
                        }
                        return this.invoke(variable, requestParams, success, error).catch(_util_utils__WEBPACK_IMPORTED_MODULE_0__.noop);
                    };
                    return ServiceVariableManager;
                }(_base_variable_manager__WEBPACK_IMPORTED_MODULE_4__.BaseVariableManager));
                /***/ 
            }),
            /***/ "./src/model/action/timer-action.ts": 
            /*!******************************************!*\
              !*** ./src/model/action/timer-action.ts ***!
              \******************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "TimerAction": function () { return ( /* binding */TimerAction); }
                    /* harmony export */ 
                });
                /* harmony import */ var _base_action__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base-action */ "./src/model/base-action.ts");
                /* harmony import */ var _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants/variables.constants */ "./src/constants/variables.constants.ts");
                /* harmony import */ var _factory_variable_manager_factory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../factory/variable-manager.factory */ "./src/factory/variable-manager.factory.ts");
                var __extends = (undefined && undefined.__extends) || (function () {
                    var extendStatics = function (d, b) {
                        extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b)
                                if (Object.prototype.hasOwnProperty.call(b, p))
                                    d[p] = b[p]; };
                        return extendStatics(d, b);
                    };
                    return function (d, b) {
                        if (typeof b !== "function" && b !== null)
                            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
                var getManager = function () {
                    return _factory_variable_manager_factory__WEBPACK_IMPORTED_MODULE_2__.VariableManagerFactory.get(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.CATEGORY.TIMER);
                };
                var TimerAction = /** @class */ (function (_super) {
                    __extends(TimerAction, _super);
                    function TimerAction(variable) {
                        var _this = _super.call(this) || this;
                        _this.repeating = false;
                        _this._isFired = false;
                        Object.assign(_this, variable);
                        return _this;
                    }
                    // Backward compatible method
                    TimerAction.prototype.fire = function (options, success, error) {
                        if (this.repeating) {
                            this.currentOptions = options;
                            this._isFired = true;
                        }
                        return getManager().trigger(this, options, success, error);
                    };
                    TimerAction.prototype.invoke = function (options, success, error) {
                        return this.fire(options, success, error);
                    };
                    TimerAction.prototype.cancel = function () {
                        return getManager().cancel(this);
                    };
                    TimerAction.prototype.mute = function () {
                        _super.prototype.mute.call(this);
                        if (this.repeating) {
                            this.cancel();
                        }
                    };
                    TimerAction.prototype.unmute = function () {
                        _super.prototype.unmute.call(this);
                        if (this.repeating && this._isFired) {
                            this.fire(this.currentOptions, null, null);
                        }
                    };
                    return TimerAction;
                }(_base_action__WEBPACK_IMPORTED_MODULE_0__.BaseAction));
                /***/ 
            }),
            /***/ "./src/model/base-action.ts": 
            /*!**********************************!*\
              !*** ./src/model/base-action.ts ***!
              \**********************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "BaseAction": function () { return ( /* binding */BaseAction); }
                    /* harmony export */ 
                });
                /* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/types */ "./src/types/types.ts");
                /* harmony import */ var _util_dataset_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/dataset-util */ "./src/util/dataset-util.ts");
                /* harmony import */ var _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/variable/variables.utils */ "./src/util/variable/variables.utils.ts");
                /* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/utils */ "./src/util/utils.ts");
                var BaseAction = /** @class */ (function () {
                    function BaseAction() {
                        this.isMuted = false;
                    }
                    BaseAction.prototype.execute = function (operation, options) {
                        var returnVal;
                        switch (operation) {
                            case _types_types__WEBPACK_IMPORTED_MODULE_0__.DataSource.Operation.GET_NAME:
                                returnVal = this.name;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_0__.DataSource.Operation.GET_UNIQUE_IDENTIFIER:
                                returnVal = this._id;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_0__.DataSource.Operation.GET_CONTEXT_IDENTIFIER:
                                returnVal = this._context;
                                break;
                        }
                        return returnVal;
                    };
                    BaseAction.prototype.invokeOnParamChange = function (obj, newVal, oldVal) {
                        var target = obj.target, root = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.getTarget)(this), targetObj = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.getTargetObj)(obj, root, this), targetNodeKey = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.getTargetNodeKey)(target);
                        if ((newVal === oldVal && _.isUndefined(newVal)) || (_.isUndefined(newVal) && (!_.isUndefined(oldVal) || !_.isUndefined(targetObj[targetNodeKey])))) {
                            return;
                        }
                        // Skip cloning for blob column
                        if (!_.includes(['blob', 'file'], obj.type)) {
                            newVal = (0, _util_utils__WEBPACK_IMPORTED_MODULE_3__.getClonedObject)(newVal);
                        }
                        (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.setValueToNode)(target, obj, root, this, newVal); // cloning newVal to keep the source clean
                        return Promise.resolve(this);
                    };
                    BaseAction.prototype.getData = function () {
                        return this.dataSet;
                    };
                    BaseAction.prototype.setData = function (dataSet) {
                        if (_util_dataset_util__WEBPACK_IMPORTED_MODULE_1__["default"].isValidDataset(dataSet)) {
                            this.dataSet = dataSet;
                        }
                        return this.dataSet;
                    };
                    BaseAction.prototype.getValue = function (key, index) {
                        return _util_dataset_util__WEBPACK_IMPORTED_MODULE_1__["default"].getValue(this.dataSet, key, index);
                    };
                    BaseAction.prototype.setValue = function (key, value) {
                        return _util_dataset_util__WEBPACK_IMPORTED_MODULE_1__["default"].setValue(this.dataSet, key, value);
                    };
                    BaseAction.prototype.getItem = function (index) {
                        return _util_dataset_util__WEBPACK_IMPORTED_MODULE_1__["default"].getItem(this.dataSet, index);
                    };
                    /**
                     *
                     * @param index, a number in ideal case
                     *        it can be the object to be replaced by the passed value
                     * @param value
                     * @returns {any}
                     */
                    BaseAction.prototype.setItem = function (index, value) {
                        return _util_dataset_util__WEBPACK_IMPORTED_MODULE_1__["default"].setItem(this.dataSet, index, value);
                    };
                    BaseAction.prototype.addItem = function (value, index) {
                        return _util_dataset_util__WEBPACK_IMPORTED_MODULE_1__["default"].addItem(this.dataSet, value, index);
                    };
                    BaseAction.prototype.removeItem = function (index, exactMatch) {
                        return _util_dataset_util__WEBPACK_IMPORTED_MODULE_1__["default"].removeItem(this.dataSet, index, exactMatch);
                    };
                    BaseAction.prototype.clearData = function () {
                        this.dataSet = _util_dataset_util__WEBPACK_IMPORTED_MODULE_1__["default"].getValidDataset();
                        return this.dataSet;
                    };
                    BaseAction.prototype.getCount = function () {
                        return _util_dataset_util__WEBPACK_IMPORTED_MODULE_1__["default"].getCount(this.dataSet);
                    };
                    BaseAction.prototype.init = function () {
                    };
                    BaseAction.prototype.mute = function () {
                        this.isMuted = true;
                    };
                    BaseAction.prototype.unmute = function () {
                        this.isMuted = false;
                    };
                    return BaseAction;
                }());
                /***/ 
            }),
            /***/ "./src/model/base-variable.ts": 
            /*!************************************!*\
              !*** ./src/model/base-variable.ts ***!
              \************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "BaseVariable": function () { return ( /* binding */BaseVariable); },
                    /* harmony export */ "VariableEvents": function () { return ( /* binding */VariableEvents); }
                    /* harmony export */ 
                });
                /* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/types */ "./src/types/types.ts");
                /* harmony import */ var _util_dataset_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/dataset-util */ "./src/util/dataset-util.ts");
                /* harmony import */ var _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/variable/variables.utils */ "./src/util/variable/variables.utils.ts");
                /* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/utils */ "./src/util/utils.ts");
                /* harmony import */ var _types_event_notifier__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../types/event-notifier */ "./src/types/event-notifier.ts");
                var VariableEvents;
                (function (VariableEvents) {
                    VariableEvents["BEFORE_INVOKE"] = "beforeInvoke";
                    VariableEvents["AFTER_INVOKE"] = "afterInvoke";
                })(VariableEvents || (VariableEvents = {}));
                ;
                var BaseVariable = /** @class */ (function () {
                    function BaseVariable() {
                        this.isMuted = false;
                        this.eventNotifier = new _types_event_notifier__WEBPACK_IMPORTED_MODULE_4__.DefaultEventNotifier();
                    }
                    BaseVariable.prototype.notify = function (event, args) {
                        this.eventNotifier.notify(event, args);
                    };
                    BaseVariable.prototype.subscribe = function (event, fn) {
                        return this.eventNotifier.subscribe(event, fn);
                    };
                    BaseVariable.prototype.execute = function (operation, options) {
                        var returnVal;
                        switch (operation) {
                            case _types_types__WEBPACK_IMPORTED_MODULE_0__.DataSource.Operation.GET_NAME:
                                returnVal = this.name;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_0__.DataSource.Operation.GET_UNIQUE_IDENTIFIER:
                                returnVal = this._id;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_0__.DataSource.Operation.GET_CONTEXT_IDENTIFIER:
                                returnVal = this._context;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_0__.DataSource.Operation.ADD_ITEM:
                                returnVal = this.addItem(options.item, _.omit(options, 'item'));
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_0__.DataSource.Operation.SET_ITEM:
                                returnVal = this.setItem(options.prevItem, options.item, _.omit(options, 'prevItem', 'item'));
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_0__.DataSource.Operation.REMOVE_ITEM:
                                returnVal = this.removeItem(options.item, _.omit(options, 'item'));
                                break;
                        }
                        return returnVal;
                    };
                    BaseVariable.prototype.invokeOnParamChange = function (obj, newVal, oldVal) {
                        var runMode = true;
                        if (!obj) {
                            return;
                        }
                        var target = obj === null || obj === void 0 ? void 0 : obj.target, root = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.getTarget)(this), targetObj = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.getTargetObj)(obj, root, this), targetNodeKey = (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.getTargetNodeKey)(target);
                        if ((newVal === oldVal && _.isUndefined(newVal)) || (_.isUndefined(newVal) && (!_.isUndefined(oldVal) || !_.isUndefined(targetObj[targetNodeKey])))) {
                            return;
                        }
                        // Skip cloning for blob column
                        if (!_.includes(['blob', 'file'], obj.type)) {
                            newVal = (0, _util_utils__WEBPACK_IMPORTED_MODULE_3__.getClonedObject)(newVal);
                        }
                        (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.setValueToNode)(target, obj, root, this, newVal); // cloning newVal to keep the source clean
                        if (runMode) {
                            /*set the internal bound node map with the latest updated value*/
                            if (!_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.internalBoundNodeMap.has(this)) {
                                _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.internalBoundNodeMap.set(this, {});
                            }
                            _.set(_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.internalBoundNodeMap.get(this), [this.name, root, target], newVal);
                            /*update the internal nodes after internal node map is set*/
                            if (_.isObject(newVal)) {
                                (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_2__.updateInternalNodes)(target, root, this);
                            }
                        }
                        return Promise.resolve(this);
                    };
                    BaseVariable.prototype.getData = function () {
                        return this.dataSet;
                    };
                    BaseVariable.prototype.setData = function (dataSet) {
                        if (_util_dataset_util__WEBPACK_IMPORTED_MODULE_1__["default"].isValidDataset(dataSet, this.isList)) {
                            this.dataSet = dataSet;
                        }
                        return this.dataSet;
                    };
                    BaseVariable.prototype.getValue = function (key, index) {
                        return _util_dataset_util__WEBPACK_IMPORTED_MODULE_1__["default"].getValue(this.dataSet, key, index, this.isList);
                    };
                    BaseVariable.prototype.setValue = function (key, value) {
                        return _util_dataset_util__WEBPACK_IMPORTED_MODULE_1__["default"].setValue(this.dataSet, key, value, this.isList);
                    };
                    BaseVariable.prototype.getItem = function (index) {
                        return _util_dataset_util__WEBPACK_IMPORTED_MODULE_1__["default"].getItem(this.dataSet, index, this.isList);
                    };
                    /**
                     *
                     * @param index, a number in ideal case
                     *        it can be the object to be replaced by the passed value
                     * @param value
                     * @returns {any}
                     */
                    BaseVariable.prototype.setItem = function (index, value, options) {
                        options = this.getChildDetails(options);
                        return _util_dataset_util__WEBPACK_IMPORTED_MODULE_1__["default"].setItem(this.dataSet, index, value, options);
                    };
                    /**
                     * This method is to get target node options like path, parentIndex and isList
                     * @param options: provided options
                     * @returns {object}
                     * Example: if we have parent dataset as object and we are performing operations on inner list then we have to set isList as true.
                     * So finding the target node type and updating the isList option.
                     */
                    BaseVariable.prototype.getChildDetails = function (options) {
                        var parentIndex, isList = this.isList, path;
                        if (options && options.path) {
                            path = options.path;
                            var targetNode = void 0;
                            if (isList) {
                                parentIndex = options.parentIndex || 0;
                                targetNode = _.get(this.dataSet[parentIndex], options.path);
                            }
                            else {
                                targetNode = _.get(this.dataSet, options.path);
                            }
                            isList = targetNode ? _.isArray(targetNode) ? true : false : true;
                        }
                        return { path: path, isList: isList, parentIndex: parentIndex };
                    };
                    BaseVariable.prototype.addItem = function (value, options) {
                        var index;
                        if (_.isNumber(options)) {
                            index = options;
                        }
                        if (_.isObject(options)) {
                            index = options.index;
                        }
                        options = this.getChildDetails(options);
                        return _util_dataset_util__WEBPACK_IMPORTED_MODULE_1__["default"].addItem(this.dataSet, value, index, options);
                    };
                    BaseVariable.prototype.removeItem = function (index, options) {
                        var exactMatch, parentIndex;
                        if (options) {
                            if (_.isBoolean(options)) {
                                exactMatch = options;
                            }
                            if (_.isObject(options)) {
                                exactMatch = options.exactMatch;
                                if (this.isList) {
                                    parentIndex = options.parentIndex || 0;
                                }
                            }
                        }
                        return _util_dataset_util__WEBPACK_IMPORTED_MODULE_1__["default"].removeItem(this.dataSet, index, { exactMatch: exactMatch, path: _.get(options, 'path'), parentIndex: parentIndex });
                    };
                    BaseVariable.prototype.clearData = function () {
                        this.dataSet = _util_dataset_util__WEBPACK_IMPORTED_MODULE_1__["default"].getValidDataset(this.isList);
                        return this.dataSet;
                    };
                    BaseVariable.prototype.getCount = function () {
                        return _util_dataset_util__WEBPACK_IMPORTED_MODULE_1__["default"].getCount(this.dataSet, this.isList);
                    };
                    /**
                     * Return the prefab name if the variable is form a prefab
                     * @returns {string}
                     */
                    BaseVariable.prototype.getPrefabName = function () {
                        var prefabname = this._context && (this._context.prefabname || this._context.prefabName);
                        // __self__ is a prefab name given to a prefab which is run in preview mode
                        return prefabname !== '__self__' && prefabname;
                    };
                    BaseVariable.prototype.mute = function () {
                        this.isMuted = true;
                    };
                    BaseVariable.prototype.unmute = function () {
                        this.isMuted = false;
                    };
                    BaseVariable.prototype.destroy = function () {
                    };
                    return BaseVariable;
                }());
                /***/ 
            }),
            /***/ "./src/model/crud-create.ts": 
            /*!**********************************!*\
              !*** ./src/model/crud-create.ts ***!
              \**********************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "CRUDCreate": function () { return ( /* binding */CRUDCreate); }
                    /* harmony export */ 
                });
                var CRUDCreate = /** @class */ (function () {
                    function CRUDCreate(variable, manager) {
                        this.variable = variable;
                        this.manager = manager;
                    }
                    CRUDCreate.prototype.setInput = function (key, val, options) {
                        return this.manager.setInput(this.variable, key, val, options, 'create');
                    };
                    CRUDCreate.prototype.invoke = function (options, success, error) {
                        options = options || {};
                        options.operation = 'create';
                        return this.manager.invoke(this.variable, options, success, error);
                    };
                    return CRUDCreate;
                }());
                /***/ 
            }),
            /***/ "./src/model/crud-delete.ts": 
            /*!**********************************!*\
              !*** ./src/model/crud-delete.ts ***!
              \**********************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "CRUDDelete": function () { return ( /* binding */CRUDDelete); }
                    /* harmony export */ 
                });
                var CRUDDelete = /** @class */ (function () {
                    function CRUDDelete(variable, manager) {
                        this.variable = variable;
                        this.manager = manager;
                    }
                    CRUDDelete.prototype.setInput = function (key, val, options) {
                        return this.manager.setInput(this.variable, key, val, options, 'delete');
                    };
                    CRUDDelete.prototype.invoke = function (options, success, error) {
                        options = options || {};
                        options.operation = 'delete';
                        return this.manager.invoke(this.variable, options, success, error);
                    };
                    return CRUDDelete;
                }());
                /***/ 
            }),
            /***/ "./src/model/crud-list.ts": 
            /*!********************************!*\
              !*** ./src/model/crud-list.ts ***!
              \********************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "CRUDList": function () { return ( /* binding */CRUDList); }
                    /* harmony export */ 
                });
                var CRUDList = /** @class */ (function () {
                    function CRUDList(variable, manager) {
                        this.variable = variable;
                        this.manager = manager;
                    }
                    CRUDList.prototype.setInput = function (key, val, options) {
                        return this.manager.setInput(this.variable, key, val, options, 'list');
                    };
                    CRUDList.prototype.invoke = function (options, success, error) {
                        options = options || {};
                        options.operation = 'list';
                        return this.manager.invoke(this.variable, options, success, error);
                    };
                    return CRUDList;
                }());
                /***/ 
            }),
            /***/ "./src/model/crud-update.ts": 
            /*!**********************************!*\
              !*** ./src/model/crud-update.ts ***!
              \**********************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "CRUDUpdate": function () { return ( /* binding */CRUDUpdate); }
                    /* harmony export */ 
                });
                var CRUDUpdate = /** @class */ (function () {
                    function CRUDUpdate(variable, manager) {
                        this.variable = variable;
                        this.manager = manager;
                    }
                    CRUDUpdate.prototype.setInput = function (key, val, options) {
                        return this.manager.setInput(this.variable, key, val, options, 'update');
                    };
                    CRUDUpdate.prototype.invoke = function (options, success, error) {
                        options = options || {};
                        options.operation = 'update';
                        return this.manager.invoke(this.variable, options, success, error);
                    };
                    return CRUDUpdate;
                }());
                /***/ 
            }),
            /***/ "./src/model/variable/api-aware-variable.ts": 
            /*!**************************************************!*\
              !*** ./src/model/variable/api-aware-variable.ts ***!
              \**************************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "ApiAwareVariable": function () { return ( /* binding */ApiAwareVariable); }
                    /* harmony export */ 
                });
                /* harmony import */ var _base_variable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base-variable */ "./src/model/base-variable.ts");
                var __extends = (undefined && undefined.__extends) || (function () {
                    var extendStatics = function (d, b) {
                        extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b)
                                if (Object.prototype.hasOwnProperty.call(b, p))
                                    d[p] = b[p]; };
                        return extendStatics(d, b);
                    };
                    return function (d, b) {
                        if (typeof b !== "function" && b !== null)
                            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
                var ApiAwareVariable = /** @class */ (function (_super) {
                    __extends(ApiAwareVariable, _super);
                    function ApiAwareVariable() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    return ApiAwareVariable;
                }(_base_variable__WEBPACK_IMPORTED_MODULE_0__.BaseVariable));
                /***/ 
            }),
            /***/ "./src/model/variable/crud-variable.ts": 
            /*!*********************************************!*\
              !*** ./src/model/variable/crud-variable.ts ***!
              \*********************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "CrudVariable": function () { return ( /* binding */CrudVariable); }
                    /* harmony export */ 
                });
                /* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/utils */ "./src/util/utils.ts");
                /* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../types/types */ "./src/types/types.ts");
                /* harmony import */ var _factory_variable_manager_factory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../factory/variable-manager.factory */ "./src/factory/variable-manager.factory.ts");
                /* harmony import */ var _api_aware_variable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./api-aware-variable */ "./src/model/variable/api-aware-variable.ts");
                /* harmony import */ var _constants_variables_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../constants/variables.constants */ "./src/constants/variables.constants.ts");
                /* harmony import */ var _util_variable_service_variable_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/variable/service-variable.utils */ "./src/util/variable/service-variable.utils.ts");
                /* harmony import */ var _crud_list__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../crud-list */ "./src/model/crud-list.ts");
                /* harmony import */ var _crud_create__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../crud-create */ "./src/model/crud-create.ts");
                /* harmony import */ var _crud_update__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../crud-update */ "./src/model/crud-update.ts");
                /* harmony import */ var _crud_delete__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../crud-delete */ "./src/model/crud-delete.ts");
                var __extends = (undefined && undefined.__extends) || (function () {
                    var extendStatics = function (d, b) {
                        extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b)
                                if (Object.prototype.hasOwnProperty.call(b, p))
                                    d[p] = b[p]; };
                        return extendStatics(d, b);
                    };
                    return function (d, b) {
                        if (typeof b !== "function" && b !== null)
                            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
                var getManager = function () {
                    return _factory_variable_manager_factory__WEBPACK_IMPORTED_MODULE_2__.VariableManagerFactory.get(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_4__.VARIABLE_CONSTANTS.CATEGORY.CRUD);
                };
                var CrudVariable = /** @class */ (function (_super) {
                    __extends(CrudVariable, _super);
                    function CrudVariable(variable) {
                        var _this = _super.call(this) || this;
                        Object.assign(_this, variable);
                        // for having separate setInput methods for each type
                        _this.list = new _crud_list__WEBPACK_IMPORTED_MODULE_6__.CRUDList(_this, getManager());
                        _this.create = new _crud_create__WEBPACK_IMPORTED_MODULE_7__.CRUDCreate(_this, getManager());
                        _this.update = new _crud_update__WEBPACK_IMPORTED_MODULE_8__.CRUDUpdate(_this, getManager());
                        _this.delete = new _crud_delete__WEBPACK_IMPORTED_MODULE_9__.CRUDDelete(_this, getManager());
                        return _this;
                    }
                    CrudVariable.prototype.execute = function (operation, options) {
                        var returnVal = _super.prototype.execute.call(this, operation, options);
                        if ((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isDefined)(returnVal)) {
                            return returnVal;
                        }
                        switch (operation) {
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.IS_API_AWARE:
                                returnVal = true;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.SUPPORTS_CRUD:
                                returnVal = false;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.SUPPORTS_DISTINCT_API:
                                returnVal = false;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.IS_PAGEABLE:
                                returnVal = this.hasPagination();
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.IS_SORTABLE:
                                returnVal = this.hasPagination() && !this._paginationConfig;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.SUPPORTS_SERVER_FILTER:
                                returnVal = false;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.SET_INPUT:
                                returnVal = this.setInput(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.LIST_RECORDS:
                                returnVal = this.invoke(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.INVOKE:
                                returnVal = this.invoke(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.UPDATE:
                                returnVal = this.invoke(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.SEARCH_RECORDS:
                                returnVal = this.searchRecords(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.DOWNLOAD:
                                returnVal = this.download(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.GET_PAGING_OPTIONS:
                                returnVal = this.pagination;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.IS_UPDATE_REQUIRED:
                                returnVal = this.isUpdateRequired(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.IS_BOUND_TO_LOCALE:
                                returnVal = false;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.CANCEL:
                                returnVal = this.cancel(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.INSERT_RECORD:
                                options.operation = 'create';
                                returnVal = this.invoke(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.UPDATE_RECORD:
                                options.operation = 'update';
                                returnVal = this.invoke(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.DELETE_RECORD:
                                options.operation = 'delete';
                                returnVal = this.invoke(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.SET_PAGINATION:
                                returnVal = this.setPagination(options);
                                break;
                            default:
                                returnVal = {};
                                break;
                        }
                        return returnVal;
                    };
                    CrudVariable.prototype.hasPagination = function () {
                        return this.controller === _constants_variables_constants__WEBPACK_IMPORTED_MODULE_4__.VARIABLE_CONSTANTS.CONTROLLER_TYPE.QUERY || !_.isEmpty(this.pagination);
                    };
                    CrudVariable.prototype.invoke = function (options, success, error) {
                        return getManager().invoke(this, options, success, error);
                    };
                    CrudVariable.prototype.createRecord = function (options, success, error) {
                        options = options || {};
                        options.operation = 'create';
                        return getManager().invoke(this, options, success, error);
                    };
                    CrudVariable.prototype.listRecords = function (options, success, error) {
                        options = options || {};
                        options.operation = 'list';
                        return getManager().invoke(this, options, success, error);
                    };
                    CrudVariable.prototype.updateRecord = function (options, success, error) {
                        options = options || {};
                        options.operation = 'update';
                        return getManager().invoke(this, options, success, error);
                    };
                    CrudVariable.prototype.deleteRecord = function (options, success, error) {
                        options = options || {};
                        options.operation = 'delete';
                        return getManager().invoke(this, options, success, error);
                    };
                    CrudVariable.prototype.download = function (options, success, error) {
                        return getManager().download(this, options, success, error);
                    };
                    CrudVariable.prototype.setInput = function (key, val, options) {
                        return getManager().setInput(this, key, val, options);
                    };
                    CrudVariable.prototype.searchRecords = function (options, success, error) {
                        var _this = this;
                        return new Promise(function (resolve, reject) {
                            getManager().searchRecords(_this, options, function (response, pagination) {
                                resolve({ data: response.content || response, pagination: pagination });
                            }, reject);
                        });
                    };
                    CrudVariable.prototype.isUpdateRequired = function (hasData) {
                        var inputFields = getManager().getInputParms(this);
                        var queryParams = _util_variable_service_variable_utils__WEBPACK_IMPORTED_MODULE_5__.ServiceVariableUtils.excludePaginationParams(inputFields);
                        if (!queryParams.length) {
                            // if we don't have any query params and variable data is available then we don't need variable update, so return false
                            if (hasData) {
                                return false;
                            }
                        }
                        return true;
                    };
                    CrudVariable.prototype.cancel = function (options) {
                        return getManager().cancel(this, options);
                    };
                    CrudVariable.prototype.setPagination = function (data) {
                        return getManager().setPagination(this, data);
                    };
                    CrudVariable.prototype.init = function () {
                        getManager().initBinding(this);
                        getManager().defineFirstLastRecord(this);
                    };
                    return CrudVariable;
                }(_api_aware_variable__WEBPACK_IMPORTED_MODULE_3__.ApiAwareVariable));
                /***/ 
            }),
            /***/ "./src/model/variable/live-variable.ts": 
            /*!*********************************************!*\
              !*** ./src/model/variable/live-variable.ts ***!
              \*********************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "LiveVariable": function () { return ( /* binding */LiveVariable); }
                    /* harmony export */ 
                });
                /* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/utils */ "./src/util/utils.ts");
                /* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../types/types */ "./src/types/types.ts");
                /* harmony import */ var _factory_variable_manager_factory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../factory/variable-manager.factory */ "./src/factory/variable-manager.factory.ts");
                /* harmony import */ var _api_aware_variable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./api-aware-variable */ "./src/model/variable/api-aware-variable.ts");
                /* harmony import */ var _constants_variables_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../constants/variables.constants */ "./src/constants/variables.constants.ts");
                /* harmony import */ var _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/variable/variables.utils */ "./src/util/variable/variables.utils.ts");
                var __extends = (undefined && undefined.__extends) || (function () {
                    var extendStatics = function (d, b) {
                        extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b)
                                if (Object.prototype.hasOwnProperty.call(b, p))
                                    d[p] = b[p]; };
                        return extendStatics(d, b);
                    };
                    return function (d, b) {
                        if (typeof b !== "function" && b !== null)
                            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
                var getManager = function () {
                    return _factory_variable_manager_factory__WEBPACK_IMPORTED_MODULE_2__.VariableManagerFactory.get(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_4__.VARIABLE_CONSTANTS.CATEGORY.LIVE);
                };
                var LiveVariable = /** @class */ (function (_super) {
                    __extends(LiveVariable, _super);
                    function LiveVariable(variable) {
                        var _this = _super.call(this) || this;
                        Object.assign(_this, variable);
                        return _this;
                    }
                    LiveVariable.prototype.execute = function (operation, options) {
                        var returnVal = _super.prototype.execute.call(this, operation, options);
                        if ((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isDefined)(returnVal)) {
                            return returnVal;
                        }
                        switch (operation) {
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.IS_API_AWARE:
                                returnVal = true;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.SUPPORTS_CRUD:
                                returnVal = true;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.SUPPORTS_DISTINCT_API:
                                returnVal = true;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.IS_PAGEABLE:
                                returnVal = true;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.IS_SORTABLE:
                                returnVal = true;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.SUPPORTS_SERVER_FILTER:
                                returnVal = true;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.GET_OPERATION_TYPE:
                                returnVal = this.operation;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.GET_RELATED_PRIMARY_KEYS:
                                returnVal = this.getRelatedTablePrimaryKeys(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.GET_ENTITY_NAME:
                                returnVal = this.propertiesMap.entityName;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.LIST_RECORDS:
                                returnVal = this.listRecords(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.UPDATE_RECORD:
                                returnVal = this.updateRecord(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.INSERT_RECORD:
                                returnVal = this.insertRecord(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.DELETE_RECORD:
                                returnVal = this.deleteRecord(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.INVOKE:
                                returnVal = this.invoke(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.UPDATE:
                                returnVal = this.update(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.GET_RELATED_TABLE_DATA:
                                returnVal = this.getRelatedTableData(options.relatedField, options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.GET_DISTINCT_DATA_BY_FIELDS:
                                returnVal = this.getDistinctDataByFields(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.GET_AGGREGATED_DATA:
                                returnVal = this.getAggregatedData(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.GET_MATCH_MODE:
                                returnVal = this.matchMode;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.DOWNLOAD:
                                returnVal = this.download(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.GET_PROPERTIES_MAP:
                                returnVal = this.propertiesMap;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.GET_PRIMARY_KEY:
                                returnVal = this.getPrimaryKey();
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.GET_BLOB_URL:
                                returnVal = "services/" + this.liveSource + "/" + this.type + "/" + options.primaryValue + "/content/" + options.columnName;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.GET_OPTIONS:
                                returnVal = this._options || {};
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.SEARCH_RECORDS:
                                returnVal = this.searchRecords(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.GET_REQUEST_PARAMS:
                                returnVal = this.getRequestParams(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.GET_PAGING_OPTIONS:
                                returnVal = this.pagination;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.IS_UPDATE_REQUIRED:
                                returnVal = true;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.IS_BOUND_TO_LOCALE:
                                returnVal = false;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.CANCEL:
                                returnVal = false;
                                break;
                            default:
                                returnVal = {};
                                break;
                        }
                        return returnVal;
                    };
                    LiveVariable.prototype.listRecords = function (options, success, error) {
                        return getManager().listRecords(this, options, success, error);
                    };
                    LiveVariable.prototype.updateRecord = function (options, success, error) {
                        return getManager().updateRecord(this, options, success, error);
                    };
                    LiveVariable.prototype.insertRecord = function (options, success, error) {
                        return getManager().insertRecord(this, options, success, error);
                    };
                    LiveVariable.prototype.deleteRecord = function (options, success, error) {
                        return getManager().deleteRecord(this, options, success, error);
                    };
                    LiveVariable.prototype.setInput = function (key, val, options) {
                        return getManager().setInput(this, key, val, options);
                    };
                    LiveVariable.prototype.setFilter = function (key, val) {
                        return getManager().setFilter(this, key, val);
                    };
                    LiveVariable.prototype.download = function (options, success, error) {
                        return getManager().download(this, options, success, error);
                    };
                    LiveVariable.prototype.invoke = function (options, success, error) {
                        switch (this.operation) {
                            case 'insert':
                                return this.insertRecord(options, success, error);
                            case 'update':
                                return this.updateRecord(options, success, error);
                            case 'delete':
                                return this.deleteRecord(options, success, error);
                            default:
                                return this.listRecords(options, success, error);
                        }
                    };
                    LiveVariable.prototype.getRelatedTablePrimaryKeys = function (columnName) {
                        return getManager().getRelatedTablePrimaryKeys(this, columnName);
                    };
                    LiveVariable.prototype.getRelatedTableData = function (columnName, options, success, error) {
                        return getManager().getRelatedTableData(this, columnName, options, success, error);
                    };
                    LiveVariable.prototype.getDistinctDataByFields = function (options, success, error) {
                        return getManager().getDistinctDataByFields(this, options, success, error);
                    };
                    LiveVariable.prototype.getAggregatedData = function (options, success, error) {
                        return getManager().getAggregatedData(this, options, success, error);
                    };
                    LiveVariable.prototype.getPrimaryKey = function () {
                        return getManager().getPrimaryKey(this);
                    };
                    LiveVariable.prototype.searchRecords = function (options, success, error) {
                        return getManager().searchRecords(this, options, success, error);
                    };
                    LiveVariable.prototype.getRequestParams = function (options) {
                        return getManager().prepareRequestParams(options);
                    };
                    LiveVariable.prototype._downgradeInputData = function (data) {
                        return getManager().downgradeFilterExpressionsToInputData(this, data);
                    };
                    LiveVariable.prototype._upgradeInputData = function (response, data) {
                        return getManager().upgradeInputDataToFilterExpressions(this, response, data);
                    };
                    LiveVariable.prototype.setOrderBy = function (expression) {
                        this.orderBy = expression;
                        return this.orderBy;
                    };
                    // legacy method
                    LiveVariable.prototype.update = function (options, success, error) {
                        return this.invoke(options, success, error);
                    };
                    LiveVariable.prototype.createRecord = function (options, success, error) {
                        return this.insertRecord(options, success, error);
                    };
                    LiveVariable.prototype.init = function () {
                        getManager().initBinding(this, 'dataBinding', this.operation === 'read' ? 'filterFields' : 'inputFields');
                        if (this.operation === 'read') {
                            getManager().initFilterExpressionBinding(this);
                        }
                        getManager().defineFirstLastRecord(this);
                    };
                    LiveVariable.prototype.invokeOnFiltertExpressionChange = function (obj, targetNodeKey, newVal, oldVal) {
                        console.log('filter expr changed', newVal, oldVal);
                        if ((newVal === oldVal && _.isUndefined(newVal)) || (_.isUndefined(newVal) && !_.isUndefined(oldVal))) {
                            return;
                        }
                        // Skip cloning for blob column
                        if (!_.includes(['blob', 'file'], obj.type)) {
                            newVal = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(newVal);
                        }
                        // backward compatibility: where we are allowing the user to bind complete object
                        if (obj.target === 'dataBinding') {
                            // remove the existing databinding element
                            this.filterExpressions.rules = [];
                            // now add all the returned values
                            _.forEach(newVal, function (value, target) {
                                this.filterExpressions.rules.push({
                                    'target': target,
                                    'value': value,
                                    'matchMode': obj.matchMode || 'startignorecase',
                                    'required': false,
                                    'type': ''
                                });
                            });
                        }
                        else {
                            // setting value to the root node
                            obj[targetNodeKey] = newVal;
                        }
                        if (this.operation === 'read') {
                            /* if auto-update set for the variable with read operation only, get its data */
                            if (this.autoUpdate && !_.isUndefined(newVal) && _.isFunction(this.update)) {
                                (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_5__.debounceVariableCall)(this, 'update');
                            }
                        }
                        else {
                            /* if auto-update set for the variable with read operation only, get its data */
                            if (this.autoUpdate && !_.isUndefined(newVal) && _.isFunction(this[this.operation + 'Record'])) {
                                (0, _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_5__.debounceVariableCall)(this, this.operation + 'Record');
                            }
                        }
                        // this.invoke();
                    };
                    LiveVariable.prototype.cancel = function (options) {
                        return getManager().cancel(this, options);
                    };
                    return LiveVariable;
                }(_api_aware_variable__WEBPACK_IMPORTED_MODULE_3__.ApiAwareVariable));
                /***/ 
            }),
            /***/ "./src/model/variable/model-variable.ts": 
            /*!**********************************************!*\
              !*** ./src/model/variable/model-variable.ts ***!
              \**********************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "ModelVariable": function () { return ( /* binding */ModelVariable); }
                    /* harmony export */ 
                });
                /* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types/types */ "./src/types/types.ts");
                /* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/utils */ "./src/util/utils.ts");
                /* harmony import */ var _factory_variable_manager_factory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../factory/variable-manager.factory */ "./src/factory/variable-manager.factory.ts");
                /* harmony import */ var _base_variable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base-variable */ "./src/model/base-variable.ts");
                /* harmony import */ var _constants_variables_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../constants/variables.constants */ "./src/constants/variables.constants.ts");
                /* harmony import */ var _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/variable/variables.utils */ "./src/util/variable/variables.utils.ts");
                var __extends = (undefined && undefined.__extends) || (function () {
                    var extendStatics = function (d, b) {
                        extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b)
                                if (Object.prototype.hasOwnProperty.call(b, p))
                                    d[p] = b[p]; };
                        return extendStatics(d, b);
                    };
                    return function (d, b) {
                        if (typeof b !== "function" && b !== null)
                            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
                var getManager = function () {
                    return _factory_variable_manager_factory__WEBPACK_IMPORTED_MODULE_2__.VariableManagerFactory.get(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_4__.VARIABLE_CONSTANTS.CATEGORY.MODEL);
                };
                var ModelVariable = /** @class */ (function (_super) {
                    __extends(ModelVariable, _super);
                    function ModelVariable(variable) {
                        var _this = _super.call(this) || this;
                        Object.assign(_this, variable);
                        return _this;
                    }
                    ModelVariable.prototype.init = function () {
                        if (this.isList) {
                            getManager().removeFirstEmptyObject(this);
                        }
                        getManager().initBinding(this, 'dataBinding', 'dataSet');
                    };
                    ModelVariable.prototype.execute = function (operation, options) {
                        var returnVal = _super.prototype.execute.call(this, operation, options);
                        if ((0, _util_utils__WEBPACK_IMPORTED_MODULE_1__.isDefined)(returnVal)) {
                            return returnVal;
                        }
                        switch (operation) {
                            case _types_types__WEBPACK_IMPORTED_MODULE_0__.DataSource.Operation.IS_API_AWARE:
                                returnVal = false;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_0__.DataSource.Operation.SUPPORTS_CRUD:
                                returnVal = false;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_0__.DataSource.Operation.SUPPORTS_DISTINCT_API:
                                returnVal = false;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_0__.DataSource.Operation.IS_PAGEABLE:
                                returnVal = false;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_0__.DataSource.Operation.IS_SORTABLE:
                                returnVal = false;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_0__.DataSource.Operation.SUPPORTS_SERVER_FILTER:
                                returnVal = false;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_0__.DataSource.Operation.IS_BOUND_TO_LOCALE:
                                returnVal = this.isBoundToLocale();
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_0__.DataSource.Operation.GET_DEFAULT_LOCALE:
                                returnVal = this.getDefaultLocale();
                                break;
                            default:
                                returnVal = {};
                                break;
                        }
                        return returnVal;
                    };
                    ModelVariable.prototype.isBoundToLocale = function () {
                        return this.name === 'supportedLocale';
                    };
                    ModelVariable.prototype.getDefaultLocale = function () {
                        return _util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_5__.appManager.getSelectedLocale();
                    };
                    return ModelVariable;
                }(_base_variable__WEBPACK_IMPORTED_MODULE_3__.BaseVariable));
                /***/ 
            }),
            /***/ "./src/model/variable/service-variable.ts": 
            /*!************************************************!*\
              !*** ./src/model/variable/service-variable.ts ***!
              \************************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "ServiceVariable": function () { return ( /* binding */ServiceVariable); }
                    /* harmony export */ 
                });
                /* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/utils */ "./src/util/utils.ts");
                /* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../types/types */ "./src/types/types.ts");
                /* harmony import */ var _factory_variable_manager_factory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../factory/variable-manager.factory */ "./src/factory/variable-manager.factory.ts");
                /* harmony import */ var _api_aware_variable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./api-aware-variable */ "./src/model/variable/api-aware-variable.ts");
                /* harmony import */ var _constants_variables_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../constants/variables.constants */ "./src/constants/variables.constants.ts");
                /* harmony import */ var _util_variable_service_variable_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/variable/service-variable.utils */ "./src/util/variable/service-variable.utils.ts");
                var __extends = (undefined && undefined.__extends) || (function () {
                    var extendStatics = function (d, b) {
                        extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b)
                                if (Object.prototype.hasOwnProperty.call(b, p))
                                    d[p] = b[p]; };
                        return extendStatics(d, b);
                    };
                    return function (d, b) {
                        if (typeof b !== "function" && b !== null)
                            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
                var getManager = function () {
                    return _factory_variable_manager_factory__WEBPACK_IMPORTED_MODULE_2__.VariableManagerFactory.get(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_4__.VARIABLE_CONSTANTS.CATEGORY.SERVICE);
                };
                var ServiceVariable = /** @class */ (function (_super) {
                    __extends(ServiceVariable, _super);
                    function ServiceVariable(variable) {
                        var _this = _super.call(this) || this;
                        Object.assign(_this, variable);
                        _this.serviceInfo = variable.serviceInfo;
                        _this.httpService = variable.httpClientService;
                        return _this;
                    }
                    ServiceVariable.prototype.execute = function (operation, options) {
                        var returnVal = _super.prototype.execute.call(this, operation, options);
                        if ((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isDefined)(returnVal)) {
                            return returnVal;
                        }
                        switch (operation) {
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.IS_API_AWARE:
                                returnVal = true;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.SUPPORTS_CRUD:
                                returnVal = false;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.SUPPORTS_DISTINCT_API:
                                returnVal = false;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.IS_PAGEABLE:
                                // Check for both client and server side pagination existence
                                returnVal = this.hasPagination();
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.IS_SORTABLE:
                                returnVal = this.hasPagination() && !this._paginationConfig;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.SUPPORTS_SERVER_FILTER:
                                returnVal = false;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.SET_INPUT:
                                returnVal = this.setInput(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.LIST_RECORDS:
                                returnVal = this.invoke(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.INVOKE:
                                returnVal = this.invoke(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.UPDATE:
                                returnVal = this.update(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.SEARCH_RECORDS:
                                returnVal = this.searchRecords(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.DOWNLOAD:
                                returnVal = this.download(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.GET_PAGING_OPTIONS:
                                returnVal = this.pagination;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.IS_UPDATE_REQUIRED:
                                returnVal = this.isUpdateRequired(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.IS_BOUND_TO_LOCALE:
                                returnVal = false;
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.CANCEL:
                                returnVal = this.cancel(options);
                                break;
                            case _types_types__WEBPACK_IMPORTED_MODULE_1__.DataSource.Operation.SET_PAGINATION:
                                returnVal = this.setPagination(options);
                                break;
                            default:
                                returnVal = {};
                                break;
                        }
                        return returnVal;
                    };
                    ServiceVariable.prototype.hasPagination = function () {
                        return this.controller === _constants_variables_constants__WEBPACK_IMPORTED_MODULE_4__.VARIABLE_CONSTANTS.CONTROLLER_TYPE.QUERY || !_.isEmpty(this.pagination);
                    };
                    ServiceVariable.prototype.invoke = function (options, success, error) {
                        // return this.invokeVar();
                        return getManager().invoke(this, options, success, error);
                    };
                    ServiceVariable.prototype.update = function (options, success, error) {
                        return getManager().invoke(this, options, success, error);
                    };
                    ServiceVariable.prototype.download = function (options, success, error) {
                        return getManager().download(this, options, success, error);
                    };
                    ServiceVariable.prototype.setInput = function (key, val, options) {
                        return getManager().setInput(this, key, val, options);
                    };
                    ServiceVariable.prototype.searchRecords = function (options, success, error) {
                        var _this = this;
                        return new Promise(function (resolve, reject) {
                            getManager().searchRecords(_this, options, function (response, pagination) {
                                resolve({ data: response.content || response, pagination: pagination });
                            }, reject);
                        });
                    };
                    ServiceVariable.prototype.isUpdateRequired = function (hasData) {
                        var inputFields = getManager().getInputParms(this);
                        var queryParams = _util_variable_service_variable_utils__WEBPACK_IMPORTED_MODULE_5__.ServiceVariableUtils.excludePaginationParams(inputFields);
                        if (!queryParams.length) {
                            // if we don't have any query params and variable data is available then we don't need variable update, so return false
                            if (hasData) {
                                return false;
                            }
                        }
                        return true;
                    };
                    ServiceVariable.prototype.setPagination = function (data) {
                        return getManager().setPagination(this, data);
                    };
                    ServiceVariable.prototype.cancel = function (options) {
                        return getManager().cancel(this, options);
                    };
                    ServiceVariable.prototype.init = function () {
                        getManager().initBinding(this);
                        getManager().defineFirstLastRecord(this);
                    };
                    return ServiceVariable;
                }(_api_aware_variable__WEBPACK_IMPORTED_MODULE_3__.ApiAwareVariable));
                /***/ 
            }),
            /***/ "./src/types/event-notifier.ts": 
            /*!*************************************!*\
              !*** ./src/types/event-notifier.ts ***!
              \*************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "DefaultEventNotifier": function () { return ( /* binding */DefaultEventNotifier); }
                    /* harmony export */ 
                });
                var DefaultEventNotifier = /** @class */ (function () {
                    function DefaultEventNotifier() {
                        this.listeners = {};
                    }
                    DefaultEventNotifier.prototype.notify = function (event, args) {
                        if (this.listeners[event]) {
                            this.listeners[event].forEach(function (l) {
                                l && l.apply(null, args);
                            });
                        }
                    };
                    DefaultEventNotifier.prototype.subscribe = function (event, fn) {
                        var _this = this;
                        this.listeners[event] = this.listeners[event] || [];
                        this.listeners[event].push(fn);
                        return function () {
                            var eventListeners = _this.listeners[event];
                            var i = eventListeners.findIndex(function (fni) { return fni === fn; });
                            eventListeners.splice(i, 1);
                        };
                    };
                    return DefaultEventNotifier;
                }());
                /***/ 
            }),
            /***/ "./src/types/http-client.service.ts": 
            /*!******************************************!*\
              !*** ./src/types/http-client.service.ts ***!
              \******************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /***/ 
            }),
            /***/ "./src/types/types.ts": 
            /*!****************************!*\
              !*** ./src/types/types.ts ***!
              \****************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "DataSource": function () { return ( /* binding */DataSource); },
                    /* harmony export */ "IDataSource": function () { return ( /* binding */IDataSource); }
                    /* harmony export */ 
                });
                var IDataSource = /** @class */ (function () {
                    function IDataSource() {
                    }
                    return IDataSource;
                }());
                var Operation;
                (function (Operation) {
                    Operation["LIST_RECORDS"] = "listRecords";
                    Operation["UPDATE_RECORD"] = "updateRecord";
                    Operation["INSERT_RECORD"] = "insertRecord";
                    Operation["DELETE_RECORD"] = "deleteRecord";
                    Operation["INVOKE"] = "invoke";
                    Operation["UPDATE"] = "update";
                    Operation["NOTIFY"] = "notify";
                    Operation["IS_API_AWARE"] = "isApiAware";
                    Operation["SUPPORTS_CRUD"] = "supportsCRUD";
                    Operation["SUPPORTS_DISTINCT_API"] = "supportsDistinctAPI";
                    Operation["IS_PAGEABLE"] = "isPageable";
                    Operation["IS_SORTABLE"] = "isSortable";
                    Operation["GET_OPERATION_TYPE"] = "getOperationType";
                    Operation["GET_RELATED_PRIMARY_KEYS"] = "getRelatedTablePrimaryKeys";
                    Operation["GET_ENTITY_NAME"] = "getEntityName";
                    Operation["SET_INPUT"] = "setinput";
                    Operation["GET_RELATED_TABLE_DATA"] = "getRelatedTableData";
                    Operation["GET_DISTINCT_DATA_BY_FIELDS"] = "getDistinctDataByFields";
                    Operation["GET_AGGREGATED_DATA"] = "getAggregatedData";
                    Operation["GET_MATCH_MODE"] = "getMatchMode";
                    Operation["DOWNLOAD"] = "download";
                    Operation["GET_NAME"] = "getName";
                    Operation["GET_PROPERTIES_MAP"] = "getPropertiesMap";
                    Operation["GET_PRIMARY_KEY"] = "getPrimaryKey";
                    Operation["GET_BLOB_URL"] = "getBlobURL";
                    Operation["SUPPORTS_SERVER_FILTER"] = "supportsServerFilter";
                    Operation["GET_OPTIONS"] = "getOptions";
                    Operation["SEARCH_RECORDS"] = "searchRecords";
                    Operation["GET_REQUEST_PARAMS"] = "getRequestParams";
                    Operation["GET_PAGING_OPTIONS"] = "getPagingOptions";
                    Operation["FETCH_DISTINCT_VALUES"] = "fetchDistinctValues";
                    Operation["GET_UNIQUE_IDENTIFIER"] = "getUniqueIdentifier";
                    Operation["GET_CONTEXT_IDENTIFIER"] = "getContextIdentifier";
                    Operation["IS_UPDATE_REQUIRED"] = "isUpdateRequired";
                    Operation["ADD_ITEM"] = "addItem";
                    Operation["SET_ITEM"] = "setItem";
                    Operation["REMOVE_ITEM"] = "removeItem";
                    Operation["IS_BOUND_TO_LOCALE"] = "isBoundToLocale";
                    Operation["GET_DEFAULT_LOCALE"] = "getDefaultLocale";
                    Operation["CANCEL"] = "cancel";
                    Operation["SET_PAGINATION"] = "setPagination";
                })(Operation || (Operation = {}));
                var DataSource = {
                    Operation: Operation
                };
                /***/ 
            }),
            /***/ "./src/util/dataset-util.ts": 
            /*!**********************************!*\
              !*** ./src/util/dataset-util.ts ***!
              \**********************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "default": function () { return (__WEBPACK_DEFAULT_EXPORT__); }
                    /* harmony export */ 
                });
                var DatasetUtil = /** @class */ (function () {
                    function DatasetUtil() {
                    }
                    DatasetUtil.isValidDataset = function (dataSet, isList) {
                        if (!dataSet) {
                            return false;
                        }
                        // check array type dataset for list type variable
                        if (isList && !_.isArray(dataSet)) {
                            return false;
                        }
                        // change the dataSet
                        return dataSet;
                    };
                    DatasetUtil.getValue = function (dataSet, key, index, isList) {
                        index = index || 0;
                        // return the value against the specified key
                        return isList ? dataSet[index][key] : dataSet[key];
                    };
                    DatasetUtil.setValue = function (dataSet, key, value, isList) {
                        // check param sanity
                        if (key && !isList) {
                            dataSet[key] = value;
                        }
                        // return the new dataSet
                        return dataSet;
                    };
                    DatasetUtil.getItem = function (dataSet, index, isList) {
                        // return the object against the specified index
                        return isList ? dataSet[index] : dataSet;
                    };
                    /**
                     * This method is used to find target node
                     * @param dataSet: provided dataSet
                     * @param options: provided options
                     * @returns {any} targetnode
                     */
                    DatasetUtil.getTargetNode = function (dataSet, options) {
                        dataSet = options.parentIndex !== undefined ? dataSet[options.parentIndex] : dataSet;
                        return _.get(dataSet, options.path);
                    };
                    DatasetUtil.setItem = function (dataSet, i, value, options) {
                        var index;
                        // check param sanity
                        if (_.isUndefined(i) || !options.isList) {
                            return dataSet;
                        }
                        if (_.isObject(i)) {
                            index = _.findIndex(dataSet, i);
                        }
                        else {
                            index = i;
                        }
                        if (options.path) {
                            var innerArray = DatasetUtil.getTargetNode(dataSet, options);
                            var innerElemindex = _.findIndex(innerArray, i);
                            if (innerElemindex > -1) {
                                innerArray[innerElemindex] = value;
                            }
                        }
                        else {
                            if (index > -1) {
                                // set the value against the specified index
                                dataSet[index] = value;
                            }
                        }
                        // return the new dataSet
                        return dataSet;
                    };
                    DatasetUtil.addItem = function (dataSet, value, index, options) {
                        // check param sanity
                        if (_.isUndefined(value) || !options.isList) {
                            return dataSet;
                        }
                        // set the value against the specified index
                        if (options.path) {
                            var innerArray = DatasetUtil.getTargetNode(dataSet, options);
                            if (innerArray) {
                                // check for index sanity
                                index = index !== undefined ? index : innerArray.length;
                                innerArray.splice(index, 0, value);
                            }
                            else {
                                options.parentIndex !== undefined ? _.set(dataSet[options.parentIndex], options.path, [value]) : _.set(dataSet, options.path, [value]);
                            }
                        }
                        else {
                            // check for index sanity
                            index = index !== undefined ? index : dataSet.length;
                            dataSet.splice(index, 0, value);
                        }
                        // return the new dataSet
                        return dataSet;
                    };
                    /**
                     *
                     * @param dataSet
                     * @param i, can be index value of the object/element in array
                     *      or
                     * the whole object which needs to be removed
                     * @param exactMatch
                     * @returns {any}
                     */
                    DatasetUtil.removeItem = function (dataSet, i, options) {
                        var index, exactMatch;
                        // check for index sanity
                        i = i !== undefined ? i : dataSet.length - 1;
                        if (_.isBoolean(options)) {
                            exactMatch = options;
                        }
                        if (_.isObject(options)) {
                            exactMatch = options.exactMatch;
                        }
                        if (_.isObject(i)) {
                            if (options.path) {
                                var innerArray = DatasetUtil.getTargetNode(dataSet, options);
                                var innerElemindex = _.findIndex(innerArray, i);
                                if (innerElemindex > -1 && (!exactMatch || (exactMatch && _.isEqual(innerArray[innerElemindex], i)))) {
                                    innerArray.splice(innerElemindex, 1);
                                }
                            }
                            else {
                                index = _.findIndex(dataSet, i);
                                // When exactMatch property is set to true delete only when every property values are same*/
                                if (index > -1 && (!exactMatch || (exactMatch && _.isEqual(dataSet[index], i)))) {
                                    dataSet.splice(index, 1);
                                }
                            }
                        }
                        else {
                            dataSet.splice(i, 1);
                        }
                        // return the new dataSet
                        return dataSet;
                    };
                    DatasetUtil.getValidDataset = function (isList) {
                        return isList ? [] : {};
                    };
                    DatasetUtil.getCount = function (dataSet, isList) {
                        return isList ? dataSet.length : Object.keys(dataSet).length;
                    };
                    return DatasetUtil;
                }());
                /* harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = (DatasetUtil);
                /***/ 
            }),
            /***/ "./src/util/file-upload.util.ts": 
            /*!**************************************!*\
              !*** ./src/util/file-upload.util.ts ***!
              \**************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "upload": function () { return ( /* binding */upload); }
                    /* harmony export */ 
                });
                /* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/util/utils.ts");
                /* harmony import */ var _notify_promise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./notify-promise */ "./src/util/notify-promise.ts");
                /* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
                /* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_2__);
                var __extends = (undefined && undefined.__extends) || (function () {
                    var extendStatics = function (d, b) {
                        extendStatics = Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                            function (d, b) { for (var p in b)
                                if (Object.prototype.hasOwnProperty.call(b, p))
                                    d[p] = b[p]; };
                        return extendStatics(d, b);
                    };
                    return function (d, b) {
                        if (typeof b !== "function" && b !== null)
                            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                        extendStatics(d, b);
                        function __() { this.constructor = d; }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
                // declare const _: any;
                var UPLOAD_STATUS;
                (function (UPLOAD_STATUS) {
                    UPLOAD_STATUS["QUEUED"] = "queued";
                    UPLOAD_STATUS["IN_PROGRESS"] = "inprogress";
                    UPLOAD_STATUS["SUCCESS"] = "success";
                    UPLOAD_STATUS["ERROR"] = "error";
                    UPLOAD_STATUS["ABORTED"] = "abort";
                })(UPLOAD_STATUS || (UPLOAD_STATUS = {}));
                function transformEvent(event) {
                    event.target = event.target || {
                        status: event.responseCode,
                        response: event.response
                    };
                    return event;
                }
                var FileTransferObject = /** @class */ (function () {
                    function FileTransferObject(file, transferFn, promise, abortFn) {
                        this.name = file.name;
                        this.size = file.size || '';
                        this.status = UPLOAD_STATUS.QUEUED;
                        this.transferFn = transferFn;
                        this.promise = promise;
                        this.abortFn = abortFn;
                    }
                    FileTransferObject.prototype.start = function () {
                        if (this.status === UPLOAD_STATUS.QUEUED) {
                            this.status = UPLOAD_STATUS.IN_PROGRESS;
                            (0, _utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(this.transferFn);
                        }
                    };
                    FileTransferObject.prototype.then = function (onSuccess, onError, onProgress) {
                        var self = this;
                        this.promise.then(function (event) {
                            self.status = UPLOAD_STATUS.SUCCESS;
                            (0, _utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(onSuccess, event);
                        }, function (event) {
                            self.status = UPLOAD_STATUS.ERROR;
                            (0, _utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(onError, event);
                        }, function (event) {
                            self.progress = Math.round(event.loaded / event.total * 100);
                            (0, _utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(onProgress, event);
                        });
                        return this;
                    };
                    FileTransferObject.prototype.finally = function (onFinal) {
                        this.promise.finally(onFinal);
                    };
                    /* aborts the file upload */
                    FileTransferObject.prototype.abort = function () {
                        this.status = UPLOAD_STATUS.ABORTED;
                        (0, _utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(this.abortFn);
                        this.finally();
                    };
                    return FileTransferObject;
                }());
                var AjaxFileTransferObject = /** @class */ (function (_super) {
                    __extends(AjaxFileTransferObject, _super);
                    function AjaxFileTransferObject(file, transferFn, promise, abortFn) {
                        return _super.call(this, file, transferFn, promise, abortFn) || this;
                    }
                    return AjaxFileTransferObject;
                }(FileTransferObject));
                /* upload file using fileTransfer */
                function uploadWithFileTransfer(file, url, options) { }
                function appendFileToFormData(file, fd, options) {
                    /* append file to form data */
                    if (lodash__WEBPACK_IMPORTED_MODULE_2___default().isArray(file)) {
                        lodash__WEBPACK_IMPORTED_MODULE_2___default().forEach(file, function (fileObject) {
                            fd.append(options.paramName, fileObject.content || fileObject, fileObject.name);
                        });
                    }
                    else if (lodash__WEBPACK_IMPORTED_MODULE_2___default().isObject(file)) {
                        fd.append(options.paramName, file.content || file, file.name);
                    }
                }
                /* upload file with ajax calling */
                function uploadWithAjax(file, variable, fd, url, options) {
                    var cloneFD = new FormData();
                    var iterate = function (value, key) {
                        var fileObject = (lodash__WEBPACK_IMPORTED_MODULE_2___default().isArray(value) ? value[0] : value);
                        if (!(fileObject instanceof File || fileObject instanceof Blob)) {
                            cloneFD.append(key, value);
                        }
                    };
                    // The foreeach method on form data doesn't exist in IE. Hence we check if it exists
                    // or else use the lodash forEach
                    if (fd.forEach) {
                        fd.forEach(iterate);
                    }
                    else {
                        lodash__WEBPACK_IMPORTED_MODULE_2___default().forEach(fd, iterate);
                    }
                    appendFileToFormData(file, cloneFD, options);
                    var promise = new _notify_promise__WEBPACK_IMPORTED_MODULE_1__.NotifyPromise(function (resolve, reject, notify) {
                        // ToDo - variable seperation
                        variable.httpService.uploadFile(url, cloneFD, variable, { notify: notify }).then(function (data) {
                            resolve(data);
                        }, function (error) {
                            reject(error);
                        });
                        file._uploadProgress = variable.request;
                    });
                    return promise;
                }
                /* upload the file - IE9 support */
                // function uploadWithIframe(file, url, options) {}
                /* upload the next file depending on the status */
                function starNextFileTransfer(fts) {
                    var ft = lodash__WEBPACK_IMPORTED_MODULE_2___default().find(fts, function (f) {
                        return f.status === UPLOAD_STATUS.QUEUED;
                    });
                    if (ft) {
                        ft.start();
                        ft.finally(starNextFileTransfer.bind(undefined, fts));
                    }
                }
                /* upload the max no of files at once i.e. two at once based on max*/
                function startFileTransfers(fts, max) {
                    var i = 0;
                    var len = fts.length;
                    while (i < max && i < len) {
                        starNextFileTransfer(fts);
                        i++;
                    }
                }
                function isMobileApp() {
                    return false;
                }
                /**
                 * This function uploads the file to the given url endpoint.
                 *
                 * @param file file to upload
                 * @param url http endpoint to which the file has to be submitted.
                 * @param options
                 * @returns a promise to listen for success, event, onProgress.
                 *  One can also abort the upload by simply calling abort function.
                 */
                function upload(files, variable, fd, config, options) {
                    options = lodash__WEBPACK_IMPORTED_MODULE_2___default().extend({
                        'paramName': config.fileParamName
                    }, options);
                    return uploadWithAjax(files, variable, fd, config.url, options);
                    // let fileTransfers = [],
                    //     url = config.uploadUrl;
                    // options = _.extend({
                    //     'paramName' : config.fileParamName
                    // }, options);
                    //
                    // if (isMobileApp()) {
                    //     _.forEach(files, function (file) {
                    //         fileTransfers.push(uploadWithFileTransfer(file, url, options));
                    //     });
                    // } else if ((window as any).FormData) {
                    //     _.forEach(files, function (file) {
                    //         fileTransfers.push(uploadWithAjax(file, url, options));
                    //     });
                    // } else {
                    //     _.forEach(files, function (file) {
                    //         fileTransfers.push(uploadWithIframe(file, url, options));
                    //     });
                    // }
                    // startFileTransfers(fileTransfers, 2);
                    // return fileTransfers;
                }
                /***/ 
            }),
            /***/ "./src/util/inflight-queue.ts": 
            /*!************************************!*\
              !*** ./src/util/inflight-queue.ts ***!
              \************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "$queue": function () { return ( /* binding */$queue); }
                    /* harmony export */ 
                });
                var InflightQueue = /** @class */ (function () {
                    function InflightQueue() {
                        this.requestsQueue = new Map();
                    }
                    /**
                     * pushes the process against a variable in its queue
                     * @param variable
                     * @param {{resolve: (value?: any) => void; reject: (reason?: any) => void}} param2
                     * the resolve callback will be called on
                     */
                    InflightQueue.prototype.addToQueue = function (variable, param2) {
                        if (this.requestsQueue.has(variable)) {
                            this.requestsQueue.get(variable).push(param2);
                        }
                        else {
                            var processes = [];
                            processes.push({ resolve: param2.resolve, reject: param2.reject, active: false });
                            this.requestsQueue.set(variable, processes);
                        }
                    };
                    /**
                     * Calls the reject method against the passed process
                     * @param process
                     */
                    InflightQueue.prototype.rejectProcess = function (process) {
                        process.reject('PROCESS_REJECTED_IN_QUEUE');
                    };
                    /**
                     * clears the queue against a variable
                     * @param variable
                     */
                    InflightQueue.prototype.clear = function (variable) {
                        this.requestsQueue.delete(variable);
                    };
                    /**
                     * executes the n/w calls for a specified variable pushed in its respective queue (pushed while it was inFlight)
                     * @param variable
                     */
                    InflightQueue.prototype.process = function (variable) {
                        var processes = this.requestsQueue.get(variable);
                        var nextProcess;
                        // process request queue for the variable only if it is not empty
                        if (!processes || !processes.length) {
                            this.clear(variable);
                            return;
                        }
                        // If only one item in queue
                        if (processes.length === 1) {
                            nextProcess = processes[0];
                            if (nextProcess.active) {
                                this.clear(variable);
                            }
                            else {
                                nextProcess.active = true;
                                nextProcess.resolve();
                            }
                            return;
                        }
                        switch (variable.inFlightBehavior) {
                            case 'executeLast':
                                for (var i = 0; i < processes.length - 2; i++) {
                                    this.rejectProcess(processes[i]);
                                }
                                processes.splice(0, processes.length - 1);
                                this.process(variable);
                                break;
                            case 'executeAll':
                                nextProcess = processes.splice(0, 1)[0];
                                if (nextProcess.active) {
                                    nextProcess = processes.splice(0, 1)[0];
                                }
                                nextProcess.active = true;
                                nextProcess.resolve();
                                break;
                            default:
                                for (var i = 0; i < processes.length - 1; i++) {
                                    this.rejectProcess(processes[i]);
                                }
                                this.clear(variable);
                                break;
                        }
                    };
                    /**
                     * initializes the queue against a variable and makes the first process call
                     * If already initialized and a process in queue is in progress, the queue is not processed.
                     * To process the next item in the queue, the process method has to be called from the caller.
                     * @param variable
                     * @returns {Promise<any>}
                     */
                    InflightQueue.prototype.submit = function (variable) {
                        var _this = this;
                        return new Promise(function (resolve, reject) {
                            _this.addToQueue(variable, { resolve: resolve, reject: reject });
                            if (_this.requestsQueue.get(variable).length === 1) {
                                _this.process(variable);
                            }
                        });
                    };
                    return InflightQueue;
                }());
                var $queue = new InflightQueue();
                /***/ 
            }),
            /***/ "./src/util/notify-promise.ts": 
            /*!************************************!*\
              !*** ./src/util/notify-promise.ts ***!
              \************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "NotifyPromise": function () { return ( /* binding */NotifyPromise); }
                    /* harmony export */ 
                });
                var NotifyPromise = /** @class */ (function () {
                    function NotifyPromise(fn) {
                        var notifyQueue = [], notify = function (status) {
                            notifyQueue.forEach(function (fn1) {
                                fn1(status);
                            });
                        };
                        var cleanUp = function () {
                            notifyQueue.length = 0;
                        };
                        var p1 = new Promise(function (res, rej) {
                            fn(res, rej, notify);
                        });
                        p1.superThen = p1.then.bind(p1);
                        p1.then = function (onResolve, onReject, onNotify) {
                            p1.superThen(function (response) {
                                onResolve(response);
                                cleanUp();
                            }, function (reason) {
                                onReject(reason);
                                cleanUp();
                            });
                            if (onNotify) {
                                notifyQueue.push(onNotify);
                            }
                        };
                        return p1;
                    }
                    return NotifyPromise;
                }());
                // let newPromise = new PromiseWithNotify((resolve, reject, notify) => {
                //     setInterval(notify, 1000);
                // })
                // console.log(newPromise)
                // newPromise.then(undefined, undefined, () => console.log(3));
                /***/ 
            }),
            /***/ "./src/util/oAuth.utils.ts": 
            /*!*********************************!*\
              !*** ./src/util/oAuth.utils.ts ***!
              \*********************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "getAccessToken": function () { return ( /* binding */getAccessToken); },
                    /* harmony export */ "performAuthorization": function () { return ( /* binding */performAuthorization); },
                    /* harmony export */ "removeAccessToken": function () { return ( /* binding */removeAccessToken); }
                    /* harmony export */ 
                });
                /* harmony import */ var _variable_variables_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./variable/variables.utils */ "./src/util/variable/variables.utils.ts");
                var performAuthorization = function (url, providerId, onSuccess, onError, securityObj) {
                    _variable_variables_utils__WEBPACK_IMPORTED_MODULE_0__.oauthService === null || _variable_variables_utils__WEBPACK_IMPORTED_MODULE_0__.oauthService === void 0 ? void 0 : _variable_variables_utils__WEBPACK_IMPORTED_MODULE_0__.oauthService.perfromOAuthorization(url, providerId, onSuccess, onError, securityObj, _variable_variables_utils__WEBPACK_IMPORTED_MODULE_0__.appManager.getCustomUrlScheme(), _variable_variables_utils__WEBPACK_IMPORTED_MODULE_0__.appManager.getDeployedURL());
                };
                var getAccessToken = function (provider, checkLoaclStorage) {
                    return (_variable_variables_utils__WEBPACK_IMPORTED_MODULE_0__.oauthService === null || _variable_variables_utils__WEBPACK_IMPORTED_MODULE_0__.oauthService === void 0 ? void 0 : _variable_variables_utils__WEBPACK_IMPORTED_MODULE_0__.oauthService.getAccessToken) && _variable_variables_utils__WEBPACK_IMPORTED_MODULE_0__.oauthService.getAccessToken(provider, checkLoaclStorage);
                };
                var removeAccessToken = function (provider) {
                    _variable_variables_utils__WEBPACK_IMPORTED_MODULE_0__.oauthService.removeAccessToken(provider);
                };
                /***/ 
            }),
            /***/ "./src/util/utils.ts": 
            /*!***************************!*\
              !*** ./src/util/utils.ts ***!
              \***************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "DEFAULT_FORMATS": function () { return ( /* binding */DEFAULT_FORMATS); },
                    /* harmony export */ "DataType": function () { return ( /* binding */DataType); },
                    /* harmony export */ "IDGenerator": function () { return ( /* binding */IDGenerator); },
                    /* harmony export */ "extractType": function () { return ( /* binding */extractType); },
                    /* harmony export */ "findValueOf": function () { return ( /* binding */findValueOf); },
                    /* harmony export */ "getBlob": function () { return ( /* binding */getBlob); },
                    /* harmony export */ "getClonedObject": function () { return ( /* binding */getClonedObject); },
                    /* harmony export */ "getValidJSON": function () { return ( /* binding */getValidJSON); },
                    /* harmony export */ "hasCordova": function () { return ( /* binding */hasCordova); },
                    /* harmony export */ "isDateTimeType": function () { return ( /* binding */isDateTimeType); },
                    /* harmony export */ "isDefined": function () { return ( /* binding */isDefined); },
                    /* harmony export */ "isNumberType": function () { return ( /* binding */isNumberType); },
                    /* harmony export */ "isObject": function () { return ( /* binding */isObject); },
                    /* harmony export */ "isPageable": function () { return ( /* binding */isPageable); },
                    /* harmony export */ "isValidWebURL": function () { return ( /* binding */isValidWebURL); },
                    /* harmony export */ "noop": function () { return ( /* binding */noop); },
                    /* harmony export */ "removeExtraSlashes": function () { return ( /* binding */removeExtraSlashes); },
                    /* harmony export */ "replace": function () { return ( /* binding */replace); },
                    /* harmony export */ "stringStartsWith": function () { return ( /* binding */stringStartsWith); },
                    /* harmony export */ "triggerFn": function () { return ( /* binding */triggerFn); },
                    /* harmony export */ "xmlToJson": function () { return ( /* binding */xmlToJson); }
                    /* harmony export */ 
                });
                /* harmony import */ var x2js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! x2js */ "./node_modules/x2js/x2js.js");
                /* harmony import */ var x2js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(x2js__WEBPACK_IMPORTED_MODULE_0__);
                /* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
                /* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
                var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
                    var _ = { label: 0, sent: function () { if (t[0] & 1)
                            throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
                    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
                    function verb(n) { return function (v) { return step([n, v]); }; }
                    function step(op) {
                        if (f)
                            throw new TypeError("Generator is already executing.");
                        while (_)
                            try {
                                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                                    return t;
                                if (y = 0, t)
                                    op = [op[0] & 2, t.value];
                                switch (op[0]) {
                                    case 0:
                                    case 1:
                                        t = op;
                                        break;
                                    case 4:
                                        _.label++;
                                        return { value: op[1], done: false };
                                    case 5:
                                        _.label++;
                                        y = op[1];
                                        op = [0];
                                        continue;
                                    case 7:
                                        op = _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                    default:
                                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                            _ = 0;
                                            continue;
                                        }
                                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                            _.label = op[1];
                                            break;
                                        }
                                        if (op[0] === 6 && _.label < t[1]) {
                                            _.label = t[1];
                                            t = op;
                                            break;
                                        }
                                        if (t && _.label < t[2]) {
                                            _.label = t[2];
                                            _.ops.push(op);
                                            break;
                                        }
                                        if (t[2])
                                            _.ops.pop();
                                        _.trys.pop();
                                        continue;
                                }
                                op = body.call(thisArg, _);
                            }
                            catch (e) {
                                op = [6, e];
                                y = 0;
                            }
                            finally {
                                f = t = 0;
                            }
                        if (op[0] & 5)
                            throw op[1];
                        return { value: op[0] ? op[1] : void 0, done: true };
                    }
                };
                // declare const X2JS: any;
                // @ts-ignore
                var DataType = {
                    INTEGER: 'integer',
                    BIG_INTEGER: 'big_integer',
                    SHORT: 'short',
                    FLOAT: 'float',
                    BIG_DECIMAL: 'big_decimal',
                    DOUBLE: 'double',
                    LONG: 'long',
                    BYTE: 'byte',
                    STRING: 'string',
                    CHARACTER: 'character',
                    TEXT: 'text',
                    DATE: 'date',
                    TIME: 'time',
                    TIMESTAMP: 'timestamp',
                    DATETIME: 'datetime',
                    LOCALDATETIME: 'localdatetime',
                    BOOLEAN: 'boolean',
                    LIST: 'list',
                    CLOB: 'clob',
                    BLOB: 'blob'
                };
                var DEFAULT_FORMATS = {
                    DATE: "yyyy-MM-dd",
                    TIME: "HH:mm:ss",
                    TIMESTAMP: "timestamp",
                    DATETIME: "yyyy-MM-ddTHH:mm:ss",
                    LOCALDATETIME: "yyyy-MM-ddTHH:mm:ss",
                    DATETIME_ORACLE: "yyyy-MM-dd HH:mm:ss",
                    DATE_TIME: "yyyy-MM-dd HH:mm:ss"
                };
                var REGEX = {
                    SNAKE_CASE: /[A-Z]/g,
                    ANDROID: /Android/i,
                    IPHONE: /iPhone/i,
                    IPOD: /iPod/i,
                    IPAD: /iPad/i,
                    MAC: /Mac/i,
                    ANDROID_TABLET: /android|android 3.0|xoom|sch-i800|playbook|tablet|kindle/i,
                    MOBILE: /Mobile/i,
                    WINDOWS: /Windows Phone/i,
                    SUPPORTED_IMAGE_FORMAT: /\.(bmp|gif|jpe|jpg|jpeg|tif|tiff|pbm|png|ico)$/i,
                    SUPPORTED_FILE_FORMAT: /\.(txt|js|css|html|script|properties|json|java|xml|smd|xmi|sql|log|wsdl|vm|ftl|jrxml|yml|yaml|md|less|jsp)$/i,
                    SUPPORTED_AUDIO_FORMAT: /\.(mp3|ogg|webm|wma|3gp|wav|m4a)$/i,
                    SUPPORTED_VIDEO_FORMAT: /\.(mp4|ogg|webm|wmv|mpeg|mpg|avi|mov)$/i,
                    PAGE_RESOURCE_PATH: /^\/pages\/.*\.(js|css|html|json)$/,
                    MIN_PAGE_RESOURCE_PATH: /.*(page.min.html)$/,
                    VALID_EMAIL: /^[a-zA-Z][\w.+]+@[a-zA-Z_]+?\.[a-zA-Z.]{1,4}[a-zA-Z]$/,
                    VALID_WEB_URL: /^(http[s]?:\/\/)(www\.){0,1}[a-zA-Z0-9=:?\/\.\-]+(\.[a-zA-Z]{2,5}[\.]{0,1})?/,
                    VALID_WEBSOCKET_URL: /^(ws[s]?:\/\/)(www\.){0,1}[a-zA-Z0-9=:?\/\.\-]+(\.[a-zA-Z]{2,5}[\.]{0,1})?/,
                    VALID_RELATIVE_URL: /^(?!www\.|(?:http|ftp)s?:\/\/|[A-Za-z]:\\|\/\/).*/,
                    REPLACE_PATTERN: /\$\{([^\}]+)\}/g,
                    ZIP_FILE: /\.zip$/i,
                    EXE_FILE: /\.exe$/i,
                    NO_QUOTES_ALLOWED: /^[^'|"]*$/,
                    NO_DOUBLE_QUOTES_ALLOWED: /^[^"]*$/,
                    VALID_HTML: /<[a-z][\s\S]*>/i,
                    VALID_PASSWORD: /^[0-9a-zA-Z-_.@&*!#$%]+$/,
                    SPECIAL_CHARACTERS: /[^A-Z0-9a-z_]+/i,
                    APP_SERVER_URL_FORMAT: /^(http[s]?:\/\/)(www\.){0,1}[a-zA-Z0-9\.\-]+([:]?[0-9]{2,5}|\.[a-zA-Z]{2,5}[\.]{0,1})\/+[^?#&=]+$/,
                    JSON_DATE_FORMAT: /\d{4}-[0-1]\d-[0-3]\d(T[0-2]\d:[0-5]\d:[0-5]\d.\d{1,3}Z$)?/,
                    DATA_URL: /^\s*data:([a-z]+\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s]*)\s*$/i
                };
                var NUMBER_TYPES = ['int', DataType.INTEGER, DataType.FLOAT, DataType.DOUBLE, DataType.LONG, DataType.SHORT, DataType.BYTE, DataType.BIG_INTEGER, DataType.BIG_DECIMAL];
                var noop = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                };
                function idGenerator(token) {
                    var id;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                id = 1;
                                _a.label = 1;
                            case 1:
                                if (false) { }
                                return [4 /*yield*/, "" + token + id++];
                            case 2:
                                _a.sent();
                                return [3 /*break*/, 1];
                            case 3: return [2 /*return*/];
                        }
                    });
                }
                var isValidWebURL = function (url) {
                    return (REGEX.VALID_WEB_URL).test(url);
                };
                /*Function to check whether the specified object is a pageable object or not.*/
                var isPageable = function (obj) {
                    var pageable = {
                        'content': [],
                        'first': true,
                        'last': true,
                        'number': 0,
                        'numberOfElements': 10,
                        'size': 20,
                        'sort': null,
                        'totalElements': 10,
                        'totalPages': 1
                    };
                    // paginated object may or may not contain 'empty' property. In either case, Pageable should return as true.
                    var paginatedObj = lodash__WEBPACK_IMPORTED_MODULE_1___default().omit(obj, 'empty');
                    return (lodash__WEBPACK_IMPORTED_MODULE_1___default().isEqual(lodash__WEBPACK_IMPORTED_MODULE_1___default().keys(pageable), lodash__WEBPACK_IMPORTED_MODULE_1___default().keys(paginatedObj).sort()));
                };
                var IDGenerator = /** @class */ (function () {
                    function IDGenerator(key) {
                        this.generator = idGenerator(key);
                    }
                    IDGenerator.prototype.nextUid = function () {
                        return this.generator.next().value;
                    };
                    return IDGenerator;
                }());
                // ToDo - variable seperation
                var hasCordova = function () {
                    return !!window['cordova'];
                };
                var removeExtraSlashes = function (url) {
                    var base64regex = /^data:image\/([a-z]{2,});base64,/;
                    if (lodash__WEBPACK_IMPORTED_MODULE_1___default().isString(url)) {
                        /*
                        * support for mobile apps having local file path url starting with file:/// and
                        * support for base64 format
                        * */
                        if (lodash__WEBPACK_IMPORTED_MODULE_1___default().startsWith(url, 'file:///') || base64regex.test(url)) {
                            return url;
                        }
                        return url.replace(new RegExp('([^:]\/)(\/)+', 'g'), '$1');
                    }
                };
                var isDefined = function (v) { return 'undefined' !== typeof v; };
                var isObject = function (v) { return null !== v && 'object' === typeof v; };
                /* returns true if the provided data type matches number type */
                var isNumberType = function (type) {
                    return (NUMBER_TYPES.indexOf(extractType(type).toLowerCase()) !== -1);
                };
                /*
                * extracts and returns the last bit from full typeRef of a field
                * e.g. returns 'String' for typeRef = 'java.lang.String'
                * @params: {typeRef} type reference
                */
                var extractType = function (typeRef) {
                    var type;
                    if (!typeRef) {
                        return DataType.STRING;
                    }
                    type = typeRef && typeRef.substring(typeRef.lastIndexOf('.') + 1);
                    type = type && type.toLowerCase();
                    type = type === DataType.LOCALDATETIME ? DataType.DATETIME : type;
                    return type;
                };
                /*Function to check if date time type*/
                var isDateTimeType = function (type) {
                    if (lodash__WEBPACK_IMPORTED_MODULE_1___default().includes(type, '.')) {
                        type = lodash__WEBPACK_IMPORTED_MODULE_1___default().toLower(extractType(type));
                    }
                    return lodash__WEBPACK_IMPORTED_MODULE_1___default().includes([DataType.DATE, DataType.TIME, DataType.TIMESTAMP, DataType.DATETIME, DataType.LOCALDATETIME], type);
                };
                var getValidJSON = function (content) {
                    if (!content) {
                        return undefined;
                    }
                    try {
                        var parsedIntValue = parseInt(content, 10);
                        /*obtaining json from editor content string*/
                        return isObject(content) || !isNaN(parsedIntValue) ? content : JSON.parse(content);
                    }
                    catch (e) {
                        /*terminating execution if new variable object is not valid json.*/
                        return undefined;
                    }
                };
                var xmlToJson = function (xmlString) {
                    var x2jsObj = new (x2js__WEBPACK_IMPORTED_MODULE_0___default())({ 'emptyNodeForm': 'content', 'attributePrefix': '', 'enableToStringFunc': false });
                    var json = x2jsObj.xml2js(xmlString);
                    if (json) {
                        json = lodash__WEBPACK_IMPORTED_MODULE_1___default().get(json, Object.keys(json)[0]);
                    }
                    return json;
                };
                /*
                 * Util method to replace patterns in string with object keys or array values
                 * Examples:
                 * Utils.replace('Hello, ${first} ${last} !', {first: 'wavemaker', last: 'ng'}) --> Hello, wavemaker ng
                 * Utils.replace('Hello, ${0} ${1} !', ['wavemaker','ng']) --> Hello, wavemaker ng
                 * Examples if parseError is true:
                 * Utils.replace('Hello, {0} {1} !', ['wavemaker','ng']) --> Hello, wavemaker ng
                 */
                var replace = function (template, map, parseError) {
                    var regEx = REGEX.REPLACE_PATTERN;
                    if (!template) {
                        return;
                    }
                    if (parseError) {
                        regEx = /\{([^\}]+)\}/g;
                    }
                    return template.replace(regEx, function (match, key) {
                        return lodash__WEBPACK_IMPORTED_MODULE_1___default().get(map, key);
                    });
                };
                /**
                 * prepare a blob object based on the content and content type provided
                 * if content is blob itself, simply returns it back
                 * @param val
                 * @param valContentType
                 * @returns {*}
                 */
                var getBlob = function (val, valContentType) {
                    if (val instanceof Blob) {
                        return val;
                    }
                    var jsonVal = getValidJSON(val);
                    if (jsonVal && jsonVal instanceof Object) {
                        val = new Blob([JSON.stringify(jsonVal)], { type: valContentType || 'application/json' });
                    }
                    else {
                        val = new Blob([val], { type: valContentType || 'text/plain' });
                    }
                    return val;
                };
                /**
                 * Returns a deep cloned replica of the passed object/array
                 * @param object object/array to clone
                 * @returns a clone of the passed object
                 */
                var getClonedObject = function (object) {
                    return lodash__WEBPACK_IMPORTED_MODULE_1___default().cloneDeep(object);
                };
                /**
                 * this method checks if a given string starts with the given string
                 */
                var stringStartsWith = function (str, startsWith, ignoreCase) {
                    if (!str) {
                        return false;
                    }
                    var regEx = new RegExp('^' + startsWith, ignoreCase ? 'i' : '');
                    return regEx.test(str);
                };
                /*function to check if fn is a function and then execute*/
                function triggerFn(fn) {
                    /* Use of slice on arguments will make this function not optimizable
                    * https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
                    * */
                    var argmnts = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        argmnts[_i - 1] = arguments[_i];
                    }
                    var start = 1;
                    var len = arguments.length, args = new Array(len - start);
                    for (start; start < len; start++) {
                        args[start - 1] = arguments[start];
                    }
                    if (lodash__WEBPACK_IMPORTED_MODULE_1___default().isFunction(fn)) {
                        return fn.apply(null, args);
                    }
                }
                /*
                 * Util method to find the value of a key in the object
                 * if key not found and create is true, an object is created against that node
                 * Examples:
                 * var a = {
                 *  b: {
                 *      c : {
                 *          d: 'test'
                 *      }
                 *  }
                 * }
                 * Utils.findValue(a, 'b.c.d') --> 'test'
                 * Utils.findValue(a, 'b.c') --> {d: 'test'}
                 * Utils.findValue(a, 'e') --> undefined
                 * Utils.findValue(a, 'e', true) --> {} and a will become:
                 * {
                 *   b: {
                 *      c : {
                 *          d: 'test'
                 *      }
                 *  },
                 *  e: {
                 *  }
                 * }
                 */
                var findValueOf = function (obj, key, create) {
                    if (!obj || !key) {
                        return;
                    }
                    if (!create) {
                        return lodash__WEBPACK_IMPORTED_MODULE_1___default().get(obj, key);
                    }
                    var parts = key.split('.'), keys = [];
                    var skipProcessing;
                    parts.forEach(function (part) {
                        if (!parts.length) { // if the part of a key is not valid, skip the processing.
                            skipProcessing = true;
                            return false;
                        }
                        var subParts = part.match(/\w+/g);
                        var subPart;
                        while (subParts.length) {
                            subPart = subParts.shift();
                            keys.push({ 'key': subPart, 'value': subParts.length ? [] : {} }); // determine whether to create an array or an object
                        }
                    });
                    if (skipProcessing) {
                        return undefined;
                    }
                    keys.forEach(function (_key) {
                        var tempObj = obj[_key.key];
                        if (!isObject(tempObj)) {
                            tempObj = getValidJSON(tempObj);
                            if (!tempObj) {
                                tempObj = _key.value;
                            }
                        }
                        obj[_key.key] = tempObj;
                        obj = tempObj;
                    });
                    return obj;
                };
                /***/ 
            }),
            /***/ "./src/util/variable/live-variable.http.utils.ts": 
            /*!*******************************************************!*\
              !*** ./src/util/variable/live-variable.http.utils.ts ***!
              \*******************************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "LVService": function () { return ( /* binding */LVService); },
                    /* harmony export */ "generateConnectionParams": function () { return ( /* binding */generateConnectionParams); },
                    /* harmony export */ "parseConfig": function () { return ( /* binding */parseConfig); }
                    /* harmony export */ 
                });
                /* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./src/util/utils.ts");
                /* harmony import */ var _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants/variables.constants */ "./src/constants/variables.constants.ts");
                /* harmony import */ var _variables_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./variables.utils */ "./src/util/variable/variables.utils.ts");
                var isStudioMode = false;
                var parseConfig = function (serviceParams) {
                    var val, param, config;
                    var urlParams = serviceParams.urlParams;
                    /*get the config out of baseServiceManager*/
                    if (_constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_URLS.hasOwnProperty(serviceParams.target) && _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_URLS[serviceParams.target].hasOwnProperty(serviceParams.action)) {
                        config = (0, _utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_URLS[serviceParams.target][serviceParams.action]);
                        /*To handle dynamic urls, append the serviceParams.config.url with the static url(i.e., config.url)*/
                        if (serviceParams.config) {
                            config.url = (serviceParams.config.url || '') + config.url;
                            config.method = serviceParams.config.method || config.method;
                            config.headers = config.headers || {};
                            // TODO[Shubham] - change to for - of
                            for (var key in serviceParams.config.headers) {
                                val = serviceParams.config.headers[key];
                                config.headers[key] = val;
                            }
                        }
                        /* check for url parameters to replace the url */
                        if (urlParams) {
                            for (param in urlParams) {
                                if (urlParams.hasOwnProperty(param)) {
                                    val = urlParams[param];
                                    if (!_.isUndefined(val) && val !== null) {
                                        config.url = config.url.replace(new RegExp(':' + param, 'g'), val);
                                    }
                                }
                            }
                        }
                        /* check for data */
                        if (serviceParams.params) {
                            config.params = serviceParams.params;
                        }
                        /* check for data */
                        if (!_.isUndefined(serviceParams.data)) {
                            config.data = serviceParams.data;
                        }
                        /* check for data parameters, written to support old service calls (.json calls) */
                        if (serviceParams.dataParams) {
                            config.data.params = serviceParams.dataParams;
                        }
                        /* check for headers */
                        if (serviceParams.headers) {
                            config.headers = serviceParams.headers;
                        }
                        /* set extra config flags */
                        config.byPassResult = serviceParams.byPassResult;
                        config.isDirectCall = serviceParams.isDirectCall;
                        config.isExtURL = serviceParams.isExtURL;
                        config.preventMultiple = serviceParams.preventMultiple;
                        config.responseType = serviceParams.responseType;
                        return config;
                    }
                    return null;
                };
                var generateConnectionParams = function (params, action) {
                    var connectionParams, urlParams, requestData;
                    requestData = params.data;
                    urlParams = {
                        projectID: params.projectID,
                        service: !_.isUndefined(params.service) ? params.service : 'services',
                        dataModelName: params.dataModelName,
                        entityName: params.entityName,
                        queryName: params.queryName,
                        queryParams: params.queryParams,
                        procedureName: params.procedureName,
                        procedureParams: params.procedureParams,
                        id: params.id,
                        relatedFieldName: params.relatedFieldName,
                        page: params.page,
                        size: params.size,
                        sort: params.sort
                    };
                    connectionParams = {
                        target: 'DATABASE',
                        action: action,
                        urlParams: urlParams,
                        data: requestData || '',
                        config: {
                            'url': params.url
                        }
                    };
                    connectionParams = parseConfig(connectionParams);
                    // TODO: Remove after backend fix
                    connectionParams.url = (0, _utils__WEBPACK_IMPORTED_MODULE_0__.removeExtraSlashes)(connectionParams.url);
                    return connectionParams;
                };
                var initiateAction = function (action, params, successCallback, failureCallback, noproxy) {
                    var connectionParams, urlParams, requestData, param, val, config, headers, httpDetails;
                    /*
                    config      = getClonedObject(config[action]);
                    headers     = config && config.headers;
                
                    requestData = params.data;
                
                    urlParams = {
                        projectID        : params.projectID,
                        service          : !_.isUndefined(params.service) ? params.service : 'services',
                        dataModelName    : params.dataModelName,
                        entityName       : params.entityName,
                        queryName        : params.queryName,
                        queryParams      : params.queryParams,
                        procedureName    : params.procedureName,
                        procedureParams  : params.procedureParams,
                        id               : params.id,
                        relatedFieldName : params.relatedFieldName,
                        page             : params.page,
                        size             : params.size,
                        sort             : params.sort
                    };
                    */
                    if (params.url && isStudioMode && !noproxy) {
                        /*
                                /!* Check for url parameters to replace the URL.
                                 * So the variable parameters in the URL will be replaced by the actual parameter values.*!/
                                if (urlParams) {
                                    for (param in urlParams) {
                                        if (urlParams.hasOwnProperty(param)) {
                                            val = urlParams[param];
                                            if (!_.isUndefined(val) && val !== null) {
                                                config.url = config.url.replace(new RegExp(':' + param, 'g'), val);
                                            }
                                        }
                                    }
                                }
                                headers = headers || {};
                                headers.skipSecurity = 'true';
                                headers['Content-Type'] = headers['Content-Type'] || 'application/json';
                                /!*(!$rootScope.preferences.workspace.loadXDomainAppDataUsingProxy is added in endpointAddress to differentiate desktop from saas*!/
                                if (action === 'testRunQuery') {
                                    headers['Content-Type'] = undefined;
                                    httpDetails = {
                                        'endpointAddress'   : $window.location.protocol + (!$rootScope.preferences.workspace.loadXDomainAppDataUsingProxy ? ('//' + $window.location.host) : '') + params.url + config.url,
                                        'method'            : config.method,
                                        'content-Type'      : 'multipart/form-data',
                                        'headers'           : headers
                                    };
                                    requestData.append(SWAGGER_CONSTANTS.WM_HTTP_JSON, new Blob([JSON.stringify(httpDetails)], {
                                        type: 'application/json'
                                    }));
                                    connectionParams = {
                                        'data': requestData,
                                        'headers': headers,
                                        'urlParams'         : {
                                            projectID: $rootScope.project.id
                                        }
                                    };
                                } else {
                                    connectionParams = {
                                        'data': {
                                            'endpointAddress'   : $window.location.protocol + (!$rootScope.preferences.workspace.loadXDomainAppDataUsingProxy ? ('//' + $window.location.host) : '') + params.url + config.url,
                                            'method'            : config.method,
                                            'requestBody'       : JSON.stringify(requestData),
                                            'headers'           : headers
                                        },
                                        'urlParams'         : {
                                            projectID: $rootScope.project.id
                                        }
                                    };
                                }
                                WebService.testRestService(connectionParams, function (response) {
                                    var parsedData = getValidJSON(response.responseBody),
                                        errMsg,
                                        localeObject;
                                    if (parsedData.hasOwnProperty('result')) {
                                        triggerFn(successCallback, parsedData.result);
                                    } else if (parsedData.hasOwnProperty('error')) {
                                        triggerFn(failureCallback, (parsedData.error && parsedData.error.message) || parsedData.error);
                                    } else if (parsedData.hasOwnProperty('errorDetails')) {
                                        localeObject = $rootScope.locale || $rootScope.appLocale;
                                        errMsg = getClonedObject(localeObject[parsedData.errorDetails.code]);
                                        triggerFn(failureCallback, replace(errMsg, parsedData.errorDetails.data) || parsedData.errorDetails);
                                    } else {
                                        triggerFn(successCallback, parsedData);
                                    }
                                }, failureCallback);*/
                    }
                    else {
                        connectionParams = generateConnectionParams(params, action);
                        params.operation = action;
                        return _variables_utils__WEBPACK_IMPORTED_MODULE_2__.httpService.sendCallAsObservable({
                            url: connectionParams.url,
                            method: connectionParams.method,
                            data: connectionParams.data,
                            headers: connectionParams.headers
                        }, params);
                    }
                };
                var LVService = {
                    searchTableDataWithQuery: function (params, successCallback, failureCallback) { return initiateAction('searchTableDataWithQuery', params, successCallback, failureCallback); },
                    executeAggregateQuery: function (params, successCallback, failureCallback) { return initiateAction('executeAggregateQuery', params, successCallback, failureCallback); },
                    searchTableData: function (params, successCallback, failureCallback) { return initiateAction('searchTableData', params, successCallback, failureCallback); },
                    readTableData: function (params, successCallback, failureCallback) { return initiateAction('readTableData', params, successCallback, failureCallback); },
                    insertTableData: function (params, successCallback, failureCallback) { return initiateAction('insertTableData', params, successCallback, failureCallback); },
                    insertMultiPartTableData: function (params, successCallback, failureCallback) { return initiateAction('insertMultiPartTableData', params, successCallback, failureCallback); },
                    updateTableData: function (params, successCallback, failureCallback) { return initiateAction('updateTableData', params, successCallback, failureCallback); },
                    updateCompositeTableData: function (params, successCallback, failureCallback) { return initiateAction('updateCompositeTableData', params, successCallback, failureCallback); },
                    periodUpdateCompositeTableData: function (params, successCallback, failureCallback) { return initiateAction('periodUpdateCompositeTableData', params, successCallback, failureCallback); },
                    updateMultiPartTableData: function (params, successCallback, failureCallback) { return initiateAction('updateMultiPartTableData', params, successCallback, failureCallback); },
                    updateMultiPartCompositeTableData: function (params, successCallback, failureCallback) { return initiateAction('updateMultiPartCompositeTableData', params, successCallback, failureCallback); },
                    deleteTableData: function (params, successCallback, failureCallback) { return initiateAction('deleteTableData', params, successCallback, failureCallback); },
                    deleteCompositeTableData: function (params, successCallback, failureCallback) { return initiateAction('deleteCompositeTableData', params, successCallback, failureCallback); },
                    periodDeleteCompositeTableData: function (params, successCallback, failureCallback) { return initiateAction('periodDeleteCompositeTableData', params, successCallback, failureCallback); },
                    exportTableData: function (params) { return initiateAction('exportTableData', params); },
                    getDistinctDataByFields: function (params) { return initiateAction('getDistinctDataByFields', params); },
                    countTableDataWithQuery: function (params, successCallback, failureCallback) { return initiateAction('countTableDataWithQuery', params, successCallback, failureCallback); }
                };
                /***/ 
            }),
            /***/ "./src/util/variable/live-variable.utils.ts": 
            /*!**************************************************!*\
              !*** ./src/util/variable/live-variable.utils.ts ***!
              \**************************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "LiveVariableUtils": function () { return ( /* binding */LiveVariableUtils); }
                    /* harmony export */ 
                });
                /* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/utils */ "./src/util/utils.ts");
                /* harmony import */ var _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants/variables.constants */ "./src/constants/variables.constants.ts");
                /* harmony import */ var _variables_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./variables.utils */ "./src/util/variable/variables.utils.ts");
                var LiveVariableUtils = /** @class */ (function () {
                    function LiveVariableUtils() {
                    }
                    LiveVariableUtils.isCompositeKey = function (primaryKey) {
                        return !primaryKey || (primaryKey && (!primaryKey.length || primaryKey.length > 1));
                    };
                    LiveVariableUtils.isNoPrimaryKey = function (primaryKey) {
                        return (!primaryKey || (primaryKey && !primaryKey.length));
                    };
                    // Generate the URL based on the primary keys and their values
                    LiveVariableUtils.getCompositeIDURL = function (primaryKeysData) {
                        var compositeId = '';
                        //  Loop over the 'compositeKeysData' and construct the 'compositeId'.
                        _.forEach(primaryKeysData, function (paramValue, paramName) {
                            compositeId += paramName + '=' + encodeURIComponent(paramValue) + '&';
                        });
                        compositeId = compositeId.slice(0, -1);
                        return compositeId;
                    };
                    // Check if table has blob column
                    LiveVariableUtils.hasBlob = function (variable) {
                        return _.find(_.get(variable, ['propertiesMap', 'columns']), { 'type': 'blob' });
                    };
                    LiveVariableUtils.getPrimaryKey = function (variable) {
                        if (!variable.propertiesMap) {
                            return [];
                        }
                        if (variable.propertiesMap.primaryFields) {
                            return variable.propertiesMap.primaryFields;
                        }
                        /*Old projects do not have primary fields. Get primary key from the columns*/
                        var primaryKey = [];
                        /*Loop through the propertiesMap and get the primary key column.*/
                        _.forEach(variable.propertiesMap.columns, function (index, column) {
                            if (column.isPrimaryKey) {
                                if (column.isRelated && (!_.includes(column.relatedFieldName, primaryKey))) {
                                    primaryKey.push(column.relatedFieldName);
                                }
                                else if (!_.includes(column.fieldName, primaryKey)) {
                                    primaryKey.push(column.fieldName);
                                }
                            }
                        });
                        return primaryKey;
                    };
                    //  Construct the URL for blob columns and set it in the data, so that widgets can use this
                    LiveVariableUtils.processBlobColumns = function (responseData, variable) {
                        if (!responseData) {
                            return;
                        }
                        var blobCols = _.map(_.filter(variable.propertiesMap.columns, { 'type': 'blob' }), 'fieldName'), deployedUrl = _.trim(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.$rootScope.project.deployedUrl);
                        var href = '', primaryKeys;
                        if (_.isEmpty(blobCols)) {
                            return;
                        }
                        if ((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.hasCordova)()) {
                            href += _.endsWith(deployedUrl, '/') ? deployedUrl : deployedUrl + '/';
                        }
                        href += ((variable._prefabName !== '' && variable._prefabName !== undefined) ? 'prefabs/' + variable._prefabName : 'services') + '/' + variable.liveSource + '/' + variable.type + '/';
                        primaryKeys = variable.propertiesMap.primaryFields || variable.propertiesMap.primaryKeys;
                        _.forEach(responseData, function (data) {
                            if (data) {
                                _.forEach(blobCols, function (col) {
                                    var compositeKeysData = {};
                                    if (data[col] === null || !_.isEmpty(_.trim(data[col]))) {
                                        return;
                                    }
                                    if (LiveVariableUtils.isCompositeKey(primaryKeys)) {
                                        primaryKeys.forEach(function (key) {
                                            compositeKeysData[key] = data[key];
                                        });
                                        data[col] = href + 'composite-id/content/' + col + '?' + LiveVariableUtils.getCompositeIDURL(compositeKeysData);
                                    }
                                    else {
                                        data[col] = href + data[_.join(primaryKeys)] + '/content/' + col;
                                    }
                                });
                            }
                        });
                    };
                    LiveVariableUtils.getHibernateOrSqlType = function (variable, fieldName, type, entityName) {
                        var columns = variable.propertiesMap.columns;
                        var column, relatedCols, relatedCol, columnParts;
                        if (_.includes(fieldName, '.')) {
                            columnParts = fieldName.split('.');
                            if (columnParts.length > 2) {
                                return undefined;
                            }
                            column = _.find(columns, function (col) {
                                return col.fieldName === columnParts[0];
                            });
                            relatedCols = column && column.columns;
                            relatedCol = _.find(relatedCols, function (col) {
                                return col.fieldName === columnParts[1];
                            });
                            return relatedCol && relatedCol[type];
                        }
                        column = _.find(columns, function (col) {
                            return col.fieldName === fieldName || col.relatedColumnName === fieldName;
                        });
                        if (!column && entityName) {
                            var entity = _.find(columns, function (col) { return col.relatedEntityName === entityName; });
                            column = _.find(entity.columns, function (col) {
                                return col.fieldName === fieldName || col.relatedColumnName === fieldName;
                            });
                        }
                        return column && column[type];
                    };
                    /*Function to get the sqlType of the specified field.*/
                    LiveVariableUtils.getSqlType = function (variable, fieldName, entityName) {
                        return LiveVariableUtils.getHibernateOrSqlType(variable, fieldName, 'type', entityName);
                    };
                    /*Function to check if the specified field has a one-to-many relation or not.*/
                    LiveVariableUtils.isRelatedFieldMany = function (variable, fieldName) {
                        var columns = variable.propertiesMap.columns, columnsCount = columns.length;
                        var index, column;
                        /*Loop through the columns of the liveVariable*/
                        for (index = 0; index < columnsCount; index += 1) {
                            column = columns[index];
                            /*If the specified field is found in the columns of the variable,
                            * then it has a many-to-one relation.*/
                            if (column.fieldName === fieldName) {
                                return false;
                            }
                        }
                        return true;
                    };
                    LiveVariableUtils.isStringType = function (type) {
                        return _.includes(['text', 'string'], _.toLower(type));
                    };
                    LiveVariableUtils.getSQLFieldType = function (variable, options) {
                        if (_.includes(['timestamp', 'datetime', 'date'], options.type)) {
                            return options.type;
                        }
                        return LiveVariableUtils.getSqlType(variable, options.fieldName) || options.type;
                    };
                    LiveVariableUtils.getAttributeName = function (variable, fieldName) {
                        var attrName = fieldName;
                        variable.propertiesMap.columns.forEach(function (column) {
                            if (column.fieldName === fieldName && column.isRelated) {
                                attrName = column.relatedFieldName;
                            }
                        });
                        return attrName;
                    };
                    LiveVariableUtils.getFilterCondition = function (filterCondition) {
                        if (_.includes(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.DB_CONSTANTS.DATABASE_RANGE_MATCH_MODES, filterCondition)) {
                            return filterCondition;
                        }
                        return _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.DB_CONSTANTS.DATABASE_MATCH_MODES.exact;
                    };
                    LiveVariableUtils.getFilterOption = function (variable, fieldOptions, options) {
                        var attributeName, fieldValue = fieldOptions.value, filterOption, filterCondition;
                        var matchModes = _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.DB_CONSTANTS.DATABASE_MATCH_MODES, fieldName = fieldOptions.fieldName, fieldRequired = fieldOptions.required || false, fieldType = LiveVariableUtils.getSQLFieldType(variable, fieldOptions);
                        filterCondition = matchModes[fieldOptions.matchMode] || matchModes[fieldOptions.filterCondition] || fieldOptions.filterCondition;
                        fieldOptions.type = fieldType;
                        /* if the field value is an object(complex type), loop over each field inside and push only first level fields */
                        if (_.isObject(fieldValue) && !_.isArray(fieldValue)) {
                            var firstLevelValues_1 = [];
                            _.forEach(fieldValue, function (subFieldValue, subFieldName) {
                                if (subFieldValue && !_.isObject(subFieldValue)) {
                                    firstLevelValues_1.push(fieldName + '.' + subFieldName + '=' + subFieldValue);
                                }
                            });
                            return firstLevelValues_1;
                        }
                        if (_.includes(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.DB_CONSTANTS.DATABASE_EMPTY_MATCH_MODES, filterCondition)) {
                            attributeName = LiveVariableUtils.getAttributeName(variable, fieldName);
                            // For non string types empty match modes are not supported, so convert them to null match modes.
                            if (fieldType && !LiveVariableUtils.isStringType(fieldType)) {
                                filterCondition = _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.DB_CONSTANTS.DATABASE_NULL_EMPTY_MATCH[filterCondition];
                            }
                            filterOption = {
                                'attributeName': attributeName,
                                'attributeValue': '',
                                'attributeType': _.toUpper(fieldType),
                                'filterCondition': filterCondition,
                                'required': fieldRequired
                            };
                            if (options.searchWithQuery) {
                                filterOption.isVariableFilter = fieldOptions.isVariableFilter;
                            }
                            return filterOption;
                        }
                        if ((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isDefined)(fieldValue) && fieldValue !== null && fieldValue !== '') {
                            /*Based on the sqlType of the field, format the value & set the filter condition.*/
                            if (fieldType) {
                                switch (fieldType) {
                                    case 'integer':
                                        fieldValue = _.isArray(fieldValue) ? _.reduce(fieldValue, function (result, value) {
                                            value = parseInt(value, 10);
                                            if (!_.isNaN(value)) {
                                                result.push(value);
                                            }
                                            return result;
                                        }, []) : parseInt(fieldValue, 10);
                                        filterCondition = filterCondition ? LiveVariableUtils.getFilterCondition(filterCondition) : matchModes['exact'];
                                        break;
                                    case 'date':
                                    case 'datetime':
                                    case 'timestamp':
                                        // ToDo - variable seperation
                                        fieldValue = (0, _variables_utils__WEBPACK_IMPORTED_MODULE_2__.formatDate)(fieldValue, fieldType);
                                        filterCondition = filterCondition ? LiveVariableUtils.getFilterCondition(filterCondition) : matchModes['exact'];
                                        break;
                                    case 'text':
                                    case 'string':
                                        if (_.isArray(fieldValue)) {
                                            filterCondition = _.includes([matchModes['in'], matchModes['notin']], filterCondition) ? filterCondition : matchModes['exact'];
                                        }
                                        else {
                                            filterCondition = filterCondition || matchModes['anywhereignorecase'];
                                        }
                                        break;
                                    default:
                                        filterCondition = filterCondition ? LiveVariableUtils.getFilterCondition(filterCondition) : matchModes['exact'];
                                        break;
                                }
                            }
                            else {
                                filterCondition = _.isString(fieldValue) ? matchModes['anywhereignorecase'] : matchModes['exact'];
                            }
                            attributeName = LiveVariableUtils.getAttributeName(variable, fieldName);
                            filterOption = {
                                'attributeName': attributeName,
                                'attributeValue': fieldValue,
                                'attributeType': _.toUpper(fieldType),
                                'filterCondition': filterCondition,
                                'required': fieldRequired
                            };
                            if (options.searchWithQuery) {
                                filterOption.isVariableFilter = fieldOptions.isVariableFilter;
                            }
                            return filterOption;
                        }
                    };
                    LiveVariableUtils.getFilterOptions = function (variable, filterFields, options) {
                        var filterOptions = [];
                        _.each(filterFields, function (fieldOptions) {
                            var filterOption = LiveVariableUtils.getFilterOption(variable, fieldOptions, options);
                            if (!_.isNil(filterOption)) {
                                if (_.isArray(filterOption)) {
                                    filterOptions = filterOptions.concat(filterOption);
                                }
                                else {
                                    filterOptions.push(filterOption);
                                }
                            }
                        });
                        return filterOptions;
                    };
                    // Wrap the field name and value in lower() in ignore case scenario
                    // TODO: Change the function name to represent the added functionality of identifiers for datetime, timestamp and float types. Previously only lower was warapped.
                    LiveVariableUtils.wrapInLowerCase = function (value, options, ignoreCase, isField) {
                        var type = _.toLower(options.attributeType);
                        // If ignore case is true and type is string/ text and match mode is string type, wrap in lower()
                        if (ignoreCase && (!type || LiveVariableUtils.isStringType(type)) && _.includes(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.DB_CONSTANTS.DATABASE_STRING_MODES, options.filterCondition)) {
                            return 'lower(' + value + ')';
                        }
                        return value;
                    };
                    LiveVariableUtils.encodeAndAddQuotes = function (value, type, skipEncode) {
                        var encodedValue = skipEncode ? value : encodeURIComponent(value);
                        type = _.toLower(type);
                        encodedValue = _.replace(encodedValue, /'/g, '\'\'');
                        // For number types, don't wrap the value in quotes
                        if (((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isNumberType)(type) && type !== 'float')) {
                            return encodedValue;
                        }
                        return '\'' + encodedValue + '\'';
                    };
                    LiveVariableUtils.getParamValue = function (value, options, ignoreCase, skipEncode) {
                        var param;
                        var filterCondition = options.filterCondition, dbModes = _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.DB_CONSTANTS.DATABASE_MATCH_MODES, type = options.attributeType;
                        if (_.includes(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.DB_CONSTANTS.DATABASE_EMPTY_MATCH_MODES, filterCondition)) {
                            // For empty matchmodes, no value is required
                            return '';
                        }
                        switch (filterCondition) {
                            case dbModes.startignorecase:
                            case dbModes.start:
                                param = LiveVariableUtils.encodeAndAddQuotes(value + '%', type, skipEncode);
                                param = LiveVariableUtils.wrapInLowerCase(param, options, ignoreCase);
                                break;
                            case dbModes.endignorecase:
                            case dbModes.end:
                                param = LiveVariableUtils.encodeAndAddQuotes('%' + value, type, skipEncode);
                                param = LiveVariableUtils.wrapInLowerCase(param, options, ignoreCase);
                                break;
                            case dbModes.nowhereignorecase:
                            case dbModes.nowhere:
                            case dbModes.anywhereignorecase:
                            case dbModes.anywhere:
                                param = LiveVariableUtils.encodeAndAddQuotes('%' + value + '%', type, skipEncode);
                                param = LiveVariableUtils.wrapInLowerCase(param, options, ignoreCase);
                                break;
                            case dbModes.between:
                                param = _.join(_.map(value, function (val) {
                                    return LiveVariableUtils.wrapInLowerCase(LiveVariableUtils.encodeAndAddQuotes(val, type, skipEncode), options, ignoreCase);
                                }), ' and ');
                                break;
                            case dbModes.in:
                            case dbModes.notin:
                                param = _.join(_.map(value, function (val) {
                                    return LiveVariableUtils.wrapInLowerCase(LiveVariableUtils.encodeAndAddQuotes(val, type, skipEncode), options, ignoreCase);
                                }), ', ');
                                param = '(' + param + ')';
                                break;
                            /*case dbModes.exactignorecase:
                            case dbModes.exact:
                            case dbModes.notequals:
                            The above three cases will be handled by default*/
                            default:
                                param = LiveVariableUtils.encodeAndAddQuotes(value, type, skipEncode);
                                param = LiveVariableUtils.wrapInLowerCase(param, options, ignoreCase);
                                break;
                        }
                        return (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isDefined)(param) ? param : '';
                    };
                    LiveVariableUtils.getSearchQuery = function (filterOptions, operator, ignoreCase, skipEncode) {
                        var query;
                        var params = [];
                        _.forEach(filterOptions, function (fieldValue) {
                            var value = fieldValue.attributeValue, dbModes = _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.DB_CONSTANTS.DATABASE_MATCH_MODES, isValArray = _.isArray(value);
                            var fieldName = fieldValue.attributeName, filterCondition = fieldValue.filterCondition, matchModeExpr, paramValue;
                            // If value is an empty array, do not generate the query
                            // If values is NaN and number type, do not generate query for this field
                            if ((isValArray && _.isEmpty(value)) || (!isValArray && isNaN(value) && ((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isNumberType)(fieldValue.attributeType))) || (!isValArray && (isNaN(value) && !moment(value).isValid() && (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isDateTimeType)(_.toLower(fieldValue.attributeType))))) {
                                return;
                            }
                            if (isValArray) {
                                // If array is value and mode is between, pass between. Else pass as in query
                                filterCondition = filterCondition === dbModes.between || filterCondition === dbModes.notin ? filterCondition : dbModes.in;
                                fieldValue.filterCondition = filterCondition;
                            }
                            matchModeExpr = _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.DB_CONSTANTS.DATABASE_MATCH_MODES_WITH_QUERY[filterCondition];
                            paramValue = LiveVariableUtils.getParamValue(value, fieldValue, ignoreCase, skipEncode);
                            fieldName = LiveVariableUtils.wrapInLowerCase(fieldName, fieldValue, ignoreCase);
                            params.push((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.replace)(matchModeExpr, [fieldName, paramValue]));
                        });
                        query = _.join(params, operator); // empty space added intentionally around OR
                        return query;
                    };
                    /**
                     * creating the proper values from the actual object like for between,in matchModes value has to be an array like [1,2]
                     * @param rules recursive filterexpressions object
                     * @param variable variable object
                     * @param options options
                     */
                    LiveVariableUtils.processFilterFields = function (rules, variable, options) {
                        _.remove(rules, function (rule) {
                            return rule && (_.isString(rule.value) && rule.value.indexOf('bind:') === 0 || (rule.matchMode === 'between' ? (_.isString(rule.secondvalue) && rule.secondvalue.indexOf('bind:') === 0) : false));
                        });
                        _.forEach(rules, function (rule, index) {
                            if (rule) {
                                if (rule.rules) {
                                    LiveVariableUtils.processFilterFields(rule.rules, variable, options);
                                }
                                else {
                                    if (!_.isNull(rule.target)) {
                                        var value = rule.matchMode.toLowerCase() === _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.DB_CONSTANTS.DATABASE_MATCH_MODES.between.toLowerCase()
                                            ? (_.isArray(rule.value) ? rule.value : [rule.value, rule.secondvalue])
                                            : (rule.matchMode.toLowerCase() === _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.DB_CONSTANTS.DATABASE_MATCH_MODES["in"].toLowerCase() || rule.matchMode.toLowerCase() === _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.DB_CONSTANTS.DATABASE_MATCH_MODES.notin.toLowerCase()
                                                ? (_.isArray(rule.value) ? rule.value : (rule.value ? rule.value.split(',').map(function (val) { return val.trim(); }) : ''))
                                                : rule.value);
                                        rules[index] = LiveVariableUtils.getFilterOption(variable, {
                                            'fieldName': rule.target,
                                            'type': rule.type,
                                            'value': value,
                                            'required': rule.required,
                                            'filterCondition': rule.matchMode || options.matchMode || variable.matchMode
                                        }, options);
                                    }
                                }
                            }
                        });
                    };
                    LiveVariableUtils.getSearchField = function (fieldValue, ignoreCase, skipEncode) {
                        var fieldName = fieldValue.attributeName;
                        var matchModeExpr;
                        var paramValue;
                        var filterCondition = fieldValue.filterCondition;
                        var value = fieldValue.attributeValue;
                        var isValArray = _.isArray(value);
                        var dbModes = _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.DB_CONSTANTS.DATABASE_MATCH_MODES;
                        // If value is an empty array, do not generate the query
                        // If values is NaN and number type, do not generate query for this field
                        if ((isValArray && _.isEmpty(value)) ||
                            (isValArray && _.some(value, function (val) { return (_.isNull(val) || _.isNaN(val) || val === ''); })) ||
                            (!isValArray && (isNaN(value) && ((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isNumberType)(fieldValue.attributeType)))) ||
                            (!isValArray && (isNaN(value) && !moment(value).isValid() && (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isDateTimeType)(_.toLower(fieldValue.attributeType))))) {
                            return;
                        }
                        if (isValArray) {
                            // If array is value and mode is between, pass between. Else pass as in query
                            filterCondition = filterCondition === dbModes.between || filterCondition === dbModes.notin ? filterCondition : dbModes.in;
                            fieldValue.filterCondition = filterCondition;
                        }
                        matchModeExpr = _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.DB_CONSTANTS.DATABASE_MATCH_MODES_WITH_QUERY[filterCondition];
                        paramValue = LiveVariableUtils.getParamValue(value, fieldValue, ignoreCase, skipEncode);
                        fieldName = LiveVariableUtils.wrapInLowerCase(fieldName, fieldValue, ignoreCase);
                        return (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.replace)(matchModeExpr, [fieldName, paramValue]);
                    };
                    /**
                     * this is used to identify whether to use ignorecase at each criteria level and not use the variable
                     * level isIgnoreCase flag and apply it to all the rules.
                     * Instead of adding an extra param to the criteria object, we have added few other matchmodes for string types like
                     * anywhere with anywhereignorecase, start with startignorecase, end with endignorecase, exact with exactignorecase,
                     * So while creating the criteria itseld user can choose whether to use ignore case or not for a particular column while querying
                     * @param matchMode
                     * @param ignoreCase
                     * @returns {*} boolean
                     */
                    LiveVariableUtils.getIgnoreCase = function (matchMode, ignoreCase) {
                        var matchModes = _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.DB_CONSTANTS.DATABASE_MATCH_MODES;
                        if (_.indexOf([matchModes['anywhere'], matchModes['nowhere'], matchModes['start'], matchModes['end'], matchModes['exact']], matchMode) !== -1) {
                            return false;
                        }
                        if (_.indexOf([matchModes['anywhereignorecase'], matchModes['nowhereignorecase'], matchModes['startignorecase'], matchModes['endignorecase'], matchModes['exactignorecase']], matchMode) !== -1) {
                            return true;
                        }
                        return ignoreCase;
                    };
                    LiveVariableUtils.generateSearchQuery = function (rules, condition, ignoreCase, skipEncode) {
                        var params = [];
                        _.forEach(rules, function (rule) {
                            if (rule) {
                                if (rule.rules) {
                                    var query = LiveVariableUtils.generateSearchQuery(rule.rules, rule.condition, ignoreCase, skipEncode);
                                    if (query !== '') {
                                        params.push('(' + query + ')');
                                    }
                                }
                                else {
                                    var searchField = LiveVariableUtils.getSearchField(rule, LiveVariableUtils.getIgnoreCase(rule.filterCondition, ignoreCase), skipEncode);
                                    if (!_.isNil(searchField)) {
                                        params.push(searchField);
                                    }
                                }
                            }
                        });
                        return _.join(params, ' ' + condition + ' ');
                    };
                    LiveVariableUtils.prepareTableOptionsForFilterExps = function (variable, options, clonedFields) {
                        if (!(0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isDefined)(options.searchWithQuery)) {
                            options.searchWithQuery = true; // Using query api instead of  search api
                        }
                        var filterOptions = [];
                        var matchModes = _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.DB_CONSTANTS.DATABASE_MATCH_MODES;
                        var orderByFields, orderByOptions, query;
                        var clonedObj = clonedFields || (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(variable.filterExpressions);
                        // if filterexpression from live filter is present use it to query
                        if (options.filterExpr && !_.isEmpty(options.filterExpr)) {
                            clonedObj = options.filterExpr;
                        }
                        // merge live filter runtime values
                        var filterRules = {};
                        if (!_.isEmpty(options.filterFields)) {
                            var operator = '';
                            for (var field in options.filterFields) {
                                operator = options.filterFields[field]['logicalOp'] || '';
                                break;
                            }
                            filterRules = { 'condition': options.logicalOp || operator || 'AND', 'rules': [] };
                            _.forEach(options.filterFields, function (filterObj, filterName) {
                                var filterCondition = matchModes[filterObj.matchMode] || matchModes[filterObj.filterCondition] || filterObj.filterCondition;
                                if (_.includes(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.DB_CONSTANTS.DATABASE_EMPTY_MATCH_MODES, filterCondition) ||
                                    (!_.isNil(filterObj.value) && filterObj.value !== '')) {
                                    var type = filterObj.type || LiveVariableUtils.getSqlType(variable, filterName, options.entityName);
                                    var ruleObj = {
                                        'target': filterName,
                                        'type': type,
                                        'matchMode': filterObj.matchMode || (LiveVariableUtils.isStringType(type) ? 'startignorecase' : 'exact'),
                                        'value': filterObj.value,
                                        'required': filterObj.required || false
                                    };
                                    filterRules.rules.push(ruleObj);
                                }
                            });
                        }
                        if (!_.isEmpty(clonedObj)) {
                            if (!_.isNil(filterRules.rules) && filterRules.rules.length) {
                                // combine both the rules using 'AND'
                                var tempRules = { 'condition': 'AND', 'rules': [] };
                                tempRules.rules.push((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(clonedObj));
                                tempRules.rules.push(filterRules);
                                clonedObj = tempRules;
                            }
                        }
                        else {
                            clonedObj = filterRules;
                        }
                        LiveVariableUtils.processFilterFields(clonedObj.rules, variable, options);
                        query = LiveVariableUtils.generateSearchQuery(clonedObj.rules, clonedObj.condition, variable.ignoreCase, options.skipEncode);
                        orderByFields = (0, _variables_utils__WEBPACK_IMPORTED_MODULE_2__.getEvaluatedOrderBy)(variable.orderBy, options.orderBy);
                        orderByOptions = orderByFields ? 'sort=' + orderByFields : '';
                        return {
                            'filter': filterOptions,
                            'sort': orderByOptions,
                            'query': query
                        };
                    };
                    LiveVariableUtils.prepareTableOptions = function (variable, options, clonedFields) {
                        if (variable.operation === 'read') {
                            return LiveVariableUtils.prepareTableOptionsForFilterExps(variable, options, clonedFields);
                        }
                        if (!(0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isDefined)(options.searchWithQuery)) {
                            options.searchWithQuery = true; //  Using query api instead of  search api
                        }
                        var filterFields = [];
                        var filterOptions = [], orderByFields, orderByOptions, query, optionsQuery;
                        clonedFields = clonedFields || variable.filterFields;
                        // get the filter fields from the variable
                        _.forEach(clonedFields, function (value, key) {
                            if (_.isObject(value) && (!options.filterFields || !options.filterFields[key] || options.filterFields[key].logicalOp === 'AND')) {
                                value.fieldName = key;
                                if (LiveVariableUtils.isStringType(LiveVariableUtils.getSQLFieldType(variable, value))) {
                                    value.filterCondition = _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.DB_CONSTANTS.DATABASE_MATCH_MODES[value.matchMode || variable.matchMode];
                                }
                                value.isVariableFilter = true;
                                filterFields.push(value);
                            }
                        });
                        // get the filter fields from the options
                        _.forEach(options.filterFields, function (value, key) {
                            value.fieldName = key;
                            value.filterCondition = _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.DB_CONSTANTS.DATABASE_MATCH_MODES[value.matchMode || options.matchMode || variable.matchMode];
                            filterFields.push(value);
                        });
                        if (variable.operation === 'read' || options.operation === 'read') {
                            filterOptions = LiveVariableUtils.getFilterOptions(variable, filterFields, options);
                        }
                        /*if searchWithQuery is true, then convert the input params into query string. For example if firstName and lastName
                         should be sent as params then query string will be q='firstName containing 'someValue' OR lastName containing 'someValue''
                         */
                        if (options.searchWithQuery && filterOptions.length) {
                            // Generate query for variable filter fields. This has AND logical operator
                            query = LiveVariableUtils.getSearchQuery(_.filter(filterOptions, { 'isVariableFilter': true }), ' AND ', variable.ignoreCase, options.skipEncode);
                            // Generate query for option filter fields. This has default logical operator as OR
                            optionsQuery = LiveVariableUtils.getSearchQuery(_.filter(filterOptions, { 'isVariableFilter': undefined }), ' ' + (options.logicalOp || 'AND') + ' ', variable.ignoreCase, options.skipEncode);
                            if (optionsQuery) {
                                // If both variable and option query are present, merge them with AND
                                query = query ? (query + ' AND ( ' + optionsQuery + ' )') : optionsQuery;
                            }
                        }
                        orderByFields = (0, _variables_utils__WEBPACK_IMPORTED_MODULE_2__.getEvaluatedOrderBy)(variable.orderBy, options.orderBy);
                        orderByOptions = orderByFields ? 'sort=' + orderByFields : '';
                        return {
                            'filter': filterOptions,
                            'sort': orderByOptions,
                            'query': query
                        };
                    };
                    /* Function to check if specified field is of type date*/
                    LiveVariableUtils.getFieldType = function (fieldName, variable, relatedField) {
                        var fieldType, columns, result;
                        if (variable.propertiesMap) {
                            columns = variable.propertiesMap.columns || [];
                            result = _.find(columns, function (obj) {
                                return obj.fieldName === fieldName;
                            });
                            // if related field name passed, get its type from columns inside the current field
                            if (relatedField && result) {
                                result = _.find(result.columns, function (obj) {
                                    return obj.fieldName === relatedField;
                                });
                            }
                            fieldType = result && result.type;
                        }
                        return fieldType;
                    };
                    // Prepare formData for blob columns
                    LiveVariableUtils.prepareFormData = function (variableDetails, rowObject) {
                        var formData = new FormData();
                        formData.rowData = _.clone(rowObject);
                        _.forEach(rowObject, function (colValue, colName) {
                            if (LiveVariableUtils.getFieldType(colName, variableDetails) === 'blob') {
                                if (_.isObject(colValue)) {
                                    if (_.isArray(colValue)) {
                                        _.forEach(colValue, function (fileObject) {
                                            formData.append(colName, fileObject, fileObject.name);
                                        });
                                    }
                                    else {
                                        formData.append(colName, colValue, colValue.name);
                                    }
                                }
                                rowObject[colName] = colValue !== null ? '' : null;
                            }
                        });
                        formData.append(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.SWAGGER_CONSTANTS.WM_DATA_JSON, new Blob([JSON.stringify(rowObject)], {
                            type: 'application/json'
                        }));
                        return formData;
                    };
                    LiveVariableUtils.traverseFilterExpressions = function (filterExpressions, traverseCallbackFn) {
                        if (filterExpressions && filterExpressions.rules) {
                            _.forEach(filterExpressions.rules, function (filExpObj, i) {
                                if (filExpObj.rules) {
                                    LiveVariableUtils.traverseFilterExpressions(filExpObj, traverseCallbackFn);
                                }
                                else {
                                    return (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.triggerFn)(traverseCallbackFn, filterExpressions, filExpObj);
                                }
                            });
                        }
                    };
                    /**
                     * Traverses recursively the filterExpressions object and if there is any required field present with no value,
                     * then we will return without proceeding further. Its upto the developer to provide the mandatory value,
                     * if he wants to assign it in teh onbefore<delete/insert/update>function then make that field in
                     * the filter query section as optional
                     * @param filterExpressions - recursive rule Object
                     * @returns {Object} object or boolean. Object if everything gets validated or else just boolean indicating failure in the validations
                     */
                    LiveVariableUtils.getFilterExprFields = function (filterExpressions) {
                        var isRequiredFieldAbsent = false;
                        var traverseCallbackFn = function (parentFilExpObj, filExpObj) {
                            if (filExpObj
                                && filExpObj.required
                                && ((_.indexOf(['null', 'isnotnull', 'empty', 'isnotempty', 'nullorempty'], filExpObj.matchMode) === -1) && filExpObj.value === '')) {
                                isRequiredFieldAbsent = true;
                                return false;
                            }
                        };
                        LiveVariableUtils.traverseFilterExpressions(filterExpressions, traverseCallbackFn);
                        return isRequiredFieldAbsent ? !isRequiredFieldAbsent : filterExpressions;
                    };
                    /**
                     *
                     * @param variable
                     * @param options
                     * @returns {function(*=): *} returns a function which should be called for the where clause.
                     * This return function can take a function as argument. This argument function can modify the filter fields
                     * before generating where clause.
                     */
                    LiveVariableUtils.getWhereClauseGenerator = function (variable, options, updatedFilterFields) {
                        return function (modifier, skipEncode) {
                            var clonedFields = LiveVariableUtils.getFilterExprFields((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getClonedObject)(updatedFilterFields || variable.filterExpressions));
                            // this flag skips the encoding of the query
                            if ((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isDefined)(skipEncode)) {
                                options.skipEncode = skipEncode;
                            }
                            if (modifier) {
                                // handling the scenario where variable can also have filterFields
                                if (options.filterFields) {
                                    modifier(clonedFields, options);
                                }
                                else {
                                    modifier(clonedFields);
                                }
                            }
                            return LiveVariableUtils.prepareTableOptions(variable, options, clonedFields).query;
                        };
                    };
                    return LiveVariableUtils;
                }());
                /***/ 
            }),
            /***/ "./src/util/variable/pagination.utils.ts": 
            /*!***********************************************!*\
              !*** ./src/util/variable/pagination.utils.ts ***!
              \***********************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "PaginationUtils": function () { return ( /* binding */PaginationUtils); }
                    /* harmony export */ 
                });
                /* harmony import */ var _metrichor_jmespath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @metrichor/jmespath */ "./node_modules/@metrichor/jmespath/dist/jmespath.esm.js");
                /* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
                /* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
                // declare const _: any;
                var PaginationUtils = /** @class */ (function () {
                    function PaginationUtils() {
                    }
                    /**
                     * Modifies the query values with the pagination info which is retrieved from the previous API response.
                     * @param variable withholds variable information
                     * @param operationInfo has metadata of the variable
                     * @param paginationInfo has metadata of the variable pagination data
                     * @returns {void} This method does not return anything
                     */
                    PaginationUtils.setPaginationQueryParams = function (variable, operationInfo, paginationInfo) {
                        operationInfo.parameters.forEach(function (element) {
                            // pagination input information varies based on the type
                            var inputParam;
                            if (paginationInfo.type === 'offset' || paginationInfo.input.offset) {
                                inputParam = 'offset';
                            }
                            else {
                                inputParam = 'page';
                            }
                            // modifies query values based on the pagination of variable
                            // compare parameter name with the input parameter's starting naming key (ex: channelcontext in channelcontext.pagination)
                            if (element.name === paginationInfo.input[inputParam].split('.')[0]) {
                                element.sampleValue = variable.pagination['page'];
                            }
                            else if (element.name === paginationInfo.input.size.split('.')[0]) {
                                element.sampleValue = variable.pagination['size'];
                            }
                        });
                    };
                    /**
                     * Sets pagination on the variable based on the response of the triggered api call.
                     * @param variable withholds variable information
                     * @param response has data of the api call's response
                     * @param options has info of the api's query params
                     * @returns {void} This method does not return anything
                     */
                    PaginationUtils.setVariablePagination = function (variable, response, options) {
                        if (!variable.pagination) {
                            variable.pagination = {
                                empty: false
                            };
                        }
                        variable.pagination['size'] = response.size;
                        variable.pagination['page'] = response.page || 0;
                        variable.pagination['totalElements'] = response.totalElements;
                        variable.pagination['numberOfElements'] = variable.pagination['size'];
                        variable.pagination['number'] = options['page'] ? options['page'] - 1 : 0;
                        /**
                         * Deduce totalPages from totalElements by size.
                         * If the total elements are evenly split among the pages, assign the same to totalPages
                         * Else assign totalPages + 1
                         */
                        variable.pagination['totalPages'] = variable.pagination['totalElements'] / variable.pagination['size'];
                        if (variable.pagination['totalElements'] % variable.pagination['size'] === 0) {
                            variable.pagination['totalPages'] = parseInt(variable.pagination['totalPages']);
                        }
                        else {
                            variable.pagination['totalPages'] = parseInt(variable.pagination['totalPages']) + 1;
                        }
                        // If pagination type is cursor, fill next & prev
                        if (response.next) {
                            variable.pagination['next'] = response.next;
                            variable.pagination['prev'] = response.prev;
                            variable.pagination['last'] = response.next ? false : true;
                            variable.pagination['first'] = response.prev ? false : true;
                        }
                        else {
                            variable.pagination['first'] = variable.pagination['page'] <= 1 ? true : false;
                            // calculate last based on current page index against total pages
                            variable.pagination['last'] = response.hasMoreItems === '' ? !(variable.pagination['page'] < variable.pagination['totalPages']) : !response.hasMoreItems;
                        }
                    };
                    /**
                     * Resolves the expression given in pagination metadata's output
                     * @param item has value of each key which is inside output pagination metadata
                     * @param response has data of the api call's response
                     * @param resHeaders has data of the api call's response headers
                     * @param res holds the information of pagination which has to be stored on the variable
                     * @param key has key name against which data has to be stored in pagination
                     * @returns {void} This method does not return anything
                     */
                    PaginationUtils.setPaginationItems = function (item, response, res, key, resHeaders) {
                        var _a;
                        // if the item has body, resolve the expression against the response
                        if (lodash__WEBPACK_IMPORTED_MODULE_1___default().startsWith(item, '$body')) {
                            var bodyKey = item.replace('$body.', '');
                            try {
                                res[key] = _metrichor_jmespath__WEBPACK_IMPORTED_MODULE_0__.jmespath.search(response, bodyKey);
                            }
                            catch (_b) {
                                console.warn(item + " expression needs to be corrected as per JMES guidelines");
                            }
                        }
                        else if (lodash__WEBPACK_IMPORTED_MODULE_1___default().startsWith(item, '$header')) { // if the item has header, resolve the expression against the response headers 
                            var headerKey = item.replace('$header.', '');
                            var headers = Object.fromEntries(resHeaders.headers);
                            var headerParams = headerKey.split('.');
                            try {
                                res[key] = _metrichor_jmespath__WEBPACK_IMPORTED_MODULE_0__.jmespath.search(headers, headerParams[0].toLowerCase());
                            }
                            catch (_c) {
                                console.warn(item + " expression needs to be corrected as per JMES guidelines");
                            }
                            if ((_a = res[key]) === null || _a === void 0 ? void 0 : _a.length) {
                                var headerVal = res[key].join();
                                if (headerParams.length === 1) {
                                    /**
                                     * If the headerParams has only 1 key (which is not an object) name assing headerVal to the res[key]
                                     */
                                    res[key] = headerVal;
                                }
                                else {
                                    /**
                                     * If the headerParams has more than 1 key (an object), parse the stringified headerVal which is an object
                                     * Resolve the expression against headerVal object amd assign it to res[key]
                                     */
                                    var keyName = headerParams.slice(1).join('.');
                                    var headerResp = JSON.parse(headerVal);
                                    var specialChar = /[!@#$%^&*()+\=\[\]{};':"\\|,<>\/?]+/;
                                    if (specialChar.test(keyName)) {
                                        // If key name has expression (ex: comparission expression) 
                                        // add root key name to keyName for JMES to resolve the expression
                                        keyName = 'headerResp.' + keyName;
                                    }
                                    try {
                                        res[key] = _metrichor_jmespath__WEBPACK_IMPORTED_MODULE_0__.jmespath.search(headerResp, keyName);
                                    }
                                    catch (_d) {
                                        console.warn(item + " expression needs to be corrected as per JMES guidelines");
                                    }
                                }
                            }
                        }
                    };
                    /**
                     * Return the pagination information of the service based on its existence on swagger or on the variable
                     * @param variable withholds variable information
                     * @param operationInfo has metadata of the variable
                     * @returns {object} This method return pagination metadata
                     */
                    PaginationUtils.getPaginationInfo = function (operationInfo, variable) {
                        if (operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.paginationInfo) {
                            return operationInfo.paginationInfo;
                        }
                        else {
                            return variable._paginationConfig;
                        }
                    };
                    /**
                     * Set query params with the pagination info, if pagination metadata is present in query params
                     * @param variable withholds variable information
                     * @param operationInfo has metadata of the variable
                     * @param options has info of the api's query params
                     * @returns {void} This method does not return anything
                     */
                    PaginationUtils.checkPaginationAtQuery = function (operationInfo, variable, options) {
                        var _a;
                        var paginationInfo = this.getPaginationInfo(operationInfo, variable);
                        // If page is not first, pagination is present on the variable and paginationInfo's input meta has size set pagination in query params
                        var hasPagination = options && options['page'] && (paginationInfo === null || paginationInfo === void 0 ? void 0 : paginationInfo.input.size) && variable.pagination;
                        if (!hasPagination) {
                            return;
                        }
                        var inputParam;
                        // if pagination type is offset, asssign inputParam to offset else page
                        if (paginationInfo.type === 'offset' || paginationInfo.input.offset) {
                            inputParam = 'offset';
                        }
                        else {
                            inputParam = 'page';
                        }
                        var paramName = paginationInfo.input[inputParam].split('.')[0];
                        var paramObj = lodash__WEBPACK_IMPORTED_MODULE_1___default().find(operationInfo.parameters, function (obj) { return obj.name === paramName; });
                        // check if the variable has query params and they are not empty
                        if (!lodash__WEBPACK_IMPORTED_MODULE_1___default().isEmpty(variable.dataBinding) && paramObj && paramObj.parameterType === 'query') {
                            /**
                             * For pagination type other than offset, assign page which is recieved from options
                             * For offset type, calculate page from size and options[page]
                             */
                            if (!((_a = paginationInfo.output) === null || _a === void 0 ? void 0 : _a.page) && paginationInfo.type !== 'offset') {
                                variable.pagination['page'] = options['page'];
                            }
                            else {
                                variable.pagination['page'] = this.getOffsetInfo(variable, options);
                            }
                            this.setPaginationQueryParams(variable, operationInfo, paginationInfo);
                        }
                    };
                    /**
                     * Deduces the offset information from the size and page params
                     * @param variable withholds variable information
                     * @param options has info of the api's query params
                     * @returns {object} Returns the next offset number
                     */
                    PaginationUtils.getOffsetInfo = function (variable, options) {
                        return variable.pagination['size'] * (options['page'] ? (options['page'] - 1) : 1);
                    };
                    /**
                     * Sets Pagination data on the request information
                     * @param variable withholds variable information
                     * @param operationInfo has metadata of the variable
                     * @param options has info of the api's query params
                     * @param paginationInfo has pagination information of the variable
                     * @param headers has request headers
                     * @param requestBody has request body
                     * @param url has request url
                     * @returns {object} Returns the request object which has pagination info
                     */
                    PaginationUtils.setPaginationAtReq = function (paginationInfo, operationInfo, variable, headers, requestBody, url, options) {
                        var reqObj = {};
                        var inputParam;
                        var resObj = {};
                        // pagination input information varies based on the type
                        if (paginationInfo.type === 'offset' || paginationInfo.input.offset) {
                            inputParam = 'offset';
                        }
                        else {
                            inputParam = 'page';
                        }
                        var paramName = paginationInfo.input[inputParam].split('.')[0];
                        // check if paramName is present in parameters of operation info 
                        var paramObj = lodash__WEBPACK_IMPORTED_MODULE_1___default().find(operationInfo.parameters, function (obj) { return obj.name === paramName; });
                        // set page/offset and size from pagination if matched parameter's type is header  
                        if ((paramObj === null || paramObj === void 0 ? void 0 : paramObj.parameterType) === 'header') {
                            lodash__WEBPACK_IMPORTED_MODULE_1___default().set(reqObj, paginationInfo.input[inputParam], variable.pagination['page']);
                            lodash__WEBPACK_IMPORTED_MODULE_1___default().set(reqObj, paginationInfo.input.size, variable.pagination['size']);
                            headers[paramName] = JSON.stringify(reqObj[paramName]);
                            resObj['headers'] = headers;
                        }
                        else if ((paramObj === null || paramObj === void 0 ? void 0 : paramObj.parameterType) === 'body') {
                            // set page/offset and size from pagination if matched parameter's type is body 
                            // assign bodyVal to updated pagination info object
                            var bodyVal = JSON.parse(paramObj.sampleValue);
                            var bodyParam = paginationInfo.input[inputParam].split('.')[1];
                            if (bodyVal && bodyVal[bodyParam]) {
                                var inputBodyParam = paginationInfo.input[inputParam].split('.').splice(1).join('.');
                                if (inputParam !== 'offset') {
                                    lodash__WEBPACK_IMPORTED_MODULE_1___default().set(reqObj, inputBodyParam, variable.pagination['page']);
                                }
                                else {
                                    lodash__WEBPACK_IMPORTED_MODULE_1___default().set(reqObj, inputBodyParam, this.getOffsetInfo(variable, options));
                                }
                                lodash__WEBPACK_IMPORTED_MODULE_1___default().set(reqObj, paginationInfo.input.size.split('.').splice(1).join('.'), variable.pagination['size']);
                                bodyVal[bodyParam] = reqObj[bodyParam];
                                requestBody = JSON.stringify(bodyVal);
                                resObj['requestBody'] = requestBody;
                            }
                        }
                        else if (variable.pagination.next && paramObj) {
                            /**
                             * For cursor type pagination, if pagination info is present in the path
                             * Based on whether user clicks on the next or prev button modify the url
                             */
                            if (paramObj.parameterType === 'path') {
                                var urlParams = operationInfo.relativePath.split('/'), paramConfig = '{' + paramObj.name + '}', paramIndex = urlParams.indexOf(paramConfig);
                                var invokeUrl = void 0;
                                if (variable.pagination.isNext) {
                                    invokeUrl = variable.pagination.next.split('/');
                                }
                                else {
                                    invokeUrl = variable.pagination.prev.split('/');
                                }
                                var urlPathParmas = void 0;
                                var urlPath = void 0;
                                if (operationInfo.directPath) { // For direct path, as url has hostname, derivate pathname using URL object
                                    urlPath = new URL(url);
                                    urlPathParmas = urlPath.pathname.split('/');
                                    urlPathParmas[paramIndex] = invokeUrl[paramIndex];
                                    urlPath.pathname = urlPathParmas.join('/');
                                    url = urlPath.href;
                                    resObj['url'] = url;
                                }
                                else { // Else modify the url with index as +1 (following proxy pattern)
                                    urlPathParmas = url.split('/');
                                    urlPathParmas[paramIndex + 1] = invokeUrl[paramIndex];
                                    url = urlPathParmas.join('/');
                                    resObj['url'] = url;
                                }
                            }
                            else if (paramObj.parameterType === 'query') {
                                /**
                                 * For cursor type pagination, if pagination info is present in the query
                                 * Based on whether user clicks on the next or prev button modify the url's query params
                                 */
                                var urlParams = url.split('?');
                                var invokeUrl = void 0;
                                if (variable.pagination.isNext) {
                                    invokeUrl = variable.pagination.next.split('?');
                                }
                                else {
                                    invokeUrl = variable.pagination.prev.split('?');
                                }
                                urlParams[1] = invokeUrl[1];
                                url = urlParams.join('?');
                                resObj['url'] = url;
                            }
                        }
                        return resObj;
                    };
                    /**
                     * Sets the pagination info recieved from api's response in the res object
                     * @param operationInfo has metadata of the variable
                     * @param res holds the information of pagination which has to be stored on the variable
                     * @param paramName has key name against which data has to be stored in pagination
                     * @param variable withholds variable information
                     * @returns {void} This method does not return anything
                     */
                    PaginationUtils.setParameterVal = function (paramName, res, operationInfo, variable) {
                        var paginationInfo = this.getPaginationInfo(operationInfo, variable);
                        var param = paginationInfo.input[paramName].split('.')[0];
                        var sizeObj = lodash__WEBPACK_IMPORTED_MODULE_1___default().find(operationInfo.parameters, function (obj) { return obj.name === param; });
                        res[paramName] = lodash__WEBPACK_IMPORTED_MODULE_1___default().result(sizeObj, 'sampleValue');
                    };
                    /**
                     * Creates res object from the response recieved from the api triggered
                     * @param variable withholds variable information
                     * @param operationInfo has metadata of the variable
                     * @param paginationInfo has metadata of the variable's pagination
                     * @param response has data of the api call's response
                     * @param options has info of the api's query params
                     * @param resHeaders has data of the api call's response headers
                     * @returns {object} An object which holds the information of pagination which has to be stored on the variable
                     */
                    PaginationUtils.generatePaginationRes = function (operationInfo, paginationInfo, response, resHeaders, options, variable) {
                        var res = {};
                        var resOutput = paginationInfo.output;
                        // If pagination type is not cursor, create the following metadata 
                        if (!(resOutput === null || resOutput === void 0 ? void 0 : resOutput.next)) {
                            /**
                             * If size is present in the pagination's output metadata deduce size from api's response
                             * Else deduce size from the pagination's input metadata size key
                             */
                            if (resOutput === null || resOutput === void 0 ? void 0 : resOutput.size) {
                                this.setPaginationItems(resOutput.size, response, res, 'size', resHeaders);
                            }
                            else {
                                this.setParameterVal('size', res, operationInfo, variable);
                            }
                            /**
                             * If page is present in the pagination's output metadata deduce page from api's response
                             * Else deduce page from the pagination's input metadata page key
                             */
                            if (resOutput === null || resOutput === void 0 ? void 0 : resOutput.page) {
                                this.setPaginationItems(resOutput.page, response, res, 'page', resHeaders);
                            }
                            else if (paginationInfo.type !== 'offset') {
                                this.setParameterVal('page', res, operationInfo, variable);
                            }
                            /**
                             * If totalElements has $minValue in it, set totalElements as $minValue
                             * If the rendered elements are greater than $minValue, set totalElements as Number of elements rendered + 1
                             
                                * If totalElements is present in the pagination's output metadata deduce totalElements from api's response
                                
                                * If Pagination type is offset, deduce totalElements from size and options[page] else deduce from size and res[page]
                                */
                            if (lodash__WEBPACK_IMPORTED_MODULE_1___default().startsWith(resOutput === null || resOutput === void 0 ? void 0 : resOutput.totalElements, '$minValue')) {
                                var totalEl = resOutput.totalElements.replace('$minValue=', '');
                                var pageParam = res['page'] ? res['page'] : options['page'];
                                var elRendered = res['size'] * pageParam;
                                if (!variable.pagination || variable.pagination['totalElements'] > elRendered) {
                                    res['totalElements'] = parseInt(totalEl);
                                }
                                else {
                                    res['totalElements'] = elRendered + 1;
                                }
                            }
                            else if (resOutput === null || resOutput === void 0 ? void 0 : resOutput.totalElements) {
                                this.setPaginationItems(resOutput.totalElements, response, res, 'totalElements', resHeaders);
                            }
                            else {
                                if (paginationInfo.type === 'offset' || paginationInfo.input.offset) {
                                    res['totalElements'] = (res['size'] * (options['page'] ? options['page'] : 1)) + 1;
                                }
                                else {
                                    res['totalElements'] = (res['size'] * res['page']) + 1;
                                }
                            }
                            /**
                             * If hasMoreItems is present in the pagination's output metadata deduce hasMoreItems from api's response
                             * Else assign it as empty which will be calculated at pagination object generation
                             */
                            if (resOutput === null || resOutput === void 0 ? void 0 : resOutput.hasMoreItems) {
                                this.setPaginationItems(resOutput.hasMoreItems, response, res, 'hasMoreItems', resHeaders);
                            }
                            else {
                                res['hasMoreItems'] = '';
                            }
                        }
                        else if (resOutput) { // For cursor type pagination set next and prev keys in res object
                            this.setPaginationItems(resOutput.next, response, res, 'next', resHeaders);
                            this.setPaginationItems(resOutput.prev, response, res, 'prev', resHeaders);
                        }
                        return res;
                    };
                    return PaginationUtils;
                }());
                /***/ 
            }),
            /***/ "./src/util/variable/service-variable.utils.ts": 
            /*!*****************************************************!*\
              !*** ./src/util/variable/service-variable.utils.ts ***!
              \*****************************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "ServiceVariableUtils": function () { return ( /* binding */ServiceVariableUtils); }
                    /* harmony export */ 
                });
                /* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/utils */ "./src/util/utils.ts");
                /* harmony import */ var _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants/variables.constants */ "./src/constants/variables.constants.ts");
                /* harmony import */ var _variables_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./variables.utils */ "./src/util/variable/variables.utils.ts");
                /* harmony import */ var _oAuth_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./../oAuth.utils */ "./src/util/oAuth.utils.ts");
                /* harmony import */ var _util_variable_pagination_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/variable/pagination.utils */ "./src/util/variable/pagination.utils.ts");
                /* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
                /* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/ __webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_5__);
                // declare const _: any;
                /**
                 * returns true if a Service variable is:
                 *  - for a query/procedure
                 *  - performs a PUT/POST operation, i.e, takes a Request Body as input
                 * @param variable
                 * @returns {any}
                 */
                var isBodyTypeQueryOrProcedure = function (variable) {
                    return (lodash__WEBPACK_IMPORTED_MODULE_5___default().includes(['QueryExecution', 'ProcedureExecution'], variable.controller)) && (lodash__WEBPACK_IMPORTED_MODULE_5___default().includes(['put', 'post'], variable.operationType));
                };
                /**
                 * returns true if the variable is a Query service variable
                 * @param {string} controller
                 * @param {string} serviceType
                 * @returns {boolean}
                 */
                var isQueryServiceVar = function (controller, serviceType) {
                    return controller === _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.CONTROLLER_TYPE.QUERY && serviceType === _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.SERVICE_TYPE.DATA;
                };
                /**
                 * Append given value to the formdata
                 * @param formData
                 * @param param - Param from which value has to be taken
                 * @param paramValue - Value which is to be appended to formdata
                 */
                var getFormData = function (formData, param, paramValue) {
                    var paramType = lodash__WEBPACK_IMPORTED_MODULE_5___default().toLower((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.extractType)(lodash__WEBPACK_IMPORTED_MODULE_5___default().get(param, 'items.type') || param.type)), paramContentType = _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.isStudioMode ? param['x-WM-CONTENT_TYPE'] : param.contentType;
                    if ((0, _variables_utils__WEBPACK_IMPORTED_MODULE_2__.isFileUploadSupported)()) {
                        if ((paramType !== 'file') && (paramContentType === 'string' || !paramContentType)) {
                            if (lodash__WEBPACK_IMPORTED_MODULE_5___default().isObject(paramValue)) {
                                paramValue = JSON.stringify(paramValue);
                            }
                            formData.append(param.name, paramValue);
                        }
                        else {
                            if (lodash__WEBPACK_IMPORTED_MODULE_5___default().isArray(paramValue) && paramType === 'file') {
                                lodash__WEBPACK_IMPORTED_MODULE_5___default().forEach(paramValue, function (fileObject) {
                                    formData.append(param.name, (fileObject && fileObject.content) || (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getBlob)(fileObject), fileObject.name);
                                });
                            }
                            else {
                                formData.append(param.name, (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.getBlob)(paramValue, paramContentType), paramValue && paramValue.name);
                            }
                        }
                        return formData;
                    }
                };
                /**
                 * Check for missing required params and format the date/time param values
                 * @param inputData
                 * @param params
                 * @returns {{requestBody: {}; missingParams: any[]}}
                 */
                var processRequestBody = function (inputData, params) {
                    var requestBody = {}, missingParams = [];
                    var paramValue;
                    lodash__WEBPACK_IMPORTED_MODULE_5___default().forEach(params, function (param) {
                        paramValue = lodash__WEBPACK_IMPORTED_MODULE_5___default().get(inputData, param.name);
                        if (!lodash__WEBPACK_IMPORTED_MODULE_5___default().isUndefined(paramValue) && paramValue !== '' && paramValue !== null && !param.readOnly) {
                            // ToDo - variable seperation
                            paramValue = (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isDateTimeType)(param.type) ? (0, _variables_utils__WEBPACK_IMPORTED_MODULE_2__.formatDate)(paramValue, param.type) : paramValue;
                            // Construct ',' separated string if param is not array type but value is an array
                            if (lodash__WEBPACK_IMPORTED_MODULE_5___default().isArray(paramValue) && lodash__WEBPACK_IMPORTED_MODULE_5___default().toLower((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.extractType)(param.type)) === 'string') {
                                paramValue = lodash__WEBPACK_IMPORTED_MODULE_5___default().join(paramValue, ',');
                            }
                            requestBody[param.name] = paramValue;
                        }
                        else if (param.required) {
                            missingParams.push(param.name || param.id);
                        }
                    });
                    return {
                        'requestBody': requestBody,
                        'missingParams': missingParams
                    };
                };
                /**
                 * Done only for HTTP calls made via the proxy server
                 * Goes though request headers, appends 'X-' to certain headers
                 * these headers need not be processed at proxy server and should directly be passed to the server
                 * e.g. Authorization, Cookie, etc.
                 * @param headers
                 * @returns {{}}
                 */
                var cloakHeadersForProxy = function (headers) {
                    var _headers = {}, UNCLOAKED_HEADERS = _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.REST_SERVICE.UNCLOAKED_HEADERS, CLOAK_PREFIX = _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.REST_SERVICE.PREFIX.CLOAK_HEADER_KEY;
                    lodash__WEBPACK_IMPORTED_MODULE_5___default().forEach(headers, function (val, key) {
                        if (lodash__WEBPACK_IMPORTED_MODULE_5___default().includes(UNCLOAKED_HEADERS, key.toUpperCase())) {
                            _headers[key] = val;
                        }
                        else {
                            _headers[CLOAK_PREFIX + key] = val;
                        }
                    });
                    return _headers;
                };
                var ServiceVariableUtils = /** @class */ (function () {
                    function ServiceVariableUtils() {
                    }
                    /**
                     * prepares the HTTP request info for a Service Variable
                     * @param variable
                     * @param operationInfo
                     * @param inputFields
                     * @returns {any}
                     */
                    ServiceVariableUtils.constructRequestParams = function (variable, operationInfo, inputFields, options) {
                        variable = variable || {};
                        // operationInfo is specifically null for un_authorized access
                        if (operationInfo === null) {
                            return {
                                'error': {
                                    'type': _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.REST_SERVICE.ERR_TYPE.USER_UNAUTHORISED,
                                    'message': _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.REST_SERVICE.ERR_MSG.USER_UNAUTHORISED,
                                    'field': '_wmServiceOperationInfo'
                                }
                            };
                        }
                        else if (lodash__WEBPACK_IMPORTED_MODULE_5___default().isEmpty(operationInfo)) {
                            return {
                                'error': {
                                    'type': _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.REST_SERVICE.ERR_TYPE.METADATA_MISSING,
                                    'message': _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.REST_SERVICE.ERR_MSG.METADATA_MISSING,
                                    'field': '_wmServiceOperationInfo'
                                }
                            };
                        }
                        else if (operationInfo && operationInfo.invalid) {
                            return {
                                'error': {
                                    'type': _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.REST_SERVICE.ERR_TYPE.CRUD_OPERATION_MISSING,
                                    'message': _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.REST_SERVICE.ERR_MSG.CRUD_OPERATION_MISSING,
                                    'field': '_wmServiceOperationInfo'
                                }
                            };
                        }
                        var directPath = operationInfo.directPath || '', relativePath = operationInfo.basePath ? operationInfo.basePath + operationInfo.relativePath : operationInfo.relativePath, isBodyTypeQueryProcedure = isBodyTypeQueryOrProcedure(variable);
                        var queryParams = '', bodyInfo, headers = {}, requestBody, url, requiredParamMissing = [], target, pathParamRex, invokeParams, authDetails = null, uname, pswd, method, formData, isProxyCall, paramValueInfo, params, securityDefnObj, accessToken, withCredentials;
                        function getFormDataObj() {
                            if (formData) {
                                return formData;
                            }
                            formData = new FormData();
                            return formData;
                        }
                        securityDefnObj = lodash__WEBPACK_IMPORTED_MODULE_5___default().get(operationInfo.securityDefinitions, '0');
                        if (securityDefnObj) {
                            switch (securityDefnObj.type) {
                                case _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.REST_SERVICE.SECURITY_DEFN.OAUTH2:
                                    accessToken = (0, _oAuth_utils__WEBPACK_IMPORTED_MODULE_3__.getAccessToken)(securityDefnObj[_constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.REST_SERVICE.OAUTH_PROVIDER_KEY], null);
                                    if (accessToken) {
                                        headers[_constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.REST_SERVICE.AUTH_HDR_KEY] = _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.REST_SERVICE.PREFIX.AUTH_HDR_VAL.OAUTH + ' ' + accessToken;
                                    }
                                    else {
                                        return {
                                            'error': {
                                                'type': _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.REST_SERVICE.ERR_TYPE.NO_ACCESSTOKEN,
                                                'message': _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.REST_SERVICE.ERR_MSG.NO_ACCESSTOKEN
                                            },
                                            'securityDefnObj': securityDefnObj
                                        };
                                    }
                                    break;
                                case _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.REST_SERVICE.SECURITY_DEFN.BASIC:
                                    uname = inputFields['wm_auth_username'];
                                    pswd = inputFields['wm_auth_password'];
                                    if (uname && pswd) {
                                        // TODO[VIBHU]: bas64 encoding alternative.
                                        headers[_constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.REST_SERVICE.AUTH_HDR_KEY] = _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.REST_SERVICE.PREFIX.AUTH_HDR_VAL.BASIC + ' ' + btoa(uname + ':' + pswd);
                                        authDetails = {
                                            'type': _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.REST_SERVICE.AUTH_TYPE.BASIC
                                        };
                                    }
                                    else {
                                        return {
                                            'error': {
                                                'type': _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.REST_SERVICE.ERR_TYPE.NO_CREDENTIALS,
                                                'message': _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.REST_SERVICE.ERR_MSG.NO_CREDENTIALS
                                            },
                                            'securityDefnObj': securityDefnObj
                                        };
                                    }
                                    break;
                            }
                        }
                        // set query params, if pagination info is present and the info should be present in query
                        _util_variable_pagination_utils__WEBPACK_IMPORTED_MODULE_4__.PaginationUtils.checkPaginationAtQuery(operationInfo, variable, options);
                        operationInfo.proxySettings = operationInfo.proxySettings || { web: true, mobile: false };
                        method = operationInfo.httpMethod || operationInfo.methodType;
                        isProxyCall = (function () {
                            // ToDo - variable seperation
                            // if (CONSTANTS.hasCordova) {
                            return operationInfo.proxySettings.mobile;
                            // }
                            return operationInfo.proxySettings.web;
                        }());
                        withCredentials = operationInfo.proxySettings.withCredentials;
                        url = isProxyCall ? relativePath : directPath;
                        /* loop through all the parameters */
                        lodash__WEBPACK_IMPORTED_MODULE_5___default().forEach(operationInfo.parameters, function (param) {
                            // Set params based on current workspace
                            function setParamsOfChildNode() {
                                if (inputFields) {
                                    // specific case for body type query/procedure variable with query params
                                    if (inputFields[param.name] && lodash__WEBPACK_IMPORTED_MODULE_5___default().isObject(inputFields[param.name])) {
                                        paramValueInfo = inputFields[param.name];
                                    }
                                    else {
                                        paramValueInfo = inputFields;
                                    }
                                    params = lodash__WEBPACK_IMPORTED_MODULE_5___default().get(operationInfo, ['definitions', param.type]);
                                }
                                else {
                                    // For Api Designer
                                    paramValueInfo = paramValue || {};
                                    params = param.children;
                                }
                            }
                            var paramValue = param.sampleValue;
                            if (((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isDefined)(paramValue) && paramValue !== null && paramValue !== '') || (isBodyTypeQueryProcedure && param.type !== 'file')) {
                                // Format dateTime params for dataService variables
                                if (variable.serviceType === _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.SERVICE_TYPE.DATA && (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.isDateTimeType)(param.type)) {
                                    // ToDo - variable seperation
                                    paramValue = (0, _variables_utils__WEBPACK_IMPORTED_MODULE_2__.formatDate)(paramValue, param.type);
                                }
                                // Construct ',' separated string if param is not array type but value is an array
                                if (lodash__WEBPACK_IMPORTED_MODULE_5___default().isArray(paramValue) && lodash__WEBPACK_IMPORTED_MODULE_5___default().toLower((0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.extractType)(param.type)) === 'string' && variable.serviceType === _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.SERVICE_TYPE.DATA) {
                                    paramValue = lodash__WEBPACK_IMPORTED_MODULE_5___default().join(paramValue, ',');
                                }
                                switch (param.parameterType.toUpperCase()) {
                                    case 'QUERY':
                                        // Ignore null valued query params for queryService variable
                                        if (lodash__WEBPACK_IMPORTED_MODULE_5___default().isNull(paramValue) && isQueryServiceVar(variable.controller, variable.serviceType)) {
                                            break;
                                        }
                                        if (!queryParams) {
                                            queryParams = '?' + param.name + '=' + encodeURIComponent(paramValue);
                                        }
                                        else {
                                            queryParams += '&' + param.name + '=' + encodeURIComponent(paramValue);
                                        }
                                        break;
                                    case 'PATH':
                                        /* replacing the path param based on the regular expression in the relative path */
                                        pathParamRex = new RegExp('\\s*\\{\\s*' + param.name + '(:\\.\\+)?\\s*\\}\\s*');
                                        url = url.replace(pathParamRex, paramValue);
                                        break;
                                    case 'HEADER':
                                        headers[param.name] = paramValue;
                                        break;
                                    case 'BODY':
                                        // For post/put query methods wrap the input
                                        if (isBodyTypeQueryProcedure) {
                                            setParamsOfChildNode();
                                            bodyInfo = processRequestBody(paramValueInfo, params);
                                            requestBody = bodyInfo.requestBody;
                                            requiredParamMissing = lodash__WEBPACK_IMPORTED_MODULE_5___default().concat(requiredParamMissing, bodyInfo.missingParams);
                                        }
                                        else {
                                            requestBody = paramValue;
                                        }
                                        break;
                                    case 'FORMDATA':
                                        if (isBodyTypeQueryProcedure && param.name === _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.SWAGGER_CONSTANTS.WM_DATA_JSON) {
                                            setParamsOfChildNode();
                                            // Process query/procedure formData non-file params params
                                            bodyInfo = processRequestBody(paramValueInfo, params);
                                            requestBody = getFormData(getFormDataObj(), param, bodyInfo.requestBody);
                                            requiredParamMissing = lodash__WEBPACK_IMPORTED_MODULE_5___default().concat(requiredParamMissing, bodyInfo.missingParams);
                                        }
                                        else {
                                            requestBody = getFormData(getFormDataObj(), param, paramValue);
                                        }
                                        break;
                                }
                            }
                            else if (param.required) {
                                requiredParamMissing.push(param.name || param.id);
                            }
                        });
                        // if required param not found, return error
                        if (requiredParamMissing.length) {
                            return {
                                'error': {
                                    'type': _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.REST_SERVICE.ERR_TYPE.REQUIRED_FIELD_MISSING,
                                    'field': requiredParamMissing.join(','),
                                    'message': (0, _util_utils__WEBPACK_IMPORTED_MODULE_0__.replace)(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.REST_SERVICE.ERR_MSG.REQUIRED_FIELD_MISSING, [requiredParamMissing.join(',')]),
                                    'skipDefaultNotification': true
                                }
                            };
                        }
                        // Setting appropriate content-Type for request accepting request body like POST, PUT, etc
                        if (!lodash__WEBPACK_IMPORTED_MODULE_5___default().includes(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.WS_CONSTANTS.NON_BODY_HTTP_METHODS, lodash__WEBPACK_IMPORTED_MODULE_5___default().toUpper(method))) {
                            /*Based on the formData browser will automatically set the content type to 'multipart/form-data' and webkit boundary*/
                            if (!(operationInfo.consumes && (operationInfo.consumes[0] === _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.WS_CONSTANTS.CONTENT_TYPES.MULTIPART_FORMDATA))) {
                                headers['Content-Type'] = (operationInfo.consumes && operationInfo.consumes[0]) || 'application/json';
                            }
                        }
                        // if the consumes has application/x-www-form-urlencoded and
                        // if the http request of given method type can have body send the queryParams as Form Data
                        if (lodash__WEBPACK_IMPORTED_MODULE_5___default().includes(operationInfo.consumes, _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.WS_CONSTANTS.CONTENT_TYPES.FORM_URL_ENCODED)
                            && !lodash__WEBPACK_IMPORTED_MODULE_5___default().includes(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.WS_CONSTANTS.NON_BODY_HTTP_METHODS, (method || '').toUpperCase())) {
                            // remove the '?' at the start of the queryParams
                            if (queryParams) {
                                requestBody = (requestBody ? requestBody + '&' : '') + queryParams.substring(1);
                            }
                            headers['Content-Type'] = _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.WS_CONSTANTS.CONTENT_TYPES.FORM_URL_ENCODED;
                        }
                        else {
                            url += queryParams;
                        }
                        /*
                         * for proxy calls:
                         *  - cloak the proper headers (required only for REST services)
                         *  - prepare complete url from relativeUrl
                         */
                        if (isProxyCall) {
                            // avoiding cloakHeadersForProxy when the method is invoked from apidesigner.
                            headers = (variable.serviceType !== _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.SERVICE_TYPE.REST && variable.serviceType !== _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.SERVICE_TYPE.OPENAPI) || operationInfo.skipCloakHeaders ? headers : cloakHeadersForProxy(headers);
                            if (variable.getPrefabName() && _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.REST_SUPPORTED_SERVICES.indexOf(variable.serviceType) !== -1) {
                                /* if it is a prefab variable (used in a normal project), modify the url */
                                url = 'prefabs/' + variable.getPrefabName() + url;
                                target = 'invokePrefabRestService';
                            }
                            else if (!variable.getPrefabName()) {
                                url = 'services' + url;
                            }
                            url = _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.$rootScope.project.deployedUrl + url;
                        }
                        // If pagination info exists, process info in request headers or body based on the metadata
                        var paginationInfo = _util_variable_pagination_utils__WEBPACK_IMPORTED_MODULE_4__.PaginationUtils.getPaginationInfo(operationInfo, variable);
                        if (paginationInfo && variable.pagination) {
                            var resp = _util_variable_pagination_utils__WEBPACK_IMPORTED_MODULE_4__.PaginationUtils.setPaginationAtReq(paginationInfo, operationInfo, variable, headers, requestBody, url, options);
                            if (resp) {
                                if (resp['headers']) {
                                    headers = resp['headers'];
                                }
                                else if (resp['requestBody']) {
                                    requestBody = resp['requestBody'];
                                }
                                else if (resp['url']) {
                                    url = resp['url'];
                                }
                            }
                        }
                        /*creating the params needed to invoke the service. url is generated from the relative path for the operation*/
                        invokeParams = {
                            'projectID': _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.$rootScope.project.id,
                            'url': url,
                            'target': target,
                            'method': method,
                            'headers': headers,
                            'data': requestBody,
                            'authDetails': authDetails,
                            'isDirectCall': !isProxyCall,
                            'isExtURL': variable.serviceType === _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.SERVICE_TYPE.REST,
                            'withCredentials': withCredentials
                        };
                        return invokeParams;
                    };
                    ServiceVariableUtils.isFileUploadRequest = function (variable) {
                        // temporary fix, have to find proper solution for deciding weather to upload file through variable
                        return variable.service === 'FileService' && variable.operation === 'uploadFile';
                    };
                    /**
                     * This method returns array of query param names for variable other then page,size,sort
                     * @params {params} params of the variable
                     */
                    ServiceVariableUtils.excludePaginationParams = function (params) {
                        return lodash__WEBPACK_IMPORTED_MODULE_5___default().map(lodash__WEBPACK_IMPORTED_MODULE_5___default().reject(params, function (param) {
                            return lodash__WEBPACK_IMPORTED_MODULE_5___default().includes(_constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.PAGINATION_PARAMS, param.name);
                        }), function (param) {
                            return param.name;
                        });
                    };
                    return ServiceVariableUtils;
                }());
                /***/ 
            }),
            /***/ "./src/util/variable/variables.utils.ts": 
            /*!**********************************************!*\
              !*** ./src/util/variable/variables.utils.ts ***!
              \**********************************************/
            /***/ (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */ "appManager": function () { return ( /* binding */appManager); },
                    /* harmony export */ "debounceVariableCall": function () { return ( /* binding */debounceVariableCall); },
                    /* harmony export */ "decodeData": function () { return ( /* binding */decodeData); },
                    /* harmony export */ "dialogService": function () { return ( /* binding */dialogService); },
                    /* harmony export */ "formatDate": function () { return ( /* binding */formatDate); },
                    /* harmony export */ "formatExportExpression": function () { return ( /* binding */formatExportExpression); },
                    /* harmony export */ "getBlob": function () { return ( /* binding */getBlob); },
                    /* harmony export */ "getErrMessage": function () { return ( /* binding */getErrMessage); },
                    /* harmony export */ "getEvaluatedOrderBy": function () { return ( /* binding */getEvaluatedOrderBy); },
                    /* harmony export */ "getTarget": function () { return ( /* binding */getTarget); },
                    /* harmony export */ "getTargetNodeKey": function () { return ( /* binding */getTargetNodeKey); },
                    /* harmony export */ "getTargetObj": function () { return ( /* binding */getTargetObj); },
                    /* harmony export */ "httpService": function () { return ( /* binding */httpService); },
                    /* harmony export */ "initiateCallback": function () { return ( /* binding */initiateCallback); },
                    /* harmony export */ "internalBoundNodeMap": function () { return ( /* binding */internalBoundNodeMap); },
                    /* harmony export */ "isFileUploadSupported": function () { return ( /* binding */isFileUploadSupported); },
                    /* harmony export */ "metadataService": function () { return ( /* binding */metadataService); },
                    /* harmony export */ "navigationService": function () { return ( /* binding */navigationService); },
                    /* harmony export */ "oauthService": function () { return ( /* binding */oauthService); },
                    /* harmony export */ "routerService": function () { return ( /* binding */routerService); },
                    /* harmony export */ "securityService": function () { return ( /* binding */securityService); },
                    /* harmony export */ "setInput": function () { return ( /* binding */setInput); },
                    /* harmony export */ "setValueToNode": function () { return ( /* binding */setValueToNode); },
                    /* harmony export */ "toasterService": function () { return ( /* binding */toasterService); },
                    /* harmony export */ "updateInternalNodes": function () { return ( /* binding */updateInternalNodes); },
                    /* harmony export */ "wmSetDependency": function () { return ( /* binding */wmSetDependency); }
                    /* harmony export */ 
                });
                /* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./src/util/utils.ts");
                /* harmony import */ var _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../constants/variables.constants */ "./src/constants/variables.constants.ts");
                /* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
                /* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_2__);
                /* harmony import */ var he__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! he */ "./node_modules/he/he.js");
                /* harmony import */ var he__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __webpack_require__.n(he__WEBPACK_IMPORTED_MODULE_3__);
                var appManager;
                var httpService;
                var metadataService;
                var navigationService;
                var routerService;
                var toasterService;
                var oauthService;
                var securityService;
                var dialogService;
                var internalBoundNodeMap = new Map();
                var timers = new Map();
                var DOT_EXPR_REX = /^\[("|')[\w\W]*(\1)\]$/;
                var _invoke = function (variable, op) {
                    var debouncedFn, cancelFn = (lodash__WEBPACK_IMPORTED_MODULE_2___default().noop), retVal;
                    if (timers.has(variable)) {
                        cancelFn = timers.get(variable).cancel;
                    }
                    cancelFn();
                    debouncedFn = lodash__WEBPACK_IMPORTED_MODULE_2___default().debounce(function () {
                        retVal = variable[op]();
                        // handle promises to avoid uncaught promise errors in console
                        if (retVal instanceof Promise) {
                            retVal.catch((lodash__WEBPACK_IMPORTED_MODULE_2___default().noop));
                        }
                    }, 100);
                    timers.set(variable, debouncedFn);
                    debouncedFn();
                };
                var wmSetDependency = function (type, ref) {
                    switch (type) {
                        case 'appManager':
                            appManager = ref;
                            break;
                        case 'http':
                            httpService = ref;
                            break;
                        case 'metadata':
                            metadataService = ref;
                            break;
                        case 'navigationService':
                            navigationService = ref;
                            break;
                        case 'router':
                            routerService = ref;
                            break;
                        case 'toaster':
                            toasterService = ref;
                            break;
                        case 'oAuth':
                            oauthService = ref;
                            break;
                        case 'security':
                            securityService = ref;
                            break;
                        case 'dialog':
                            dialogService = ref;
                            break;
                    }
                };
                var debounceVariableCall = _invoke;
                /**
                 * returns true if HTML5 File API is available else false
                 * @returns {{prototype: Blob; new(blobParts?: any[], options?: BlobPropertyBag): Blob}}
                 */
                var isFileUploadSupported = function () {
                    // ToDo - variable seperation
                    return (window.File && window.FileReader && window.FileList && window.Blob);
                };
                /**
                 * formatting the expression as required by backend which was enclosed by ${<expression>}.
                 * @param fieldDefs
                 * returns fieldDefs
                 */
                var formatExportExpression = function (fieldDefs) {
                    lodash__WEBPACK_IMPORTED_MODULE_2___default().forEach(fieldDefs, function (fieldDef) {
                        if (fieldDef.expression) {
                            fieldDef.expression = '${' + fieldDef.expression + '}';
                        }
                    });
                    return fieldDefs;
                };
                /**
                 * prepare a blob object based on the content and content type provided
                 * if content is blob itself, simply returns it back
                 * @param val
                 * @param valContentType
                 * @returns {*}
                 */
                var getBlob = function (val, valContentType) {
                    if (val instanceof Blob) {
                        return val;
                    }
                    var jsonVal = (0, _utils__WEBPACK_IMPORTED_MODULE_0__.getValidJSON)(val);
                    if (jsonVal && jsonVal instanceof Object) {
                        val = new Blob([JSON.stringify(jsonVal)], { type: valContentType || 'application/json' });
                    }
                    else {
                        val = new Blob([val], { type: valContentType || 'text/plain' });
                    }
                    return val;
                };
                /**
                 * sets the value against passed key on the "inputFields" object in the variable
                 * @param targetObj: the object in which the key, value is to be set
                 * @param variable
                 * @param key: can be:
                 *  - a string e.g. "username"
                 *  - an object, e.g. {"username": "john", "ssn": "11111"}
                 * @param val
                 * - if key is string, the value against it (for that data type)
                 * - if key is object, not required
                 * @param options
                 * @returns {any}
                 */
                var setInput = function (targetObj, key, val, options) {
                    targetObj = targetObj || {};
                    var keys, lastKey, paramObj = {};
                    // content type check
                    if (lodash__WEBPACK_IMPORTED_MODULE_2___default().isObject(options)) {
                        switch (options.type) {
                            case 'file':
                                val = getBlob(val, options.contentType);
                                break;
                            case 'number':
                                val = lodash__WEBPACK_IMPORTED_MODULE_2___default().isNumber(val) ? val : parseInt(val, 10);
                                break;
                        }
                    }
                    if (lodash__WEBPACK_IMPORTED_MODULE_2___default().isObject(key)) {
                        // check if the passed parameter is an object itself
                        paramObj = key;
                    }
                    else if (key.indexOf('.') > -1) {
                        // check for '.' in key e.g. 'employee.department'
                        keys = key.split('.');
                        lastKey = keys.pop();
                        // Finding the object based on the key
                        targetObj = (0, _utils__WEBPACK_IMPORTED_MODULE_0__.findValueOf)(targetObj, keys.join('.'), true);
                        key = lastKey;
                        paramObj[key] = val;
                    }
                    else {
                        paramObj[key] = val;
                    }
                    lodash__WEBPACK_IMPORTED_MODULE_2___default().forEach(paramObj, function (paramVal, paramKey) {
                        targetObj[paramKey] = paramVal;
                    });
                    return targetObj;
                };
                /**
                 * This method decodes the variable data which is encoded from backend before showing in the widgets.
                 * It takes variable response content as input and iterates recursively,
                 * if the value is string type then it will decode the data.
                 * @param responseContent (Array of objects)
                 */
                var decodeData = function (responseContent) {
                    if (!responseContent) {
                        return responseContent;
                    }
                    if (lodash__WEBPACK_IMPORTED_MODULE_2___default().isArray(responseContent)) {
                        lodash__WEBPACK_IMPORTED_MODULE_2___default().forEach(responseContent, function (data) {
                            if (lodash__WEBPACK_IMPORTED_MODULE_2___default().isString(data)) {
                                data = htmlDecode(data);
                            }
                            else if (lodash__WEBPACK_IMPORTED_MODULE_2___default().isObject(data)) {
                                lodash__WEBPACK_IMPORTED_MODULE_2___default().forEach(data, function (value, key) {
                                    if (value && lodash__WEBPACK_IMPORTED_MODULE_2___default().isString(value)) {
                                        data[key] = htmlDecode(value);
                                    }
                                    else if (lodash__WEBPACK_IMPORTED_MODULE_2___default().isObject(value)) {
                                        decodeData(value);
                                    }
                                });
                            }
                        });
                    }
                    else if (lodash__WEBPACK_IMPORTED_MODULE_2___default().isObject(responseContent)) {
                        lodash__WEBPACK_IMPORTED_MODULE_2___default().forEach(responseContent, function (value, key) {
                            if (value && lodash__WEBPACK_IMPORTED_MODULE_2___default().isString(value)) {
                                responseContent[key] = htmlDecode(value);
                            }
                            else if (lodash__WEBPACK_IMPORTED_MODULE_2___default().isObject(value)) {
                                decodeData(value);
                            }
                        });
                    }
                    else if (lodash__WEBPACK_IMPORTED_MODULE_2___default().isString(responseContent)) {
                        responseContent = htmlDecode(responseContent);
                        return responseContent;
                    }
                };
                function htmlDecode(input) {
                    return he__WEBPACK_IMPORTED_MODULE_3___default().unescape(input);
                }
                /**
                 *
                 * @param varOrder
                 * @param optionsOrder
                 * @returns {any}
                 */
                var getEvaluatedOrderBy = function (varOrder, optionsOrder) {
                    var optionFields, varOrderBy;
                    // If options order by is not defined, return variable order
                    if (!optionsOrder || lodash__WEBPACK_IMPORTED_MODULE_2___default().isEmpty(optionsOrder)) {
                        return varOrder;
                    }
                    // If variable order by is not defined, return options order
                    if (!varOrder) {
                        return optionsOrder;
                    }
                    // If both are present, combine the options order and variable order, with options order as precedence
                    varOrder = lodash__WEBPACK_IMPORTED_MODULE_2___default().split(varOrder, ',');
                    optionsOrder = lodash__WEBPACK_IMPORTED_MODULE_2___default().split(optionsOrder, ',');
                    optionFields = lodash__WEBPACK_IMPORTED_MODULE_2___default().map(optionsOrder, function (order) {
                        return lodash__WEBPACK_IMPORTED_MODULE_2___default().split(lodash__WEBPACK_IMPORTED_MODULE_2___default().trim(order), ' ')[0];
                    });
                    // If a field is present in both options and variable, remove the variable orderby
                    lodash__WEBPACK_IMPORTED_MODULE_2___default().remove(varOrder, function (orderBy) {
                        return lodash__WEBPACK_IMPORTED_MODULE_2___default().includes(optionFields, lodash__WEBPACK_IMPORTED_MODULE_2___default().split(lodash__WEBPACK_IMPORTED_MODULE_2___default().trim(orderBy), ' ')[0]);
                    });
                    varOrderBy = varOrder.length ? ',' + lodash__WEBPACK_IMPORTED_MODULE_2___default().join(varOrder, ',') : '';
                    return lodash__WEBPACK_IMPORTED_MODULE_2___default().join(optionsOrder, ',') + varOrderBy;
                };
                var processVariablePostBindUpdate = function (nodeName, nodeVal, nodeType, variable, noUpdate) {
                    switch (variable.category) {
                        case _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.CATEGORY.LIVE:
                            if (variable.operation === 'read') {
                                if (nodeName === 'dataBinding') {
                                    lodash__WEBPACK_IMPORTED_MODULE_2___default().forEach(nodeVal, function (val, key) {
                                        variable.filterFields[key] = {
                                            'value': val
                                        };
                                    });
                                }
                                else {
                                    variable.filterFields[nodeName] = {
                                        'value': nodeVal,
                                        'type': nodeType
                                    };
                                }
                                /* if auto-update set for the variable with read operation only, get its data */
                                if (variable.autoUpdate && !lodash__WEBPACK_IMPORTED_MODULE_2___default().isUndefined(nodeVal) && lodash__WEBPACK_IMPORTED_MODULE_2___default().isFunction(variable.listRecords) && !noUpdate) {
                                    _invoke(variable, 'listRecords');
                                }
                            }
                            else {
                                if (nodeName === 'dataBinding') {
                                    variable.inputFields = nodeVal;
                                }
                                else {
                                    variable.inputFields[nodeName] = nodeVal;
                                }
                                /* if auto-update set for the variable with read operation only, get its data */
                                if (variable.autoUpdate && !lodash__WEBPACK_IMPORTED_MODULE_2___default().isUndefined(nodeVal) && lodash__WEBPACK_IMPORTED_MODULE_2___default().isFunction(variable[variable.operation + 'Record']) && !noUpdate) {
                                    _invoke(variable, variable.operation + 'Record');
                                }
                            }
                            break;
                        case _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.CATEGORY.CRUD:
                            if (variable.operationType === 'list' && variable.autoUpdate && !lodash__WEBPACK_IMPORTED_MODULE_2___default().isUndefined(nodeVal) && lodash__WEBPACK_IMPORTED_MODULE_2___default().isFunction(variable.invoke) && !noUpdate) {
                                _invoke(variable, 'invoke');
                            }
                            break;
                        case _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.CATEGORY.SERVICE:
                        case _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.CATEGORY.LOGIN:
                            if (variable.autoUpdate && !lodash__WEBPACK_IMPORTED_MODULE_2___default().isUndefined(nodeVal) && lodash__WEBPACK_IMPORTED_MODULE_2___default().isFunction(variable.invoke) && !noUpdate) {
                                _invoke(variable, 'invoke');
                            }
                            break;
                        case _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.CATEGORY.DEVICE:
                            variable[nodeName] = nodeVal;
                            if (variable.autoUpdate && !lodash__WEBPACK_IMPORTED_MODULE_2___default().isUndefined(nodeVal) && lodash__WEBPACK_IMPORTED_MODULE_2___default().isFunction(variable.invoke) && !noUpdate) {
                                _invoke(variable, 'invoke');
                            }
                            break;
                    }
                };
                /**
                * Returns the object node for a bind object, where the value has to be updated
                * obj.target = "a"
                    * @param obj
                * @param root
                * @param variable
                * @returns {*}
                */
                var getTargetObj = function (obj, root, variable) {
                    /*
                     * if the target key is in the form as "['my.param']"
                     * keep the target key as "my.param" and do not split further
                     * this is done, so that, the computed value against this binding is assigned as
                     *      {"my.param": "value"}
                     * and not as
                     *      {
                     *          "my": {
                     *              "param": "value"
                     *          }
                     *      }
                     */
                    var target = obj.target, targetObj;
                    var rootNode = variable[root];
                    if (DOT_EXPR_REX.test(target)) {
                        targetObj = rootNode;
                    }
                    else {
                        target = target.substr(0, target.lastIndexOf('.'));
                        if (obj.target === root) {
                            targetObj = variable;
                        }
                        else if (target) {
                            targetObj = (0, _utils__WEBPACK_IMPORTED_MODULE_0__.findValueOf)(rootNode, target, true);
                        }
                        else {
                            targetObj = rootNode;
                        }
                    }
                    return targetObj;
                };
                /**
                 * Gets the key for the target object
                 * the computed value will be updated against this key in the targetObject(computed by getTargetObj())
                 * @param target
                 * @param regex
                 * @returns {*}
                 */
                var getTargetNodeKey = function (target) {
                    /*
                     * if the target key is in the form as "['my.param']"
                     * keep the target key as "my.param" and do not split further
                     * this is done, so that, the computed value against this binding is assigned as
                     *      {"my.param": "value"}
                     * and not as
                     *      {
                     *          "my": {
                     *              "param": "value"
                     *          }
                     *      }
                     */
                    var targetNodeKey;
                    if (DOT_EXPR_REX.test(target)) {
                        targetNodeKey = target.replace(/^(\[["'])|(["']\])$/g, '');
                    }
                    else {
                        targetNodeKey = target.split('.').pop();
                    }
                    return targetNodeKey;
                };
                var setValueToNode = function (target, obj, root, variable, value, noUpdate) {
                    var targetNodeKey = getTargetNodeKey(target), targetObj = getTargetObj(obj, root, variable);
                    value = !lodash__WEBPACK_IMPORTED_MODULE_2___default().isUndefined(value) ? value : obj.value;
                    /* sanity check, user can bind parent nodes to non-object values, so child node bindings may fail */
                    if (targetObj) {
                        targetObj[targetNodeKey] = value;
                    }
                    processVariablePostBindUpdate(targetNodeKey, value, obj.type, variable, noUpdate);
                };
                var getTarget = function (variable) {
                    var target;
                    switch (variable.category) {
                        case _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.CATEGORY.MODEL:
                            target = 'dataSet';
                            break;
                        case _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.CATEGORY.LIVE:
                            target = variable.operation === 'read' ? 'filterFields' : 'inputFields';
                            break;
                        default:
                            target = 'dataBinding';
                            break;
                    }
                    return target;
                };
                /**
                 * The model internalBoundNodeMap stores the reference to latest computed values against internal(nested) bound nodes
                 * This is done so that the internal node's computed value is not lost, once its parent node's value is computed at a later point
                 * E.g.
                 * Variable.employeeVar has following bindings
                 * "dataBinding": [
                 {
                         "target": "department.budget",
                         "value": "bind:Variables.budgetVar.dataSet"
                     },
                 {
                         "target": "department",
                         "value": "bind:Variables.departmentVar.dataSet"
                     }
                 ]
                 * When department.budget is computed, employeeVar.dataSet = {
                 *  "department": {
                 *      "budget": {"q1": 1111}
                 *  }
                 * }
                 *
                 * When department is computed
                 *  "department": {
                 *      "name": "HR",
                 *      "location": "Hyderabad"
                 *  }
                 * The budget field (computed earlier) is LOST.
                 *
                 * To avoid this, the latest values against internal nodes (in this case department.budget) are stored in a map
                 * These values are assigned back to internal fields if the parent is computed (in this case department)
                 * @param target
                 * @param root
                 * @param variable
                 */
                var updateInternalNodes = function (target, root, variable) {
                    var boundInternalNodes = lodash__WEBPACK_IMPORTED_MODULE_2___default().keys(lodash__WEBPACK_IMPORTED_MODULE_2___default().get(internalBoundNodeMap.get(variable), [variable.name, root])), targetNodeKey = getTargetNodeKey(target);
                    var internalNodes;
                    function findInternalNodeBound() {
                        return lodash__WEBPACK_IMPORTED_MODULE_2___default().filter(boundInternalNodes, function (node) {
                            // the later condition in check (targetNodeKey === root || targetNodeKey === 'dataBinding') is specifically for live variable of insert/update types
                            return (node !== targetNodeKey && lodash__WEBPACK_IMPORTED_MODULE_2___default().includes(node, targetNodeKey)) || ((targetNodeKey === root || targetNodeKey === 'dataBinding') && node !== targetNodeKey);
                        });
                    }
                    internalNodes = findInternalNodeBound();
                    if ((internalNodes.length)) {
                        lodash__WEBPACK_IMPORTED_MODULE_2___default().forEach(internalNodes, function (node) {
                            setValueToNode(node, { target: node }, root, variable, lodash__WEBPACK_IMPORTED_MODULE_2___default().get(internalBoundNodeMap.get(variable), [variable.name, root, node]));
                        });
                    }
                };
                var initiateCallback = function (type, variable, data, options, skipDefaultNotification) {
                    /*checking if event is available and variable has event property and variable event property bound to function*/
                    var eventValues = variable[type], callBackScope = variable._context;
                    var errorVariable;
                    /**
                     * For error event:
                     * trigger app level error handler.
                     * if no event is assigned, trigger default appNotification variable.
                     */
                    if (type === _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.EVENT.ERROR && !skipDefaultNotification) {
                        if (!eventValues) {
                            /* in case of error, if no event assigned, handle through default notification variable */
                            errorVariable = callBackScope.Actions[_constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.DEFAULT_VAR.NOTIFICATION];
                            if (errorVariable) {
                                data = errorVariable.getMessage() || data;
                                data = lodash__WEBPACK_IMPORTED_MODULE_2___default().isString(data) ? data : 'An error has occured. Please check the app logs.';
                                errorVariable.invoke({ 'message': data }, undefined, undefined);
                                // $rootScope.$evalAsync(function () {
                                // $rootScope.$emit("invoke-service", VARIABLE_CONSTANTS.DEFAULT_VAR.NOTIFICATION, {scope: callBackScope, message: response});
                                // });
                            }
                        }
                    }
                    // TODO: [Vibhu], check whether to support legacy event calling mechanism (ideally, it should have been migrated)
                    // ToDo - variable seperation
                    // const fn = $parseEvent(variable[type]);
                    var fn = variable[type] || _utils__WEBPACK_IMPORTED_MODULE_0__.noop;
                    if (type === _constants_variables_constants__WEBPACK_IMPORTED_MODULE_1__.VARIABLE_CONSTANTS.EVENT.BEFORE_UPDATE) {
                        if (variable.category === 'wm.LiveVariable' && variable.operation === 'read') {
                            return fn(variable._context, { variable: variable, dataFilter: data, options: options });
                        }
                        else {
                            return fn(variable._context, { variable: variable, inputData: data, options: options });
                        }
                    }
                    else {
                        return fn(variable._context, { variable: variable, data: data, options: options });
                    }
                };
                var getDateTimeFormatForType = function (type) {
                    return _utils__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_FORMATS[lodash__WEBPACK_IMPORTED_MODULE_2___default().toUpper(type)];
                };
                // Format value for datetime types
                var _formatDate = function (dateValue, type) {
                    var epoch;
                    if (lodash__WEBPACK_IMPORTED_MODULE_2___default().isDate(dateValue)) {
                        epoch = dateValue.getTime();
                    }
                    else {
                        if (!isNaN(dateValue)) {
                            dateValue = parseInt(dateValue, 10);
                        }
                        epoch = dateValue && moment(dateValue).valueOf();
                    }
                    if (isNaN(epoch) && type !== _utils__WEBPACK_IMPORTED_MODULE_0__.DataType.TIME) {
                        return epoch;
                    }
                    if (type === _utils__WEBPACK_IMPORTED_MODULE_0__.DataType.TIMESTAMP) {
                        return epoch;
                    }
                    if (type === _utils__WEBPACK_IMPORTED_MODULE_0__.DataType.TIME && !epoch) {
                        epoch = moment(new Date().toDateString() + ' ' + dateValue).valueOf();
                    }
                    return dateValue && appManager.getPipe('date').transform(epoch, getDateTimeFormatForType(type));
                };
                // Function to convert values of date time types into default formats
                var formatDate = function (value, type) {
                    if (lodash__WEBPACK_IMPORTED_MODULE_2___default().includes(type, '.')) {
                        type = lodash__WEBPACK_IMPORTED_MODULE_2___default().toLower((0, _utils__WEBPACK_IMPORTED_MODULE_0__.extractType)(type));
                    }
                    if (lodash__WEBPACK_IMPORTED_MODULE_2___default().isArray(value)) {
                        return lodash__WEBPACK_IMPORTED_MODULE_2___default().map(value, function (val) {
                            return _formatDate(val, type);
                        });
                    }
                    return _formatDate(value, type);
                };
                var parseErrors = function (errors) {
                    var errMsg = '';
                    if (errors && errors.error && errors.error.length) {
                        errors.error.forEach(function (errorDetails, i) {
                            errMsg += parseError(errorDetails) + (i > 0 ? '\n' : '');
                        });
                    }
                    return errMsg;
                };
                var parseError = function (errorObj) {
                    var errMsg;
                    errMsg = errorObj.message ? (0, _utils__WEBPACK_IMPORTED_MODULE_0__.replace)(errorObj.message, errorObj.parameters, true) : ((errorObj.parameters && errorObj.parameters[0]) || '');
                    return errMsg;
                };
                /**
                 * This method filters and returns error message from the failed network call response.
                 * @param err, error form network call failure
                 */
                var getErrMessage = function (err, localeObject) {
                    var HTTP_STATUS_MSG = {
                        404: localeObject['MESSAGE_404_ERROR'] || 'Requested resource not found',
                        401: localeObject['MESSAGE_401_ERROR'] || 'Requested resource requires authentication',
                        403: localeObject['LABEL_FORBIDDEN_MESSAGE'] || 'The requested resource access/action is forbidden.'
                    };
                    // check if error message present for responded http status
                    var errMsg = HTTP_STATUS_MSG[err.status];
                    var errorDetails = err.error;
                    errorDetails = (0, _utils__WEBPACK_IMPORTED_MODULE_0__.getValidJSON)(errorDetails) || errorDetails;
                    // WM services have the format of error response as errorDetails.error
                    if (errorDetails && errorDetails.errors) {
                        errMsg = parseErrors(errorDetails.errors) || errMsg || 'Service Call Failed';
                    }
                    else {
                        errMsg = errMsg || 'Service Call Failed';
                    }
                    return errMsg;
                };
                /***/ 
            }),
            /***/ "./node_modules/x2js/x2js.js": 
            /*!***********************************!*\
              !*** ./node_modules/x2js/x2js.js ***!
              \***********************************/
            /***/ (function (module, exports) {
                var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; /*
                    Copyright 2015 Axinom
                    Copyright 2011-2013 Abdulla Abdurakhmanov
                    Original sources are available at https://code.google.com/p/x2js/
                
                    Licensed under the Apache License, Version 2.0 (the "License");
                    you may not use this file except in compliance with the License.
                    You may obtain a copy of the License at
                
                    http://www.apache.org/licenses/LICENSE-2.0
                
                    Unless required by applicable law or agreed to in writing, software
                    distributed under the License is distributed on an "AS IS" BASIS,
                    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                    See the License for the specific language governing permissions and
                    limitations under the License.
                */
                /*
                    Supported export methods:
                    * AMD
                    * <script> (window.X2JS)
                    * Node.js
                
                    Limitations:
                    * Attribute namespace prefixes are not parsed as such.
                    * Overall the serialization/deserializaton code is "best effort" and not foolproof.
                */
                // Module definition pattern used is returnExports from https://github.com/umdjs/umd
                (function (root, factory) {
                    "use strict";
                    /* global define */
                    if (true) {
                        // AMD. Register as an anonymous module.
                        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                            __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                                (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                    }
                    else { }
                })(this, function (CustomDOMParser) {
                    "use strict";
                    // We return a constructor that can be used to make X2JS instances.
                    return function X2JS(config) {
                        var VERSION = "3.4.4";
                        config = config || {};
                        function initConfigDefaults() {
                            // If set to "property" then <element>_asArray will be created
                            // to allow you to access any element as an array (even if there is only one of it).
                            config.arrayAccessForm = config.arrayAccessForm || "none";
                            // If "text" then <empty></empty> will be transformed to "".
                            // If "object" then <empty></empty> will be transformed to {}.
                            config.emptyNodeForm = config.emptyNodeForm || "text";
                            // Function that will be called for each elements, if the function returns true, the element will be skipped
                            // function(name, value) { return true; };
                            config.jsAttributeFilter = config.jsAttributeFilter;
                            // Function that will be called for each elements, the element value will be replaced by the returned value
                            // function(name, value) { return parseFloat(value); };
                            config.jsAttributeConverter = config.jsAttributeConverter;
                            // Allows attribute values to be converted on the fly during parsing to objects.
                            // 	"test": function(name, value) { return true; }
                            //	"convert": function(name, value) { return parseFloat(value); };
                            // convert() will be called for every attribute where test() returns true
                            // and the return value from convert() will replace the original value of the attribute.
                            config.attributeConverters = config.attributeConverters || [];
                            // Any elements that match the paths here will have their text parsed
                            // as an XML datetime value (2011-11-12T13:00:00-07:00 style).
                            // The path can be a plain string (parent.child1.child2),
                            // a regex (/.*\.child2/) or function(elementPath).
                            config.datetimeAccessFormPaths = config.datetimeAccessFormPaths || [];
                            // Any elements that match the paths listed here will be stored in JavaScript objects
                            // as arrays even if there is only one of them. The path can be a plain string
                            // (parent.child1.child2), a regex (/.*\.child2/) or function(elementName, elementPath).
                            config.arrayAccessFormPaths = config.arrayAccessFormPaths || [];
                            // xmldom constructor arguments
                            // @see https://github.com/jindw/xmldom#api-reference
                            config.xmldomOptions = config.xmldomOptions || {};
                            // If true, a toString function is generated to print nodes containing text or cdata.
                            // Useful if you want to accept both plain text and CData as equivalent inputs.
                            if (config.enableToStringFunc === undefined) {
                                config.enableToStringFunc = true;
                            }
                            // If true, empty text tags are ignored for elements with child nodes.
                            if (config.skipEmptyTextNodesForObj === undefined) {
                                config.skipEmptyTextNodesForObj = true;
                            }
                            // If true, whitespace is trimmed from text nodes.
                            if (config.stripWhitespaces === undefined) {
                                config.stripWhitespaces = true;
                            }
                            // If true, double quotes are used in generated XML.
                            if (config.useDoubleQuotes === undefined) {
                                config.useDoubleQuotes = true;
                            }
                            // If true, the root element of the XML document is ignored when converting to objects.
                            // The result will directly have the root element's children as its own properties.
                            if (config.ignoreRoot === undefined) {
                                config.ignoreRoot = false;
                            }
                            // Whether XML characters in text are escaped when reading/writing XML.
                            if (config.escapeMode === undefined) {
                                config.escapeMode = true;
                            }
                            // Prefix to use for properties that are created to represent XML attributes.
                            if (config.attributePrefix === undefined) {
                                config.attributePrefix = "_";
                            }
                            // If true, empty elements will created as self closing elements (<element />)
                            // If false, empty elements will be created with start and end tags (<element></element>)
                            if (config.selfClosingElements === undefined) {
                                config.selfClosingElements = true;
                            }
                            // If this property defined as false and an XML element has CData node ONLY, it will be converted to text without additional property "__cdata"
                            if (config.keepCData === undefined) {
                                config.keepCData = false;
                            }
                            // If this property defined as true, use { __text: 'abc' } over 'abc'
                            if (config.keepText === undefined) {
                                config.keepText = false;
                            }
                            // If true, will output dates in UTC
                            if (config.jsDateUTC === undefined) {
                                config.jsDateUTC = false;
                            }
                        }
                        function initRequiredPolyfills() {
                            function pad(number) {
                                var r = String(number);
                                if (r.length === 1) {
                                    r = '0' + r;
                                }
                                return r;
                            }
                            // Hello IE8-
                            if (typeof String.prototype.trim !== 'function') {
                                String.prototype.trim = function trim() {
                                    return this.replace(/^\s+|^\n+|(\s|\n)+$/g, '');
                                };
                            }
                            if (typeof Date.prototype.toISOString !== 'function') {
                                // Implementation from http://stackoverflow.com/questions/2573521/how-do-i-output-an-iso-8601-formatted-string-in-javascript
                                Date.prototype.toISOString = function toISOString() {
                                    var MS_IN_S = 1000;
                                    return this.getUTCFullYear()
                                        + '-' + pad(this.getUTCMonth() + 1)
                                        + '-' + pad(this.getUTCDate())
                                        + 'T' + pad(this.getUTCHours())
                                        + ':' + pad(this.getUTCMinutes())
                                        + ':' + pad(this.getUTCSeconds())
                                        + '.' + String((this.getUTCMilliseconds() / MS_IN_S).toFixed(3)).slice(2, 5)
                                        + 'Z';
                                };
                            }
                        }
                        initConfigDefaults();
                        initRequiredPolyfills();
                        var DOMNodeTypes = {
                            "ELEMENT_NODE": 1,
                            "TEXT_NODE": 3,
                            "CDATA_SECTION_NODE": 4,
                            "COMMENT_NODE": 8,
                            "DOCUMENT_NODE": 9
                        };
                        function getDomNodeLocalName(domNode) {
                            var localName = domNode.localName;
                            if (localName == null) {
                                // Yeah, this is IE!!
                                localName = domNode.baseName;
                            }
                            if (localName == null || localName === "") {
                                // ==="" is IE too
                                localName = domNode.nodeName;
                            }
                            return localName;
                        }
                        function getDomNodeNamespacePrefix(node) {
                            return node.prefix;
                        }
                        function escapeXmlChars(str) {
                            if (typeof str === "string")
                                return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;');
                            else
                                return str;
                        }
                        function unescapeXmlChars(str) {
                            return str.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&amp;/g, '&');
                        }
                        function ensureProperArrayAccessForm(element, childName, elementPath) {
                            switch (config.arrayAccessForm) {
                                case "property":
                                    if (!(element[childName] instanceof Array))
                                        element[childName + "_asArray"] = [element[childName]];
                                    else
                                        element[childName + "_asArray"] = element[childName];
                                    break;
                            }
                            if (!(element[childName] instanceof Array) && config.arrayAccessFormPaths.length > 0) {
                                var match = false;
                                for (var i = 0; i < config.arrayAccessFormPaths.length; i++) {
                                    var arrayPath = config.arrayAccessFormPaths[i];
                                    if (typeof arrayPath === "string") {
                                        if (arrayPath === elementPath) {
                                            match = true;
                                            break;
                                        }
                                    }
                                    else if (arrayPath instanceof RegExp) {
                                        if (arrayPath.test(elementPath)) {
                                            match = true;
                                            break;
                                        }
                                    }
                                    else if (typeof arrayPath === "function") {
                                        if (arrayPath(childName, elementPath)) {
                                            match = true;
                                            break;
                                        }
                                    }
                                }
                                if (match)
                                    element[childName] = [element[childName]];
                            }
                        }
                        function xmlDateTimeToDate(prop) {
                            // Implementation based up on http://stackoverflow.com/questions/8178598/xml-datetime-to-javascript-date-object
                            // Improved to support full spec and optional parts
                            var MINUTES_PER_HOUR = 60;
                            var bits = prop.split(/[-T:+Z]/g);
                            var d = new Date(bits[0], bits[1] - 1, bits[2]);
                            var secondBits = bits[5].split("\.");
                            d.setHours(bits[3], bits[4], secondBits[0]);
                            if (secondBits.length > 1)
                                d.setMilliseconds(secondBits[1]);
                            // Get supplied time zone offset in minutes
                            if (bits[6] && bits[7]) {
                                var offsetMinutes = bits[6] * MINUTES_PER_HOUR + Number(bits[7]);
                                var sign = /\d\d-\d\d:\d\d$/.test(prop) ? '-' : '+';
                                // Apply the sign
                                offsetMinutes = 0 + (sign === '-' ? -1 * offsetMinutes : offsetMinutes);
                                // Apply offset and local timezone
                                d.setMinutes(d.getMinutes() - offsetMinutes - d.getTimezoneOffset());
                            }
                            else if (prop.indexOf("Z", prop.length - 1) !== -1) {
                                d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds()));
                            }
                            // d is now a local time equivalent to the supplied time
                            return d;
                        }
                        function convertToDateIfRequired(value, childName, fullPath) {
                            if (config.datetimeAccessFormPaths.length > 0) {
                                var pathWithoutTextNode = fullPath.split("\.#")[0];
                                for (var i = 0; i < config.datetimeAccessFormPaths.length; i++) {
                                    var candidatePath = config.datetimeAccessFormPaths[i];
                                    if (typeof candidatePath === "string") {
                                        if (candidatePath === pathWithoutTextNode)
                                            return xmlDateTimeToDate(value);
                                    }
                                    else if (candidatePath instanceof RegExp) {
                                        if (candidatePath.test(pathWithoutTextNode))
                                            return xmlDateTimeToDate(value);
                                    }
                                    else if (typeof candidatePath === "function") {
                                        if (candidatePath(pathWithoutTextNode))
                                            return xmlDateTimeToDate(value);
                                    }
                                }
                            }
                            return value;
                        }
                        function deserializeRootElementChildren(rootElement) {
                            var result = {};
                            var children = rootElement.childNodes;
                            // Alternative for firstElementChild which is not supported in some environments
                            for (var i = 0; i < children.length; i++) {
                                var child = children.item(i);
                                if (child.nodeType === DOMNodeTypes.ELEMENT_NODE) {
                                    var childName = getDomNodeLocalName(child);
                                    if (config.ignoreRoot)
                                        result = deserializeDomChildren(child, childName);
                                    else
                                        result[childName] = deserializeDomChildren(child, childName);
                                }
                            }
                            return result;
                        }
                        function deserializeElementChildren(element, elementPath) {
                            var result = {};
                            result.__cnt = 0;
                            var nodeChildren = element.childNodes;
                            // Child nodes.
                            for (var iChild = 0; iChild < nodeChildren.length; iChild++) {
                                var child = nodeChildren.item(iChild);
                                var childName = getDomNodeLocalName(child);
                                if (child.nodeType === DOMNodeTypes.COMMENT_NODE)
                                    continue;
                                result.__cnt++;
                                // We deliberately do not accept everything falsey here because
                                // elements that resolve to empty string should still be preserved.
                                if (result[childName] == null) {
                                    result[childName] = deserializeDomChildren(child, elementPath + "." + childName);
                                    ensureProperArrayAccessForm(result, childName, elementPath + "." + childName);
                                }
                                else {
                                    if (!(result[childName] instanceof Array)) {
                                        result[childName] = [result[childName]];
                                        ensureProperArrayAccessForm(result, childName, elementPath + "." + childName);
                                    }
                                    result[childName][result[childName].length] = deserializeDomChildren(child, elementPath + "." + childName);
                                }
                            }
                            // Attributes
                            for (var iAttribute = 0; iAttribute < element.attributes.length; iAttribute++) {
                                var attribute = element.attributes.item(iAttribute);
                                result.__cnt++;
                                var adjustedValue = attribute.value;
                                for (var iConverter = 0; iConverter < config.attributeConverters.length; iConverter++) {
                                    var converter = config.attributeConverters[iConverter];
                                    if (converter.test.call(null, attribute.name, attribute.value))
                                        adjustedValue = converter.convert.call(null, attribute.name, attribute.value);
                                }
                                result[config.attributePrefix + attribute.name] = adjustedValue;
                            }
                            // Node namespace prefix
                            var namespacePrefix = getDomNodeNamespacePrefix(element);
                            if (namespacePrefix) {
                                result.__cnt++;
                                result.__prefix = namespacePrefix;
                            }
                            if (result["#text"]) {
                                result.__text = result["#text"];
                                if (result.__text instanceof Array) {
                                    result.__text = result.__text.join("\n");
                                }
                                if (config.escapeMode)
                                    result.__text = unescapeXmlChars(result.__text);
                                if (config.stripWhitespaces)
                                    result.__text = result.__text.trim();
                                delete result["#text"];
                                if (config.arrayAccessForm === "property")
                                    delete result["#text_asArray"];
                                result.__text = convertToDateIfRequired(result.__text, "#text", elementPath + ".#text");
                            }
                            if (result.hasOwnProperty('#cdata-section')) {
                                result.__cdata = result["#cdata-section"];
                                delete result["#cdata-section"];
                                if (config.arrayAccessForm === "property")
                                    delete result["#cdata-section_asArray"];
                            }
                            if (result.__cnt === 1 && result.__text && !config.keepText) {
                                result = result.__text;
                            }
                            else if (result.__cnt === 0 && config.emptyNodeForm === "text") {
                                result = '';
                            }
                            else if (result.__cnt > 1 && result.__text !== undefined && config.skipEmptyTextNodesForObj) {
                                if (config.stripWhitespaces && result.__text === "" || result.__text.trim() === "") {
                                    delete result.__text;
                                }
                            }
                            delete result.__cnt;
                            /**
                             * We are checking if we are creating a __cdata property or if we just add the content of cdata inside result.
                             * But, if we have a property inside xml tag (<tag PROPERTY="1"></tag>), and a cdata inside, we can't ignore it.
                             * In this case we are keeping __cdata property.
                             */
                            if (!config.keepCData && (!result.hasOwnProperty('__text') && result.hasOwnProperty('__cdata') && Object.keys(result).length === 1)) {
                                return (result.__cdata ? result.__cdata : '');
                            }
                            if (config.enableToStringFunc && (result.__text || result.__cdata)) {
                                result.toString = function toString() {
                                    return (this.__text ? this.__text : '') + (this.__cdata ? this.__cdata : '');
                                };
                            }
                            return result;
                        }
                        function deserializeDomChildren(node, parentPath) {
                            if (node.nodeType === DOMNodeTypes.DOCUMENT_NODE) {
                                return deserializeRootElementChildren(node);
                            }
                            else if (node.nodeType === DOMNodeTypes.ELEMENT_NODE) {
                                return deserializeElementChildren(node, parentPath);
                            }
                            else if (node.nodeType === DOMNodeTypes.TEXT_NODE || node.nodeType === DOMNodeTypes.CDATA_SECTION_NODE) {
                                return node.nodeValue;
                            }
                            else {
                                return null;
                            }
                        }
                        function serializeStartTag(jsObject, elementName, attributeNames, selfClosing) {
                            var resultStr = "<" + ((jsObject && jsObject.__prefix) ? (jsObject.__prefix + ":") : "") + elementName;
                            if (attributeNames) {
                                for (var i = 0; i < attributeNames.length; i++) {
                                    var attributeName = attributeNames[i];
                                    var attributeValue = jsObject[attributeName];
                                    if (config.escapeMode)
                                        attributeValue = escapeXmlChars(attributeValue);
                                    resultStr += " " + attributeName.substr(config.attributePrefix.length) + "=";
                                    if (config.useDoubleQuotes)
                                        resultStr += '"' + attributeValue + '"';
                                    else
                                        resultStr += "'" + attributeValue + "'";
                                }
                            }
                            if (!selfClosing)
                                resultStr += ">";
                            else
                                resultStr += " />";
                            return resultStr;
                        }
                        function serializeEndTag(jsObject, elementName) {
                            return "</" + ((jsObject && jsObject.__prefix) ? (jsObject.__prefix + ":") : "") + elementName + ">";
                        }
                        function endsWith(str, suffix) {
                            return str.indexOf(suffix, str.length - suffix.length) !== -1;
                        }
                        function isSpecialProperty(jsonObj, propertyName) {
                            if ((config.arrayAccessForm === "property" && endsWith(propertyName.toString(), ("_asArray")))
                                || propertyName.toString().indexOf(config.attributePrefix) === 0
                                || propertyName.toString().indexOf("__") === 0
                                || (jsonObj[propertyName] instanceof Function))
                                return true;
                            else
                                return false;
                        }
                        function getDataElementCount(jsObject) {
                            var count = 0;
                            if (jsObject instanceof Object) {
                                for (var propertyName in jsObject) {
                                    if (isSpecialProperty(jsObject, propertyName))
                                        continue;
                                    count++;
                                }
                            }
                            return count;
                        }
                        function getDataAttributeNames(jsObject) {
                            var names = [];
                            if (jsObject instanceof Object) {
                                for (var attributeName in jsObject) {
                                    if (attributeName.toString().indexOf("__") === -1
                                        && attributeName.toString().indexOf(config.attributePrefix) === 0) {
                                        names.push(attributeName);
                                    }
                                }
                            }
                            return names;
                        }
                        function serializeComplexTextNodeContents(textNode) {
                            var result = "";
                            if (textNode.__cdata) {
                                result += "<![CDATA[" + textNode.__cdata + "]]>";
                            }
                            if (textNode.__text || typeof (textNode.__text) === 'number' || typeof (textNode.__text) === 'boolean') {
                                if (config.escapeMode)
                                    result += escapeXmlChars(textNode.__text);
                                else
                                    result += textNode.__text;
                            }
                            return result;
                        }
                        function serializeTextNodeContents(textNode) {
                            var result = "";
                            if (textNode instanceof Object) {
                                result += serializeComplexTextNodeContents(textNode);
                            }
                            else if (textNode !== null) {
                                if (config.escapeMode)
                                    result += escapeXmlChars(textNode);
                                else
                                    result += textNode;
                            }
                            return result;
                        }
                        function serializeArray(elementArray, elementName, attributes) {
                            var result = "";
                            if (elementArray.length === 0) {
                                result += serializeStartTag(elementArray, elementName, attributes, true);
                            }
                            else {
                                for (var i = 0; i < elementArray.length; i++) {
                                    result += serializeJavaScriptObject(elementArray[i], elementName, getDataAttributeNames(elementArray[i]));
                                }
                            }
                            return result;
                        }
                        function serializeJavaScriptObject(element, elementName, attributes) {
                            var result = "";
                            // Filter out elements
                            if (config.jsAttributeFilter && config.jsAttributeFilter.call(null, elementName, element)) {
                                return result;
                            }
                            // Convert element
                            if (config.jsAttributeConverter) {
                                element = config.jsAttributeConverter.call(null, elementName, element);
                            }
                            if ((element === undefined || element === null || element === '') && config.selfClosingElements) {
                                result += serializeStartTag(element, elementName, attributes, true);
                            }
                            else if (typeof element === 'object') {
                                if (Object.prototype.toString.call(element) === '[object Array]') {
                                    result += serializeArray(element, elementName, attributes);
                                }
                                else if (element instanceof Date) {
                                    result += serializeStartTag(element, elementName, attributes, false);
                                    // Serialize date
                                    result += config.jsDateUTC ? element.toUTCString() : element.toISOString();
                                    result += serializeEndTag(element, elementName);
                                }
                                else {
                                    var childElementCount = getDataElementCount(element);
                                    if (childElementCount > 0 || typeof (element.__text) === 'number' || typeof (element.__text) === 'boolean' || element.__text || element.__cdata) {
                                        result += serializeStartTag(element, elementName, attributes, false);
                                        result += serializeJavaScriptObjectChildren(element);
                                        result += serializeEndTag(element, elementName);
                                    }
                                    else if (config.selfClosingElements) {
                                        result += serializeStartTag(element, elementName, attributes, true);
                                    }
                                    else {
                                        result += serializeStartTag(element, elementName, attributes, false);
                                        result += serializeEndTag(element, elementName);
                                    }
                                }
                            }
                            else {
                                result += serializeStartTag(element, elementName, attributes, false);
                                result += serializeTextNodeContents(element);
                                result += serializeEndTag(element, elementName);
                            }
                            return result;
                        }
                        function serializeJavaScriptObjectChildren(jsObject) {
                            var result = "";
                            var elementCount = getDataElementCount(jsObject);
                            if (elementCount > 0) {
                                for (var elementName in jsObject) {
                                    if (isSpecialProperty(jsObject, elementName))
                                        continue;
                                    var element = jsObject[elementName];
                                    var attributes = getDataAttributeNames(element);
                                    result += serializeJavaScriptObject(element, elementName, attributes);
                                }
                            }
                            result += serializeTextNodeContents(jsObject);
                            return result;
                        }
                        function parseXml(xml) {
                            if (xml === undefined) {
                                return null;
                            }
                            if (typeof xml !== "string") {
                                return null;
                            }
                            var parser = null;
                            var domNode = null;
                            if (CustomDOMParser) {
                                // This branch is used for node.js, with the xmldom parser.
                                parser = new CustomDOMParser(config.xmldomOptions);
                                domNode = parser.parseFromString(xml, "text/xml");
                            }
                            else if (window && window.DOMParser) {
                                parser = new window.DOMParser();
                                var parsererrorNS = null;
                                var isIEParser = window.ActiveXObject || "ActiveXObject" in window;
                                // IE9+ now is here
                                if (!isIEParser && document.all && !document.addEventListener) {
                                    try {
                                        parsererrorNS = parser.parseFromString("INVALID", "text/xml").childNodes[0].namespaceURI;
                                    }
                                    catch (err) {
                                        parsererrorNS = null;
                                    }
                                }
                                try {
                                    domNode = parser.parseFromString(xml, "text/xml");
                                    if (parsererrorNS !== null && domNode.getElementsByTagNameNS(parsererrorNS, "parsererror").length > 0) {
                                        domNode = null;
                                    }
                                }
                                catch (err) {
                                    domNode = null;
                                }
                            }
                            else {
                                // IE :(
                                if (xml.indexOf("<?") === 0) {
                                    xml = xml.substr(xml.indexOf("?>") + 2);
                                }
                                /* global ActiveXObject */
                                domNode = new ActiveXObject("Microsoft.XMLDOM");
                                domNode.async = "false";
                                domNode.loadXML(xml);
                            }
                            return domNode;
                        }
                        this.asArray = function asArray(prop) {
                            if (prop === undefined || prop === null) {
                                return [];
                            }
                            else if (prop instanceof Array) {
                                return prop;
                            }
                            else {
                                return [prop];
                            }
                        };
                        this.toXmlDateTime = function toXmlDateTime(dt) {
                            if (dt instanceof Date) {
                                return dt.toISOString();
                            }
                            else if (typeof (dt) === 'number') {
                                return new Date(dt).toISOString();
                            }
                            else {
                                return null;
                            }
                        };
                        this.asDateTime = function asDateTime(prop) {
                            if (typeof (prop) === "string") {
                                return xmlDateTimeToDate(prop);
                            }
                            else {
                                return prop;
                            }
                        };
                        /*
                            Internally the logic works in a cycle:
                            DOM->JS - implemented by custom logic (deserialization).
                            JS->XML - implemented by custom logic (serialization).
                            XML->DOM - implemented by browser.
                        */
                        // Transformns an XML string into DOM-tree
                        this.xml2dom = function xml2dom(xml) {
                            return parseXml(xml);
                        };
                        // Transforms a DOM tree to JavaScript objects.
                        this.dom2js = function dom2js(domNode) {
                            return deserializeDomChildren(domNode, null);
                        };
                        // Transforms JavaScript objects to a DOM tree.
                        this.js2dom = function js2dom(jsObject) {
                            var xml = this.js2xml(jsObject);
                            return parseXml(xml);
                        };
                        // Transformns an XML string into JavaScript objects.
                        this.xml2js = function xml2js(xml) {
                            var domNode = parseXml(xml);
                            if (domNode != null)
                                return this.dom2js(domNode);
                            else
                                return null;
                        };
                        // Transforms JavaScript objects into an XML string.
                        this.js2xml = function js2xml(jsObject) {
                            return serializeJavaScriptObjectChildren(jsObject);
                        };
                        this.getVersion = function getVersion() {
                            return VERSION;
                        };
                    };
                });
                /***/ 
            })
            /******/ 
        });
        /************************************************************************/
        /******/ // The module cache
        /******/ var __webpack_module_cache__ = {};
        /******/
        /******/ // The require function
        /******/ function __webpack_require__(moduleId) {
            /******/ // Check if module is in cache
            /******/ var cachedModule = __webpack_module_cache__[moduleId];
            /******/ if (cachedModule !== undefined) {
                /******/ return cachedModule.exports;
                /******/ }
            /******/ // Create a new module (and put it into the cache)
            /******/ var module = __webpack_module_cache__[moduleId] = {
                /******/ id: moduleId,
                /******/ loaded: false,
                /******/ exports: {}
                /******/ 
            };
            /******/
            /******/ // Execute the module function
            /******/ __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            /******/
            /******/ // Flag the module as loaded
            /******/ module.loaded = true;
            /******/
            /******/ // Return the exports of the module
            /******/ return module.exports;
            /******/ 
        }
        /******/
        /************************************************************************/
        /******/ /* webpack/runtime/compat get default export */
        /******/ (function () {
            /******/ // getDefaultExport function for compatibility with non-harmony modules
            /******/ __webpack_require__.n = function (module) {
                /******/ var getter = module && module.__esModule ?
                    /******/ function () { return (module['default']); } :
                    /******/ function () { return (module); };
                /******/ __webpack_require__.d(getter, { a: getter });
                /******/ return getter;
                /******/ 
            };
            /******/ 
        })();
        /******/
        /******/ /* webpack/runtime/define property getters */
        /******/ (function () {
            /******/ // define getter functions for harmony exports
            /******/ __webpack_require__.d = function (exports, definition) {
                /******/ for (var key in definition) {
                    /******/ if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
                        /******/ Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
                        /******/ }
                    /******/ }
                /******/ 
            };
            /******/ 
        })();
        /******/
        /******/ /* webpack/runtime/global */
        /******/ (function () {
            /******/ __webpack_require__.g = (function () {
                /******/ if (typeof globalThis === 'object')
                    return globalThis;
                /******/ try {
                    /******/ return this || new Function('return this')();
                    /******/ }
                catch (e) {
                    /******/ if (typeof window === 'object')
                        return window;
                    /******/ }
                /******/ 
            })();
            /******/ 
        })();
        /******/
        /******/ /* webpack/runtime/hasOwnProperty shorthand */
        /******/ (function () {
            /******/ __webpack_require__.o = function (obj, prop) { return (Object.prototype.hasOwnProperty.call(obj, prop)); };
            /******/ 
        })();
        /******/
        /******/ /* webpack/runtime/make namespace object */
        /******/ (function () {
            /******/ // define __esModule on exports
            /******/ __webpack_require__.r = function (exports) {
                /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                    /******/ Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
                    /******/ }
                /******/ Object.defineProperty(exports, '__esModule', { value: true });
                /******/ 
            };
            /******/ 
        })();
        /******/
        /******/ /* webpack/runtime/node module decorator */
        /******/ (function () {
            /******/ __webpack_require__.nmd = function (module) {
                /******/ module.paths = [];
                /******/ if (!module.children)
                    module.children = [];
                /******/ return module;
                /******/ 
            };
            /******/ 
        })();
        /******/
        /************************************************************************/
        var __webpack_exports__ = {};
        // This entry need to be wrapped in an IIFE because it need to be in strict mode.
        (function () {
            "use strict";
            /*!******************!*\
              !*** ./index.ts ***!
              \******************/
            __webpack_require__.r(__webpack_exports__);
            /* harmony export */ __webpack_require__.d(__webpack_exports__, {
                /* harmony export */ "$rootScope": function () { return ( /* reexport safe */_src_constants_variables_constants__WEBPACK_IMPORTED_MODULE_0__.$rootScope); },
                /* harmony export */ "ApiAwareVariable": function () { return ( /* reexport safe */_src_model_variable_api_aware_variable__WEBPACK_IMPORTED_MODULE_3__.ApiAwareVariable); },
                /* harmony export */ "BaseAction": function () { return ( /* reexport safe */_src_model_base_action__WEBPACK_IMPORTED_MODULE_2__.BaseAction); },
                /* harmony export */ "CONSTANTS": function () { return ( /* reexport safe */_src_constants_variables_constants__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS); },
                /* harmony export */ "CrudVariable": function () { return ( /* reexport safe */_src_model_variable_crud_variable__WEBPACK_IMPORTED_MODULE_7__.CrudVariable); },
                /* harmony export */ "DB_CONSTANTS": function () { return ( /* reexport safe */_src_constants_variables_constants__WEBPACK_IMPORTED_MODULE_0__.DB_CONSTANTS); },
                /* harmony export */ "LVService": function () { return ( /* reexport safe */_src_util_variable_live_variable_http_utils__WEBPACK_IMPORTED_MODULE_10__.LVService); },
                /* harmony export */ "LiveVariable": function () { return ( /* reexport safe */_src_model_variable_live_variable__WEBPACK_IMPORTED_MODULE_8__.LiveVariable); },
                /* harmony export */ "LiveVariableUtils": function () { return ( /* reexport safe */_src_util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_11__.LiveVariableUtils); },
                /* harmony export */ "ModelVariable": function () { return ( /* reexport safe */_src_model_variable_model_variable__WEBPACK_IMPORTED_MODULE_5__.ModelVariable); },
                /* harmony export */ "SWAGGER_CONSTANTS": function () { return ( /* reexport safe */_src_constants_variables_constants__WEBPACK_IMPORTED_MODULE_0__.SWAGGER_CONSTANTS); },
                /* harmony export */ "ServiceVariable": function () { return ( /* reexport safe */_src_model_variable_service_variable__WEBPACK_IMPORTED_MODULE_6__.ServiceVariable); },
                /* harmony export */ "TEST": function () { return ( /* binding */TEST); },
                /* harmony export */ "TimerAction": function () { return ( /* reexport safe */_src_model_action_timer_action__WEBPACK_IMPORTED_MODULE_4__.TimerAction); },
                /* harmony export */ "VARIABLE_CONSTANTS": function () { return ( /* reexport safe */_src_constants_variables_constants__WEBPACK_IMPORTED_MODULE_0__.VARIABLE_CONSTANTS); },
                /* harmony export */ "VARIABLE_URLS": function () { return ( /* reexport safe */_src_constants_variables_constants__WEBPACK_IMPORTED_MODULE_0__.VARIABLE_URLS); },
                /* harmony export */ "WS_CONSTANTS": function () { return ( /* reexport safe */_src_constants_variables_constants__WEBPACK_IMPORTED_MODULE_0__.WS_CONSTANTS); },
                /* harmony export */ "appManager": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.appManager); },
                /* harmony export */ "debounceVariableCall": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.debounceVariableCall); },
                /* harmony export */ "decodeData": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.decodeData); },
                /* harmony export */ "dialogService": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.dialogService); },
                /* harmony export */ "formatDate": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.formatDate); },
                /* harmony export */ "formatExportExpression": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.formatExportExpression); },
                /* harmony export */ "generateConnectionParams": function () { return ( /* reexport safe */_src_util_variable_live_variable_http_utils__WEBPACK_IMPORTED_MODULE_10__.generateConnectionParams); },
                /* harmony export */ "getBlob": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.getBlob); },
                /* harmony export */ "getErrMessage": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.getErrMessage); },
                /* harmony export */ "getEvaluatedOrderBy": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.getEvaluatedOrderBy); },
                /* harmony export */ "getTarget": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.getTarget); },
                /* harmony export */ "getTargetNodeKey": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.getTargetNodeKey); },
                /* harmony export */ "getTargetObj": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.getTargetObj); },
                /* harmony export */ "httpService": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.httpService); },
                /* harmony export */ "initiateCallback": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.initiateCallback); },
                /* harmony export */ "internalBoundNodeMap": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.internalBoundNodeMap); },
                /* harmony export */ "isFileUploadSupported": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.isFileUploadSupported); },
                /* harmony export */ "metadataService": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.metadataService); },
                /* harmony export */ "navigationService": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.navigationService); },
                /* harmony export */ "oauthService": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.oauthService); },
                /* harmony export */ "parseConfig": function () { return ( /* reexport safe */_src_util_variable_live_variable_http_utils__WEBPACK_IMPORTED_MODULE_10__.parseConfig); },
                /* harmony export */ "routerService": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.routerService); },
                /* harmony export */ "securityService": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.securityService); },
                /* harmony export */ "setInput": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.setInput); },
                /* harmony export */ "setValueToNode": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.setValueToNode); },
                /* harmony export */ "toasterService": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.toasterService); },
                /* harmony export */ "updateInternalNodes": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.updateInternalNodes); },
                /* harmony export */ "wmSetDependency": function () { return ( /* reexport safe */_src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__.wmSetDependency); }
                /* harmony export */ 
            });
            /* harmony import */ var _src_constants_variables_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/constants/variables.constants */ "./src/constants/variables.constants.ts");
            /* harmony import */ var _src_util_variable_variables_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/util/variable/variables.utils */ "./src/util/variable/variables.utils.ts");
            /* harmony import */ var _src_model_base_action__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/model/base-action */ "./src/model/base-action.ts");
            /* harmony import */ var _src_model_variable_api_aware_variable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/model/variable/api-aware-variable */ "./src/model/variable/api-aware-variable.ts");
            /* harmony import */ var _src_model_action_timer_action__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/model/action/timer-action */ "./src/model/action/timer-action.ts");
            /* harmony import */ var _src_model_variable_model_variable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/model/variable/model-variable */ "./src/model/variable/model-variable.ts");
            /* harmony import */ var _src_model_variable_service_variable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/model/variable/service-variable */ "./src/model/variable/service-variable.ts");
            /* harmony import */ var _src_model_variable_crud_variable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/model/variable/crud-variable */ "./src/model/variable/crud-variable.ts");
            /* harmony import */ var _src_model_variable_live_variable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/model/variable/live-variable */ "./src/model/variable/live-variable.ts");
            /* harmony import */ var _src_types_http_client_service__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/types/http-client.service */ "./src/types/http-client.service.ts");
            /* harmony import */ var _src_util_variable_live_variable_http_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/util/variable/live-variable.http.utils */ "./src/util/variable/live-variable.http.utils.ts");
            /* harmony import */ var _src_util_variable_live_variable_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/util/variable/live-variable.utils */ "./src/util/variable/live-variable.utils.ts");
            var TEST = 'hello from variables';
        })();
        /******/ return __webpack_exports__;
        /******/ 
    })();
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxLQUFLO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0Esa0RBQWtELEtBQUsseUJBQXlCLE9BQU87QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsUUFBUSw4RUFBOEU7QUFDOUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUssV0FBVyxlQUFlLEVBQUUsc0JBQXNCLFVBQVUsMkJBQTJCLGVBQWUsWUFBWTtBQUNySztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDhDQUE4QyxLQUFLLHVCQUF1QixPQUFPLGNBQWMsU0FBUyxzQkFBc0Isa0NBQWtDO0FBQ2hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsaUNBQWlDLGNBQWMsZ0RBQWdEO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxVQUFVO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwQkFBMEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxVQUFVO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLFFBQVEsRUFBQztBQUNtTTs7Ozs7Ozs7Ozs7O0FDNW9EM047QUFDQSxDQUFDOztBQUVEO0FBQ0EsbUJBQW1CLEtBQTBCOztBQUU3QztBQUNBLGtCQUFrQixLQUF5QjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLHFCQUFNLGdCQUFnQixxQkFBTTtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsOGlCQUE4aUIsd1pBQXdaLFdBQVc7O0FBRW4rQjtBQUNBO0FBQ0EsY0FBYztBQUNkLGFBQWE7QUFDYixlQUFlO0FBQ2YsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQSx3eGZBQXd4ZixpbkJBQWluQiw2QkFBNkIseUJBQXlCO0FBQy83Z0Isa0JBQWtCLDR0ZUFBNHRlLHdLQUF3SywydVpBQTJ1Wix3S0FBd0ssNmdGQUE2Z0Y7QUFDdHo5Qix3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDLG1CQUFtQixpQkFBaUI7QUFDcEMscUJBQXFCLE1BQU0sWUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsR0FBRztBQUMzQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLElBQUk7QUFDSixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUVVO0FBQ1o7QUFDQSxFQUFFLG1DQUFPO0FBQ1Q7QUFDQSxHQUFHO0FBQUEsa0dBQUM7QUFDSixHQUFHLEtBQUssWUFVTjs7QUFFRixDQUFDOzs7Ozs7Ozs7Ozs7QUN4VkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNLGFBQWEsT0FBTzs7QUFFcEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsRUFBRTs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmOztBQUVB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UixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFD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ZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxT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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLE1BQU07QUFDckIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLDBCQUEwQjtBQUN6QztBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxzQkFBc0I7QUFDckMsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsV0FBVztBQUNsQyxlQUFlLFNBQVM7QUFDeEI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsbUJBQW1CO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVEsSUFBSSxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVEsSUFBSSxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSw4QkFBOEIsbUJBQW1CLGlCQUFpQjtBQUNsRTtBQUNBO0FBQ0EsOEJBQThCLG1CQUFtQixpQkFBaUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtQkFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxtQkFBbUI7QUFDdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsZUFBZTtBQUNmO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsV0FBVztBQUMxQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxXQUFXO0FBQzFCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUSxJQUFJLFFBQVEsSUFBSSxRQUFRO0FBQ2xELGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFdBQVc7QUFDMUIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRLElBQUksUUFBUSxJQUFJLFFBQVE7QUFDbEQsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxzQkFBc0I7QUFDckMsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBLHNCQUFzQixRQUFRLE9BQU8sVUFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVEsSUFBSSxRQUFRLElBQUksUUFBUTtBQUNwRCxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU8sVUFBVSxJQUFJLE9BQU8sa0JBQWtCO0FBQ3RFLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDRCQUE0QjtBQUNsRCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHNDQUFzQyxvQkFBb0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsNEJBQTRCO0FBQ2xELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsMENBQTBDLG9CQUFvQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkJBQTJCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUSxPQUFPLFVBQVU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0IsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCLDhCQUE4QixnQkFBZ0IsUUFBUSxHQUFHO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsY0FBYztBQUM3QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQixRQUFRLEdBQUc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsY0FBYztBQUM3QixlQUFlLE1BQU07QUFDckIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBLHNCQUFzQixRQUFRLE9BQU8scUJBQXFCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0EsUUFBUTtBQUNSLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhCQUE4QjtBQUNwRCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHdDQUF3QyxlQUFlO0FBQ3ZELGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRLElBQUksUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUSxJQUFJLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRLGdCQUFnQixJQUFJLGdCQUFnQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsV0FBVztBQUMxQixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxzQkFBc0I7QUFDckMsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxzQkFBc0I7QUFDckMsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUSxPQUFPLGdDQUFnQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsY0FBYztBQUM3QixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLHNCQUFzQixRQUFRLE9BQU8sVUFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsY0FBYztBQUM3QixlQUFlLEdBQUc7QUFDbEIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBLFFBQVEsSUFBSTtBQUNaLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxjQUFjO0FBQzdCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUSxPQUFPLFVBQVU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVEsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUSxPQUFPLFVBQVU7QUFDL0M7QUFDQSxrREFBa0QsZUFBZTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsdUJBQXVCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxjQUFjO0FBQzdCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxLQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxpQkFBaUI7QUFDaEMsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZUFBZTtBQUM5QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRLFdBQVc7QUFDbEMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QyxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0EsdUVBQXVFLDBCQUEwQixHQUFHO0FBQ3BHLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTTtBQUNqRCxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxzREFBc0QsMEJBQTBCLEdBQUc7QUFDbkYseUNBQXlDLGFBQWEsZ0JBQWdCO0FBQ3RFLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EseURBQXlELG9DQUFvQztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxvQkFBb0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZELDJDQUEyQyxPQUFPO0FBQ2xELGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0IsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtQkFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLDZCQUE2QixFQUFFO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLGdDQUFnQyxnQ0FBZ0M7QUFDaEUsY0FBYztBQUNkO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSyxPQUFPLGdCQUFnQjs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNB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TDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7VUMvdkJEO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N6QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGlDQUFpQyxXQUFXO1dBQzVDO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEdBQUc7V0FDSDtXQUNBO1dBQ0EsQ0FBQzs7Ozs7V0NQRDs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7O1dDTkE7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNKb0Q7QUFDQTtBQUNaO0FBQ2dCO0FBQ1I7QUFDSTtBQUNFO0FBQ0g7QUFDQTtBQUNIO0FBQ2E7QUFDTDtBQUVqRCxJQUFNLElBQUksR0FBVyxzQkFBc0IsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dtX2NvbW1vbl92YXJpYWJsZXMvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL3dtX2NvbW1vbl92YXJpYWJsZXMvLi9ub2RlX21vZHVsZXMvQG1ldHJpY2hvci9qbWVzcGF0aC9kaXN0L2ptZXNwYXRoLmVzbS5qcyIsIndlYnBhY2s6Ly93bV9jb21tb25fdmFyaWFibGVzLy4vbm9kZV9tb2R1bGVzL2hlL2hlLmpzIiwid2VicGFjazovL3dtX2NvbW1vbl92YXJpYWJsZXMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2xvZGFzaC5qcyIsIndlYnBhY2s6Ly93bV9jb21tb25fdmFyaWFibGVzLy4vVXNlcnMvdmFzdW5kaGFyYWtfNTAwMzA3L1Zhc3VuZGhhcmFQcm9qZWN0cy93YXZlbWFrZXItc3R1ZGlvLWZyb250ZW5kL3dhdmVtYWtlci11aS12YXJpYWJsZXMvc3JjL2NvbnN0YW50cy92YXJpYWJsZXMuY29uc3RhbnRzLnRzIiwid2VicGFjazovL3dtX2NvbW1vbl92YXJpYWJsZXMvLi9Vc2Vycy92YXN1bmRoYXJha181MDAzMDcvVmFzdW5kaGFyYVByb2plY3RzL3dhdmVtYWtlci1zdHVkaW8tZnJvbnRlbmQvd2F2ZW1ha2VyLXVpLXZhcmlhYmxlcy9zcmMvZmFjdG9yeS92YXJpYWJsZS1tYW5hZ2VyLmZhY3RvcnkudHMiLCJ3ZWJwYWNrOi8vd21fY29tbW9uX3ZhcmlhYmxlcy8uL1VzZXJzL3Zhc3VuZGhhcmFrXzUwMDMwNy9WYXN1bmRoYXJhUHJvamVjdHMvd2F2ZW1ha2VyLXN0dWRpby1mcm9udGVuZC93YXZlbWFrZXItdWktdmFyaWFibGVzL3NyYy9tYW5hZ2VyL2FjdGlvbi90aW1lci1hY3Rpb24ubWFuYWdlci50cyIsIndlYnBhY2s6Ly93bV9jb21tb25fdmFyaWFibGVzLy4vVXNlcnMvdmFzdW5kaGFyYWtfNTAwMzA3L1Zhc3VuZGhhcmFQcm9qZWN0cy93YXZlbWFrZXItc3R1ZGlvLWZyb250ZW5kL3dhdmVtYWtlci11aS12YXJpYWJsZXMvc3JjL21hbmFnZXIvdmFyaWFibGUvYmFzZS12YXJpYWJsZS5tYW5hZ2VyLnRzIiwid2VicGFjazovL3dtX2NvbW1vbl92YXJpYWJsZXMvLi9Vc2Vycy92YXN1bmRoYXJha181MDAzMDcvVmFzdW5kaGFyYVByb2plY3RzL3dhdmVtYWtlci1zdHVkaW8tZnJvbnRlbmQvd2F2ZW1ha2VyLXVpLXZhcmlhYmxlcy9zcmMvbWFuYWdlci92YXJpYWJsZS9jcnVkLXZhcmlhYmxlLm1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vd21fY29tbW9uX3ZhcmlhYmxlcy8uL1VzZXJzL3Zhc3VuZGhhcmFrXzUwMDMwNy9WYXN1bmRoYXJhUHJvamVjdHMvd2F2ZW1ha2VyLXN0dWRpby1mcm9udGVuZC93YXZlbWFrZXItdWktdmFyaWFibGVzL3NyYy9tYW5hZ2VyL3ZhcmlhYmxlL2xpdmUtdmFyaWFibGUubWFuYWdlci50cyIsIndlYnBhY2s6Ly93bV9jb21tb25fdmFyaWFibGVzLy4vVXNlcnMvdmFzdW5kaGFyYWtfNTAwMzA3L1Zhc3VuZGhhcmFQcm9qZWN0cy93YXZlbWFrZXItc3R1ZGlvLWZyb250ZW5kL3dhdmVtYWtlci11aS12YXJpYWJsZXMvc3JjL21hbmFnZXIvdmFyaWFibGUvbW9kZWwtdmFyaWFibGUubWFuYWdlci50cyIsIndlYnBhY2s6Ly93bV9jb21tb25fdmFyaWFibGVzLy4vVXNlcnMvdmFzdW5kaGFyYWtfNTAwMzA3L1Zhc3VuZGhhcmFQcm9qZWN0cy93YXZlbWFrZXItc3R1ZGlvLWZyb250ZW5kL3dhdmVtYWtlci11aS12YXJpYWJsZXMvc3JjL21hbmFnZXIvdmFyaWFibGUvc2VydmljZS12YXJpYWJsZS5tYW5hZ2VyLnRzIiwid2VicGFjazovL3dtX2NvbW1vbl92YXJpYWJsZXMvLi9Vc2Vycy92YXN1bmRoYXJha181MDAzMDcvVmFzdW5kaGFyYVByb2plY3RzL3dhdmVtYWtlci1zdHVkaW8tZnJvbnRlbmQvd2F2ZW1ha2VyLXVpLXZhcmlhYmxlcy9zcmMvbW9kZWwvYWN0aW9uL3RpbWVyLWFjdGlvbi50cyIsIndlYnBhY2s6Ly93bV9jb21tb25fdmFyaWFibGVzLy4vVXNlcnMvdmFzdW5kaGFyYWtfNTAwMzA3L1Zhc3VuZGhhcmFQcm9qZWN0cy93YXZlbWFrZXItc3R1ZGlvLWZyb250ZW5kL3dhdmVtYWtlci11aS12YXJpYWJsZXMvc3JjL21vZGVsL2Jhc2UtYWN0aW9uLnRzIiwid2VicGFjazovL3dtX2NvbW1vbl92YXJpYWJsZXMvLi9Vc2Vycy92YXN1bmRoYXJha181MDAzMDcvVmFzdW5kaGFyYVByb2plY3RzL3dhdmVtYWtlci1zdHVkaW8tZnJvbnRlbmQvd2F2ZW1ha2VyLXVpLXZhcmlhYmxlcy9zcmMvbW9kZWwvYmFzZS12YXJpYWJsZS50cyIsIndlYnBhY2s6Ly93bV9jb21tb25fdmFyaWFibGVzLy4vVXNlcnMvdmFzdW5kaGFyYWtfNTAwMzA3L1Zhc3VuZGhhcmFQcm9qZWN0cy93YXZlbWFrZXItc3R1ZGlvLWZyb250ZW5kL3dhdmVtYWtlci11aS12YXJpYWJsZXMvc3JjL21vZGVsL2NydWQtY3JlYXRlLnRzIiwid2VicGFjazovL3dtX2NvbW1vbl92YXJpYWJsZXMvLi9Vc2Vycy92YXN1bmRoYXJha181MDAzMDcvVmFzdW5kaGFyYVByb2plY3RzL3dhdmVtYWtlci1zdHVkaW8tZnJvbnRlbmQvd2F2ZW1ha2VyLXVpLXZhcmlhYmxlcy9zcmMvbW9kZWwvY3J1ZC1kZWxldGUudHMiLCJ3ZWJwYWNrOi8vd21fY29tbW9uX3ZhcmlhYmxlcy8uL1VzZXJzL3Zhc3VuZGhhcmFrXzUwMDMwNy9WYXN1bmRoYXJhUHJvamVjdHMvd2F2ZW1ha2VyLXN0dWRpby1mcm9udGVuZC93YXZlbWFrZXItdWktdmFyaWFibGVzL3NyYy9tb2RlbC9jcnVkLWxpc3QudHMiLCJ3ZWJwYWNrOi8vd21fY29tbW9uX3ZhcmlhYmxlcy8uL1VzZXJzL3Zhc3VuZGhhcmFrXzUwMDMwNy9WYXN1bmRoYXJhUHJvamVjdHMvd2F2ZW1ha2VyLXN0dWRpby1mcm9udGVuZC93YXZlbWFrZXItdWktdmFyaWFibGVzL3NyYy9tb2RlbC9jcnVkLXVwZGF0ZS50cyIsIndlYnBhY2s6Ly93bV9jb21tb25fdmFyaWFibGVzLy4vVXNlcnMvdmFzdW5kaGFyYWtfNTAwMzA3L1Zhc3VuZGhhcmFQcm9qZWN0cy93YXZlbWFrZXItc3R1ZGlvLWZyb250ZW5kL3dhdmVtYWtlci11aS12YXJpYWJsZXMvc3JjL21vZGVsL3ZhcmlhYmxlL2FwaS1hd2FyZS12YXJpYWJsZS50cyIsIndlYnBhY2s6Ly93bV9jb21tb25fdmFyaWFibGVzLy4vVXNlcnMvdmFzdW5kaGFyYWtfNTAwMzA3L1Zhc3VuZGhhcmFQcm9qZWN0cy93YXZlbWFrZXItc3R1ZGlvLWZyb250ZW5kL3dhdmVtYWtlci11aS12YXJpYWJsZXMvc3JjL21vZGVsL3ZhcmlhYmxlL2NydWQtdmFyaWFibGUudHMiLCJ3ZWJwYWNrOi8vd21fY29tbW9uX3ZhcmlhYmxlcy8uL1VzZXJzL3Zhc3VuZGhhcmFrXzUwMDMwNy9WYXN1bmRoYXJhUHJvamVjdHMvd2F2ZW1ha2VyLXN0dWRpby1mcm9udGVuZC93YXZlbWFrZXItdWktdmFyaWFibGVzL3NyYy9tb2RlbC92YXJpYWJsZS9saXZlLXZhcmlhYmxlLnRzIiwid2VicGFjazovL3dtX2NvbW1vbl92YXJpYWJsZXMvLi9Vc2Vycy92YXN1bmRoYXJha181MDAzMDcvVmFzdW5kaGFyYVByb2plY3RzL3dhdmVtYWtlci1zdHVkaW8tZnJvbnRlbmQvd2F2ZW1ha2VyLXVpLXZhcmlhYmxlcy9zcmMvbW9kZWwvdmFyaWFibGUvbW9kZWwtdmFyaWFibGUudHMiLCJ3ZWJwYWNrOi8vd21fY29tbW9uX3ZhcmlhYmxlcy8uL1VzZXJzL3Zhc3VuZGhhcmFrXzUwMDMwNy9WYXN1bmRoYXJhUHJvamVjdHMvd2F2ZW1ha2VyLXN0dWRpby1mcm9udGVuZC93YXZlbWFrZXItdWktdmFyaWFibGVzL3NyYy9tb2RlbC92YXJpYWJsZS9zZXJ2aWNlLXZhcmlhYmxlLnRzIiwid2VicGFjazovL3dtX2NvbW1vbl92YXJpYWJsZXMvLi9Vc2Vycy92YXN1bmRoYXJha181MDAzMDcvVmFzdW5kaGFyYVByb2plY3RzL3dhdmVtYWtlci1zdHVkaW8tZnJvbnRlbmQvd2F2ZW1ha2VyLXVpLXZhcmlhYmxlcy9zcmMvdHlwZXMvZXZlbnQtbm90aWZpZXIudHMiLCJ3ZWJwYWNrOi8vd21fY29tbW9uX3ZhcmlhYmxlcy8uL1VzZXJzL3Zhc3VuZGhhcmFrXzUwMDMwNy9WYXN1bmRoYXJhUHJvamVjdHMvd2F2ZW1ha2VyLXN0dWRpby1mcm9udGVuZC93YXZlbWFrZXItdWktdmFyaWFibGVzL3NyYy90eXBlcy9odHRwLWNsaWVudC5zZXJ2aWNlLnRzIiwid2VicGFjazovL3dtX2NvbW1vbl92YXJpYWJsZXMvLi9Vc2Vycy92YXN1bmRoYXJha181MDAzMDcvVmFzdW5kaGFyYVByb2plY3RzL3dhdmVtYWtlci1zdHVkaW8tZnJvbnRlbmQvd2F2ZW1ha2VyLXVpLXZhcmlhYmxlcy9zcmMvdHlwZXMvdHlwZXMudHMiLCJ3ZWJwYWNrOi8vd21fY29tbW9uX3ZhcmlhYmxlcy8uL1VzZXJzL3Zhc3VuZGhhcmFrXzUwMDMwNy9WYXN1bmRoYXJhUHJvamVjdHMvd2F2ZW1ha2VyLXN0dWRpby1mcm9udGVuZC93YXZlbWFrZXItdWktdmFyaWFibGVzL3NyYy91dGlsL2RhdGFzZXQtdXRpbC50cyIsIndlYnBhY2s6Ly93bV9jb21tb25fdmFyaWFibGVzLy4vVXNlcnMvdmFzdW5kaGFyYWtfNTAwMzA3L1Zhc3VuZGhhcmFQcm9qZWN0cy93YXZlbWFrZXItc3R1ZGlvLWZyb250ZW5kL3dhdmVtYWtlci11aS12YXJpYWJsZXMvc3JjL3V0aWwvZmlsZS11cGxvYWQudXRpbC50cyIsIndlYnBhY2s6Ly93bV9jb21tb25fdmFyaWFibGVzLy4vVXNlcnMvdmFzdW5kaGFyYWtfNTAwMzA3L1Zhc3VuZGhhcmFQcm9qZWN0cy93YXZlbWFrZXItc3R1ZGlvLWZyb250ZW5kL3dhdmVtYWtlci11aS12YXJpYWJsZXMvc3JjL3V0aWwvaW5mbGlnaHQtcXVldWUudHMiLCJ3ZWJwYWNrOi8vd21fY29tbW9uX3ZhcmlhYmxlcy8uL1VzZXJzL3Zhc3VuZGhhcmFrXzUwMDMwNy9WYXN1bmRoYXJhUHJvamVjdHMvd2F2ZW1ha2VyLXN0dWRpby1mcm9udGVuZC93YXZlbWFrZXItdWktdmFyaWFibGVzL3NyYy91dGlsL25vdGlmeS1wcm9taXNlLnRzIiwid2VicGFjazovL3dtX2NvbW1vbl92YXJpYWJsZXMvLi9Vc2Vycy92YXN1bmRoYXJha181MDAzMDcvVmFzdW5kaGFyYVByb2plY3RzL3dhdmVtYWtlci1zdHVkaW8tZnJvbnRlbmQvd2F2ZW1ha2VyLXVpLXZhcmlhYmxlcy9zcmMvdXRpbC9vQXV0aC51dGlscy50cyIsIndlYnBhY2s6Ly93bV9jb21tb25fdmFyaWFibGVzLy4vVXNlcnMvdmFzdW5kaGFyYWtfNTAwMzA3L1Zhc3VuZGhhcmFQcm9qZWN0cy93YXZlbWFrZXItc3R1ZGlvLWZyb250ZW5kL3dhdmVtYWtlci11aS12YXJpYWJsZXMvc3JjL3V0aWwvdXRpbHMudHMiLCJ3ZWJwYWNrOi8vd21fY29tbW9uX3ZhcmlhYmxlcy8uL1VzZXJzL3Zhc3VuZGhhcmFrXzUwMDMwNy9WYXN1bmRoYXJhUHJvamVjdHMvd2F2ZW1ha2VyLXN0dWRpby1mcm9udGVuZC93YXZlbWFrZXItdWktdmFyaWFibGVzL3NyYy91dGlsL3ZhcmlhYmxlL2xpdmUtdmFyaWFibGUuaHR0cC51dGlscy50cyIsIndlYnBhY2s6Ly93bV9jb21tb25fdmFyaWFibGVzLy4vVXNlcnMvdmFzdW5kaGFyYWtfNTAwMzA3L1Zhc3VuZGhhcmFQcm9qZWN0cy93YXZlbWFrZXItc3R1ZGlvLWZyb250ZW5kL3dhdmVtYWtlci11aS12YXJpYWJsZXMvc3JjL3V0aWwvdmFyaWFibGUvbGl2ZS12YXJpYWJsZS51dGlscy50cyIsIndlYnBhY2s6Ly93bV9jb21tb25fdmFyaWFibGVzLy4vVXNlcnMvdmFzdW5kaGFyYWtfNTAwMzA3L1Zhc3VuZGhhcmFQcm9qZWN0cy93YXZlbWFrZXItc3R1ZGlvLWZyb250ZW5kL3dhdmVtYWtlci11aS12YXJpYWJsZXMvc3JjL3V0aWwvdmFyaWFibGUvcGFnaW5hdGlvbi51dGlscy50cyIsIndlYnBhY2s6Ly93bV9jb21tb25fdmFyaWFibGVzLy4vVXNlcnMvdmFzdW5kaGFyYWtfNTAwMzA3L1Zhc3VuZGhhcmFQcm9qZWN0cy93YXZlbWFrZXItc3R1ZGlvLWZyb250ZW5kL3dhdmVtYWtlci11aS12YXJpYWJsZXMvc3JjL3V0aWwvdmFyaWFibGUvc2VydmljZS12YXJpYWJsZS51dGlscy50cyIsIndlYnBhY2s6Ly93bV9jb21tb25fdmFyaWFibGVzLy4vVXNlcnMvdmFzdW5kaGFyYWtfNTAwMzA3L1Zhc3VuZGhhcmFQcm9qZWN0cy93YXZlbWFrZXItc3R1ZGlvLWZyb250ZW5kL3dhdmVtYWtlci11aS12YXJpYWJsZXMvc3JjL3V0aWwvdmFyaWFibGUvdmFyaWFibGVzLnV0aWxzLnRzIiwid2VicGFjazovL3dtX2NvbW1vbl92YXJpYWJsZXMvLi9ub2RlX21vZHVsZXMveDJqcy94MmpzLmpzIiwid2VicGFjazovL3dtX2NvbW1vbl92YXJpYWJsZXMvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vd21fY29tbW9uX3ZhcmlhYmxlcy93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly93bV9jb21tb25fdmFyaWFibGVzL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly93bV9jb21tb25fdmFyaWFibGVzL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vd21fY29tbW9uX3ZhcmlhYmxlcy93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3dtX2NvbW1vbl92YXJpYWJsZXMvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly93bV9jb21tb25fdmFyaWFibGVzL3dlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vd21fY29tbW9uX3ZhcmlhYmxlcy8uL1VzZXJzL3Zhc3VuZGhhcmFrXzUwMDMwNy9WYXN1bmRoYXJhUHJvamVjdHMvd2F2ZW1ha2VyLXN0dWRpby1mcm9udGVuZC93YXZlbWFrZXItdWktdmFyaWFibGVzL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIndtX2NvbW1vbl92YXJpYWJsZXNcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wid21fY29tbW9uX3ZhcmlhYmxlc1wiXSA9IGZhY3RvcnkoKTtcbn0pKHdpbmRvdywgKCkgPT4ge1xucmV0dXJuICIsImNvbnN0IGlzT2JqZWN0ID0gKG9iaikgPT4ge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufTtcbmNvbnN0IHN0cmljdERlZXBFcXVhbCA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gICAgaWYgKGZpcnN0ID09PSBzZWNvbmQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZmlyc3QgIT09IHR5cGVvZiBzZWNvbmQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaXJzdCkgJiYgQXJyYXkuaXNBcnJheShzZWNvbmQpKSB7XG4gICAgICAgIGlmIChmaXJzdC5sZW5ndGggIT09IHNlY29uZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpcnN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoIXN0cmljdERlZXBFcXVhbChmaXJzdFtpXSwgc2Vjb25kW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KGZpcnN0KSAmJiBpc09iamVjdChzZWNvbmQpKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0RW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGZpcnN0KTtcbiAgICAgICAgY29uc3Qgc2Vjb25kS2V5cyA9IG5ldyBTZXQoT2JqZWN0LmtleXMoc2Vjb25kKSk7XG4gICAgICAgIGlmIChmaXJzdEVudHJpZXMubGVuZ3RoICE9PSBzZWNvbmRLZXlzLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBmaXJzdEVudHJpZXMpIHtcbiAgICAgICAgICAgIGlmICghc3RyaWN0RGVlcEVxdWFsKHZhbHVlLCBzZWNvbmRba2V5XSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWNvbmRLZXlzLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWNvbmRLZXlzLnNpemUgPT09IDA7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBpc0ZhbHNlID0gKG9iaikgPT4ge1xuICAgIGlmIChvYmogPT09ICcnIHx8IG9iaiA9PT0gZmFsc2UgfHwgb2JqID09PSBudWxsIHx8IG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopICYmIG9iai5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChpc09iamVjdChvYmopKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgaXNBbHBoYSA9IChjaCkgPT4ge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogc3RyaWN0LWNvbXBhcmlzb25zXG4gICAgcmV0dXJuIChjaCA+PSAnYScgJiYgY2ggPD0gJ3onKSB8fCAoY2ggPj0gJ0EnICYmIGNoIDw9ICdaJykgfHwgY2ggPT09ICdfJztcbn07XG5jb25zdCBpc051bSA9IChjaCkgPT4ge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogc3RyaWN0LWNvbXBhcmlzb25zXG4gICAgcmV0dXJuIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB8fCBjaCA9PT0gJy0nO1xufTtcbmNvbnN0IGlzQWxwaGFOdW0gPSAoY2gpID0+IHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IHN0cmljdC1jb21wYXJpc29uc1xuICAgIHJldHVybiAoY2ggPj0gJ2EnICYmIGNoIDw9ICd6JykgfHwgKGNoID49ICdBJyAmJiBjaCA8PSAnWicpIHx8IChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB8fCBjaCA9PT0gJ18nO1xufTtcblxudmFyIFRva2VuO1xuKGZ1bmN0aW9uIChUb2tlbikge1xuICAgIFRva2VuW1wiVE9LX0VPRlwiXSA9IFwiRU9GXCI7XG4gICAgVG9rZW5bXCJUT0tfVU5RVU9URURJREVOVElGSUVSXCJdID0gXCJVbnF1b3RlZElkZW50aWZpZXJcIjtcbiAgICBUb2tlbltcIlRPS19RVU9URURJREVOVElGSUVSXCJdID0gXCJRdW90ZWRJZGVudGlmaWVyXCI7XG4gICAgVG9rZW5bXCJUT0tfUkJSQUNLRVRcIl0gPSBcIlJicmFja2V0XCI7XG4gICAgVG9rZW5bXCJUT0tfUlBBUkVOXCJdID0gXCJScGFyZW5cIjtcbiAgICBUb2tlbltcIlRPS19DT01NQVwiXSA9IFwiQ29tbWFcIjtcbiAgICBUb2tlbltcIlRPS19DT0xPTlwiXSA9IFwiQ29sb25cIjtcbiAgICBUb2tlbltcIlRPS19SQlJBQ0VcIl0gPSBcIlJicmFjZVwiO1xuICAgIFRva2VuW1wiVE9LX05VTUJFUlwiXSA9IFwiTnVtYmVyXCI7XG4gICAgVG9rZW5bXCJUT0tfQ1VSUkVOVFwiXSA9IFwiQ3VycmVudFwiO1xuICAgIFRva2VuW1wiVE9LX1JPT1RcIl0gPSBcIlJvb3RcIjtcbiAgICBUb2tlbltcIlRPS19FWFBSRUZcIl0gPSBcIkV4cHJlZlwiO1xuICAgIFRva2VuW1wiVE9LX1BJUEVcIl0gPSBcIlBpcGVcIjtcbiAgICBUb2tlbltcIlRPS19PUlwiXSA9IFwiT3JcIjtcbiAgICBUb2tlbltcIlRPS19BTkRcIl0gPSBcIkFuZFwiO1xuICAgIFRva2VuW1wiVE9LX0VRXCJdID0gXCJFUVwiO1xuICAgIFRva2VuW1wiVE9LX0dUXCJdID0gXCJHVFwiO1xuICAgIFRva2VuW1wiVE9LX0xUXCJdID0gXCJMVFwiO1xuICAgIFRva2VuW1wiVE9LX0dURVwiXSA9IFwiR1RFXCI7XG4gICAgVG9rZW5bXCJUT0tfTFRFXCJdID0gXCJMVEVcIjtcbiAgICBUb2tlbltcIlRPS19ORVwiXSA9IFwiTkVcIjtcbiAgICBUb2tlbltcIlRPS19GTEFUVEVOXCJdID0gXCJGbGF0dGVuXCI7XG4gICAgVG9rZW5bXCJUT0tfU1RBUlwiXSA9IFwiU3RhclwiO1xuICAgIFRva2VuW1wiVE9LX0ZJTFRFUlwiXSA9IFwiRmlsdGVyXCI7XG4gICAgVG9rZW5bXCJUT0tfRE9UXCJdID0gXCJEb3RcIjtcbiAgICBUb2tlbltcIlRPS19OT1RcIl0gPSBcIk5vdFwiO1xuICAgIFRva2VuW1wiVE9LX0xCUkFDRVwiXSA9IFwiTGJyYWNlXCI7XG4gICAgVG9rZW5bXCJUT0tfTEJSQUNLRVRcIl0gPSBcIkxicmFja2V0XCI7XG4gICAgVG9rZW5bXCJUT0tfTFBBUkVOXCJdID0gXCJMcGFyZW5cIjtcbiAgICBUb2tlbltcIlRPS19MSVRFUkFMXCJdID0gXCJMaXRlcmFsXCI7XG59KShUb2tlbiB8fCAoVG9rZW4gPSB7fSkpO1xuY29uc3QgYmFzaWNUb2tlbnMgPSB7XG4gICAgJygnOiBUb2tlbi5UT0tfTFBBUkVOLFxuICAgICcpJzogVG9rZW4uVE9LX1JQQVJFTixcbiAgICAnKic6IFRva2VuLlRPS19TVEFSLFxuICAgICcsJzogVG9rZW4uVE9LX0NPTU1BLFxuICAgICcuJzogVG9rZW4uVE9LX0RPVCxcbiAgICAnOic6IFRva2VuLlRPS19DT0xPTixcbiAgICAnQCc6IFRva2VuLlRPS19DVVJSRU5ULFxuICAgIFsnJCddOiBUb2tlbi5UT0tfUk9PVCxcbiAgICAnXSc6IFRva2VuLlRPS19SQlJBQ0tFVCxcbiAgICAneyc6IFRva2VuLlRPS19MQlJBQ0UsXG4gICAgJ30nOiBUb2tlbi5UT0tfUkJSQUNFLFxufTtcbmNvbnN0IG9wZXJhdG9yU3RhcnRUb2tlbiA9IHtcbiAgICAnISc6IHRydWUsXG4gICAgJzwnOiB0cnVlLFxuICAgICc9JzogdHJ1ZSxcbiAgICAnPic6IHRydWUsXG59O1xuY29uc3Qgc2tpcENoYXJzID0ge1xuICAgICdcXHQnOiB0cnVlLFxuICAgICdcXG4nOiB0cnVlLFxuICAgICdcXHInOiB0cnVlLFxuICAgICcgJzogdHJ1ZSxcbn07XG5jbGFzcyBTdHJlYW1MZXhlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSAwO1xuICAgIH1cbiAgICB0b2tlbml6ZShzdHJlYW0pIHtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSAwO1xuICAgICAgICBsZXQgc3RhcnQ7XG4gICAgICAgIGxldCBpZGVudGlmaWVyO1xuICAgICAgICBsZXQgdG9rZW47XG4gICAgICAgIHdoaWxlICh0aGlzLl9jdXJyZW50IDwgc3RyZWFtLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGlzQWxwaGEoc3RyZWFtW3RoaXMuX2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gdGhpcy5jb25zdW1lVW5xdW90ZWRJZGVudGlmaWVyKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uVE9LX1VOUVVPVEVESURFTlRJRklFUixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiYXNpY1Rva2Vuc1tzdHJlYW1bdGhpcy5fY3VycmVudF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLl9jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBiYXNpY1Rva2Vuc1tzdHJlYW1bdGhpcy5fY3VycmVudF1dLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3RyZWFtW3RoaXMuX2N1cnJlbnRdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTnVtKHN0cmVhbVt0aGlzLl9jdXJyZW50XSkpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuY29uc3VtZU51bWJlcihzdHJlYW0pO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmNvbnN1bWVMQnJhY2tldChzdHJlYW0pO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gdGhpcy5jb25zdW1lUXVvdGVkSWRlbnRpZmllcihzdHJlYW0pO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlRPS19RVU9URURJREVOVElGSUVSLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gYCdgKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSB0aGlzLmNvbnN1bWVSYXdTdHJpbmdMaXRlcmFsKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uVE9LX0xJVEVSQUwsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSAnYCcpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgbGl0ZXJhbCA9IHRoaXMuY29uc3VtZUxpdGVyYWwoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5UT0tfTElURVJBTCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxpdGVyYWwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcGVyYXRvclN0YXJ0VG9rZW5bc3RyZWFtW3RoaXMuX2N1cnJlbnRdXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmNvbnN1bWVPcGVyYXRvcihzdHJlYW0pO1xuICAgICAgICAgICAgICAgIHRva2VuICYmIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNraXBDaGFyc1tzdHJlYW1bdGhpcy5fY3VycmVudF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09ICcmJykge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50ICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gJyYnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goeyBzdGFydCwgdHlwZTogVG9rZW4uVE9LX0FORCwgdmFsdWU6ICcmJicgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7IHN0YXJ0LCB0eXBlOiBUb2tlbi5UT0tfRVhQUkVGLCB2YWx1ZTogJyYnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gJ3wnKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgKz0gMTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSAnfCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCArPSAxO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7IHN0YXJ0LCB0eXBlOiBUb2tlbi5UT0tfT1IsIHZhbHVlOiAnfHwnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goeyBzdGFydCwgdHlwZTogVG9rZW4uVE9LX1BJUEUsIHZhbHVlOiAnfCcgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYFVua25vd24gY2hhcmFjdGVyOiAke3N0cmVhbVt0aGlzLl9jdXJyZW50XX1gKTtcbiAgICAgICAgICAgICAgICBlcnJvci5uYW1lID0gJ0xleGVyRXJyb3InO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICAgIGNvbnN1bWVVbnF1b3RlZElkZW50aWZpZXIoc3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgdGhpcy5fY3VycmVudCArPSAxO1xuICAgICAgICB3aGlsZSAodGhpcy5fY3VycmVudCA8IHN0cmVhbS5sZW5ndGggJiYgaXNBbHBoYU51bShzdHJlYW1bdGhpcy5fY3VycmVudF0pKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmVhbS5zbGljZShzdGFydCwgdGhpcy5fY3VycmVudCk7XG4gICAgfVxuICAgIGNvbnN1bWVRdW90ZWRJZGVudGlmaWVyKHN0cmVhbSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgIHRoaXMuX2N1cnJlbnQgKz0gMTtcbiAgICAgICAgY29uc3QgbWF4TGVuZ3RoID0gc3RyZWFtLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSAhPT0gJ1wiJyAmJiB0aGlzLl9jdXJyZW50IDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoc3RyZWFtW2N1cnJlbnRdID09PSAnXFxcXCcgJiYgKHN0cmVhbVtjdXJyZW50ICsgMV0gPT09ICdcXFxcJyB8fCBzdHJlYW1bY3VycmVudCArIDFdID09PSAnXCInKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnQgKz0gMTtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyZWFtLnNsaWNlKHN0YXJ0LCB0aGlzLl9jdXJyZW50KSk7XG4gICAgfVxuICAgIGNvbnN1bWVSYXdTdHJpbmdMaXRlcmFsKHN0cmVhbSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgIHRoaXMuX2N1cnJlbnQgKz0gMTtcbiAgICAgICAgY29uc3QgbWF4TGVuZ3RoID0gc3RyZWFtLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSAhPT0gYCdgICYmIHRoaXMuX2N1cnJlbnQgPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgIGlmIChzdHJlYW1bY3VycmVudF0gPT09ICdcXFxcJyAmJiAoc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gJ1xcXFwnIHx8IHN0cmVhbVtjdXJyZW50ICsgMV0gPT09IGAnYCkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyZW50ICs9IDE7XG4gICAgICAgIGNvbnN0IGxpdGVyYWwgPSBzdHJlYW0uc2xpY2Uoc3RhcnQgKyAxLCB0aGlzLl9jdXJyZW50IC0gMSk7XG4gICAgICAgIHJldHVybiBsaXRlcmFsLnJlcGxhY2UoYFxcXFwnYCwgYCdgKTtcbiAgICB9XG4gICAgY29uc3VtZU51bWJlcihzdHJlYW0pIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICB0aGlzLl9jdXJyZW50ICs9IDE7XG4gICAgICAgIGNvbnN0IG1heExlbmd0aCA9IHN0cmVhbS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpc051bShzdHJlYW1bdGhpcy5fY3VycmVudF0pICYmIHRoaXMuX2N1cnJlbnQgPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlSW50KHN0cmVhbS5zbGljZShzdGFydCwgdGhpcy5fY3VycmVudCksIDEwKTtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIHZhbHVlLCB0eXBlOiBUb2tlbi5UT0tfTlVNQkVSIH07XG4gICAgfVxuICAgIGNvbnN1bWVMQnJhY2tldChzdHJlYW0pIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICB0aGlzLl9jdXJyZW50ICs9IDE7XG4gICAgICAgIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09ICc/Jykge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudCArPSAxO1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQsIHR5cGU6IFRva2VuLlRPS19GSUxURVIsIHZhbHVlOiAnWz8nIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gJ10nKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ICs9IDE7XG4gICAgICAgICAgICByZXR1cm4geyBzdGFydCwgdHlwZTogVG9rZW4uVE9LX0ZMQVRURU4sIHZhbHVlOiAnW10nIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIHR5cGU6IFRva2VuLlRPS19MQlJBQ0tFVCwgdmFsdWU6ICdbJyB9O1xuICAgIH1cbiAgICBjb25zdW1lT3BlcmF0b3Ioc3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgY29uc3Qgc3RhcnRpbmdDaGFyID0gc3RyZWFtW3N0YXJ0XTtcbiAgICAgICAgdGhpcy5fY3VycmVudCArPSAxO1xuICAgICAgICBpZiAoc3RhcnRpbmdDaGFyID09PSAnIScpIHtcbiAgICAgICAgICAgIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09ICc9Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgKz0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGFydCwgdHlwZTogVG9rZW4uVE9LX05FLCB2YWx1ZTogJyE9JyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQsIHR5cGU6IFRva2VuLlRPS19OT1QsIHZhbHVlOiAnIScgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRpbmdDaGFyID09PSAnPCcpIHtcbiAgICAgICAgICAgIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09ICc9Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgKz0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGFydCwgdHlwZTogVG9rZW4uVE9LX0xURSwgdmFsdWU6ICc8PScgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0LCB0eXBlOiBUb2tlbi5UT0tfTFQsIHZhbHVlOiAnPCcgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRpbmdDaGFyID09PSAnPicpIHtcbiAgICAgICAgICAgIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09ICc9Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgKz0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGFydCwgdHlwZTogVG9rZW4uVE9LX0dURSwgdmFsdWU6ICc+PScgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0LCB0eXBlOiBUb2tlbi5UT0tfR1QsIHZhbHVlOiAnPicgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRpbmdDaGFyID09PSAnPScgJiYgc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSAnPScpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgKz0gMTtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0LCB0eXBlOiBUb2tlbi5UT0tfRVEsIHZhbHVlOiAnPT0nIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3VtZUxpdGVyYWwoc3RyZWFtKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnQgKz0gMTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICBjb25zdCBtYXhMZW5ndGggPSBzdHJlYW0ubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdICE9PSAnYCcgJiYgdGhpcy5fY3VycmVudCA8IG1heExlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgaWYgKHN0cmVhbVtjdXJyZW50XSA9PT0gJ1xcXFwnICYmIChzdHJlYW1bY3VycmVudCArIDFdID09PSAnXFxcXCcgfHwgc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gJ2AnKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIGxldCBsaXRlcmFsU3RyaW5nID0gc3RyZWFtLnNsaWNlKHN0YXJ0LCB0aGlzLl9jdXJyZW50KS50cmltTGVmdCgpO1xuICAgICAgICBsaXRlcmFsU3RyaW5nID0gbGl0ZXJhbFN0cmluZy5yZXBsYWNlKCdcXFxcYCcsICdgJyk7XG4gICAgICAgIGNvbnN0IGxpdGVyYWwgPSB0aGlzLmxvb2tzTGlrZUpTT04obGl0ZXJhbFN0cmluZylcbiAgICAgICAgICAgID8gSlNPTi5wYXJzZShsaXRlcmFsU3RyaW5nKVxuICAgICAgICAgICAgOiBKU09OLnBhcnNlKGBcIiR7bGl0ZXJhbFN0cmluZ31cImApO1xuICAgICAgICB0aGlzLl9jdXJyZW50ICs9IDE7XG4gICAgICAgIHJldHVybiBsaXRlcmFsO1xuICAgIH1cbiAgICBsb29rc0xpa2VKU09OKGxpdGVyYWxTdHJpbmcpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRpbmdDaGFycyA9ICdbe1wiJztcbiAgICAgICAgY29uc3QganNvbkxpdGVyYWxzID0gWyd0cnVlJywgJ2ZhbHNlJywgJ251bGwnXTtcbiAgICAgICAgY29uc3QgbnVtYmVyTG9va2luZyA9ICctMDEyMzQ1Njc4OSc7XG4gICAgICAgIGlmIChsaXRlcmFsU3RyaW5nID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydGluZ0NoYXJzLmluY2x1ZGVzKGxpdGVyYWxTdHJpbmdbMF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoanNvbkxpdGVyYWxzLmluY2x1ZGVzKGxpdGVyYWxTdHJpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtYmVyTG9va2luZy5pbmNsdWRlcyhsaXRlcmFsU3RyaW5nWzBdKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBKU09OLnBhcnNlKGxpdGVyYWxTdHJpbmcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jb25zdCBMZXhlciA9IG5ldyBTdHJlYW1MZXhlcigpO1xuXG5jb25zdCBiaW5kaW5nUG93ZXIgPSB7XG4gICAgW1Rva2VuLlRPS19FT0ZdOiAwLFxuICAgIFtUb2tlbi5UT0tfVU5RVU9URURJREVOVElGSUVSXTogMCxcbiAgICBbVG9rZW4uVE9LX1FVT1RFRElERU5USUZJRVJdOiAwLFxuICAgIFtUb2tlbi5UT0tfUkJSQUNLRVRdOiAwLFxuICAgIFtUb2tlbi5UT0tfUlBBUkVOXTogMCxcbiAgICBbVG9rZW4uVE9LX0NPTU1BXTogMCxcbiAgICBbVG9rZW4uVE9LX1JCUkFDRV06IDAsXG4gICAgW1Rva2VuLlRPS19OVU1CRVJdOiAwLFxuICAgIFtUb2tlbi5UT0tfQ1VSUkVOVF06IDAsXG4gICAgW1Rva2VuLlRPS19FWFBSRUZdOiAwLFxuICAgIFtUb2tlbi5UT0tfUk9PVF06IDAsXG4gICAgW1Rva2VuLlRPS19QSVBFXTogMSxcbiAgICBbVG9rZW4uVE9LX09SXTogMixcbiAgICBbVG9rZW4uVE9LX0FORF06IDMsXG4gICAgW1Rva2VuLlRPS19FUV06IDUsXG4gICAgW1Rva2VuLlRPS19HVF06IDUsXG4gICAgW1Rva2VuLlRPS19MVF06IDUsXG4gICAgW1Rva2VuLlRPS19HVEVdOiA1LFxuICAgIFtUb2tlbi5UT0tfTFRFXTogNSxcbiAgICBbVG9rZW4uVE9LX05FXTogNSxcbiAgICBbVG9rZW4uVE9LX0ZMQVRURU5dOiA5LFxuICAgIFtUb2tlbi5UT0tfU1RBUl06IDIwLFxuICAgIFtUb2tlbi5UT0tfRklMVEVSXTogMjEsXG4gICAgW1Rva2VuLlRPS19ET1RdOiA0MCxcbiAgICBbVG9rZW4uVE9LX05PVF06IDQ1LFxuICAgIFtUb2tlbi5UT0tfTEJSQUNFXTogNTAsXG4gICAgW1Rva2VuLlRPS19MQlJBQ0tFVF06IDU1LFxuICAgIFtUb2tlbi5UT0tfTFBBUkVOXTogNjAsXG59O1xuY2xhc3MgVG9rZW5QYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICB9XG4gICAgcGFyc2UoZXhwcmVzc2lvbikge1xuICAgICAgICB0aGlzLmxvYWRUb2tlbnMoZXhwcmVzc2lvbik7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICBjb25zdCBhc3QgPSB0aGlzLmV4cHJlc3Npb24oMCk7XG4gICAgICAgIGlmICh0aGlzLmxvb2thaGVhZCgwKSAhPT0gVG9rZW4uVE9LX0VPRikge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmxvb2thaGVhZFRva2VuKDApO1xuICAgICAgICAgICAgdGhpcy5lcnJvclRva2VuKHRva2VuLCBgVW5leHBlY3RlZCB0b2tlbiB0eXBlOiAke3Rva2VuLnR5cGV9LCB2YWx1ZTogJHt0b2tlbi52YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICBsb2FkVG9rZW5zKGV4cHJlc3Npb24pIHtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBbLi4uTGV4ZXIudG9rZW5pemUoZXhwcmVzc2lvbiksIHsgdHlwZTogVG9rZW4uVE9LX0VPRiwgdmFsdWU6ICcnLCBzdGFydDogZXhwcmVzc2lvbi5sZW5ndGggfV07XG4gICAgfVxuICAgIGV4cHJlc3Npb24ocmJwKSB7XG4gICAgICAgIGNvbnN0IGxlZnRUb2tlbiA9IHRoaXMubG9va2FoZWFkVG9rZW4oMCk7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubnVkKGxlZnRUb2tlbik7XG4gICAgICAgIGxldCBjdXJyZW50VG9rZW5UeXBlID0gdGhpcy5sb29rYWhlYWQoMCk7XG4gICAgICAgIHdoaWxlIChyYnAgPCBiaW5kaW5nUG93ZXJbY3VycmVudFRva2VuVHlwZV0pIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgbGVmdCA9IHRoaXMubGVkKGN1cnJlbnRUb2tlblR5cGUsIGxlZnQpO1xuICAgICAgICAgICAgY3VycmVudFRva2VuVHlwZSA9IHRoaXMubG9va2FoZWFkKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgIH1cbiAgICBsb29rYWhlYWQob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLmluZGV4ICsgb2Zmc2V0XS50eXBlO1xuICAgIH1cbiAgICBsb29rYWhlYWRUb2tlbihvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMuaW5kZXggKyBvZmZzZXRdO1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICB0aGlzLmluZGV4ICs9IDE7XG4gICAgfVxuICAgIG51ZCh0b2tlbikge1xuICAgICAgICBsZXQgbGVmdDtcbiAgICAgICAgbGV0IHJpZ2h0O1xuICAgICAgICBsZXQgZXhwcmVzc2lvbjtcbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFRva2VuLlRPS19MSVRFUkFMOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdMaXRlcmFsJywgdmFsdWU6IHRva2VuLnZhbHVlIH07XG4gICAgICAgICAgICBjYXNlIFRva2VuLlRPS19VTlFVT1RFRElERU5USUZJRVI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ0ZpZWxkJywgbmFtZTogdG9rZW4udmFsdWUgfTtcbiAgICAgICAgICAgIGNhc2UgVG9rZW4uVE9LX1FVT1RFRElERU5USUZJRVI6XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHsgdHlwZTogJ0ZpZWxkJywgbmFtZTogdG9rZW4udmFsdWUgfTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQoMCkgPT09IFRva2VuLlRPS19MUEFSRU4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdW90ZWQgaWRlbnRpZmllciBub3QgYWxsb3dlZCBmb3IgZnVuY3Rpb24gbmFtZXMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFRva2VuLlRPS19OT1Q6XG4gICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyLk5vdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ05vdEV4cHJlc3Npb24nLCBjaGlsZHJlbjogW3JpZ2h0XSB9O1xuICAgICAgICAgICAgY2FzZSBUb2tlbi5UT0tfU1RBUjpcbiAgICAgICAgICAgICAgICBsZWZ0ID0geyB0eXBlOiAnSWRlbnRpdHknIH07XG4gICAgICAgICAgICAgICAgcmlnaHQgPVxuICAgICAgICAgICAgICAgICAgICAodGhpcy5sb29rYWhlYWQoMCkgPT09IFRva2VuLlRPS19SQlJBQ0tFVCAmJiB7IHR5cGU6ICdJZGVudGl0eScgfSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5TdGFyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnVmFsdWVQcm9qZWN0aW9uJywgY2hpbGRyZW46IFtsZWZ0LCByaWdodF0gfTtcbiAgICAgICAgICAgIGNhc2UgVG9rZW4uVE9LX0ZJTFRFUjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZWQodG9rZW4udHlwZSwgeyB0eXBlOiAnSWRlbnRpdHknIH0pO1xuICAgICAgICAgICAgY2FzZSBUb2tlbi5UT0tfTEJSQUNFOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTXVsdGlzZWxlY3RIYXNoKCk7XG4gICAgICAgICAgICBjYXNlIFRva2VuLlRPS19GTEFUVEVOOlxuICAgICAgICAgICAgICAgIGxlZnQgPSB7IHR5cGU6IFRva2VuLlRPS19GTEFUVEVOLCBjaGlsZHJlbjogW3sgdHlwZTogJ0lkZW50aXR5JyB9XSB9O1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZVByb2plY3Rpb25SSFMoYmluZGluZ1Bvd2VyLkZsYXR0ZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdQcm9qZWN0aW9uJywgY2hpbGRyZW46IFtsZWZ0LCByaWdodF0gfTtcbiAgICAgICAgICAgIGNhc2UgVG9rZW4uVE9LX0xCUkFDS0VUOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZCgwKSA9PT0gVG9rZW4uVE9LX05VTUJFUiB8fCB0aGlzLmxvb2thaGVhZCgwKSA9PT0gVG9rZW4uVE9LX0NPTE9OKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUluZGV4RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0SWZTbGljZSh7IHR5cGU6ICdJZGVudGl0eScgfSwgcmlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQoMCkgPT09IFRva2VuLlRPS19TVEFSICYmIHRoaXMubG9va2FoZWFkKDEpID09PSBUb2tlbi5UT0tfUkJSQUNLRVQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5TdGFyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbeyB0eXBlOiAnSWRlbnRpdHknIH0sIHJpZ2h0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdQcm9qZWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VNdWx0aXNlbGVjdExpc3QoKTtcbiAgICAgICAgICAgIGNhc2UgVG9rZW4uVE9LX0NVUlJFTlQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogVG9rZW4uVE9LX0NVUlJFTlQgfTtcbiAgICAgICAgICAgIGNhc2UgVG9rZW4uVE9LX1JPT1Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogVG9rZW4uVE9LX1JPT1QgfTtcbiAgICAgICAgICAgIGNhc2UgVG9rZW4uVE9LX0VYUFJFRjpcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uKGJpbmRpbmdQb3dlci5FeHByZWYpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdFeHByZXNzaW9uUmVmZXJlbmNlJywgY2hpbGRyZW46IFtleHByZXNzaW9uXSB9O1xuICAgICAgICAgICAgY2FzZSBUb2tlbi5UT0tfTFBBUkVOOlxuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQoMCkgIT09IFRva2VuLlRPS19SUEFSRU4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkKDApID09PSBUb2tlbi5UT0tfQ1VSUkVOVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHsgdHlwZTogVG9rZW4uVE9LX0NVUlJFTlQgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goVG9rZW4uVE9LX1JQQVJFTik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JUb2tlbih0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGVkKHRva2VuTmFtZSwgbGVmdCkge1xuICAgICAgICBsZXQgcmlnaHQ7XG4gICAgICAgIHN3aXRjaCAodG9rZW5OYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFRva2VuLlRPS19ET1Q6XG4gICAgICAgICAgICAgICAgY29uc3QgcmJwID0gYmluZGluZ1Bvd2VyLkRvdDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQoMCkgIT09IFRva2VuLlRPS19TVEFSKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZURvdFJIUyhyYnApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnU3ViZXhwcmVzc2lvbicsIGNoaWxkcmVuOiBbbGVmdCwgcmlnaHRdIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZVByb2plY3Rpb25SSFMocmJwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnVmFsdWVQcm9qZWN0aW9uJywgY2hpbGRyZW46IFtsZWZ0LCByaWdodF0gfTtcbiAgICAgICAgICAgIGNhc2UgVG9rZW4uVE9LX1BJUEU6XG4gICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyLlBpcGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFRva2VuLlRPS19QSVBFLCBjaGlsZHJlbjogW2xlZnQsIHJpZ2h0XSB9O1xuICAgICAgICAgICAgY2FzZSBUb2tlbi5UT0tfT1I6XG4gICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyLk9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnT3JFeHByZXNzaW9uJywgY2hpbGRyZW46IFtsZWZ0LCByaWdodF0gfTtcbiAgICAgICAgICAgIGNhc2UgVG9rZW4uVE9LX0FORDpcbiAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMuZXhwcmVzc2lvbihiaW5kaW5nUG93ZXIuQW5kKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnQW5kRXhwcmVzc2lvbicsIGNoaWxkcmVuOiBbbGVmdCwgcmlnaHRdIH07XG4gICAgICAgICAgICBjYXNlIFRva2VuLlRPS19MUEFSRU46XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGxlZnQubmFtZTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IGV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMubG9va2FoZWFkKDApICE9PSBUb2tlbi5UT0tfUlBBUkVOKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZCgwKSA9PT0gVG9rZW4uVE9LX0NVUlJFTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSB7IHR5cGU6IFRva2VuLlRPS19DVVJSRU5UIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkKDApID09PSBUb2tlbi5UT0tfQ09NTUEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goVG9rZW4uVE9LX0NPTU1BKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goVG9rZW4uVE9LX1JQQVJFTik7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHsgbmFtZSwgdHlwZTogJ0Z1bmN0aW9uJywgY2hpbGRyZW46IGFyZ3MgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIGNhc2UgVG9rZW4uVE9LX0ZJTFRFUjpcbiAgICAgICAgICAgICAgICBjb25zdCBjb25kaXRpb24gPSB0aGlzLmV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaChUb2tlbi5UT0tfUkJSQUNLRVQpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID1cbiAgICAgICAgICAgICAgICAgICAgKHRoaXMubG9va2FoZWFkKDApID09PSBUb2tlbi5UT0tfRkxBVFRFTiAmJiB7IHR5cGU6ICdJZGVudGl0eScgfSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5GaWx0ZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdGaWx0ZXJQcm9qZWN0aW9uJywgY2hpbGRyZW46IFtsZWZ0LCByaWdodCwgY29uZGl0aW9uXSB9O1xuICAgICAgICAgICAgY2FzZSBUb2tlbi5UT0tfRkxBVFRFTjpcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0Tm9kZSA9IHsgdHlwZTogVG9rZW4uVE9LX0ZMQVRURU4sIGNoaWxkcmVuOiBbbGVmdF0gfTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodE5vZGUgPSB0aGlzLnBhcnNlUHJvamVjdGlvblJIUyhiaW5kaW5nUG93ZXIuRmxhdHRlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ1Byb2plY3Rpb24nLCBjaGlsZHJlbjogW2xlZnROb2RlLCByaWdodE5vZGVdIH07XG4gICAgICAgICAgICBjYXNlIFRva2VuLlRPS19FUTpcbiAgICAgICAgICAgIGNhc2UgVG9rZW4uVE9LX05FOlxuICAgICAgICAgICAgY2FzZSBUb2tlbi5UT0tfR1Q6XG4gICAgICAgICAgICBjYXNlIFRva2VuLlRPS19HVEU6XG4gICAgICAgICAgICBjYXNlIFRva2VuLlRPS19MVDpcbiAgICAgICAgICAgIGNhc2UgVG9rZW4uVE9LX0xURTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNvbXBhcmF0b3IobGVmdCwgdG9rZW5OYW1lKTtcbiAgICAgICAgICAgIGNhc2UgVG9rZW4uVE9LX0xCUkFDS0VUOlxuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5sb29rYWhlYWRUb2tlbigwKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uVE9LX05VTUJFUiB8fCB0b2tlbi50eXBlID09PSBUb2tlbi5UT0tfQ09MT04pIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcnNlSW5kZXhFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2plY3RJZlNsaWNlKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaChUb2tlbi5UT0tfU1RBUik7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaChUb2tlbi5UT0tfUkJSQUNLRVQpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZVByb2plY3Rpb25SSFMoYmluZGluZ1Bvd2VyLlN0YXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdQcm9qZWN0aW9uJywgY2hpbGRyZW46IFtsZWZ0LCByaWdodF0gfTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JUb2tlbih0aGlzLmxvb2thaGVhZFRva2VuKDApKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXRjaCh0b2tlblR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkKDApID09PSB0b2tlblR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmxvb2thaGVhZFRva2VuKDApO1xuICAgICAgICAgICAgdGhpcy5lcnJvclRva2VuKHRva2VuLCBgRXhwZWN0ZWQgJHt0b2tlblR5cGV9LCBnb3Q6ICR7dG9rZW4udHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlcnJvclRva2VuKHRva2VuLCBtZXNzYWdlID0gJycpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSB8fCBgSW52YWxpZCB0b2tlbiAoJHt0b2tlbi50eXBlfSk6IFwiJHt0b2tlbi52YWx1ZX1cImApO1xuICAgICAgICBlcnJvci5uYW1lID0gJ1BhcnNlckVycm9yJztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHBhcnNlSW5kZXhFeHByZXNzaW9uKCkge1xuICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQoMCkgPT09IFRva2VuLlRPS19DT0xPTiB8fCB0aGlzLmxvb2thaGVhZCgxKSA9PT0gVG9rZW4uVE9LX0NPTE9OKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNsaWNlRXhwcmVzc2lvbigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgICAgICB0eXBlOiAnSW5kZXgnLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMubG9va2FoZWFkVG9rZW4oMCkudmFsdWUsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICB0aGlzLm1hdGNoKFRva2VuLlRPS19SQlJBQ0tFVCk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBwcm9qZWN0SWZTbGljZShsZWZ0LCByaWdodCkge1xuICAgICAgICBjb25zdCBpbmRleEV4cHIgPSB7IHR5cGU6ICdJbmRleEV4cHJlc3Npb24nLCBjaGlsZHJlbjogW2xlZnQsIHJpZ2h0XSB9O1xuICAgICAgICBpZiAocmlnaHQudHlwZSA9PT0gJ1NsaWNlJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW2luZGV4RXhwciwgdGhpcy5wYXJzZVByb2plY3Rpb25SSFMoYmluZGluZ1Bvd2VyLlN0YXIpXSxcbiAgICAgICAgICAgICAgICB0eXBlOiAnUHJvamVjdGlvbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleEV4cHI7XG4gICAgfVxuICAgIHBhcnNlU2xpY2VFeHByZXNzaW9uKCkge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IFtudWxsLCBudWxsLCBudWxsXTtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnRUb2tlblR5cGUgPSB0aGlzLmxvb2thaGVhZCgwKTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRUb2tlblR5cGUgIT09IFRva2VuLlRPS19SQlJBQ0tFVCAmJiBpbmRleCA8IDMpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VG9rZW5UeXBlID09PSBUb2tlbi5UT0tfQ09MT04pIHtcbiAgICAgICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudFRva2VuVHlwZSA9PT0gVG9rZW4uVE9LX05VTUJFUikge1xuICAgICAgICAgICAgICAgIHBhcnRzW2luZGV4XSA9IHRoaXMubG9va2FoZWFkVG9rZW4oMCkudmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMubG9va2FoZWFkVG9rZW4oMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvclRva2VuKHRva2VuLCBgU3ludGF4IGVycm9yLCB1bmV4cGVjdGVkIHRva2VuOiAke3Rva2VuLnZhbHVlfSgke3Rva2VuLnR5cGV9KWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFRva2VuVHlwZSA9IHRoaXMubG9va2FoZWFkKDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWF0Y2goVG9rZW4uVE9LX1JCUkFDS0VUKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBwYXJ0cyxcbiAgICAgICAgICAgIHR5cGU6ICdTbGljZScsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHBhcnNlQ29tcGFyYXRvcihsZWZ0LCBjb21wYXJhdG9yKSB7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5leHByZXNzaW9uKGJpbmRpbmdQb3dlcltjb21wYXJhdG9yXSk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdDb21wYXJhdG9yJywgbmFtZTogY29tcGFyYXRvciwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF0gfTtcbiAgICB9XG4gICAgcGFyc2VEb3RSSFMocmJwKSB7XG4gICAgICAgIGNvbnN0IGxvb2thaGVhZCA9IHRoaXMubG9va2FoZWFkKDApO1xuICAgICAgICBjb25zdCBleHByVG9rZW5zID0gW1Rva2VuLlRPS19VTlFVT1RFRElERU5USUZJRVIsIFRva2VuLlRPS19RVU9URURJREVOVElGSUVSLCBUb2tlbi5UT0tfU1RBUl07XG4gICAgICAgIGlmIChleHByVG9rZW5zLmluY2x1ZGVzKGxvb2thaGVhZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24ocmJwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9va2FoZWFkID09PSBUb2tlbi5UT0tfTEJSQUNLRVQpIHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goVG9rZW4uVE9LX0xCUkFDS0VUKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTXVsdGlzZWxlY3RMaXN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvb2thaGVhZCA9PT0gVG9rZW4uVE9LX0xCUkFDRSkge1xuICAgICAgICAgICAgdGhpcy5tYXRjaChUb2tlbi5UT0tfTEJSQUNFKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTXVsdGlzZWxlY3RIYXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmxvb2thaGVhZFRva2VuKDApO1xuICAgICAgICB0aGlzLmVycm9yVG9rZW4odG9rZW4sIGBTeW50YXggZXJyb3IsIHVuZXhwZWN0ZWQgdG9rZW46ICR7dG9rZW4udmFsdWV9KCR7dG9rZW4udHlwZX0pYCk7XG4gICAgfVxuICAgIHBhcnNlUHJvamVjdGlvblJIUyhyYnApIHtcbiAgICAgICAgaWYgKGJpbmRpbmdQb3dlclt0aGlzLmxvb2thaGVhZCgwKV0gPCAxMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ0lkZW50aXR5JyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxvb2thaGVhZCgwKSA9PT0gVG9rZW4uVE9LX0xCUkFDS0VUKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uKHJicCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkKDApID09PSBUb2tlbi5UT0tfRklMVEVSKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uKHJicCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkKDApID09PSBUb2tlbi5UT0tfRE9UKSB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKFRva2VuLlRPS19ET1QpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VEb3RSSFMocmJwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMubG9va2FoZWFkVG9rZW4oMCk7XG4gICAgICAgIHRoaXMuZXJyb3JUb2tlbih0b2tlbiwgYFN5bnRheCBlcnJvciwgdW5leHBlY3RlZCB0b2tlbjogJHt0b2tlbi52YWx1ZX0oJHt0b2tlbi50eXBlfSlgKTtcbiAgICB9XG4gICAgcGFyc2VNdWx0aXNlbGVjdExpc3QoKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25zID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLmxvb2thaGVhZCgwKSAhPT0gVG9rZW4uVE9LX1JCUkFDS0VUKSB7XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uKDApO1xuICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChleHByZXNzaW9uKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZCgwKSA9PT0gVG9rZW4uVE9LX0NPTU1BKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaChUb2tlbi5UT0tfQ09NTUEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZCgwKSA9PT0gVG9rZW4uVE9LX1JCUkFDS0VUKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCB0b2tlbiBSYnJhY2tldCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hdGNoKFRva2VuLlRPS19SQlJBQ0tFVCk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdNdWx0aVNlbGVjdExpc3QnLCBjaGlsZHJlbjogZXhwcmVzc2lvbnMgfTtcbiAgICB9XG4gICAgcGFyc2VNdWx0aXNlbGVjdEhhc2goKSB7XG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXJUeXBlcyA9IFtUb2tlbi5UT0tfVU5RVU9URURJREVOVElGSUVSLCBUb2tlbi5UT0tfUVVPVEVESURFTlRJRklFUl07XG4gICAgICAgIGxldCBrZXlUb2tlbjtcbiAgICAgICAgbGV0IGtleU5hbWU7XG4gICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBwcmV0dGllclxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBrZXlUb2tlbiA9IHRoaXMubG9va2FoZWFkVG9rZW4oMCk7XG4gICAgICAgICAgICBpZiAoIWlkZW50aWZpZXJUeXBlcy5pbmNsdWRlcyhrZXlUb2tlbi50eXBlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0aW5nIGFuIGlkZW50aWZpZXIgdG9rZW4sIGdvdDogJHtrZXlUb2tlbi50eXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5TmFtZSA9IGtleVRva2VuLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKFRva2VuLlRPS19DT0xPTik7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goeyB2YWx1ZSwgdHlwZTogJ0tleVZhbHVlUGFpcicsIG5hbWU6IGtleU5hbWUgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQoMCkgPT09IFRva2VuLlRPS19DT01NQSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goVG9rZW4uVE9LX0NPTU1BKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubG9va2FoZWFkKDApID09PSBUb2tlbi5UT0tfUkJSQUNFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaChUb2tlbi5UT0tfUkJSQUNFKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0eXBlOiAnTXVsdGlTZWxlY3RIYXNoJywgY2hpbGRyZW46IHBhaXJzIH07XG4gICAgfVxufVxuY29uc3QgUGFyc2VyID0gbmV3IFRva2VuUGFyc2VyKCk7XG5cbnZhciBJbnB1dEFyZ3VtZW50O1xuKGZ1bmN0aW9uIChJbnB1dEFyZ3VtZW50KSB7XG4gICAgSW5wdXRBcmd1bWVudFtJbnB1dEFyZ3VtZW50W1wiVFlQRV9OVU1CRVJcIl0gPSAwXSA9IFwiVFlQRV9OVU1CRVJcIjtcbiAgICBJbnB1dEFyZ3VtZW50W0lucHV0QXJndW1lbnRbXCJUWVBFX0FOWVwiXSA9IDFdID0gXCJUWVBFX0FOWVwiO1xuICAgIElucHV0QXJndW1lbnRbSW5wdXRBcmd1bWVudFtcIlRZUEVfU1RSSU5HXCJdID0gMl0gPSBcIlRZUEVfU1RSSU5HXCI7XG4gICAgSW5wdXRBcmd1bWVudFtJbnB1dEFyZ3VtZW50W1wiVFlQRV9BUlJBWVwiXSA9IDNdID0gXCJUWVBFX0FSUkFZXCI7XG4gICAgSW5wdXRBcmd1bWVudFtJbnB1dEFyZ3VtZW50W1wiVFlQRV9PQkpFQ1RcIl0gPSA0XSA9IFwiVFlQRV9PQkpFQ1RcIjtcbiAgICBJbnB1dEFyZ3VtZW50W0lucHV0QXJndW1lbnRbXCJUWVBFX0JPT0xFQU5cIl0gPSA1XSA9IFwiVFlQRV9CT09MRUFOXCI7XG4gICAgSW5wdXRBcmd1bWVudFtJbnB1dEFyZ3VtZW50W1wiVFlQRV9FWFBSRUZcIl0gPSA2XSA9IFwiVFlQRV9FWFBSRUZcIjtcbiAgICBJbnB1dEFyZ3VtZW50W0lucHV0QXJndW1lbnRbXCJUWVBFX05VTExcIl0gPSA3XSA9IFwiVFlQRV9OVUxMXCI7XG4gICAgSW5wdXRBcmd1bWVudFtJbnB1dEFyZ3VtZW50W1wiVFlQRV9BUlJBWV9OVU1CRVJcIl0gPSA4XSA9IFwiVFlQRV9BUlJBWV9OVU1CRVJcIjtcbiAgICBJbnB1dEFyZ3VtZW50W0lucHV0QXJndW1lbnRbXCJUWVBFX0FSUkFZX1NUUklOR1wiXSA9IDldID0gXCJUWVBFX0FSUkFZX1NUUklOR1wiO1xufSkoSW5wdXRBcmd1bWVudCB8fCAoSW5wdXRBcmd1bWVudCA9IHt9KSk7XG5jbGFzcyBSdW50aW1lIHtcbiAgICBjb25zdHJ1Y3RvcihpbnRlcnByZXRlcikge1xuICAgICAgICB0aGlzLlRZUEVfTkFNRV9UQUJMRSA9IHtcbiAgICAgICAgICAgIFtJbnB1dEFyZ3VtZW50LlRZUEVfTlVNQkVSXTogJ251bWJlcicsXG4gICAgICAgICAgICBbSW5wdXRBcmd1bWVudC5UWVBFX0FOWV06ICdhbnknLFxuICAgICAgICAgICAgW0lucHV0QXJndW1lbnQuVFlQRV9TVFJJTkddOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIFtJbnB1dEFyZ3VtZW50LlRZUEVfQVJSQVldOiAnYXJyYXknLFxuICAgICAgICAgICAgW0lucHV0QXJndW1lbnQuVFlQRV9PQkpFQ1RdOiAnb2JqZWN0JyxcbiAgICAgICAgICAgIFtJbnB1dEFyZ3VtZW50LlRZUEVfQk9PTEVBTl06ICdib29sZWFuJyxcbiAgICAgICAgICAgIFtJbnB1dEFyZ3VtZW50LlRZUEVfRVhQUkVGXTogJ2V4cHJlc3Npb24nLFxuICAgICAgICAgICAgW0lucHV0QXJndW1lbnQuVFlQRV9OVUxMXTogJ251bGwnLFxuICAgICAgICAgICAgW0lucHV0QXJndW1lbnQuVFlQRV9BUlJBWV9OVU1CRVJdOiAnQXJyYXk8bnVtYmVyPicsXG4gICAgICAgICAgICBbSW5wdXRBcmd1bWVudC5UWVBFX0FSUkFZX1NUUklOR106ICdBcnJheTxzdHJpbmc+JyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mdW5jdGlvbkFicyA9IChbaW5wdXRWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhpbnB1dFZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mdW5jdGlvbkF2ZyA9IChbaW5wdXRBcnJheV0pID0+IHtcbiAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dEFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgc3VtICs9IGlucHV0QXJyYXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3VtIC8gaW5wdXRBcnJheS5sZW5ndGg7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZnVuY3Rpb25DZWlsID0gKFtpbnB1dFZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChpbnB1dFZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mdW5jdGlvbkNvbnRhaW5zID0gcmVzb2x2ZWRBcmdzID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtzZWFyY2hhYmxlLCBzZWFyY2hWYWx1ZV0gPSByZXNvbHZlZEFyZ3M7XG4gICAgICAgICAgICByZXR1cm4gc2VhcmNoYWJsZS5pbmNsdWRlcyhzZWFyY2hWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZnVuY3Rpb25FbmRzV2l0aCA9IHJlc29sdmVkQXJncyA9PiB7XG4gICAgICAgICAgICBjb25zdCBbc2VhcmNoU3RyLCBzdWZmaXhdID0gcmVzb2x2ZWRBcmdzO1xuICAgICAgICAgICAgcmV0dXJuIHNlYXJjaFN0ci5pbmNsdWRlcyhzdWZmaXgsIHNlYXJjaFN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mdW5jdGlvbkZsb29yID0gKFtpbnB1dFZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoaW5wdXRWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZnVuY3Rpb25Kb2luID0gcmVzb2x2ZWRBcmdzID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtqb2luQ2hhciwgbGlzdEpvaW5dID0gcmVzb2x2ZWRBcmdzO1xuICAgICAgICAgICAgcmV0dXJuIGxpc3RKb2luLmpvaW4oam9pbkNoYXIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZ1bmN0aW9uS2V5cyA9IChbaW5wdXRPYmplY3RdKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoaW5wdXRPYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZ1bmN0aW9uTGVuZ3RoID0gKFtpbnB1dFZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc09iamVjdChpbnB1dFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dFZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhpbnB1dFZhbHVlKS5sZW5ndGg7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZnVuY3Rpb25NYXAgPSAocmVzb2x2ZWRBcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2ludGVycHJldGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWFwcGVkID0gW107XG4gICAgICAgICAgICBjb25zdCBpbnRlcnByZXRlciA9IHRoaXMuX2ludGVycHJldGVyO1xuICAgICAgICAgICAgY29uc3QgZXhwcmVmTm9kZSA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gcmVzb2x2ZWRBcmdzWzFdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIG1hcHBlZC5wdXNoKGludGVycHJldGVyLnZpc2l0KGV4cHJlZk5vZGUsIGVsZW1lbnRzW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFwcGVkO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZ1bmN0aW9uTWF4ID0gKFtpbnB1dFZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpbnB1dFZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHlwZU5hbWUgPSB0aGlzLmdldFR5cGVOYW1lKGlucHV0VmFsdWVbMF0pO1xuICAgICAgICAgICAgaWYgKHR5cGVOYW1lID09PSBJbnB1dEFyZ3VtZW50LlRZUEVfTlVNQkVSKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KC4uLmlucHV0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBpbnB1dFZhbHVlO1xuICAgICAgICAgICAgbGV0IG1heEVsZW1lbnQgPSBlbGVtZW50c1swXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4RWxlbWVudC5sb2NhbGVDb21wYXJlKGVsZW1lbnRzW2ldKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4RWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXhFbGVtZW50O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZ1bmN0aW9uTWF4QnkgPSAocmVzb2x2ZWRBcmdzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleHByZWZOb2RlID0gcmVzb2x2ZWRBcmdzWzFdO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRBcnJheSA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgICAgIGNvbnN0IGtleUZ1bmN0aW9uID0gdGhpcy5jcmVhdGVLZXlGdW5jdGlvbihleHByZWZOb2RlLCBbSW5wdXRBcmd1bWVudC5UWVBFX05VTUJFUiwgSW5wdXRBcmd1bWVudC5UWVBFX1NUUklOR10pO1xuICAgICAgICAgICAgbGV0IG1heE51bWJlciA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgIGxldCBtYXhSZWNvcmQ7XG4gICAgICAgICAgICBsZXQgY3VycmVudDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzb2x2ZWRBcnJheS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBrZXlGdW5jdGlvbiAmJiBrZXlGdW5jdGlvbihyZXNvbHZlZEFycmF5W2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnQgPiBtYXhOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4TnVtYmVyID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgbWF4UmVjb3JkID0gcmVzb2x2ZWRBcnJheVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF4UmVjb3JkO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZ1bmN0aW9uTWVyZ2UgPSByZXNvbHZlZEFyZ3MgPT4ge1xuICAgICAgICAgICAgbGV0IG1lcmdlZCA9IHt9O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNvbHZlZEFyZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gcmVzb2x2ZWRBcmdzW2ldO1xuICAgICAgICAgICAgICAgIG1lcmdlZCA9IE9iamVjdC5hc3NpZ24obWVyZ2VkLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAvLyBmb3IgKGNvbnN0IGtleSBpbiBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gICBtZXJnZWRba2V5XSA9IGN1cnJlbnRba2V5XTtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZ1bmN0aW9uTWluID0gKFtpbnB1dFZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpbnB1dFZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHlwZU5hbWUgPSB0aGlzLmdldFR5cGVOYW1lKGlucHV0VmFsdWVbMF0pO1xuICAgICAgICAgICAgaWYgKHR5cGVOYW1lID09PSBJbnB1dEFyZ3VtZW50LlRZUEVfTlVNQkVSKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKC4uLmlucHV0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBpbnB1dFZhbHVlO1xuICAgICAgICAgICAgbGV0IG1pbkVsZW1lbnQgPSBlbGVtZW50c1swXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHNbaV0ubG9jYWxlQ29tcGFyZShtaW5FbGVtZW50KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtaW5FbGVtZW50O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZ1bmN0aW9uTWluQnkgPSAocmVzb2x2ZWRBcmdzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleHByZWZOb2RlID0gcmVzb2x2ZWRBcmdzWzFdO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRBcnJheSA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgICAgIGNvbnN0IGtleUZ1bmN0aW9uID0gdGhpcy5jcmVhdGVLZXlGdW5jdGlvbihleHByZWZOb2RlLCBbSW5wdXRBcmd1bWVudC5UWVBFX05VTUJFUiwgSW5wdXRBcmd1bWVudC5UWVBFX1NUUklOR10pO1xuICAgICAgICAgICAgbGV0IG1pbk51bWJlciA9IEluZmluaXR5O1xuICAgICAgICAgICAgbGV0IG1pblJlY29yZDtcbiAgICAgICAgICAgIGxldCBjdXJyZW50O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNvbHZlZEFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGtleUZ1bmN0aW9uICYmIGtleUZ1bmN0aW9uKHJlc29sdmVkQXJyYXlbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSB1bmRlZmluZWQgJiYgY3VycmVudCA8IG1pbk51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBtaW5OdW1iZXIgPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICBtaW5SZWNvcmQgPSByZXNvbHZlZEFycmF5W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtaW5SZWNvcmQ7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZnVuY3Rpb25Ob3ROdWxsID0gKHJlc29sdmVkQXJncykgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNvbHZlZEFyZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRUeXBlTmFtZShyZXNvbHZlZEFyZ3NbaV0pICE9PSBJbnB1dEFyZ3VtZW50LlRZUEVfTlVMTCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRBcmdzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZ1bmN0aW9uUmV2ZXJzZSA9IChbaW5wdXRWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVOYW1lID0gdGhpcy5nZXRUeXBlTmFtZShpbnB1dFZhbHVlKTtcbiAgICAgICAgICAgIGlmICh0eXBlTmFtZSA9PT0gSW5wdXRBcmd1bWVudC5UWVBFX1NUUklORykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3RyID0gaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgICAgICBsZXQgcmV2ZXJzZWRTdHIgPSAnJztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gb3JpZ2luYWxTdHIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZWRTdHIgKz0gb3JpZ2luYWxTdHJbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXZlcnNlZFN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJldmVyc2VkQXJyYXkgPSBpbnB1dFZhbHVlLnNsaWNlKDApO1xuICAgICAgICAgICAgcmV2ZXJzZWRBcnJheS5yZXZlcnNlKCk7XG4gICAgICAgICAgICByZXR1cm4gcmV2ZXJzZWRBcnJheTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mdW5jdGlvblNvcnQgPSAoW2lucHV0VmFsdWVdKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLmlucHV0VmFsdWVdLnNvcnQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mdW5jdGlvblNvcnRCeSA9IChyZXNvbHZlZEFyZ3MpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faW50ZXJwcmV0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzb3J0ZWRBcnJheSA9IHJlc29sdmVkQXJnc1swXS5zbGljZSgwKTtcbiAgICAgICAgICAgIGlmIChzb3J0ZWRBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc29ydGVkQXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbnRlcnByZXRlciA9IHRoaXMuX2ludGVycHJldGVyO1xuICAgICAgICAgICAgY29uc3QgZXhwcmVmTm9kZSA9IHJlc29sdmVkQXJnc1sxXTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkVHlwZSA9IHRoaXMuZ2V0VHlwZU5hbWUoaW50ZXJwcmV0ZXIudmlzaXQoZXhwcmVmTm9kZSwgc29ydGVkQXJyYXlbMF0pKTtcbiAgICAgICAgICAgIGlmIChyZXF1aXJlZFR5cGUgIT09IHVuZGVmaW5lZCAmJiAhW0lucHV0QXJndW1lbnQuVFlQRV9OVU1CRVIsIElucHV0QXJndW1lbnQuVFlQRV9TVFJJTkddLmluY2x1ZGVzKHJlcXVpcmVkVHlwZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFR5cGVFcnJvcjogdW5leHBlY3RlZCB0eXBlICgke3RoaXMuVFlQRV9OQU1FX1RBQkxFW3JlcXVpcmVkVHlwZV19KWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVjb3JhdGVkID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvcnRlZEFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgZGVjb3JhdGVkLnB1c2goW2ksIHNvcnRlZEFycmF5W2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvcmF0ZWQuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJBID0gaW50ZXJwcmV0ZXIudmlzaXQoZXhwcmVmTm9kZSwgYVsxXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwckIgPSBpbnRlcnByZXRlci52aXNpdChleHByZWZOb2RlLCBiWzFdKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRUeXBlTmFtZShleHByQSkgIT09IHJlcXVpcmVkVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFR5cGVFcnJvcjogZXhwZWN0ZWQgKCR7dGhpcy5UWVBFX05BTUVfVEFCTEVbcmVxdWlyZWRUeXBlXX0pLCByZWNlaXZlZCAke3RoaXMuVFlQRV9OQU1FX1RBQkxFW3RoaXMuZ2V0VHlwZU5hbWUoZXhwckEpXX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5nZXRUeXBlTmFtZShleHByQikgIT09IHJlcXVpcmVkVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFR5cGVFcnJvcjogZXhwZWN0ZWQgKCR7dGhpcy5UWVBFX05BTUVfVEFCTEVbcmVxdWlyZWRUeXBlXX0pLCByZWNlaXZlZCAke3RoaXMuVFlQRV9OQU1FX1RBQkxFW3RoaXMuZ2V0VHlwZU5hbWUoZXhwckIpXX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV4cHJBID4gZXhwckIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBleHByQSA8IGV4cHJCID8gLTEgOiBhWzBdIC0gYlswXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkZWNvcmF0ZWQubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICBzb3J0ZWRBcnJheVtqXSA9IGRlY29yYXRlZFtqXVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWRBcnJheTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mdW5jdGlvblN0YXJ0c1dpdGggPSAoW3NlYXJjaGFibGUsIHNlYXJjaFN0cl0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzZWFyY2hhYmxlLnN0YXJ0c1dpdGgoc2VhcmNoU3RyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mdW5jdGlvblN1bSA9IChbaW5wdXRWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dFZhbHVlLnJlZHVjZSgoeCwgeSkgPT4geCArIHksIDApO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZ1bmN0aW9uVG9BcnJheSA9IChbaW5wdXRWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldFR5cGVOYW1lKGlucHV0VmFsdWUpID09PSBJbnB1dEFyZ3VtZW50LlRZUEVfQVJSQVkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbaW5wdXRWYWx1ZV07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZnVuY3Rpb25Ub051bWJlciA9IChbaW5wdXRWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVOYW1lID0gdGhpcy5nZXRUeXBlTmFtZShpbnB1dFZhbHVlKTtcbiAgICAgICAgICAgIGxldCBjb252ZXJ0ZWRWYWx1ZTtcbiAgICAgICAgICAgIGlmICh0eXBlTmFtZSA9PT0gSW5wdXRBcmd1bWVudC5UWVBFX05VTUJFUikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVOYW1lID09PSBJbnB1dEFyZ3VtZW50LlRZUEVfU1RSSU5HKSB7XG4gICAgICAgICAgICAgICAgY29udmVydGVkVmFsdWUgPSAraW5wdXRWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGNvbnZlcnRlZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZnVuY3Rpb25Ub1N0cmluZyA9IChbaW5wdXRWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldFR5cGVOYW1lKGlucHV0VmFsdWUpID09PSBJbnB1dEFyZ3VtZW50LlRZUEVfU1RSSU5HKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaW5wdXRWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZnVuY3Rpb25UeXBlID0gKFtpbnB1dFZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmdldFR5cGVOYW1lKGlucHV0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBJbnB1dEFyZ3VtZW50LlRZUEVfTlVNQkVSOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgICAgICAgICAgICAgY2FzZSBJbnB1dEFyZ3VtZW50LlRZUEVfU1RSSU5HOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICAgICAgICAgICAgY2FzZSBJbnB1dEFyZ3VtZW50LlRZUEVfQVJSQVk6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgICAgICAgICAgICAgIGNhc2UgSW5wdXRBcmd1bWVudC5UWVBFX09CSkVDVDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgICAgICAgICAgICAgIGNhc2UgSW5wdXRBcmd1bWVudC5UWVBFX0JPT0xFQU46XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnYm9vbGVhbic7XG4gICAgICAgICAgICAgICAgY2FzZSBJbnB1dEFyZ3VtZW50LlRZUEVfRVhQUkVGOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2V4cHJlZic7XG4gICAgICAgICAgICAgICAgY2FzZSBJbnB1dEFyZ3VtZW50LlRZUEVfTlVMTDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZnVuY3Rpb25WYWx1ZXMgPSAoW2lucHV0T2JqZWN0XSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoaW5wdXRPYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZ1bmN0aW9uVGFibGUgPSB7XG4gICAgICAgICAgICBhYnM6IHtcbiAgICAgICAgICAgICAgICBfZnVuYzogdGhpcy5mdW5jdGlvbkFicyxcbiAgICAgICAgICAgICAgICBfc2lnbmF0dXJlOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzOiBbSW5wdXRBcmd1bWVudC5UWVBFX05VTUJFUl0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhdmc6IHtcbiAgICAgICAgICAgICAgICBfZnVuYzogdGhpcy5mdW5jdGlvbkF2ZyxcbiAgICAgICAgICAgICAgICBfc2lnbmF0dXJlOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzOiBbSW5wdXRBcmd1bWVudC5UWVBFX0FSUkFZX05VTUJFUl0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjZWlsOiB7XG4gICAgICAgICAgICAgICAgX2Z1bmM6IHRoaXMuZnVuY3Rpb25DZWlsLFxuICAgICAgICAgICAgICAgIF9zaWduYXR1cmU6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXM6IFtJbnB1dEFyZ3VtZW50LlRZUEVfTlVNQkVSXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRhaW5zOiB7XG4gICAgICAgICAgICAgICAgX2Z1bmM6IHRoaXMuZnVuY3Rpb25Db250YWlucyxcbiAgICAgICAgICAgICAgICBfc2lnbmF0dXJlOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzOiBbSW5wdXRBcmd1bWVudC5UWVBFX1NUUklORywgSW5wdXRBcmd1bWVudC5UWVBFX0FSUkFZXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXM6IFtJbnB1dEFyZ3VtZW50LlRZUEVfQU5ZXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuZHNfd2l0aDoge1xuICAgICAgICAgICAgICAgIF9mdW5jOiB0aGlzLmZ1bmN0aW9uRW5kc1dpdGgsXG4gICAgICAgICAgICAgICAgX3NpZ25hdHVyZTogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlczogW0lucHV0QXJndW1lbnQuVFlQRV9TVFJJTkddLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlczogW0lucHV0QXJndW1lbnQuVFlQRV9TVFJJTkddLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmxvb3I6IHtcbiAgICAgICAgICAgICAgICBfZnVuYzogdGhpcy5mdW5jdGlvbkZsb29yLFxuICAgICAgICAgICAgICAgIF9zaWduYXR1cmU6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXM6IFtJbnB1dEFyZ3VtZW50LlRZUEVfTlVNQkVSXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGpvaW46IHtcbiAgICAgICAgICAgICAgICBfZnVuYzogdGhpcy5mdW5jdGlvbkpvaW4sXG4gICAgICAgICAgICAgICAgX3NpZ25hdHVyZTogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlczogW0lucHV0QXJndW1lbnQuVFlQRV9TVFJJTkddLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlczogW0lucHV0QXJndW1lbnQuVFlQRV9BUlJBWV9TVFJJTkddLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2V5czoge1xuICAgICAgICAgICAgICAgIF9mdW5jOiB0aGlzLmZ1bmN0aW9uS2V5cyxcbiAgICAgICAgICAgICAgICBfc2lnbmF0dXJlOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzOiBbSW5wdXRBcmd1bWVudC5UWVBFX09CSkVDVF0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgICAgICBfZnVuYzogdGhpcy5mdW5jdGlvbkxlbmd0aCxcbiAgICAgICAgICAgICAgICBfc2lnbmF0dXJlOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzOiBbSW5wdXRBcmd1bWVudC5UWVBFX1NUUklORywgSW5wdXRBcmd1bWVudC5UWVBFX0FSUkFZLCBJbnB1dEFyZ3VtZW50LlRZUEVfT0JKRUNUXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hcDoge1xuICAgICAgICAgICAgICAgIF9mdW5jOiB0aGlzLmZ1bmN0aW9uTWFwLFxuICAgICAgICAgICAgICAgIF9zaWduYXR1cmU6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXM6IFtJbnB1dEFyZ3VtZW50LlRZUEVfRVhQUkVGXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXM6IFtJbnB1dEFyZ3VtZW50LlRZUEVfQVJSQVldLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICAgICAgX2Z1bmM6IHRoaXMuZnVuY3Rpb25NYXgsXG4gICAgICAgICAgICAgICAgX3NpZ25hdHVyZTogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlczogW0lucHV0QXJndW1lbnQuVFlQRV9BUlJBWV9OVU1CRVIsIElucHV0QXJndW1lbnQuVFlQRV9BUlJBWV9TVFJJTkddLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF4X2J5OiB7XG4gICAgICAgICAgICAgICAgX2Z1bmM6IHRoaXMuZnVuY3Rpb25NYXhCeSxcbiAgICAgICAgICAgICAgICBfc2lnbmF0dXJlOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzOiBbSW5wdXRBcmd1bWVudC5UWVBFX0FSUkFZXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXM6IFtJbnB1dEFyZ3VtZW50LlRZUEVfRVhQUkVGXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lcmdlOiB7XG4gICAgICAgICAgICAgICAgX2Z1bmM6IHRoaXMuZnVuY3Rpb25NZXJnZSxcbiAgICAgICAgICAgICAgICBfc2lnbmF0dXJlOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzOiBbSW5wdXRBcmd1bWVudC5UWVBFX09CSkVDVF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWRpYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1pbjoge1xuICAgICAgICAgICAgICAgIF9mdW5jOiB0aGlzLmZ1bmN0aW9uTWluLFxuICAgICAgICAgICAgICAgIF9zaWduYXR1cmU6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXM6IFtJbnB1dEFyZ3VtZW50LlRZUEVfQVJSQVlfTlVNQkVSLCBJbnB1dEFyZ3VtZW50LlRZUEVfQVJSQVlfU1RSSU5HXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1pbl9ieToge1xuICAgICAgICAgICAgICAgIF9mdW5jOiB0aGlzLmZ1bmN0aW9uTWluQnksXG4gICAgICAgICAgICAgICAgX3NpZ25hdHVyZTogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlczogW0lucHV0QXJndW1lbnQuVFlQRV9BUlJBWV0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzOiBbSW5wdXRBcmd1bWVudC5UWVBFX0VYUFJFRl0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub3RfbnVsbDoge1xuICAgICAgICAgICAgICAgIF9mdW5jOiB0aGlzLmZ1bmN0aW9uTm90TnVsbCxcbiAgICAgICAgICAgICAgICBfc2lnbmF0dXJlOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzOiBbSW5wdXRBcmd1bWVudC5UWVBFX0FOWV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWRpYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldmVyc2U6IHtcbiAgICAgICAgICAgICAgICBfZnVuYzogdGhpcy5mdW5jdGlvblJldmVyc2UsXG4gICAgICAgICAgICAgICAgX3NpZ25hdHVyZTogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlczogW0lucHV0QXJndW1lbnQuVFlQRV9TVFJJTkcsIElucHV0QXJndW1lbnQuVFlQRV9BUlJBWV0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzb3J0OiB7XG4gICAgICAgICAgICAgICAgX2Z1bmM6IHRoaXMuZnVuY3Rpb25Tb3J0LFxuICAgICAgICAgICAgICAgIF9zaWduYXR1cmU6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXM6IFtJbnB1dEFyZ3VtZW50LlRZUEVfQVJSQVlfU1RSSU5HLCBJbnB1dEFyZ3VtZW50LlRZUEVfQVJSQVlfTlVNQkVSXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNvcnRfYnk6IHtcbiAgICAgICAgICAgICAgICBfZnVuYzogdGhpcy5mdW5jdGlvblNvcnRCeSxcbiAgICAgICAgICAgICAgICBfc2lnbmF0dXJlOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzOiBbSW5wdXRBcmd1bWVudC5UWVBFX0FSUkFZXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXM6IFtJbnB1dEFyZ3VtZW50LlRZUEVfRVhQUkVGXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXJ0c193aXRoOiB7XG4gICAgICAgICAgICAgICAgX2Z1bmM6IHRoaXMuZnVuY3Rpb25TdGFydHNXaXRoLFxuICAgICAgICAgICAgICAgIF9zaWduYXR1cmU6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXM6IFtJbnB1dEFyZ3VtZW50LlRZUEVfU1RSSU5HXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXM6IFtJbnB1dEFyZ3VtZW50LlRZUEVfU1RSSU5HXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1bToge1xuICAgICAgICAgICAgICAgIF9mdW5jOiB0aGlzLmZ1bmN0aW9uU3VtLFxuICAgICAgICAgICAgICAgIF9zaWduYXR1cmU6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXM6IFtJbnB1dEFyZ3VtZW50LlRZUEVfQVJSQVlfTlVNQkVSXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvX2FycmF5OiB7XG4gICAgICAgICAgICAgICAgX2Z1bmM6IHRoaXMuZnVuY3Rpb25Ub0FycmF5LFxuICAgICAgICAgICAgICAgIF9zaWduYXR1cmU6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXM6IFtJbnB1dEFyZ3VtZW50LlRZUEVfQU5ZXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvX251bWJlcjoge1xuICAgICAgICAgICAgICAgIF9mdW5jOiB0aGlzLmZ1bmN0aW9uVG9OdW1iZXIsXG4gICAgICAgICAgICAgICAgX3NpZ25hdHVyZTogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlczogW0lucHV0QXJndW1lbnQuVFlQRV9BTlldLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9fc3RyaW5nOiB7XG4gICAgICAgICAgICAgICAgX2Z1bmM6IHRoaXMuZnVuY3Rpb25Ub1N0cmluZyxcbiAgICAgICAgICAgICAgICBfc2lnbmF0dXJlOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzOiBbSW5wdXRBcmd1bWVudC5UWVBFX0FOWV0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgX2Z1bmM6IHRoaXMuZnVuY3Rpb25UeXBlLFxuICAgICAgICAgICAgICAgIF9zaWduYXR1cmU6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXM6IFtJbnB1dEFyZ3VtZW50LlRZUEVfQU5ZXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIF9mdW5jOiB0aGlzLmZ1bmN0aW9uVmFsdWVzLFxuICAgICAgICAgICAgICAgIF9zaWduYXR1cmU6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXM6IFtJbnB1dEFyZ3VtZW50LlRZUEVfT0JKRUNUXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faW50ZXJwcmV0ZXIgPSBpbnRlcnByZXRlcjtcbiAgICB9XG4gICAgcmVnaXN0ZXJGdW5jdGlvbihuYW1lLCBjdXN0b21GdW5jdGlvbiwgc2lnbmF0dXJlKSB7XG4gICAgICAgIGlmIChuYW1lIGluIHRoaXMuZnVuY3Rpb25UYWJsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGdW5jdGlvbiBhbHJlYWR5IGRlZmluZWQ6ICR7bmFtZX0oKWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnVuY3Rpb25UYWJsZVtuYW1lXSA9IHtcbiAgICAgICAgICAgIF9mdW5jOiBjdXN0b21GdW5jdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX3NpZ25hdHVyZTogc2lnbmF0dXJlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjYWxsRnVuY3Rpb24obmFtZSwgcmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uRW50cnkgPSB0aGlzLmZ1bmN0aW9uVGFibGVbbmFtZV07XG4gICAgICAgIGlmIChmdW5jdGlvbkVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBmdW5jdGlvbjogJHtuYW1lfSgpYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWxpZGF0ZUFyZ3MobmFtZSwgcmVzb2x2ZWRBcmdzLCBmdW5jdGlvbkVudHJ5Ll9zaWduYXR1cmUpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb25FbnRyeS5fZnVuYy5jYWxsKHRoaXMsIHJlc29sdmVkQXJncyk7XG4gICAgfVxuICAgIHZhbGlkYXRlSW5wdXRTaWduYXR1cmVzKG5hbWUsIHNpZ25hdHVyZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25hdHVyZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKCd2YXJpYWRpYycgaW4gc2lnbmF0dXJlW2ldICYmIGkgIT09IHNpZ25hdHVyZS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBcmd1bWVudEVycm9yOiAke25hbWV9KCkgJ3ZhcmlhZGljJyBhcmd1bWVudCAke2kgKyAxfSBtdXN0IG9jY3VyIGxhc3RgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YWxpZGF0ZUFyZ3MobmFtZSwgYXJncywgc2lnbmF0dXJlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCBwbHVyYWxpemVkO1xuICAgICAgICB0aGlzLnZhbGlkYXRlSW5wdXRTaWduYXR1cmVzKG5hbWUsIHNpZ25hdHVyZSk7XG4gICAgICAgIGNvbnN0IG51bWJlck9mUmVxdWlyZWRBcmdzID0gc2lnbmF0dXJlLmZpbHRlcihhcmdTaWduYXR1cmUgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSAhYXJnU2lnbmF0dXJlLm9wdGlvbmFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTsgfSkubGVuZ3RoO1xuICAgICAgICBjb25zdCBsYXN0QXJnSXNWYXJpYWRpYyA9IChfYiA9IChfYSA9IHNpZ25hdHVyZVtzaWduYXR1cmUubGVuZ3RoIC0gMV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YXJpYWRpYykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgICAgIGNvbnN0IHRvb0Zld0FyZ3MgPSBhcmdzLmxlbmd0aCA8IG51bWJlck9mUmVxdWlyZWRBcmdzO1xuICAgICAgICBjb25zdCB0b29NYW55QXJncyA9IGFyZ3MubGVuZ3RoID4gc2lnbmF0dXJlLmxlbmd0aDtcbiAgICAgICAgY29uc3QgdG9vRmV3TW9kaWZpZXIgPSB0b29GZXdBcmdzICYmICgoIWxhc3RBcmdJc1ZhcmlhZGljICYmIG51bWJlck9mUmVxdWlyZWRBcmdzID4gMSkgfHwgbGFzdEFyZ0lzVmFyaWFkaWMpID8gJ2F0IGxlYXN0ICcgOiAnJztcbiAgICAgICAgaWYgKChsYXN0QXJnSXNWYXJpYWRpYyAmJiB0b29GZXdBcmdzKSB8fCAoIWxhc3RBcmdJc1ZhcmlhZGljICYmICh0b29GZXdBcmdzIHx8IHRvb01hbnlBcmdzKSkpIHtcbiAgICAgICAgICAgIHBsdXJhbGl6ZWQgPSBzaWduYXR1cmUubGVuZ3RoID4gMTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXJndW1lbnRFcnJvcjogJHtuYW1lfSgpIHRha2VzICR7dG9vRmV3TW9kaWZpZXJ9JHtudW1iZXJPZlJlcXVpcmVkQXJnc30gYXJndW1lbnQkeyhwbHVyYWxpemVkICYmICdzJykgfHwgJyd9IGJ1dCByZWNlaXZlZCAke2FyZ3MubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50U3BlYztcbiAgICAgICAgbGV0IGFjdHVhbFR5cGU7XG4gICAgICAgIGxldCB0eXBlTWF0Y2hlZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduYXR1cmUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHR5cGVNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjdXJyZW50U3BlYyA9IHNpZ25hdHVyZVtpXS50eXBlcztcbiAgICAgICAgICAgIGFjdHVhbFR5cGUgPSB0aGlzLmdldFR5cGVOYW1lKGFyZ3NbaV0pO1xuICAgICAgICAgICAgbGV0IGo7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY3VycmVudFNwZWMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0dWFsVHlwZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMudHlwZU1hdGNoZXMoYWN0dWFsVHlwZSwgY3VycmVudFNwZWNbal0sIGFyZ3NbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0eXBlTWF0Y2hlZCAmJiBhY3R1YWxUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZCA9IGN1cnJlbnRTcGVjXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKHR5cGVJZGVudGlmaWVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlRZUEVfTkFNRV9UQUJMRVt0eXBlSWRlbnRpZmllcl07XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyB8ICcpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVHlwZUVycm9yOiAke25hbWV9KCkgZXhwZWN0ZWQgYXJndW1lbnQgJHtpICsgMX0gdG8gYmUgdHlwZSAoJHtleHBlY3RlZH0pIGJ1dCByZWNlaXZlZCB0eXBlICR7dGhpcy5UWVBFX05BTUVfVEFCTEVbYWN0dWFsVHlwZV19IGluc3RlYWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHlwZU1hdGNoZXMoYWN0dWFsLCBleHBlY3RlZCwgYXJnVmFsdWUpIHtcbiAgICAgICAgaWYgKGV4cGVjdGVkID09PSBJbnB1dEFyZ3VtZW50LlRZUEVfQU5ZKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwZWN0ZWQgPT09IElucHV0QXJndW1lbnQuVFlQRV9BUlJBWV9TVFJJTkcgfHxcbiAgICAgICAgICAgIGV4cGVjdGVkID09PSBJbnB1dEFyZ3VtZW50LlRZUEVfQVJSQVlfTlVNQkVSIHx8XG4gICAgICAgICAgICBleHBlY3RlZCA9PT0gSW5wdXRBcmd1bWVudC5UWVBFX0FSUkFZKSB7XG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWQgPT09IElucHV0QXJndW1lbnQuVFlQRV9BUlJBWSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY3R1YWwgPT09IElucHV0QXJndW1lbnQuVFlQRV9BUlJBWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY3R1YWwgPT09IElucHV0QXJndW1lbnQuVFlQRV9BUlJBWSkge1xuICAgICAgICAgICAgICAgIGxldCBzdWJ0eXBlO1xuICAgICAgICAgICAgICAgIGlmIChleHBlY3RlZCA9PT0gSW5wdXRBcmd1bWVudC5UWVBFX0FSUkFZX05VTUJFUikge1xuICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlID0gSW5wdXRBcmd1bWVudC5UWVBFX05VTUJFUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXhwZWN0ZWQgPT09IElucHV0QXJndW1lbnQuVFlQRV9BUlJBWV9TVFJJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VidHlwZSA9IElucHV0QXJndW1lbnQuVFlQRV9TVFJJTkc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJnVmFsdWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZU5hbWUgPSB0aGlzLmdldFR5cGVOYW1lKGFyZ1ZhbHVlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVOYW1lICE9PSB1bmRlZmluZWQgJiYgc3VidHlwZSAhPT0gdW5kZWZpbmVkICYmICF0aGlzLnR5cGVNYXRjaGVzKHR5cGVOYW1lLCBzdWJ0eXBlLCBhcmdWYWx1ZVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhY3R1YWwgPT09IGV4cGVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0VHlwZU5hbWUob2JqKSB7XG4gICAgICAgIHN3aXRjaCAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpIHtcbiAgICAgICAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIElucHV0QXJndW1lbnQuVFlQRV9TVFJJTkc7XG4gICAgICAgICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgICAgICAgICAgIHJldHVybiBJbnB1dEFyZ3VtZW50LlRZUEVfTlVNQkVSO1xuICAgICAgICAgICAgY2FzZSAnW29iamVjdCBBcnJheV0nOlxuICAgICAgICAgICAgICAgIHJldHVybiBJbnB1dEFyZ3VtZW50LlRZUEVfQVJSQVk7XG4gICAgICAgICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gSW5wdXRBcmd1bWVudC5UWVBFX0JPT0xFQU47XG4gICAgICAgICAgICBjYXNlICdbb2JqZWN0IE51bGxdJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gSW5wdXRBcmd1bWVudC5UWVBFX05VTEw7XG4gICAgICAgICAgICBjYXNlICdbb2JqZWN0IE9iamVjdF0nOlxuICAgICAgICAgICAgICAgIGlmIChvYmouam1lc3BhdGhUeXBlID09PSBUb2tlbi5UT0tfRVhQUkVGKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJbnB1dEFyZ3VtZW50LlRZUEVfRVhQUkVGO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gSW5wdXRBcmd1bWVudC5UWVBFX09CSkVDVDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZUtleUZ1bmN0aW9uKGV4cHJlZk5vZGUsIGFsbG93ZWRUeXBlcykge1xuICAgICAgICBpZiAoIXRoaXMuX2ludGVycHJldGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW50ZXJwcmV0ZXIgPSB0aGlzLl9pbnRlcnByZXRlcjtcbiAgICAgICAgY29uc3Qga2V5RnVuYyA9ICh4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gaW50ZXJwcmV0ZXIudmlzaXQoZXhwcmVmTm9kZSwgeCk7XG4gICAgICAgICAgICBpZiAoIWFsbG93ZWRUeXBlcy5pbmNsdWRlcyh0aGlzLmdldFR5cGVOYW1lKGN1cnJlbnQpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBUeXBlRXJyb3I6IGV4cGVjdGVkIG9uZSBvZiAoJHthbGxvd2VkVHlwZXNcbiAgICAgICAgICAgICAgICAgICAgLm1hcCh0ID0+IHRoaXMuVFlQRV9OQU1FX1RBQkxFW3RdKVxuICAgICAgICAgICAgICAgICAgICAuam9pbignIHwgJyl9KSwgcmVjZWl2ZWQgJHt0aGlzLlRZUEVfTkFNRV9UQUJMRVt0aGlzLmdldFR5cGVOYW1lKGN1cnJlbnQpXX1gO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBrZXlGdW5jO1xuICAgIH1cbn1cblxuY2xhc3MgVHJlZUludGVycHJldGVyJDEge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9yb290VmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLnJ1bnRpbWUgPSBuZXcgUnVudGltZSh0aGlzKTtcbiAgICB9XG4gICAgc2VhcmNoKG5vZGUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3Jvb3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdChub2RlLCB2YWx1ZSk7XG4gICAgfVxuICAgIHZpc2l0KG5vZGUsIHZhbHVlKSB7XG4gICAgICAgIGxldCBtYXRjaGVkO1xuICAgICAgICBsZXQgY3VycmVudDtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgbGV0IGZpcnN0O1xuICAgICAgICBsZXQgc2Vjb25kO1xuICAgICAgICBsZXQgZmllbGQ7XG4gICAgICAgIGxldCBsZWZ0O1xuICAgICAgICBsZXQgcmlnaHQ7XG4gICAgICAgIGxldCBjb2xsZWN0ZWQ7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgYmFzZTtcbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0ZpZWxkJzpcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQgPSB2YWx1ZVtub2RlLm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNhc2UgJ1N1YmV4cHJlc3Npb24nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblsxXSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIGNhc2UgJ0luZGV4RXhwcmVzc2lvbic6XG4gICAgICAgICAgICAgICAgbGVmdCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCBsZWZ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHQ7XG4gICAgICAgICAgICBjYXNlICdJbmRleCc6XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gbm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdmFsdWUubGVuZ3RoICsgaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIGNhc2UgJ1NsaWNlJzpcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzbGljZVBhcmFtcyA9IFsuLi5ub2RlLmNoaWxkcmVuXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wdXRlZCA9IHRoaXMuY29tcHV0ZVNsaWNlUGFyYW1zKHZhbHVlLmxlbmd0aCwgc2xpY2VQYXJhbXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzdGFydCwgc3RvcCwgc3RlcF0gPSBjb21wdXRlZDtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdG9wOyBpICs9IHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPiBzdG9wOyBpICs9IHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgY2FzZSAnUHJvamVjdGlvbic6XG4gICAgICAgICAgICAgICAgYmFzZSA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShiYXNlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29sbGVjdGVkID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGJhc2UubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblsxXSwgYmFzZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWQucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGVkO1xuICAgICAgICAgICAgY2FzZSAnVmFsdWVQcm9qZWN0aW9uJzpcbiAgICAgICAgICAgICAgICBiYXNlID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzBdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc09iamVjdChiYXNlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29sbGVjdGVkID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhiYXNlKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMV0sIHZhbHVlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWQucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGVkO1xuICAgICAgICAgICAgY2FzZSAnRmlsdGVyUHJvamVjdGlvbic6XG4gICAgICAgICAgICAgICAgYmFzZSA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShiYXNlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaW5hbFJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmFzZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzJdLCBiYXNlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0ZhbHNlKG1hdGNoZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKGJhc2VbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZmlsdGVyZWQubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblsxXSwgZmlsdGVyZWRbal0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxSZXN1bHRzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbmFsUmVzdWx0cztcbiAgICAgICAgICAgIGNhc2UgJ0NvbXBhcmF0b3InOlxuICAgICAgICAgICAgICAgIGZpcnN0ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzBdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgc2Vjb25kID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChub2RlLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUb2tlbi5UT0tfRVE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzdHJpY3REZWVwRXF1YWwoZmlyc3QsIHNlY29uZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUb2tlbi5UT0tfTkU6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAhc3RyaWN0RGVlcEVxdWFsKGZpcnN0LCBzZWNvbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVG9rZW4uVE9LX0dUOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlyc3QgPiBzZWNvbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUb2tlbi5UT0tfR1RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlyc3QgPj0gc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVG9rZW4uVE9LX0xUOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlyc3QgPCBzZWNvbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUb2tlbi5UT0tfTFRFOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlyc3QgPD0gc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY29tcGFyYXRvcjogJHtub2RlLm5hbWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBjYXNlIFRva2VuLlRPS19GTEFUVEVOOlxuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzBdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9yaWdpbmFsKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG1lcmdlZCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvcmlnaW5hbC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gb3JpZ2luYWxbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZWQgPSBbLi4ubWVyZ2VkLCAuLi5jdXJyZW50XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlZC5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgICAgICAgICBjYXNlICdJZGVudGl0eSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgY2FzZSAnTXVsdGlTZWxlY3RMaXN0JzpcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbGxlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZC5wdXNoKHRoaXMudmlzaXQobm9kZS5jaGlsZHJlbltpXSwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RlZDtcbiAgICAgICAgICAgIGNhc2UgJ011bHRpU2VsZWN0SGFzaCc6XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2xsZWN0ZWQgPSB7fTtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQ7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWRbY2hpbGQubmFtZV0gPSB0aGlzLnZpc2l0KGNoaWxkLnZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0ZWQ7XG4gICAgICAgICAgICBjYXNlICdPckV4cHJlc3Npb24nOlxuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNGYWxzZShtYXRjaGVkKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgICAgICAgICAgY2FzZSAnQW5kRXhwcmVzc2lvbic6XG4gICAgICAgICAgICAgICAgZmlyc3QgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNGYWxzZShmaXJzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdOb3RFeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgICBmaXJzdCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0ZhbHNlKGZpcnN0KTtcbiAgICAgICAgICAgIGNhc2UgJ0xpdGVyYWwnOlxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgICAgICAgICAgY2FzZSBUb2tlbi5UT0tfUElQRTpcbiAgICAgICAgICAgICAgICBsZWZ0ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzBdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblsxXSwgbGVmdCk7XG4gICAgICAgICAgICBjYXNlIFRva2VuLlRPS19DVVJSRU5UOlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgVG9rZW4uVE9LX1JPT1Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RWYWx1ZTtcbiAgICAgICAgICAgIGNhc2UgJ0Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZEFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcmdzLnB1c2godGhpcy52aXNpdChub2RlLmNoaWxkcmVuW2pdLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ydW50aW1lLmNhbGxGdW5jdGlvbihub2RlLm5hbWUsIHJlc29sdmVkQXJncyk7XG4gICAgICAgICAgICBjYXNlICdFeHByZXNzaW9uUmVmZXJlbmNlJzpcbiAgICAgICAgICAgICAgICBjb25zdCByZWZOb2RlID0gbm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICByZWZOb2RlLmptZXNwYXRoVHlwZSA9IFRva2VuLlRPS19FWFBSRUY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZk5vZGU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBub2RlIHR5cGU6ICR7bm9kZS50eXBlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXB1dGVTbGljZVBhcmFtcyhhcnJheUxlbmd0aCwgc2xpY2VQYXJhbXMpIHtcbiAgICAgICAgbGV0IFtzdGFydCwgc3RvcCwgc3RlcF0gPSBzbGljZVBhcmFtcztcbiAgICAgICAgaWYgKHN0ZXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0ZXAgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0ZXAgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdJbnZhbGlkIHNsaWNlLCBzdGVwIGNhbm5vdCBiZSAwJyk7XG4gICAgICAgICAgICBlcnJvci5uYW1lID0gJ1J1bnRpbWVFcnJvcic7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGVwVmFsdWVOZWdhdGl2ZSA9IHN0ZXAgPCAwID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICBzdGFydCA9IHN0YXJ0ID09PSBudWxsID8gKHN0ZXBWYWx1ZU5lZ2F0aXZlID8gYXJyYXlMZW5ndGggLSAxIDogMCkgOiB0aGlzLmNhcFNsaWNlUmFuZ2UoYXJyYXlMZW5ndGgsIHN0YXJ0LCBzdGVwKTtcbiAgICAgICAgc3RvcCA9IHN0b3AgPT09IG51bGwgPyAoc3RlcFZhbHVlTmVnYXRpdmUgPyAtMSA6IGFycmF5TGVuZ3RoKSA6IHRoaXMuY2FwU2xpY2VSYW5nZShhcnJheUxlbmd0aCwgc3RvcCwgc3RlcCk7XG4gICAgICAgIHJldHVybiBbc3RhcnQsIHN0b3AsIHN0ZXBdO1xuICAgIH1cbiAgICBjYXBTbGljZVJhbmdlKGFycmF5TGVuZ3RoLCBhY3R1YWxWYWx1ZSwgc3RlcCkge1xuICAgICAgICBsZXQgbmV4dEFjdHVhbFZhbHVlID0gYWN0dWFsVmFsdWU7XG4gICAgICAgIGlmIChuZXh0QWN0dWFsVmFsdWUgPCAwKSB7XG4gICAgICAgICAgICBuZXh0QWN0dWFsVmFsdWUgKz0gYXJyYXlMZW5ndGg7XG4gICAgICAgICAgICBpZiAobmV4dEFjdHVhbFZhbHVlIDwgMCkge1xuICAgICAgICAgICAgICAgIG5leHRBY3R1YWxWYWx1ZSA9IHN0ZXAgPCAwID8gLTEgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5leHRBY3R1YWxWYWx1ZSA+PSBhcnJheUxlbmd0aCkge1xuICAgICAgICAgICAgbmV4dEFjdHVhbFZhbHVlID0gc3RlcCA8IDAgPyBhcnJheUxlbmd0aCAtIDEgOiBhcnJheUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dEFjdHVhbFZhbHVlO1xuICAgIH1cbn1cbmNvbnN0IFRyZWVJbnRlcnByZXRlckluc3RhbmNlID0gbmV3IFRyZWVJbnRlcnByZXRlciQxKCk7XG5cbmNvbnN0IFRZUEVfQU5ZID0gSW5wdXRBcmd1bWVudC5UWVBFX0FOWTtcbmNvbnN0IFRZUEVfQVJSQVkgPSBJbnB1dEFyZ3VtZW50LlRZUEVfQVJSQVk7XG5jb25zdCBUWVBFX0FSUkFZX05VTUJFUiA9IElucHV0QXJndW1lbnQuVFlQRV9BUlJBWV9OVU1CRVI7XG5jb25zdCBUWVBFX0FSUkFZX1NUUklORyA9IElucHV0QXJndW1lbnQuVFlQRV9BUlJBWV9TVFJJTkc7XG5jb25zdCBUWVBFX0JPT0xFQU4gPSBJbnB1dEFyZ3VtZW50LlRZUEVfQk9PTEVBTjtcbmNvbnN0IFRZUEVfRVhQUkVGID0gSW5wdXRBcmd1bWVudC5UWVBFX0VYUFJFRjtcbmNvbnN0IFRZUEVfTlVMTCA9IElucHV0QXJndW1lbnQuVFlQRV9OVUxMO1xuY29uc3QgVFlQRV9OVU1CRVIgPSBJbnB1dEFyZ3VtZW50LlRZUEVfTlVNQkVSO1xuY29uc3QgVFlQRV9PQkpFQ1QgPSBJbnB1dEFyZ3VtZW50LlRZUEVfT0JKRUNUO1xuY29uc3QgVFlQRV9TVFJJTkcgPSBJbnB1dEFyZ3VtZW50LlRZUEVfU1RSSU5HO1xuZnVuY3Rpb24gY29tcGlsZShleHByZXNzaW9uKSB7XG4gICAgY29uc3Qgbm9kZVRyZWUgPSBQYXJzZXIucGFyc2UoZXhwcmVzc2lvbik7XG4gICAgcmV0dXJuIG5vZGVUcmVlO1xufVxuZnVuY3Rpb24gdG9rZW5pemUoZXhwcmVzc2lvbikge1xuICAgIHJldHVybiBMZXhlci50b2tlbml6ZShleHByZXNzaW9uKTtcbn1cbmNvbnN0IHJlZ2lzdGVyRnVuY3Rpb24gPSAoZnVuY3Rpb25OYW1lLCBjdXN0b21GdW5jdGlvbiwgc2lnbmF0dXJlKSA9PiB7XG4gICAgVHJlZUludGVycHJldGVySW5zdGFuY2UucnVudGltZS5yZWdpc3RlckZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgY3VzdG9tRnVuY3Rpb24sIHNpZ25hdHVyZSk7XG59O1xuZnVuY3Rpb24gc2VhcmNoKGRhdGEsIGV4cHJlc3Npb24pIHtcbiAgICBjb25zdCBub2RlVHJlZSA9IFBhcnNlci5wYXJzZShleHByZXNzaW9uKTtcbiAgICByZXR1cm4gVHJlZUludGVycHJldGVySW5zdGFuY2Uuc2VhcmNoKG5vZGVUcmVlLCBkYXRhKTtcbn1cbmNvbnN0IFRyZWVJbnRlcnByZXRlciA9IFRyZWVJbnRlcnByZXRlckluc3RhbmNlO1xuY29uc3Qgam1lc3BhdGggPSB7XG4gICAgY29tcGlsZSxcbiAgICByZWdpc3RlckZ1bmN0aW9uLFxuICAgIHNlYXJjaCxcbiAgICB0b2tlbml6ZSxcbiAgICBUcmVlSW50ZXJwcmV0ZXIsXG4gICAgVFlQRV9BTlksXG4gICAgVFlQRV9BUlJBWV9OVU1CRVIsXG4gICAgVFlQRV9BUlJBWV9TVFJJTkcsXG4gICAgVFlQRV9BUlJBWSxcbiAgICBUWVBFX0JPT0xFQU4sXG4gICAgVFlQRV9FWFBSRUYsXG4gICAgVFlQRV9OVUxMLFxuICAgIFRZUEVfTlVNQkVSLFxuICAgIFRZUEVfT0JKRUNULFxuICAgIFRZUEVfU1RSSU5HLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgam1lc3BhdGg7XG5leHBvcnQgeyBUWVBFX0FOWSwgVFlQRV9BUlJBWSwgVFlQRV9BUlJBWV9OVU1CRVIsIFRZUEVfQVJSQVlfU1RSSU5HLCBUWVBFX0JPT0xFQU4sIFRZUEVfRVhQUkVGLCBUWVBFX05VTEwsIFRZUEVfTlVNQkVSLCBUWVBFX09CSkVDVCwgVFlQRV9TVFJJTkcsIFRyZWVJbnRlcnByZXRlciwgY29tcGlsZSwgam1lc3BhdGgsIHJlZ2lzdGVyRnVuY3Rpb24sIHNlYXJjaCwgdG9rZW5pemUgfTtcbiIsIi8qISBodHRwczovL210aHMuYmUvaGUgdjEuMi4wIGJ5IEBtYXRoaWFzIHwgTUlUIGxpY2Vuc2UgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlcyBgZXhwb3J0c2AuXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHM7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuXG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSxcblx0Ly8gYW5kIHVzZSBpdCBhcyBgcm9vdGAuXG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0Ly8gQWxsIGFzdHJhbCBzeW1ib2xzLlxuXHR2YXIgcmVnZXhBc3RyYWxTeW1ib2xzID0gL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZztcblx0Ly8gQWxsIEFTQ0lJIHN5bWJvbHMgKG5vdCBqdXN0IHByaW50YWJsZSBBU0NJSSkgZXhjZXB0IHRob3NlIGxpc3RlZCBpbiB0aGVcblx0Ly8gZmlyc3QgY29sdW1uIG9mIHRoZSBvdmVycmlkZXMgdGFibGUuXG5cdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3RhYmxlLWNoYXJyZWYtb3ZlcnJpZGVzXG5cdHZhciByZWdleEFzY2lpV2hpdGVsaXN0ID0gL1tcXHgwMS1cXHg3Rl0vZztcblx0Ly8gQWxsIEJNUCBzeW1ib2xzIHRoYXQgYXJlIG5vdCBBU0NJSSBuZXdsaW5lcywgcHJpbnRhYmxlIEFTQ0lJIHN5bWJvbHMsIG9yXG5cdC8vIGNvZGUgcG9pbnRzIGxpc3RlZCBpbiB0aGUgZmlyc3QgY29sdW1uIG9mIHRoZSBvdmVycmlkZXMgdGFibGUgb25cblx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjdGFibGUtY2hhcnJlZi1vdmVycmlkZXMuXG5cdHZhciByZWdleEJtcFdoaXRlbGlzdCA9IC9bXFx4MDEtXFx0XFx4MEJcXGZcXHgwRS1cXHgxRlxceDdGXFx4ODFcXHg4RFxceDhGXFx4OTBcXHg5RFxceEEwLVxcdUZGRkZdL2c7XG5cblx0dmFyIHJlZ2V4RW5jb2RlTm9uQXNjaWkgPSAvPFxcdTIwRDJ8PVxcdTIwRTV8PlxcdTIwRDJ8XFx1MjA1RlxcdTIwMEF8XFx1MjE5RFxcdTAzMzh8XFx1MjIwMlxcdTAzMzh8XFx1MjIyMFxcdTIwRDJ8XFx1MjIyOVxcdUZFMDB8XFx1MjIyQVxcdUZFMDB8XFx1MjIzQ1xcdTIwRDJ8XFx1MjIzRFxcdTAzMzF8XFx1MjIzRVxcdTAzMzN8XFx1MjI0MlxcdTAzMzh8XFx1MjI0QlxcdTAzMzh8XFx1MjI0RFxcdTIwRDJ8XFx1MjI0RVxcdTAzMzh8XFx1MjI0RlxcdTAzMzh8XFx1MjI1MFxcdTAzMzh8XFx1MjI2MVxcdTIwRTV8XFx1MjI2NFxcdTIwRDJ8XFx1MjI2NVxcdTIwRDJ8XFx1MjI2NlxcdTAzMzh8XFx1MjI2N1xcdTAzMzh8XFx1MjI2OFxcdUZFMDB8XFx1MjI2OVxcdUZFMDB8XFx1MjI2QVxcdTAzMzh8XFx1MjI2QVxcdTIwRDJ8XFx1MjI2QlxcdTAzMzh8XFx1MjI2QlxcdTIwRDJ8XFx1MjI3RlxcdTAzMzh8XFx1MjI4MlxcdTIwRDJ8XFx1MjI4M1xcdTIwRDJ8XFx1MjI4QVxcdUZFMDB8XFx1MjI4QlxcdUZFMDB8XFx1MjI4RlxcdTAzMzh8XFx1MjI5MFxcdTAzMzh8XFx1MjI5M1xcdUZFMDB8XFx1MjI5NFxcdUZFMDB8XFx1MjJCNFxcdTIwRDJ8XFx1MjJCNVxcdTIwRDJ8XFx1MjJEOFxcdTAzMzh8XFx1MjJEOVxcdTAzMzh8XFx1MjJEQVxcdUZFMDB8XFx1MjJEQlxcdUZFMDB8XFx1MjJGNVxcdTAzMzh8XFx1MjJGOVxcdTAzMzh8XFx1MjkzM1xcdTAzMzh8XFx1MjlDRlxcdTAzMzh8XFx1MjlEMFxcdTAzMzh8XFx1MkE2RFxcdTAzMzh8XFx1MkE3MFxcdTAzMzh8XFx1MkE3RFxcdTAzMzh8XFx1MkE3RVxcdTAzMzh8XFx1MkFBMVxcdTAzMzh8XFx1MkFBMlxcdTAzMzh8XFx1MkFBQ1xcdUZFMDB8XFx1MkFBRFxcdUZFMDB8XFx1MkFBRlxcdTAzMzh8XFx1MkFCMFxcdTAzMzh8XFx1MkFDNVxcdTAzMzh8XFx1MkFDNlxcdTAzMzh8XFx1MkFDQlxcdUZFMDB8XFx1MkFDQ1xcdUZFMDB8XFx1MkFGRFxcdTIwRTV8W1xceEEwLVxcdTAxMTNcXHUwMTE2LVxcdTAxMjJcXHUwMTI0LVxcdTAxMkJcXHUwMTJFLVxcdTAxNERcXHUwMTUwLVxcdTAxN0VcXHUwMTkyXFx1MDFCNVxcdTAxRjVcXHUwMjM3XFx1MDJDNlxcdTAyQzdcXHUwMkQ4LVxcdTAyRERcXHUwMzExXFx1MDM5MS1cXHUwM0ExXFx1MDNBMy1cXHUwM0E5XFx1MDNCMS1cXHUwM0M5XFx1MDNEMVxcdTAzRDJcXHUwM0Q1XFx1MDNENlxcdTAzRENcXHUwM0REXFx1MDNGMFxcdTAzRjFcXHUwM0Y1XFx1MDNGNlxcdTA0MDEtXFx1MDQwQ1xcdTA0MEUtXFx1MDQ0RlxcdTA0NTEtXFx1MDQ1Q1xcdTA0NUVcXHUwNDVGXFx1MjAwMi1cXHUyMDA1XFx1MjAwNy1cXHUyMDEwXFx1MjAxMy1cXHUyMDE2XFx1MjAxOC1cXHUyMDFBXFx1MjAxQy1cXHUyMDFFXFx1MjAyMC1cXHUyMDIyXFx1MjAyNVxcdTIwMjZcXHUyMDMwLVxcdTIwMzVcXHUyMDM5XFx1MjAzQVxcdTIwM0VcXHUyMDQxXFx1MjA0M1xcdTIwNDRcXHUyMDRGXFx1MjA1N1xcdTIwNUYtXFx1MjA2M1xcdTIwQUNcXHUyMERCXFx1MjBEQ1xcdTIxMDJcXHUyMTA1XFx1MjEwQS1cXHUyMTEzXFx1MjExNS1cXHUyMTFFXFx1MjEyMlxcdTIxMjRcXHUyMTI3LVxcdTIxMjlcXHUyMTJDXFx1MjEyRFxcdTIxMkYtXFx1MjEzMVxcdTIxMzMtXFx1MjEzOFxcdTIxNDUtXFx1MjE0OFxcdTIxNTMtXFx1MjE1RVxcdTIxOTAtXFx1MjE5QlxcdTIxOUQtXFx1MjFBN1xcdTIxQTktXFx1MjFBRVxcdTIxQjAtXFx1MjFCM1xcdTIxQjUtXFx1MjFCN1xcdTIxQkEtXFx1MjFEQlxcdTIxRERcXHUyMUU0XFx1MjFFNVxcdTIxRjVcXHUyMUZELVxcdTIyMDVcXHUyMjA3LVxcdTIyMDlcXHUyMjBCXFx1MjIwQ1xcdTIyMEYtXFx1MjIxNFxcdTIyMTYtXFx1MjIxOFxcdTIyMUFcXHUyMjFELVxcdTIyMzhcXHUyMjNBLVxcdTIyNTdcXHUyMjU5XFx1MjI1QVxcdTIyNUNcXHUyMjVGLVxcdTIyNjJcXHUyMjY0LVxcdTIyOEJcXHUyMjhELVxcdTIyOUJcXHUyMjlELVxcdTIyQTVcXHUyMkE3LVxcdTIyQjBcXHUyMkIyLVxcdTIyQkJcXHUyMkJELVxcdTIyREJcXHUyMkRFLVxcdTIyRTNcXHUyMkU2LVxcdTIyRjdcXHUyMkY5LVxcdTIyRkVcXHUyMzA1XFx1MjMwNlxcdTIzMDgtXFx1MjMxMFxcdTIzMTJcXHUyMzEzXFx1MjMxNVxcdTIzMTZcXHUyMzFDLVxcdTIzMUZcXHUyMzIyXFx1MjMyM1xcdTIzMkRcXHUyMzJFXFx1MjMzNlxcdTIzM0RcXHUyMzNGXFx1MjM3Q1xcdTIzQjBcXHUyM0IxXFx1MjNCNC1cXHUyM0I2XFx1MjNEQy1cXHUyM0RGXFx1MjNFMlxcdTIzRTdcXHUyNDIzXFx1MjRDOFxcdTI1MDBcXHUyNTAyXFx1MjUwQ1xcdTI1MTBcXHUyNTE0XFx1MjUxOFxcdTI1MUNcXHUyNTI0XFx1MjUyQ1xcdTI1MzRcXHUyNTNDXFx1MjU1MC1cXHUyNTZDXFx1MjU4MFxcdTI1ODRcXHUyNTg4XFx1MjU5MS1cXHUyNTkzXFx1MjVBMVxcdTI1QUFcXHUyNUFCXFx1MjVBRFxcdTI1QUVcXHUyNUIxXFx1MjVCMy1cXHUyNUI1XFx1MjVCOFxcdTI1QjlcXHUyNUJELVxcdTI1QkZcXHUyNUMyXFx1MjVDM1xcdTI1Q0FcXHUyNUNCXFx1MjVFQ1xcdTI1RUZcXHUyNUY4LVxcdTI1RkNcXHUyNjA1XFx1MjYwNlxcdTI2MEVcXHUyNjQwXFx1MjY0MlxcdTI2NjBcXHUyNjYzXFx1MjY2NVxcdTI2NjZcXHUyNjZBXFx1MjY2RC1cXHUyNjZGXFx1MjcxM1xcdTI3MTdcXHUyNzIwXFx1MjczNlxcdTI3NThcXHUyNzcyXFx1Mjc3M1xcdTI3QzhcXHUyN0M5XFx1MjdFNi1cXHUyN0VEXFx1MjdGNS1cXHUyN0ZBXFx1MjdGQ1xcdTI3RkZcXHUyOTAyLVxcdTI5MDVcXHUyOTBDLVxcdTI5MTNcXHUyOTE2XFx1MjkxOS1cXHUyOTIwXFx1MjkyMy1cXHUyOTJBXFx1MjkzM1xcdTI5MzUtXFx1MjkzOVxcdTI5M0NcXHUyOTNEXFx1Mjk0NVxcdTI5NDgtXFx1Mjk0QlxcdTI5NEUtXFx1Mjk3NlxcdTI5NzhcXHUyOTc5XFx1Mjk3Qi1cXHUyOTdGXFx1Mjk4NVxcdTI5ODZcXHUyOThCLVxcdTI5OTZcXHUyOTlBXFx1Mjk5Q1xcdTI5OURcXHUyOUE0LVxcdTI5QjdcXHUyOUI5XFx1MjlCQlxcdTI5QkNcXHUyOUJFLVxcdTI5QzVcXHUyOUM5XFx1MjlDRC1cXHUyOUQwXFx1MjlEQy1cXHUyOURFXFx1MjlFMy1cXHUyOUU1XFx1MjlFQlxcdTI5RjRcXHUyOUY2XFx1MkEwMC1cXHUyQTAyXFx1MkEwNFxcdTJBMDZcXHUyQTBDXFx1MkEwRFxcdTJBMTAtXFx1MkExN1xcdTJBMjItXFx1MkEyN1xcdTJBMjlcXHUyQTJBXFx1MkEyRC1cXHUyQTMxXFx1MkEzMy1cXHUyQTNDXFx1MkEzRlxcdTJBNDBcXHUyQTQyLVxcdTJBNERcXHUyQTUwXFx1MkE1My1cXHUyQTU4XFx1MkE1QS1cXHUyQTVEXFx1MkE1RlxcdTJBNjZcXHUyQTZBXFx1MkE2RC1cXHUyQTc1XFx1MkE3Ny1cXHUyQTlBXFx1MkE5RC1cXHUyQUEyXFx1MkFBNC1cXHUyQUIwXFx1MkFCMy1cXHUyQUM4XFx1MkFDQlxcdTJBQ0NcXHUyQUNGLVxcdTJBREJcXHUyQUU0XFx1MkFFNi1cXHUyQUU5XFx1MkFFQi1cXHUyQUYzXFx1MkFGRFxcdUZCMDAtXFx1RkIwNF18XFx1RDgzNVtcXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVEQ0NGXFx1REQwNFxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERDZCXS9nO1xuXHR2YXIgZW5jb2RlTWFwID0geydcXHhBRCc6J3NoeScsJ1xcdTIwMEMnOid6d25qJywnXFx1MjAwRCc6J3p3aicsJ1xcdTIwMEUnOidscm0nLCdcXHUyMDYzJzonaWMnLCdcXHUyMDYyJzonaXQnLCdcXHUyMDYxJzonYWYnLCdcXHUyMDBGJzoncmxtJywnXFx1MjAwQic6J1plcm9XaWR0aFNwYWNlJywnXFx1MjA2MCc6J05vQnJlYWsnLCdcXHUwMzExJzonRG93bkJyZXZlJywnXFx1MjBEQic6J3Rkb3QnLCdcXHUyMERDJzonRG90RG90JywnXFx0JzonVGFiJywnXFxuJzonTmV3TGluZScsJ1xcdTIwMDgnOidwdW5jc3AnLCdcXHUyMDVGJzonTWVkaXVtU3BhY2UnLCdcXHUyMDA5JzondGhpbnNwJywnXFx1MjAwQSc6J2hhaXJzcCcsJ1xcdTIwMDQnOidlbXNwMTMnLCdcXHUyMDAyJzonZW5zcCcsJ1xcdTIwMDUnOidlbXNwMTQnLCdcXHUyMDAzJzonZW1zcCcsJ1xcdTIwMDcnOidudW1zcCcsJ1xceEEwJzonbmJzcCcsJ1xcdTIwNUZcXHUyMDBBJzonVGhpY2tTcGFjZScsJ1xcdTIwM0UnOidvbGluZScsJ18nOidsb3diYXInLCdcXHUyMDEwJzonZGFzaCcsJ1xcdTIwMTMnOiduZGFzaCcsJ1xcdTIwMTQnOidtZGFzaCcsJ1xcdTIwMTUnOidob3JiYXInLCcsJzonY29tbWEnLCc7Jzonc2VtaScsJ1xcdTIwNEYnOidic2VtaScsJzonOidjb2xvbicsJ1xcdTJBNzQnOidDb2xvbmUnLCchJzonZXhjbCcsJ1xceEExJzonaWV4Y2wnLCc/JzoncXVlc3QnLCdcXHhCRic6J2lxdWVzdCcsJy4nOidwZXJpb2QnLCdcXHUyMDI1JzonbmxkcicsJ1xcdTIwMjYnOidtbGRyJywnXFx4QjcnOidtaWRkb3QnLCdcXCcnOidhcG9zJywnXFx1MjAxOCc6J2xzcXVvJywnXFx1MjAxOSc6J3JzcXVvJywnXFx1MjAxQSc6J3NicXVvJywnXFx1MjAzOSc6J2xzYXF1bycsJ1xcdTIwM0EnOidyc2FxdW8nLCdcIic6J3F1b3QnLCdcXHUyMDFDJzonbGRxdW8nLCdcXHUyMDFEJzoncmRxdW8nLCdcXHUyMDFFJzonYmRxdW8nLCdcXHhBQic6J2xhcXVvJywnXFx4QkInOidyYXF1bycsJygnOidscGFyJywnKSc6J3JwYXInLCdbJzonbHNxYicsJ10nOidyc3FiJywneyc6J2xjdWInLCd9JzoncmN1YicsJ1xcdTIzMDgnOidsY2VpbCcsJ1xcdTIzMDknOidyY2VpbCcsJ1xcdTIzMEEnOidsZmxvb3InLCdcXHUyMzBCJzoncmZsb29yJywnXFx1Mjk4NSc6J2xvcGFyJywnXFx1Mjk4Nic6J3JvcGFyJywnXFx1Mjk4Qic6J2xicmtlJywnXFx1Mjk4Qyc6J3JicmtlJywnXFx1Mjk4RCc6J2xicmtzbHUnLCdcXHUyOThFJzoncmJya3NsZCcsJ1xcdTI5OEYnOidsYnJrc2xkJywnXFx1Mjk5MCc6J3JicmtzbHUnLCdcXHUyOTkxJzonbGFuZ2QnLCdcXHUyOTkyJzoncmFuZ2QnLCdcXHUyOTkzJzonbHBhcmx0JywnXFx1Mjk5NCc6J3JwYXJndCcsJ1xcdTI5OTUnOidndGxQYXInLCdcXHUyOTk2JzonbHRyUGFyJywnXFx1MjdFNic6J2xvYnJrJywnXFx1MjdFNyc6J3JvYnJrJywnXFx1MjdFOCc6J2xhbmcnLCdcXHUyN0U5JzoncmFuZycsJ1xcdTI3RUEnOidMYW5nJywnXFx1MjdFQic6J1JhbmcnLCdcXHUyN0VDJzonbG9hbmcnLCdcXHUyN0VEJzoncm9hbmcnLCdcXHUyNzcyJzonbGJicmsnLCdcXHUyNzczJzoncmJicmsnLCdcXHUyMDE2JzonVmVydCcsJ1xceEE3Jzonc2VjdCcsJ1xceEI2JzoncGFyYScsJ0AnOidjb21tYXQnLCcqJzonYXN0JywnLyc6J3NvbCcsJ3VuZGVmaW5lZCc6bnVsbCwnJic6J2FtcCcsJyMnOidudW0nLCclJzoncGVyY250JywnXFx1MjAzMCc6J3Blcm1pbCcsJ1xcdTIwMzEnOidwZXJ0ZW5rJywnXFx1MjAyMCc6J2RhZ2dlcicsJ1xcdTIwMjEnOidEYWdnZXInLCdcXHUyMDIyJzonYnVsbCcsJ1xcdTIwNDMnOidoeWJ1bGwnLCdcXHUyMDMyJzoncHJpbWUnLCdcXHUyMDMzJzonUHJpbWUnLCdcXHUyMDM0JzondHByaW1lJywnXFx1MjA1Nyc6J3FwcmltZScsJ1xcdTIwMzUnOidicHJpbWUnLCdcXHUyMDQxJzonY2FyZXQnLCdgJzonZ3JhdmUnLCdcXHhCNCc6J2FjdXRlJywnXFx1MDJEQyc6J3RpbGRlJywnXic6J0hhdCcsJ1xceEFGJzonbWFjcicsJ1xcdTAyRDgnOidicmV2ZScsJ1xcdTAyRDknOidkb3QnLCdcXHhBOCc6J2RpZScsJ1xcdTAyREEnOidyaW5nJywnXFx1MDJERCc6J2RibGFjJywnXFx4QjgnOidjZWRpbCcsJ1xcdTAyREInOidvZ29uJywnXFx1MDJDNic6J2NpcmMnLCdcXHUwMkM3JzonY2Fyb24nLCdcXHhCMCc6J2RlZycsJ1xceEE5JzonY29weScsJ1xceEFFJzoncmVnJywnXFx1MjExNyc6J2NvcHlzcicsJ1xcdTIxMTgnOid3cCcsJ1xcdTIxMUUnOidyeCcsJ1xcdTIxMjcnOidtaG8nLCdcXHUyMTI5JzonaWlvdGEnLCdcXHUyMTkwJzonbGFycicsJ1xcdTIxOUEnOidubGFycicsJ1xcdTIxOTInOidyYXJyJywnXFx1MjE5Qic6J25yYXJyJywnXFx1MjE5MSc6J3VhcnInLCdcXHUyMTkzJzonZGFycicsJ1xcdTIxOTQnOidoYXJyJywnXFx1MjFBRSc6J25oYXJyJywnXFx1MjE5NSc6J3ZhcnInLCdcXHUyMTk2JzonbndhcnInLCdcXHUyMTk3JzonbmVhcnInLCdcXHUyMTk4Jzonc2VhcnInLCdcXHUyMTk5Jzonc3dhcnInLCdcXHUyMTlEJzoncmFycncnLCdcXHUyMTlEXFx1MDMzOCc6J25yYXJydycsJ1xcdTIxOUUnOidMYXJyJywnXFx1MjE5Ric6J1VhcnInLCdcXHUyMUEwJzonUmFycicsJ1xcdTIxQTEnOidEYXJyJywnXFx1MjFBMic6J2xhcnJ0bCcsJ1xcdTIxQTMnOidyYXJydGwnLCdcXHUyMUE0JzonbWFwc3RvbGVmdCcsJ1xcdTIxQTUnOidtYXBzdG91cCcsJ1xcdTIxQTYnOidtYXAnLCdcXHUyMUE3JzonbWFwc3RvZG93bicsJ1xcdTIxQTknOidsYXJyaGsnLCdcXHUyMUFBJzoncmFycmhrJywnXFx1MjFBQic6J2xhcnJscCcsJ1xcdTIxQUMnOidyYXJybHAnLCdcXHUyMUFEJzonaGFycncnLCdcXHUyMUIwJzonbHNoJywnXFx1MjFCMSc6J3JzaCcsJ1xcdTIxQjInOidsZHNoJywnXFx1MjFCMyc6J3Jkc2gnLCdcXHUyMUI1JzonY3JhcnInLCdcXHUyMUI2JzonY3VsYXJyJywnXFx1MjFCNyc6J2N1cmFycicsJ1xcdTIxQkEnOidvbGFycicsJ1xcdTIxQkInOidvcmFycicsJ1xcdTIxQkMnOidsaGFydScsJ1xcdTIxQkQnOidsaGFyZCcsJ1xcdTIxQkUnOid1aGFycicsJ1xcdTIxQkYnOid1aGFybCcsJ1xcdTIxQzAnOidyaGFydScsJ1xcdTIxQzEnOidyaGFyZCcsJ1xcdTIxQzInOidkaGFycicsJ1xcdTIxQzMnOidkaGFybCcsJ1xcdTIxQzQnOidybGFycicsJ1xcdTIxQzUnOid1ZGFycicsJ1xcdTIxQzYnOidscmFycicsJ1xcdTIxQzcnOidsbGFycicsJ1xcdTIxQzgnOid1dWFycicsJ1xcdTIxQzknOidycmFycicsJ1xcdTIxQ0EnOidkZGFycicsJ1xcdTIxQ0InOidscmhhcicsJ1xcdTIxQ0MnOidybGhhcicsJ1xcdTIxRDAnOidsQXJyJywnXFx1MjFDRCc6J25sQXJyJywnXFx1MjFEMSc6J3VBcnInLCdcXHUyMUQyJzonckFycicsJ1xcdTIxQ0YnOiduckFycicsJ1xcdTIxRDMnOidkQXJyJywnXFx1MjFENCc6J2lmZicsJ1xcdTIxQ0UnOiduaEFycicsJ1xcdTIxRDUnOid2QXJyJywnXFx1MjFENic6J253QXJyJywnXFx1MjFENyc6J25lQXJyJywnXFx1MjFEOCc6J3NlQXJyJywnXFx1MjFEOSc6J3N3QXJyJywnXFx1MjFEQSc6J2xBYXJyJywnXFx1MjFEQic6J3JBYXJyJywnXFx1MjFERCc6J3ppZ3JhcnInLCdcXHUyMUU0JzonbGFycmInLCdcXHUyMUU1JzoncmFycmInLCdcXHUyMUY1JzonZHVhcnInLCdcXHUyMUZEJzonbG9hcnInLCdcXHUyMUZFJzoncm9hcnInLCdcXHUyMUZGJzonaG9hcnInLCdcXHUyMjAwJzonZm9yYWxsJywnXFx1MjIwMSc6J2NvbXAnLCdcXHUyMjAyJzoncGFydCcsJ1xcdTIyMDJcXHUwMzM4JzonbnBhcnQnLCdcXHUyMjAzJzonZXhpc3QnLCdcXHUyMjA0JzonbmV4aXN0JywnXFx1MjIwNSc6J2VtcHR5JywnXFx1MjIwNyc6J0RlbCcsJ1xcdTIyMDgnOidpbicsJ1xcdTIyMDknOidub3RpbicsJ1xcdTIyMEInOiduaScsJ1xcdTIyMEMnOidub3RuaScsJ1xcdTAzRjYnOidiZXBzaScsJ1xcdTIyMEYnOidwcm9kJywnXFx1MjIxMCc6J2NvcHJvZCcsJ1xcdTIyMTEnOidzdW0nLCcrJzoncGx1cycsJ1xceEIxJzoncG0nLCdcXHhGNyc6J2RpdicsJ1xceEQ3JzondGltZXMnLCc8JzonbHQnLCdcXHUyMjZFJzonbmx0JywnPFxcdTIwRDInOidudmx0JywnPSc6J2VxdWFscycsJ1xcdTIyNjAnOiduZScsJz1cXHUyMEU1JzonYm5lJywnXFx1MkE3NSc6J0VxdWFsJywnPic6J2d0JywnXFx1MjI2Ric6J25ndCcsJz5cXHUyMEQyJzonbnZndCcsJ1xceEFDJzonbm90JywnfCc6J3ZlcnQnLCdcXHhBNic6J2JydmJhcicsJ1xcdTIyMTInOidtaW51cycsJ1xcdTIyMTMnOidtcCcsJ1xcdTIyMTQnOidwbHVzZG8nLCdcXHUyMDQ0JzonZnJhc2wnLCdcXHUyMjE2Jzonc2V0bW4nLCdcXHUyMjE3JzonbG93YXN0JywnXFx1MjIxOCc6J2NvbXBmbicsJ1xcdTIyMUEnOidTcXJ0JywnXFx1MjIxRCc6J3Byb3AnLCdcXHUyMjFFJzonaW5maW4nLCdcXHUyMjFGJzonYW5ncnQnLCdcXHUyMjIwJzonYW5nJywnXFx1MjIyMFxcdTIwRDInOiduYW5nJywnXFx1MjIyMSc6J2FuZ21zZCcsJ1xcdTIyMjInOidhbmdzcGgnLCdcXHUyMjIzJzonbWlkJywnXFx1MjIyNCc6J25taWQnLCdcXHUyMjI1JzoncGFyJywnXFx1MjIyNic6J25wYXInLCdcXHUyMjI3JzonYW5kJywnXFx1MjIyOCc6J29yJywnXFx1MjIyOSc6J2NhcCcsJ1xcdTIyMjlcXHVGRTAwJzonY2FwcycsJ1xcdTIyMkEnOidjdXAnLCdcXHUyMjJBXFx1RkUwMCc6J2N1cHMnLCdcXHUyMjJCJzonaW50JywnXFx1MjIyQyc6J0ludCcsJ1xcdTIyMkQnOid0aW50JywnXFx1MkEwQyc6J3FpbnQnLCdcXHUyMjJFJzonb2ludCcsJ1xcdTIyMkYnOidDb25pbnQnLCdcXHUyMjMwJzonQ2NvbmludCcsJ1xcdTIyMzEnOidjd2ludCcsJ1xcdTIyMzInOidjd2NvbmludCcsJ1xcdTIyMzMnOidhd2NvbmludCcsJ1xcdTIyMzQnOid0aGVyZTQnLCdcXHUyMjM1JzonYmVjYXVzJywnXFx1MjIzNic6J3JhdGlvJywnXFx1MjIzNyc6J0NvbG9uJywnXFx1MjIzOCc6J21pbnVzZCcsJ1xcdTIyM0EnOidtRERvdCcsJ1xcdTIyM0InOidob210aHQnLCdcXHUyMjNDJzonc2ltJywnXFx1MjI0MSc6J25zaW0nLCdcXHUyMjNDXFx1MjBEMic6J252c2ltJywnXFx1MjIzRCc6J2JzaW0nLCdcXHUyMjNEXFx1MDMzMSc6J3JhY2UnLCdcXHUyMjNFJzonYWMnLCdcXHUyMjNFXFx1MDMzMyc6J2FjRScsJ1xcdTIyM0YnOidhY2QnLCdcXHUyMjQwJzond3InLCdcXHUyMjQyJzonZXNpbScsJ1xcdTIyNDJcXHUwMzM4JzonbmVzaW0nLCdcXHUyMjQzJzonc2ltZScsJ1xcdTIyNDQnOiduc2ltZScsJ1xcdTIyNDUnOidjb25nJywnXFx1MjI0Nyc6J25jb25nJywnXFx1MjI0Nic6J3NpbW5lJywnXFx1MjI0OCc6J2FwJywnXFx1MjI0OSc6J25hcCcsJ1xcdTIyNEEnOidhcGUnLCdcXHUyMjRCJzonYXBpZCcsJ1xcdTIyNEJcXHUwMzM4JzonbmFwaWQnLCdcXHUyMjRDJzonYmNvbmcnLCdcXHUyMjREJzonQ3VwQ2FwJywnXFx1MjI2RCc6J05vdEN1cENhcCcsJ1xcdTIyNERcXHUyMEQyJzonbnZhcCcsJ1xcdTIyNEUnOididW1wJywnXFx1MjI0RVxcdTAzMzgnOiduYnVtcCcsJ1xcdTIyNEYnOididW1wZScsJ1xcdTIyNEZcXHUwMzM4JzonbmJ1bXBlJywnXFx1MjI1MCc6J2RvdGVxJywnXFx1MjI1MFxcdTAzMzgnOiduZWRvdCcsJ1xcdTIyNTEnOidlRG90JywnXFx1MjI1Mic6J2VmRG90JywnXFx1MjI1Myc6J2VyRG90JywnXFx1MjI1NCc6J2NvbG9uZScsJ1xcdTIyNTUnOidlY29sb24nLCdcXHUyMjU2JzonZWNpcicsJ1xcdTIyNTcnOidjaXJlJywnXFx1MjI1OSc6J3dlZGdlcScsJ1xcdTIyNUEnOid2ZWVlcScsJ1xcdTIyNUMnOid0cmllJywnXFx1MjI1Ric6J2VxdWVzdCcsJ1xcdTIyNjEnOidlcXVpdicsJ1xcdTIyNjInOiduZXF1aXYnLCdcXHUyMjYxXFx1MjBFNSc6J2JuZXF1aXYnLCdcXHUyMjY0JzonbGUnLCdcXHUyMjcwJzonbmxlJywnXFx1MjI2NFxcdTIwRDInOidudmxlJywnXFx1MjI2NSc6J2dlJywnXFx1MjI3MSc6J25nZScsJ1xcdTIyNjVcXHUyMEQyJzonbnZnZScsJ1xcdTIyNjYnOidsRScsJ1xcdTIyNjZcXHUwMzM4JzonbmxFJywnXFx1MjI2Nyc6J2dFJywnXFx1MjI2N1xcdTAzMzgnOiduZ0UnLCdcXHUyMjY4XFx1RkUwMCc6J2x2bkUnLCdcXHUyMjY4JzonbG5FJywnXFx1MjI2OSc6J2duRScsJ1xcdTIyNjlcXHVGRTAwJzonZ3ZuRScsJ1xcdTIyNkEnOidsbCcsJ1xcdTIyNkFcXHUwMzM4Jzonbkx0dicsJ1xcdTIyNkFcXHUyMEQyJzonbkx0JywnXFx1MjI2Qic6J2dnJywnXFx1MjI2QlxcdTAzMzgnOiduR3R2JywnXFx1MjI2QlxcdTIwRDInOiduR3QnLCdcXHUyMjZDJzondHdpeHQnLCdcXHUyMjcyJzonbHNpbScsJ1xcdTIyNzQnOidubHNpbScsJ1xcdTIyNzMnOidnc2ltJywnXFx1MjI3NSc6J25nc2ltJywnXFx1MjI3Nic6J2xnJywnXFx1MjI3OCc6J250bGcnLCdcXHUyMjc3JzonZ2wnLCdcXHUyMjc5JzonbnRnbCcsJ1xcdTIyN0EnOidwcicsJ1xcdTIyODAnOiducHInLCdcXHUyMjdCJzonc2MnLCdcXHUyMjgxJzonbnNjJywnXFx1MjI3Qyc6J3ByY3VlJywnXFx1MjJFMCc6J25wcmN1ZScsJ1xcdTIyN0QnOidzY2N1ZScsJ1xcdTIyRTEnOiduc2NjdWUnLCdcXHUyMjdFJzoncHJzaW0nLCdcXHUyMjdGJzonc2NzaW0nLCdcXHUyMjdGXFx1MDMzOCc6J05vdFN1Y2NlZWRzVGlsZGUnLCdcXHUyMjgyJzonc3ViJywnXFx1MjI4NCc6J25zdWInLCdcXHUyMjgyXFx1MjBEMic6J3Zuc3ViJywnXFx1MjI4Myc6J3N1cCcsJ1xcdTIyODUnOiduc3VwJywnXFx1MjI4M1xcdTIwRDInOid2bnN1cCcsJ1xcdTIyODYnOidzdWJlJywnXFx1MjI4OCc6J25zdWJlJywnXFx1MjI4Nyc6J3N1cGUnLCdcXHUyMjg5JzonbnN1cGUnLCdcXHUyMjhBXFx1RkUwMCc6J3ZzdWJuZScsJ1xcdTIyOEEnOidzdWJuZScsJ1xcdTIyOEJcXHVGRTAwJzondnN1cG5lJywnXFx1MjI4Qic6J3N1cG5lJywnXFx1MjI4RCc6J2N1cGRvdCcsJ1xcdTIyOEUnOid1cGx1cycsJ1xcdTIyOEYnOidzcXN1YicsJ1xcdTIyOEZcXHUwMzM4JzonTm90U3F1YXJlU3Vic2V0JywnXFx1MjI5MCc6J3Nxc3VwJywnXFx1MjI5MFxcdTAzMzgnOidOb3RTcXVhcmVTdXBlcnNldCcsJ1xcdTIyOTEnOidzcXN1YmUnLCdcXHUyMkUyJzonbnNxc3ViZScsJ1xcdTIyOTInOidzcXN1cGUnLCdcXHUyMkUzJzonbnNxc3VwZScsJ1xcdTIyOTMnOidzcWNhcCcsJ1xcdTIyOTNcXHVGRTAwJzonc3FjYXBzJywnXFx1MjI5NCc6J3NxY3VwJywnXFx1MjI5NFxcdUZFMDAnOidzcWN1cHMnLCdcXHUyMjk1Jzonb3BsdXMnLCdcXHUyMjk2Jzonb21pbnVzJywnXFx1MjI5Nyc6J290aW1lcycsJ1xcdTIyOTgnOidvc29sJywnXFx1MjI5OSc6J29kb3QnLCdcXHUyMjlBJzonb2NpcicsJ1xcdTIyOUInOidvYXN0JywnXFx1MjI5RCc6J29kYXNoJywnXFx1MjI5RSc6J3BsdXNiJywnXFx1MjI5Ric6J21pbnVzYicsJ1xcdTIyQTAnOid0aW1lc2InLCdcXHUyMkExJzonc2RvdGInLCdcXHUyMkEyJzondmRhc2gnLCdcXHUyMkFDJzonbnZkYXNoJywnXFx1MjJBMyc6J2Rhc2h2JywnXFx1MjJBNCc6J3RvcCcsJ1xcdTIyQTUnOidib3QnLCdcXHUyMkE3JzonbW9kZWxzJywnXFx1MjJBOCc6J3ZEYXNoJywnXFx1MjJBRCc6J252RGFzaCcsJ1xcdTIyQTknOidWZGFzaCcsJ1xcdTIyQUUnOiduVmRhc2gnLCdcXHUyMkFBJzonVnZkYXNoJywnXFx1MjJBQic6J1ZEYXNoJywnXFx1MjJBRic6J25WRGFzaCcsJ1xcdTIyQjAnOidwcnVyZWwnLCdcXHUyMkIyJzondmx0cmknLCdcXHUyMkVBJzonbmx0cmknLCdcXHUyMkIzJzondnJ0cmknLCdcXHUyMkVCJzonbnJ0cmknLCdcXHUyMkI0JzonbHRyaWUnLCdcXHUyMkVDJzonbmx0cmllJywnXFx1MjJCNFxcdTIwRDInOidudmx0cmllJywnXFx1MjJCNSc6J3J0cmllJywnXFx1MjJFRCc6J25ydHJpZScsJ1xcdTIyQjVcXHUyMEQyJzonbnZydHJpZScsJ1xcdTIyQjYnOidvcmlnb2YnLCdcXHUyMkI3JzonaW1vZicsJ1xcdTIyQjgnOidtdW1hcCcsJ1xcdTIyQjknOidoZXJjb24nLCdcXHUyMkJBJzonaW50Y2FsJywnXFx1MjJCQic6J3ZlZWJhcicsJ1xcdTIyQkQnOidiYXJ2ZWUnLCdcXHUyMkJFJzonYW5ncnR2YicsJ1xcdTIyQkYnOidscnRyaScsJ1xcdTIyQzAnOidXZWRnZScsJ1xcdTIyQzEnOidWZWUnLCdcXHUyMkMyJzoneGNhcCcsJ1xcdTIyQzMnOid4Y3VwJywnXFx1MjJDNCc6J2RpYW0nLCdcXHUyMkM1Jzonc2RvdCcsJ1xcdTIyQzYnOidTdGFyJywnXFx1MjJDNyc6J2Rpdm9ueCcsJ1xcdTIyQzgnOidib3d0aWUnLCdcXHUyMkM5JzonbHRpbWVzJywnXFx1MjJDQSc6J3J0aW1lcycsJ1xcdTIyQ0InOidsdGhyZWUnLCdcXHUyMkNDJzoncnRocmVlJywnXFx1MjJDRCc6J2JzaW1lJywnXFx1MjJDRSc6J2N1dmVlJywnXFx1MjJDRic6J2N1d2VkJywnXFx1MjJEMCc6J1N1YicsJ1xcdTIyRDEnOidTdXAnLCdcXHUyMkQyJzonQ2FwJywnXFx1MjJEMyc6J0N1cCcsJ1xcdTIyRDQnOidmb3JrJywnXFx1MjJENSc6J2VwYXInLCdcXHUyMkQ2JzonbHRkb3QnLCdcXHUyMkQ3JzonZ3Rkb3QnLCdcXHUyMkQ4JzonTGwnLCdcXHUyMkQ4XFx1MDMzOCc6J25MbCcsJ1xcdTIyRDknOidHZycsJ1xcdTIyRDlcXHUwMzM4JzonbkdnJywnXFx1MjJEQVxcdUZFMDAnOidsZXNnJywnXFx1MjJEQSc6J2xlZycsJ1xcdTIyREInOidnZWwnLCdcXHUyMkRCXFx1RkUwMCc6J2dlc2wnLCdcXHUyMkRFJzonY3VlcHInLCdcXHUyMkRGJzonY3Vlc2MnLCdcXHUyMkU2JzonbG5zaW0nLCdcXHUyMkU3JzonZ25zaW0nLCdcXHUyMkU4JzoncHJuc2ltJywnXFx1MjJFOSc6J3NjbnNpbScsJ1xcdTIyRUUnOid2ZWxsaXAnLCdcXHUyMkVGJzonY3Rkb3QnLCdcXHUyMkYwJzondXRkb3QnLCdcXHUyMkYxJzonZHRkb3QnLCdcXHUyMkYyJzonZGlzaW4nLCdcXHUyMkYzJzonaXNpbnN2JywnXFx1MjJGNCc6J2lzaW5zJywnXFx1MjJGNSc6J2lzaW5kb3QnLCdcXHUyMkY1XFx1MDMzOCc6J25vdGluZG90JywnXFx1MjJGNic6J25vdGludmMnLCdcXHUyMkY3Jzonbm90aW52YicsJ1xcdTIyRjknOidpc2luRScsJ1xcdTIyRjlcXHUwMzM4Jzonbm90aW5FJywnXFx1MjJGQSc6J25pc2QnLCdcXHUyMkZCJzoneG5pcycsJ1xcdTIyRkMnOiduaXMnLCdcXHUyMkZEJzonbm90bml2YycsJ1xcdTIyRkUnOidub3RuaXZiJywnXFx1MjMwNSc6J2JhcndlZCcsJ1xcdTIzMDYnOidCYXJ3ZWQnLCdcXHUyMzBDJzonZHJjcm9wJywnXFx1MjMwRCc6J2RsY3JvcCcsJ1xcdTIzMEUnOid1cmNyb3AnLCdcXHUyMzBGJzondWxjcm9wJywnXFx1MjMxMCc6J2Jub3QnLCdcXHUyMzEyJzoncHJvZmxpbmUnLCdcXHUyMzEzJzoncHJvZnN1cmYnLCdcXHUyMzE1JzondGVscmVjJywnXFx1MjMxNic6J3RhcmdldCcsJ1xcdTIzMUMnOid1bGNvcm4nLCdcXHUyMzFEJzondXJjb3JuJywnXFx1MjMxRSc6J2RsY29ybicsJ1xcdTIzMUYnOidkcmNvcm4nLCdcXHUyMzIyJzonZnJvd24nLCdcXHUyMzIzJzonc21pbGUnLCdcXHUyMzJEJzonY3lsY3R5JywnXFx1MjMyRSc6J3Byb2ZhbGFyJywnXFx1MjMzNic6J3RvcGJvdCcsJ1xcdTIzM0QnOidvdmJhcicsJ1xcdTIzM0YnOidzb2xiYXInLCdcXHUyMzdDJzonYW5nemFycicsJ1xcdTIzQjAnOidsbW91c3QnLCdcXHUyM0IxJzoncm1vdXN0JywnXFx1MjNCNCc6J3RicmsnLCdcXHUyM0I1JzonYmJyaycsJ1xcdTIzQjYnOidiYnJrdGJyaycsJ1xcdTIzREMnOidPdmVyUGFyZW50aGVzaXMnLCdcXHUyM0REJzonVW5kZXJQYXJlbnRoZXNpcycsJ1xcdTIzREUnOidPdmVyQnJhY2UnLCdcXHUyM0RGJzonVW5kZXJCcmFjZScsJ1xcdTIzRTInOid0cnBleml1bScsJ1xcdTIzRTcnOidlbGludGVycycsJ1xcdTI0MjMnOidibGFuaycsJ1xcdTI1MDAnOidib3hoJywnXFx1MjUwMic6J2JveHYnLCdcXHUyNTBDJzonYm94ZHInLCdcXHUyNTEwJzonYm94ZGwnLCdcXHUyNTE0JzonYm94dXInLCdcXHUyNTE4JzonYm94dWwnLCdcXHUyNTFDJzonYm94dnInLCdcXHUyNTI0JzonYm94dmwnLCdcXHUyNTJDJzonYm94aGQnLCdcXHUyNTM0JzonYm94aHUnLCdcXHUyNTNDJzonYm94dmgnLCdcXHUyNTUwJzonYm94SCcsJ1xcdTI1NTEnOidib3hWJywnXFx1MjU1Mic6J2JveGRSJywnXFx1MjU1Myc6J2JveERyJywnXFx1MjU1NCc6J2JveERSJywnXFx1MjU1NSc6J2JveGRMJywnXFx1MjU1Nic6J2JveERsJywnXFx1MjU1Nyc6J2JveERMJywnXFx1MjU1OCc6J2JveHVSJywnXFx1MjU1OSc6J2JveFVyJywnXFx1MjU1QSc6J2JveFVSJywnXFx1MjU1Qic6J2JveHVMJywnXFx1MjU1Qyc6J2JveFVsJywnXFx1MjU1RCc6J2JveFVMJywnXFx1MjU1RSc6J2JveHZSJywnXFx1MjU1Ric6J2JveFZyJywnXFx1MjU2MCc6J2JveFZSJywnXFx1MjU2MSc6J2JveHZMJywnXFx1MjU2Mic6J2JveFZsJywnXFx1MjU2Myc6J2JveFZMJywnXFx1MjU2NCc6J2JveEhkJywnXFx1MjU2NSc6J2JveGhEJywnXFx1MjU2Nic6J2JveEhEJywnXFx1MjU2Nyc6J2JveEh1JywnXFx1MjU2OCc6J2JveGhVJywnXFx1MjU2OSc6J2JveEhVJywnXFx1MjU2QSc6J2JveHZIJywnXFx1MjU2Qic6J2JveFZoJywnXFx1MjU2Qyc6J2JveFZIJywnXFx1MjU4MCc6J3VoYmxrJywnXFx1MjU4NCc6J2xoYmxrJywnXFx1MjU4OCc6J2Jsb2NrJywnXFx1MjU5MSc6J2JsazE0JywnXFx1MjU5Mic6J2JsazEyJywnXFx1MjU5Myc6J2JsazM0JywnXFx1MjVBMSc6J3NxdScsJ1xcdTI1QUEnOidzcXVmJywnXFx1MjVBQic6J0VtcHR5VmVyeVNtYWxsU3F1YXJlJywnXFx1MjVBRCc6J3JlY3QnLCdcXHUyNUFFJzonbWFya2VyJywnXFx1MjVCMSc6J2ZsdG5zJywnXFx1MjVCMyc6J3h1dHJpJywnXFx1MjVCNCc6J3V0cmlmJywnXFx1MjVCNSc6J3V0cmknLCdcXHUyNUI4JzoncnRyaWYnLCdcXHUyNUI5JzoncnRyaScsJ1xcdTI1QkQnOid4ZHRyaScsJ1xcdTI1QkUnOidkdHJpZicsJ1xcdTI1QkYnOidkdHJpJywnXFx1MjVDMic6J2x0cmlmJywnXFx1MjVDMyc6J2x0cmknLCdcXHUyNUNBJzonbG96JywnXFx1MjVDQic6J2NpcicsJ1xcdTI1RUMnOid0cmlkb3QnLCdcXHUyNUVGJzoneGNpcmMnLCdcXHUyNUY4JzondWx0cmknLCdcXHUyNUY5JzondXJ0cmknLCdcXHUyNUZBJzonbGx0cmknLCdcXHUyNUZCJzonRW1wdHlTbWFsbFNxdWFyZScsJ1xcdTI1RkMnOidGaWxsZWRTbWFsbFNxdWFyZScsJ1xcdTI2MDUnOidzdGFyZicsJ1xcdTI2MDYnOidzdGFyJywnXFx1MjYwRSc6J3Bob25lJywnXFx1MjY0MCc6J2ZlbWFsZScsJ1xcdTI2NDInOidtYWxlJywnXFx1MjY2MCc6J3NwYWRlcycsJ1xcdTI2NjMnOidjbHVicycsJ1xcdTI2NjUnOidoZWFydHMnLCdcXHUyNjY2JzonZGlhbXMnLCdcXHUyNjZBJzonc3VuZycsJ1xcdTI3MTMnOidjaGVjaycsJ1xcdTI3MTcnOidjcm9zcycsJ1xcdTI3MjAnOidtYWx0JywnXFx1MjczNic6J3NleHQnLCdcXHUyNzU4JzonVmVydGljYWxTZXBhcmF0b3InLCdcXHUyN0M4JzonYnNvbGhzdWInLCdcXHUyN0M5Jzonc3VwaHNvbCcsJ1xcdTI3RjUnOid4bGFycicsJ1xcdTI3RjYnOid4cmFycicsJ1xcdTI3RjcnOid4aGFycicsJ1xcdTI3RjgnOid4bEFycicsJ1xcdTI3RjknOid4ckFycicsJ1xcdTI3RkEnOid4aEFycicsJ1xcdTI3RkMnOid4bWFwJywnXFx1MjdGRic6J2R6aWdyYXJyJywnXFx1MjkwMic6J252bEFycicsJ1xcdTI5MDMnOidudnJBcnInLCdcXHUyOTA0JzonbnZIYXJyJywnXFx1MjkwNSc6J01hcCcsJ1xcdTI5MEMnOidsYmFycicsJ1xcdTI5MEQnOidyYmFycicsJ1xcdTI5MEUnOidsQmFycicsJ1xcdTI5MEYnOidyQmFycicsJ1xcdTI5MTAnOidSQmFycicsJ1xcdTI5MTEnOidERG90cmFoZCcsJ1xcdTI5MTInOidVcEFycm93QmFyJywnXFx1MjkxMyc6J0Rvd25BcnJvd0JhcicsJ1xcdTI5MTYnOidSYXJydGwnLCdcXHUyOTE5JzonbGF0YWlsJywnXFx1MjkxQSc6J3JhdGFpbCcsJ1xcdTI5MUInOidsQXRhaWwnLCdcXHUyOTFDJzonckF0YWlsJywnXFx1MjkxRCc6J2xhcnJmcycsJ1xcdTI5MUUnOidyYXJyZnMnLCdcXHUyOTFGJzonbGFycmJmcycsJ1xcdTI5MjAnOidyYXJyYmZzJywnXFx1MjkyMyc6J253YXJoaycsJ1xcdTI5MjQnOiduZWFyaGsnLCdcXHUyOTI1Jzonc2VhcmhrJywnXFx1MjkyNic6J3N3YXJoaycsJ1xcdTI5MjcnOidud25lYXInLCdcXHUyOTI4JzondG9lYScsJ1xcdTI5MjknOid0b3NhJywnXFx1MjkyQSc6J3N3bndhcicsJ1xcdTI5MzMnOidyYXJyYycsJ1xcdTI5MzNcXHUwMzM4JzonbnJhcnJjJywnXFx1MjkzNSc6J2N1ZGFycnInLCdcXHUyOTM2JzonbGRjYScsJ1xcdTI5MzcnOidyZGNhJywnXFx1MjkzOCc6J2N1ZGFycmwnLCdcXHUyOTM5JzonbGFycnBsJywnXFx1MjkzQyc6J2N1cmFycm0nLCdcXHUyOTNEJzonY3VsYXJycCcsJ1xcdTI5NDUnOidyYXJycGwnLCdcXHUyOTQ4JzonaGFycmNpcicsJ1xcdTI5NDknOidVYXJyb2NpcicsJ1xcdTI5NEEnOidsdXJkc2hhcicsJ1xcdTI5NEInOidsZHJ1c2hhcicsJ1xcdTI5NEUnOidMZWZ0UmlnaHRWZWN0b3InLCdcXHUyOTRGJzonUmlnaHRVcERvd25WZWN0b3InLCdcXHUyOTUwJzonRG93bkxlZnRSaWdodFZlY3RvcicsJ1xcdTI5NTEnOidMZWZ0VXBEb3duVmVjdG9yJywnXFx1Mjk1Mic6J0xlZnRWZWN0b3JCYXInLCdcXHUyOTUzJzonUmlnaHRWZWN0b3JCYXInLCdcXHUyOTU0JzonUmlnaHRVcFZlY3RvckJhcicsJ1xcdTI5NTUnOidSaWdodERvd25WZWN0b3JCYXInLCdcXHUyOTU2JzonRG93bkxlZnRWZWN0b3JCYXInLCdcXHUyOTU3JzonRG93blJpZ2h0VmVjdG9yQmFyJywnXFx1Mjk1OCc6J0xlZnRVcFZlY3RvckJhcicsJ1xcdTI5NTknOidMZWZ0RG93blZlY3RvckJhcicsJ1xcdTI5NUEnOidMZWZ0VGVlVmVjdG9yJywnXFx1Mjk1Qic6J1JpZ2h0VGVlVmVjdG9yJywnXFx1Mjk1Qyc6J1JpZ2h0VXBUZWVWZWN0b3InLCdcXHUyOTVEJzonUmlnaHREb3duVGVlVmVjdG9yJywnXFx1Mjk1RSc6J0Rvd25MZWZ0VGVlVmVjdG9yJywnXFx1Mjk1Ric6J0Rvd25SaWdodFRlZVZlY3RvcicsJ1xcdTI5NjAnOidMZWZ0VXBUZWVWZWN0b3InLCdcXHUyOTYxJzonTGVmdERvd25UZWVWZWN0b3InLCdcXHUyOTYyJzonbEhhcicsJ1xcdTI5NjMnOid1SGFyJywnXFx1Mjk2NCc6J3JIYXInLCdcXHUyOTY1JzonZEhhcicsJ1xcdTI5NjYnOidsdXJ1aGFyJywnXFx1Mjk2Nyc6J2xkcmRoYXInLCdcXHUyOTY4JzoncnVsdWhhcicsJ1xcdTI5NjknOidyZGxkaGFyJywnXFx1Mjk2QSc6J2xoYXJ1bCcsJ1xcdTI5NkInOidsbGhhcmQnLCdcXHUyOTZDJzoncmhhcnVsJywnXFx1Mjk2RCc6J2xyaGFyZCcsJ1xcdTI5NkUnOid1ZGhhcicsJ1xcdTI5NkYnOidkdWhhcicsJ1xcdTI5NzAnOidSb3VuZEltcGxpZXMnLCdcXHUyOTcxJzonZXJhcnInLCdcXHUyOTcyJzonc2ltcmFycicsJ1xcdTI5NzMnOidsYXJyc2ltJywnXFx1Mjk3NCc6J3JhcnJzaW0nLCdcXHUyOTc1JzoncmFycmFwJywnXFx1Mjk3Nic6J2x0bGFycicsJ1xcdTI5NzgnOidndHJhcnInLCdcXHUyOTc5Jzonc3VicmFycicsJ1xcdTI5N0InOidzdXBsYXJyJywnXFx1Mjk3Qyc6J2xmaXNodCcsJ1xcdTI5N0QnOidyZmlzaHQnLCdcXHUyOTdFJzondWZpc2h0JywnXFx1Mjk3Ric6J2RmaXNodCcsJ1xcdTI5OUEnOid2emlnemFnJywnXFx1Mjk5Qyc6J3ZhbmdydCcsJ1xcdTI5OUQnOidhbmdydHZiZCcsJ1xcdTI5QTQnOidhbmdlJywnXFx1MjlBNSc6J3JhbmdlJywnXFx1MjlBNic6J2R3YW5nbGUnLCdcXHUyOUE3JzondXdhbmdsZScsJ1xcdTI5QTgnOidhbmdtc2RhYScsJ1xcdTI5QTknOidhbmdtc2RhYicsJ1xcdTI5QUEnOidhbmdtc2RhYycsJ1xcdTI5QUInOidhbmdtc2RhZCcsJ1xcdTI5QUMnOidhbmdtc2RhZScsJ1xcdTI5QUQnOidhbmdtc2RhZicsJ1xcdTI5QUUnOidhbmdtc2RhZycsJ1xcdTI5QUYnOidhbmdtc2RhaCcsJ1xcdTI5QjAnOidiZW1wdHl2JywnXFx1MjlCMSc6J2RlbXB0eXYnLCdcXHUyOUIyJzonY2VtcHR5dicsJ1xcdTI5QjMnOidyYWVtcHR5dicsJ1xcdTI5QjQnOidsYWVtcHR5dicsJ1xcdTI5QjUnOidvaGJhcicsJ1xcdTI5QjYnOidvbWlkJywnXFx1MjlCNyc6J29wYXInLCdcXHUyOUI5Jzonb3BlcnAnLCdcXHUyOUJCJzonb2xjcm9zcycsJ1xcdTI5QkMnOidvZHNvbGQnLCdcXHUyOUJFJzonb2xjaXInLCdcXHUyOUJGJzonb2ZjaXInLCdcXHUyOUMwJzonb2x0JywnXFx1MjlDMSc6J29ndCcsJ1xcdTI5QzInOidjaXJzY2lyJywnXFx1MjlDMyc6J2NpckUnLCdcXHUyOUM0Jzonc29sYicsJ1xcdTI5QzUnOidic29sYicsJ1xcdTI5QzknOidib3hib3gnLCdcXHUyOUNEJzondHJpc2InLCdcXHUyOUNFJzoncnRyaWx0cmknLCdcXHUyOUNGJzonTGVmdFRyaWFuZ2xlQmFyJywnXFx1MjlDRlxcdTAzMzgnOidOb3RMZWZ0VHJpYW5nbGVCYXInLCdcXHUyOUQwJzonUmlnaHRUcmlhbmdsZUJhcicsJ1xcdTI5RDBcXHUwMzM4JzonTm90UmlnaHRUcmlhbmdsZUJhcicsJ1xcdTI5REMnOidpaW5maW4nLCdcXHUyOUREJzonaW5maW50aWUnLCdcXHUyOURFJzonbnZpbmZpbicsJ1xcdTI5RTMnOidlcGFyc2wnLCdcXHUyOUU0Jzonc21lcGFyc2wnLCdcXHUyOUU1JzonZXF2cGFyc2wnLCdcXHUyOUVCJzonbG96ZicsJ1xcdTI5RjQnOidSdWxlRGVsYXllZCcsJ1xcdTI5RjYnOidkc29sJywnXFx1MkEwMCc6J3hvZG90JywnXFx1MkEwMSc6J3hvcGx1cycsJ1xcdTJBMDInOid4b3RpbWUnLCdcXHUyQTA0JzoneHVwbHVzJywnXFx1MkEwNic6J3hzcWN1cCcsJ1xcdTJBMEQnOidmcGFydGludCcsJ1xcdTJBMTAnOidjaXJmbmludCcsJ1xcdTJBMTEnOidhd2ludCcsJ1xcdTJBMTInOidycHBvbGludCcsJ1xcdTJBMTMnOidzY3BvbGludCcsJ1xcdTJBMTQnOiducG9saW50JywnXFx1MkExNSc6J3BvaW50aW50JywnXFx1MkExNic6J3F1YXRpbnQnLCdcXHUyQTE3JzonaW50bGFyaGsnLCdcXHUyQTIyJzoncGx1c2NpcicsJ1xcdTJBMjMnOidwbHVzYWNpcicsJ1xcdTJBMjQnOidzaW1wbHVzJywnXFx1MkEyNSc6J3BsdXNkdScsJ1xcdTJBMjYnOidwbHVzc2ltJywnXFx1MkEyNyc6J3BsdXN0d28nLCdcXHUyQTI5JzonbWNvbW1hJywnXFx1MkEyQSc6J21pbnVzZHUnLCdcXHUyQTJEJzonbG9wbHVzJywnXFx1MkEyRSc6J3JvcGx1cycsJ1xcdTJBMkYnOidDcm9zcycsJ1xcdTJBMzAnOid0aW1lc2QnLCdcXHUyQTMxJzondGltZXNiYXInLCdcXHUyQTMzJzonc21hc2hwJywnXFx1MkEzNCc6J2xvdGltZXMnLCdcXHUyQTM1Jzoncm90aW1lcycsJ1xcdTJBMzYnOidvdGltZXNhcycsJ1xcdTJBMzcnOidPdGltZXMnLCdcXHUyQTM4Jzonb2RpdicsJ1xcdTJBMzknOid0cmlwbHVzJywnXFx1MkEzQSc6J3RyaW1pbnVzJywnXFx1MkEzQic6J3RyaXRpbWUnLCdcXHUyQTNDJzonaXByb2QnLCdcXHUyQTNGJzonYW1hbGcnLCdcXHUyQTQwJzonY2FwZG90JywnXFx1MkE0Mic6J25jdXAnLCdcXHUyQTQzJzonbmNhcCcsJ1xcdTJBNDQnOidjYXBhbmQnLCdcXHUyQTQ1JzonY3Vwb3InLCdcXHUyQTQ2JzonY3VwY2FwJywnXFx1MkE0Nyc6J2NhcGN1cCcsJ1xcdTJBNDgnOidjdXBicmNhcCcsJ1xcdTJBNDknOidjYXBicmN1cCcsJ1xcdTJBNEEnOidjdXBjdXAnLCdcXHUyQTRCJzonY2FwY2FwJywnXFx1MkE0Qyc6J2NjdXBzJywnXFx1MkE0RCc6J2NjYXBzJywnXFx1MkE1MCc6J2NjdXBzc20nLCdcXHUyQTUzJzonQW5kJywnXFx1MkE1NCc6J09yJywnXFx1MkE1NSc6J2FuZGFuZCcsJ1xcdTJBNTYnOidvcm9yJywnXFx1MkE1Nyc6J29yc2xvcGUnLCdcXHUyQTU4JzonYW5kc2xvcGUnLCdcXHUyQTVBJzonYW5kdicsJ1xcdTJBNUInOidvcnYnLCdcXHUyQTVDJzonYW5kZCcsJ1xcdTJBNUQnOidvcmQnLCdcXHUyQTVGJzond2VkYmFyJywnXFx1MkE2Nic6J3Nkb3RlJywnXFx1MkE2QSc6J3NpbWRvdCcsJ1xcdTJBNkQnOidjb25nZG90JywnXFx1MkE2RFxcdTAzMzgnOiduY29uZ2RvdCcsJ1xcdTJBNkUnOidlYXN0ZXInLCdcXHUyQTZGJzonYXBhY2lyJywnXFx1MkE3MCc6J2FwRScsJ1xcdTJBNzBcXHUwMzM4JzonbmFwRScsJ1xcdTJBNzEnOidlcGx1cycsJ1xcdTJBNzInOidwbHVzZScsJ1xcdTJBNzMnOidFc2ltJywnXFx1MkE3Nyc6J2VERG90JywnXFx1MkE3OCc6J2VxdWl2REQnLCdcXHUyQTc5JzonbHRjaXInLCdcXHUyQTdBJzonZ3RjaXInLCdcXHUyQTdCJzonbHRxdWVzdCcsJ1xcdTJBN0MnOidndHF1ZXN0JywnXFx1MkE3RCc6J2xlcycsJ1xcdTJBN0RcXHUwMzM4JzonbmxlcycsJ1xcdTJBN0UnOidnZXMnLCdcXHUyQTdFXFx1MDMzOCc6J25nZXMnLCdcXHUyQTdGJzonbGVzZG90JywnXFx1MkE4MCc6J2dlc2RvdCcsJ1xcdTJBODEnOidsZXNkb3RvJywnXFx1MkE4Mic6J2dlc2RvdG8nLCdcXHUyQTgzJzonbGVzZG90b3InLCdcXHUyQTg0JzonZ2VzZG90b2wnLCdcXHUyQTg1JzonbGFwJywnXFx1MkE4Nic6J2dhcCcsJ1xcdTJBODcnOidsbmUnLCdcXHUyQTg4JzonZ25lJywnXFx1MkE4OSc6J2xuYXAnLCdcXHUyQThBJzonZ25hcCcsJ1xcdTJBOEInOidsRWcnLCdcXHUyQThDJzonZ0VsJywnXFx1MkE4RCc6J2xzaW1lJywnXFx1MkE4RSc6J2dzaW1lJywnXFx1MkE4Ric6J2xzaW1nJywnXFx1MkE5MCc6J2dzaW1sJywnXFx1MkE5MSc6J2xnRScsJ1xcdTJBOTInOidnbEUnLCdcXHUyQTkzJzonbGVzZ2VzJywnXFx1MkE5NCc6J2dlc2xlcycsJ1xcdTJBOTUnOidlbHMnLCdcXHUyQTk2JzonZWdzJywnXFx1MkE5Nyc6J2Vsc2RvdCcsJ1xcdTJBOTgnOidlZ3Nkb3QnLCdcXHUyQTk5JzonZWwnLCdcXHUyQTlBJzonZWcnLCdcXHUyQTlEJzonc2ltbCcsJ1xcdTJBOUUnOidzaW1nJywnXFx1MkE5Ric6J3NpbWxFJywnXFx1MkFBMCc6J3NpbWdFJywnXFx1MkFBMSc6J0xlc3NMZXNzJywnXFx1MkFBMVxcdTAzMzgnOidOb3ROZXN0ZWRMZXNzTGVzcycsJ1xcdTJBQTInOidHcmVhdGVyR3JlYXRlcicsJ1xcdTJBQTJcXHUwMzM4JzonTm90TmVzdGVkR3JlYXRlckdyZWF0ZXInLCdcXHUyQUE0JzonZ2xqJywnXFx1MkFBNSc6J2dsYScsJ1xcdTJBQTYnOidsdGNjJywnXFx1MkFBNyc6J2d0Y2MnLCdcXHUyQUE4JzonbGVzY2MnLCdcXHUyQUE5JzonZ2VzY2MnLCdcXHUyQUFBJzonc210JywnXFx1MkFBQic6J2xhdCcsJ1xcdTJBQUMnOidzbXRlJywnXFx1MkFBQ1xcdUZFMDAnOidzbXRlcycsJ1xcdTJBQUQnOidsYXRlJywnXFx1MkFBRFxcdUZFMDAnOidsYXRlcycsJ1xcdTJBQUUnOididW1wRScsJ1xcdTJBQUYnOidwcmUnLCdcXHUyQUFGXFx1MDMzOCc6J25wcmUnLCdcXHUyQUIwJzonc2NlJywnXFx1MkFCMFxcdTAzMzgnOiduc2NlJywnXFx1MkFCMyc6J3ByRScsJ1xcdTJBQjQnOidzY0UnLCdcXHUyQUI1JzoncHJuRScsJ1xcdTJBQjYnOidzY25FJywnXFx1MkFCNyc6J3ByYXAnLCdcXHUyQUI4Jzonc2NhcCcsJ1xcdTJBQjknOidwcm5hcCcsJ1xcdTJBQkEnOidzY25hcCcsJ1xcdTJBQkInOidQcicsJ1xcdTJBQkMnOidTYycsJ1xcdTJBQkQnOidzdWJkb3QnLCdcXHUyQUJFJzonc3VwZG90JywnXFx1MkFCRic6J3N1YnBsdXMnLCdcXHUyQUMwJzonc3VwcGx1cycsJ1xcdTJBQzEnOidzdWJtdWx0JywnXFx1MkFDMic6J3N1cG11bHQnLCdcXHUyQUMzJzonc3ViZWRvdCcsJ1xcdTJBQzQnOidzdXBlZG90JywnXFx1MkFDNSc6J3N1YkUnLCdcXHUyQUM1XFx1MDMzOCc6J25zdWJFJywnXFx1MkFDNic6J3N1cEUnLCdcXHUyQUM2XFx1MDMzOCc6J25zdXBFJywnXFx1MkFDNyc6J3N1YnNpbScsJ1xcdTJBQzgnOidzdXBzaW0nLCdcXHUyQUNCXFx1RkUwMCc6J3ZzdWJuRScsJ1xcdTJBQ0InOidzdWJuRScsJ1xcdTJBQ0NcXHVGRTAwJzondnN1cG5FJywnXFx1MkFDQyc6J3N1cG5FJywnXFx1MkFDRic6J2NzdWInLCdcXHUyQUQwJzonY3N1cCcsJ1xcdTJBRDEnOidjc3ViZScsJ1xcdTJBRDInOidjc3VwZScsJ1xcdTJBRDMnOidzdWJzdXAnLCdcXHUyQUQ0Jzonc3Vwc3ViJywnXFx1MkFENSc6J3N1YnN1YicsJ1xcdTJBRDYnOidzdXBzdXAnLCdcXHUyQUQ3Jzonc3VwaHN1YicsJ1xcdTJBRDgnOidzdXBkc3ViJywnXFx1MkFEOSc6J2Zvcmt2JywnXFx1MkFEQSc6J3RvcGZvcmsnLCdcXHUyQURCJzonbWxjcCcsJ1xcdTJBRTQnOidEYXNodicsJ1xcdTJBRTYnOidWZGFzaGwnLCdcXHUyQUU3JzonQmFydicsJ1xcdTJBRTgnOid2QmFyJywnXFx1MkFFOSc6J3ZCYXJ2JywnXFx1MkFFQic6J1ZiYXInLCdcXHUyQUVDJzonTm90JywnXFx1MkFFRCc6J2JOb3QnLCdcXHUyQUVFJzoncm5taWQnLCdcXHUyQUVGJzonY2lybWlkJywnXFx1MkFGMCc6J21pZGNpcicsJ1xcdTJBRjEnOid0b3BjaXInLCdcXHUyQUYyJzonbmhwYXInLCdcXHUyQUYzJzoncGFyc2ltJywnXFx1MkFGRCc6J3BhcnNsJywnXFx1MkFGRFxcdTIwRTUnOiducGFyc2wnLCdcXHUyNjZEJzonZmxhdCcsJ1xcdTI2NkUnOiduYXR1cicsJ1xcdTI2NkYnOidzaGFycCcsJ1xceEE0JzonY3VycmVuJywnXFx4QTInOidjZW50JywnJCc6J2RvbGxhcicsJ1xceEEzJzoncG91bmQnLCdcXHhBNSc6J3llbicsJ1xcdTIwQUMnOidldXJvJywnXFx4QjknOidzdXAxJywnXFx4QkQnOidoYWxmJywnXFx1MjE1Myc6J2ZyYWMxMycsJ1xceEJDJzonZnJhYzE0JywnXFx1MjE1NSc6J2ZyYWMxNScsJ1xcdTIxNTknOidmcmFjMTYnLCdcXHUyMTVCJzonZnJhYzE4JywnXFx4QjInOidzdXAyJywnXFx1MjE1NCc6J2ZyYWMyMycsJ1xcdTIxNTYnOidmcmFjMjUnLCdcXHhCMyc6J3N1cDMnLCdcXHhCRSc6J2ZyYWMzNCcsJ1xcdTIxNTcnOidmcmFjMzUnLCdcXHUyMTVDJzonZnJhYzM4JywnXFx1MjE1OCc6J2ZyYWM0NScsJ1xcdTIxNUEnOidmcmFjNTYnLCdcXHUyMTVEJzonZnJhYzU4JywnXFx1MjE1RSc6J2ZyYWM3OCcsJ1xcdUQ4MzVcXHVEQ0I2JzonYXNjcicsJ1xcdUQ4MzVcXHVERDUyJzonYW9wZicsJ1xcdUQ4MzVcXHVERDFFJzonYWZyJywnXFx1RDgzNVxcdUREMzgnOidBb3BmJywnXFx1RDgzNVxcdUREMDQnOidBZnInLCdcXHVEODM1XFx1REM5Qyc6J0FzY3InLCdcXHhBQSc6J29yZGYnLCdcXHhFMSc6J2FhY3V0ZScsJ1xceEMxJzonQWFjdXRlJywnXFx4RTAnOidhZ3JhdmUnLCdcXHhDMCc6J0FncmF2ZScsJ1xcdTAxMDMnOidhYnJldmUnLCdcXHUwMTAyJzonQWJyZXZlJywnXFx4RTInOidhY2lyYycsJ1xceEMyJzonQWNpcmMnLCdcXHhFNSc6J2FyaW5nJywnXFx4QzUnOidhbmdzdCcsJ1xceEU0JzonYXVtbCcsJ1xceEM0JzonQXVtbCcsJ1xceEUzJzonYXRpbGRlJywnXFx4QzMnOidBdGlsZGUnLCdcXHUwMTA1JzonYW9nb24nLCdcXHUwMTA0JzonQW9nb24nLCdcXHUwMTAxJzonYW1hY3InLCdcXHUwMTAwJzonQW1hY3InLCdcXHhFNic6J2FlbGlnJywnXFx4QzYnOidBRWxpZycsJ1xcdUQ4MzVcXHVEQ0I3JzonYnNjcicsJ1xcdUQ4MzVcXHVERDUzJzonYm9wZicsJ1xcdUQ4MzVcXHVERDFGJzonYmZyJywnXFx1RDgzNVxcdUREMzknOidCb3BmJywnXFx1MjEyQyc6J0JzY3InLCdcXHVEODM1XFx1REQwNSc6J0JmcicsJ1xcdUQ4MzVcXHVERDIwJzonY2ZyJywnXFx1RDgzNVxcdURDQjgnOidjc2NyJywnXFx1RDgzNVxcdURENTQnOidjb3BmJywnXFx1MjEyRCc6J0NmcicsJ1xcdUQ4MzVcXHVEQzlFJzonQ3NjcicsJ1xcdTIxMDInOidDb3BmJywnXFx1MDEwNyc6J2NhY3V0ZScsJ1xcdTAxMDYnOidDYWN1dGUnLCdcXHUwMTA5JzonY2NpcmMnLCdcXHUwMTA4JzonQ2NpcmMnLCdcXHUwMTBEJzonY2Nhcm9uJywnXFx1MDEwQyc6J0NjYXJvbicsJ1xcdTAxMEInOidjZG90JywnXFx1MDEwQSc6J0Nkb3QnLCdcXHhFNyc6J2NjZWRpbCcsJ1xceEM3JzonQ2NlZGlsJywnXFx1MjEwNSc6J2luY2FyZScsJ1xcdUQ4MzVcXHVERDIxJzonZGZyJywnXFx1MjE0Nic6J2RkJywnXFx1RDgzNVxcdURENTUnOidkb3BmJywnXFx1RDgzNVxcdURDQjknOidkc2NyJywnXFx1RDgzNVxcdURDOUYnOidEc2NyJywnXFx1RDgzNVxcdUREMDcnOidEZnInLCdcXHUyMTQ1JzonREQnLCdcXHVEODM1XFx1REQzQic6J0RvcGYnLCdcXHUwMTBGJzonZGNhcm9uJywnXFx1MDEwRSc6J0RjYXJvbicsJ1xcdTAxMTEnOidkc3Ryb2snLCdcXHUwMTEwJzonRHN0cm9rJywnXFx4RjAnOidldGgnLCdcXHhEMCc6J0VUSCcsJ1xcdTIxNDcnOidlZScsJ1xcdTIxMkYnOidlc2NyJywnXFx1RDgzNVxcdUREMjInOidlZnInLCdcXHVEODM1XFx1REQ1Nic6J2VvcGYnLCdcXHUyMTMwJzonRXNjcicsJ1xcdUQ4MzVcXHVERDA4JzonRWZyJywnXFx1RDgzNVxcdUREM0MnOidFb3BmJywnXFx4RTknOidlYWN1dGUnLCdcXHhDOSc6J0VhY3V0ZScsJ1xceEU4JzonZWdyYXZlJywnXFx4QzgnOidFZ3JhdmUnLCdcXHhFQSc6J2VjaXJjJywnXFx4Q0EnOidFY2lyYycsJ1xcdTAxMUInOidlY2Fyb24nLCdcXHUwMTFBJzonRWNhcm9uJywnXFx4RUInOidldW1sJywnXFx4Q0InOidFdW1sJywnXFx1MDExNyc6J2Vkb3QnLCdcXHUwMTE2JzonRWRvdCcsJ1xcdTAxMTknOidlb2dvbicsJ1xcdTAxMTgnOidFb2dvbicsJ1xcdTAxMTMnOidlbWFjcicsJ1xcdTAxMTInOidFbWFjcicsJ1xcdUQ4MzVcXHVERDIzJzonZmZyJywnXFx1RDgzNVxcdURENTcnOidmb3BmJywnXFx1RDgzNVxcdURDQkInOidmc2NyJywnXFx1RDgzNVxcdUREMDknOidGZnInLCdcXHVEODM1XFx1REQzRCc6J0ZvcGYnLCdcXHUyMTMxJzonRnNjcicsJ1xcdUZCMDAnOidmZmxpZycsJ1xcdUZCMDMnOidmZmlsaWcnLCdcXHVGQjA0JzonZmZsbGlnJywnXFx1RkIwMSc6J2ZpbGlnJywnZmonOidmamxpZycsJ1xcdUZCMDInOidmbGxpZycsJ1xcdTAxOTInOidmbm9mJywnXFx1MjEwQSc6J2dzY3InLCdcXHVEODM1XFx1REQ1OCc6J2dvcGYnLCdcXHVEODM1XFx1REQyNCc6J2dmcicsJ1xcdUQ4MzVcXHVEQ0EyJzonR3NjcicsJ1xcdUQ4MzVcXHVERDNFJzonR29wZicsJ1xcdUQ4MzVcXHVERDBBJzonR2ZyJywnXFx1MDFGNSc6J2dhY3V0ZScsJ1xcdTAxMUYnOidnYnJldmUnLCdcXHUwMTFFJzonR2JyZXZlJywnXFx1MDExRCc6J2djaXJjJywnXFx1MDExQyc6J0djaXJjJywnXFx1MDEyMSc6J2dkb3QnLCdcXHUwMTIwJzonR2RvdCcsJ1xcdTAxMjInOidHY2VkaWwnLCdcXHVEODM1XFx1REQyNSc6J2hmcicsJ1xcdTIxMEUnOidwbGFuY2toJywnXFx1RDgzNVxcdURDQkQnOidoc2NyJywnXFx1RDgzNVxcdURENTknOidob3BmJywnXFx1MjEwQic6J0hzY3InLCdcXHUyMTBDJzonSGZyJywnXFx1MjEwRCc6J0hvcGYnLCdcXHUwMTI1JzonaGNpcmMnLCdcXHUwMTI0JzonSGNpcmMnLCdcXHUyMTBGJzonaGJhcicsJ1xcdTAxMjcnOidoc3Ryb2snLCdcXHUwMTI2JzonSHN0cm9rJywnXFx1RDgzNVxcdURENUEnOidpb3BmJywnXFx1RDgzNVxcdUREMjYnOidpZnInLCdcXHVEODM1XFx1RENCRSc6J2lzY3InLCdcXHUyMTQ4JzonaWknLCdcXHVEODM1XFx1REQ0MCc6J0lvcGYnLCdcXHUyMTEwJzonSXNjcicsJ1xcdTIxMTEnOidJbScsJ1xceEVEJzonaWFjdXRlJywnXFx4Q0QnOidJYWN1dGUnLCdcXHhFQyc6J2lncmF2ZScsJ1xceENDJzonSWdyYXZlJywnXFx4RUUnOidpY2lyYycsJ1xceENFJzonSWNpcmMnLCdcXHhFRic6J2l1bWwnLCdcXHhDRic6J0l1bWwnLCdcXHUwMTI5JzonaXRpbGRlJywnXFx1MDEyOCc6J0l0aWxkZScsJ1xcdTAxMzAnOidJZG90JywnXFx1MDEyRic6J2lvZ29uJywnXFx1MDEyRSc6J0lvZ29uJywnXFx1MDEyQic6J2ltYWNyJywnXFx1MDEyQSc6J0ltYWNyJywnXFx1MDEzMyc6J2lqbGlnJywnXFx1MDEzMic6J0lKbGlnJywnXFx1MDEzMSc6J2ltYXRoJywnXFx1RDgzNVxcdURDQkYnOidqc2NyJywnXFx1RDgzNVxcdURENUInOidqb3BmJywnXFx1RDgzNVxcdUREMjcnOidqZnInLCdcXHVEODM1XFx1RENBNSc6J0pzY3InLCdcXHVEODM1XFx1REQwRCc6J0pmcicsJ1xcdUQ4MzVcXHVERDQxJzonSm9wZicsJ1xcdTAxMzUnOidqY2lyYycsJ1xcdTAxMzQnOidKY2lyYycsJ1xcdTAyMzcnOidqbWF0aCcsJ1xcdUQ4MzVcXHVERDVDJzona29wZicsJ1xcdUQ4MzVcXHVEQ0MwJzona3NjcicsJ1xcdUQ4MzVcXHVERDI4Jzona2ZyJywnXFx1RDgzNVxcdURDQTYnOidLc2NyJywnXFx1RDgzNVxcdURENDInOidLb3BmJywnXFx1RDgzNVxcdUREMEUnOidLZnInLCdcXHUwMTM3Jzona2NlZGlsJywnXFx1MDEzNic6J0tjZWRpbCcsJ1xcdUQ4MzVcXHVERDI5JzonbGZyJywnXFx1RDgzNVxcdURDQzEnOidsc2NyJywnXFx1MjExMyc6J2VsbCcsJ1xcdUQ4MzVcXHVERDVEJzonbG9wZicsJ1xcdTIxMTInOidMc2NyJywnXFx1RDgzNVxcdUREMEYnOidMZnInLCdcXHVEODM1XFx1REQ0Myc6J0xvcGYnLCdcXHUwMTNBJzonbGFjdXRlJywnXFx1MDEzOSc6J0xhY3V0ZScsJ1xcdTAxM0UnOidsY2Fyb24nLCdcXHUwMTNEJzonTGNhcm9uJywnXFx1MDEzQyc6J2xjZWRpbCcsJ1xcdTAxM0InOidMY2VkaWwnLCdcXHUwMTQyJzonbHN0cm9rJywnXFx1MDE0MSc6J0xzdHJvaycsJ1xcdTAxNDAnOidsbWlkb3QnLCdcXHUwMTNGJzonTG1pZG90JywnXFx1RDgzNVxcdUREMkEnOidtZnInLCdcXHVEODM1XFx1REQ1RSc6J21vcGYnLCdcXHVEODM1XFx1RENDMic6J21zY3InLCdcXHVEODM1XFx1REQxMCc6J01mcicsJ1xcdUQ4MzVcXHVERDQ0JzonTW9wZicsJ1xcdTIxMzMnOidNc2NyJywnXFx1RDgzNVxcdUREMkInOiduZnInLCdcXHVEODM1XFx1REQ1Ric6J25vcGYnLCdcXHVEODM1XFx1RENDMyc6J25zY3InLCdcXHUyMTE1JzonTm9wZicsJ1xcdUQ4MzVcXHVEQ0E5JzonTnNjcicsJ1xcdUQ4MzVcXHVERDExJzonTmZyJywnXFx1MDE0NCc6J25hY3V0ZScsJ1xcdTAxNDMnOidOYWN1dGUnLCdcXHUwMTQ4JzonbmNhcm9uJywnXFx1MDE0Nyc6J05jYXJvbicsJ1xceEYxJzonbnRpbGRlJywnXFx4RDEnOidOdGlsZGUnLCdcXHUwMTQ2JzonbmNlZGlsJywnXFx1MDE0NSc6J05jZWRpbCcsJ1xcdTIxMTYnOidudW1lcm8nLCdcXHUwMTRCJzonZW5nJywnXFx1MDE0QSc6J0VORycsJ1xcdUQ4MzVcXHVERDYwJzonb29wZicsJ1xcdUQ4MzVcXHVERDJDJzonb2ZyJywnXFx1MjEzNCc6J29zY3InLCdcXHVEODM1XFx1RENBQSc6J09zY3InLCdcXHVEODM1XFx1REQxMic6J09mcicsJ1xcdUQ4MzVcXHVERDQ2JzonT29wZicsJ1xceEJBJzonb3JkbScsJ1xceEYzJzonb2FjdXRlJywnXFx4RDMnOidPYWN1dGUnLCdcXHhGMic6J29ncmF2ZScsJ1xceEQyJzonT2dyYXZlJywnXFx4RjQnOidvY2lyYycsJ1xceEQ0JzonT2NpcmMnLCdcXHhGNic6J291bWwnLCdcXHhENic6J091bWwnLCdcXHUwMTUxJzonb2RibGFjJywnXFx1MDE1MCc6J09kYmxhYycsJ1xceEY1Jzonb3RpbGRlJywnXFx4RDUnOidPdGlsZGUnLCdcXHhGOCc6J29zbGFzaCcsJ1xceEQ4JzonT3NsYXNoJywnXFx1MDE0RCc6J29tYWNyJywnXFx1MDE0Qyc6J09tYWNyJywnXFx1MDE1Myc6J29lbGlnJywnXFx1MDE1Mic6J09FbGlnJywnXFx1RDgzNVxcdUREMkQnOidwZnInLCdcXHVEODM1XFx1RENDNSc6J3BzY3InLCdcXHVEODM1XFx1REQ2MSc6J3BvcGYnLCdcXHUyMTE5JzonUG9wZicsJ1xcdUQ4MzVcXHVERDEzJzonUGZyJywnXFx1RDgzNVxcdURDQUInOidQc2NyJywnXFx1RDgzNVxcdURENjInOidxb3BmJywnXFx1RDgzNVxcdUREMkUnOidxZnInLCdcXHVEODM1XFx1RENDNic6J3FzY3InLCdcXHVEODM1XFx1RENBQyc6J1FzY3InLCdcXHVEODM1XFx1REQxNCc6J1FmcicsJ1xcdTIxMUEnOidRb3BmJywnXFx1MDEzOCc6J2tncmVlbicsJ1xcdUQ4MzVcXHVERDJGJzoncmZyJywnXFx1RDgzNVxcdURENjMnOidyb3BmJywnXFx1RDgzNVxcdURDQzcnOidyc2NyJywnXFx1MjExQic6J1JzY3InLCdcXHUyMTFDJzonUmUnLCdcXHUyMTFEJzonUm9wZicsJ1xcdTAxNTUnOidyYWN1dGUnLCdcXHUwMTU0JzonUmFjdXRlJywnXFx1MDE1OSc6J3JjYXJvbicsJ1xcdTAxNTgnOidSY2Fyb24nLCdcXHUwMTU3JzoncmNlZGlsJywnXFx1MDE1Nic6J1JjZWRpbCcsJ1xcdUQ4MzVcXHVERDY0Jzonc29wZicsJ1xcdUQ4MzVcXHVEQ0M4Jzonc3NjcicsJ1xcdUQ4MzVcXHVERDMwJzonc2ZyJywnXFx1RDgzNVxcdURENEEnOidTb3BmJywnXFx1RDgzNVxcdUREMTYnOidTZnInLCdcXHVEODM1XFx1RENBRSc6J1NzY3InLCdcXHUyNEM4Jzonb1MnLCdcXHUwMTVCJzonc2FjdXRlJywnXFx1MDE1QSc6J1NhY3V0ZScsJ1xcdTAxNUQnOidzY2lyYycsJ1xcdTAxNUMnOidTY2lyYycsJ1xcdTAxNjEnOidzY2Fyb24nLCdcXHUwMTYwJzonU2Nhcm9uJywnXFx1MDE1Ric6J3NjZWRpbCcsJ1xcdTAxNUUnOidTY2VkaWwnLCdcXHhERic6J3N6bGlnJywnXFx1RDgzNVxcdUREMzEnOid0ZnInLCdcXHVEODM1XFx1RENDOSc6J3RzY3InLCdcXHVEODM1XFx1REQ2NSc6J3RvcGYnLCdcXHVEODM1XFx1RENBRic6J1RzY3InLCdcXHVEODM1XFx1REQxNyc6J1RmcicsJ1xcdUQ4MzVcXHVERDRCJzonVG9wZicsJ1xcdTAxNjUnOid0Y2Fyb24nLCdcXHUwMTY0JzonVGNhcm9uJywnXFx1MDE2Myc6J3RjZWRpbCcsJ1xcdTAxNjInOidUY2VkaWwnLCdcXHUyMTIyJzondHJhZGUnLCdcXHUwMTY3JzondHN0cm9rJywnXFx1MDE2Nic6J1RzdHJvaycsJ1xcdUQ4MzVcXHVEQ0NBJzondXNjcicsJ1xcdUQ4MzVcXHVERDY2JzondW9wZicsJ1xcdUQ4MzVcXHVERDMyJzondWZyJywnXFx1RDgzNVxcdURENEMnOidVb3BmJywnXFx1RDgzNVxcdUREMTgnOidVZnInLCdcXHVEODM1XFx1RENCMCc6J1VzY3InLCdcXHhGQSc6J3VhY3V0ZScsJ1xceERBJzonVWFjdXRlJywnXFx4RjknOid1Z3JhdmUnLCdcXHhEOSc6J1VncmF2ZScsJ1xcdTAxNkQnOid1YnJldmUnLCdcXHUwMTZDJzonVWJyZXZlJywnXFx4RkInOid1Y2lyYycsJ1xceERCJzonVWNpcmMnLCdcXHUwMTZGJzondXJpbmcnLCdcXHUwMTZFJzonVXJpbmcnLCdcXHhGQyc6J3V1bWwnLCdcXHhEQyc6J1V1bWwnLCdcXHUwMTcxJzondWRibGFjJywnXFx1MDE3MCc6J1VkYmxhYycsJ1xcdTAxNjknOid1dGlsZGUnLCdcXHUwMTY4JzonVXRpbGRlJywnXFx1MDE3Myc6J3VvZ29uJywnXFx1MDE3Mic6J1VvZ29uJywnXFx1MDE2Qic6J3VtYWNyJywnXFx1MDE2QSc6J1VtYWNyJywnXFx1RDgzNVxcdUREMzMnOid2ZnInLCdcXHVEODM1XFx1REQ2Nyc6J3ZvcGYnLCdcXHVEODM1XFx1RENDQic6J3ZzY3InLCdcXHVEODM1XFx1REQxOSc6J1ZmcicsJ1xcdUQ4MzVcXHVERDREJzonVm9wZicsJ1xcdUQ4MzVcXHVEQ0IxJzonVnNjcicsJ1xcdUQ4MzVcXHVERDY4Jzond29wZicsJ1xcdUQ4MzVcXHVEQ0NDJzond3NjcicsJ1xcdUQ4MzVcXHVERDM0Jzond2ZyJywnXFx1RDgzNVxcdURDQjInOidXc2NyJywnXFx1RDgzNVxcdURENEUnOidXb3BmJywnXFx1RDgzNVxcdUREMUEnOidXZnInLCdcXHUwMTc1Jzond2NpcmMnLCdcXHUwMTc0JzonV2NpcmMnLCdcXHVEODM1XFx1REQzNSc6J3hmcicsJ1xcdUQ4MzVcXHVEQ0NEJzoneHNjcicsJ1xcdUQ4MzVcXHVERDY5JzoneG9wZicsJ1xcdUQ4MzVcXHVERDRGJzonWG9wZicsJ1xcdUQ4MzVcXHVERDFCJzonWGZyJywnXFx1RDgzNVxcdURDQjMnOidYc2NyJywnXFx1RDgzNVxcdUREMzYnOid5ZnInLCdcXHVEODM1XFx1RENDRSc6J3lzY3InLCdcXHVEODM1XFx1REQ2QSc6J3lvcGYnLCdcXHVEODM1XFx1RENCNCc6J1lzY3InLCdcXHVEODM1XFx1REQxQyc6J1lmcicsJ1xcdUQ4MzVcXHVERDUwJzonWW9wZicsJ1xceEZEJzoneWFjdXRlJywnXFx4REQnOidZYWN1dGUnLCdcXHUwMTc3JzoneWNpcmMnLCdcXHUwMTc2JzonWWNpcmMnLCdcXHhGRic6J3l1bWwnLCdcXHUwMTc4JzonWXVtbCcsJ1xcdUQ4MzVcXHVEQ0NGJzonenNjcicsJ1xcdUQ4MzVcXHVERDM3JzonemZyJywnXFx1RDgzNVxcdURENkInOid6b3BmJywnXFx1MjEyOCc6J1pmcicsJ1xcdTIxMjQnOidab3BmJywnXFx1RDgzNVxcdURDQjUnOidac2NyJywnXFx1MDE3QSc6J3phY3V0ZScsJ1xcdTAxNzknOidaYWN1dGUnLCdcXHUwMTdFJzonemNhcm9uJywnXFx1MDE3RCc6J1pjYXJvbicsJ1xcdTAxN0MnOid6ZG90JywnXFx1MDE3Qic6J1pkb3QnLCdcXHUwMUI1JzonaW1wZWQnLCdcXHhGRSc6J3Rob3JuJywnXFx4REUnOidUSE9STicsJ1xcdTAxNDknOiduYXBvcycsJ1xcdTAzQjEnOidhbHBoYScsJ1xcdTAzOTEnOidBbHBoYScsJ1xcdTAzQjInOidiZXRhJywnXFx1MDM5Mic6J0JldGEnLCdcXHUwM0IzJzonZ2FtbWEnLCdcXHUwMzkzJzonR2FtbWEnLCdcXHUwM0I0JzonZGVsdGEnLCdcXHUwMzk0JzonRGVsdGEnLCdcXHUwM0I1JzonZXBzaScsJ1xcdTAzRjUnOidlcHNpdicsJ1xcdTAzOTUnOidFcHNpbG9uJywnXFx1MDNERCc6J2dhbW1hZCcsJ1xcdTAzREMnOidHYW1tYWQnLCdcXHUwM0I2JzonemV0YScsJ1xcdTAzOTYnOidaZXRhJywnXFx1MDNCNyc6J2V0YScsJ1xcdTAzOTcnOidFdGEnLCdcXHUwM0I4JzondGhldGEnLCdcXHUwM0QxJzondGhldGF2JywnXFx1MDM5OCc6J1RoZXRhJywnXFx1MDNCOSc6J2lvdGEnLCdcXHUwMzk5JzonSW90YScsJ1xcdTAzQkEnOidrYXBwYScsJ1xcdTAzRjAnOidrYXBwYXYnLCdcXHUwMzlBJzonS2FwcGEnLCdcXHUwM0JCJzonbGFtYmRhJywnXFx1MDM5Qic6J0xhbWJkYScsJ1xcdTAzQkMnOidtdScsJ1xceEI1JzonbWljcm8nLCdcXHUwMzlDJzonTXUnLCdcXHUwM0JEJzonbnUnLCdcXHUwMzlEJzonTnUnLCdcXHUwM0JFJzoneGknLCdcXHUwMzlFJzonWGknLCdcXHUwM0JGJzonb21pY3JvbicsJ1xcdTAzOUYnOidPbWljcm9uJywnXFx1MDNDMCc6J3BpJywnXFx1MDNENic6J3BpdicsJ1xcdTAzQTAnOidQaScsJ1xcdTAzQzEnOidyaG8nLCdcXHUwM0YxJzoncmhvdicsJ1xcdTAzQTEnOidSaG8nLCdcXHUwM0MzJzonc2lnbWEnLCdcXHUwM0EzJzonU2lnbWEnLCdcXHUwM0MyJzonc2lnbWFmJywnXFx1MDNDNCc6J3RhdScsJ1xcdTAzQTQnOidUYXUnLCdcXHUwM0M1JzondXBzaScsJ1xcdTAzQTUnOidVcHNpbG9uJywnXFx1MDNEMic6J1Vwc2knLCdcXHUwM0M2JzoncGhpJywnXFx1MDNENSc6J3BoaXYnLCdcXHUwM0E2JzonUGhpJywnXFx1MDNDNyc6J2NoaScsJ1xcdTAzQTcnOidDaGknLCdcXHUwM0M4JzoncHNpJywnXFx1MDNBOCc6J1BzaScsJ1xcdTAzQzknOidvbWVnYScsJ1xcdTAzQTknOidvaG0nLCdcXHUwNDMwJzonYWN5JywnXFx1MDQxMCc6J0FjeScsJ1xcdTA0MzEnOidiY3knLCdcXHUwNDExJzonQmN5JywnXFx1MDQzMic6J3ZjeScsJ1xcdTA0MTInOidWY3knLCdcXHUwNDMzJzonZ2N5JywnXFx1MDQxMyc6J0djeScsJ1xcdTA0NTMnOidnamN5JywnXFx1MDQwMyc6J0dKY3knLCdcXHUwNDM0JzonZGN5JywnXFx1MDQxNCc6J0RjeScsJ1xcdTA0NTInOidkamN5JywnXFx1MDQwMic6J0RKY3knLCdcXHUwNDM1JzonaWVjeScsJ1xcdTA0MTUnOidJRWN5JywnXFx1MDQ1MSc6J2lvY3knLCdcXHUwNDAxJzonSU9jeScsJ1xcdTA0NTQnOidqdWtjeScsJ1xcdTA0MDQnOidKdWtjeScsJ1xcdTA0MzYnOid6aGN5JywnXFx1MDQxNic6J1pIY3knLCdcXHUwNDM3JzonemN5JywnXFx1MDQxNyc6J1pjeScsJ1xcdTA0NTUnOidkc2N5JywnXFx1MDQwNSc6J0RTY3knLCdcXHUwNDM4JzonaWN5JywnXFx1MDQxOCc6J0ljeScsJ1xcdTA0NTYnOidpdWtjeScsJ1xcdTA0MDYnOidJdWtjeScsJ1xcdTA0NTcnOid5aWN5JywnXFx1MDQwNyc6J1lJY3knLCdcXHUwNDM5JzonamN5JywnXFx1MDQxOSc6J0pjeScsJ1xcdTA0NTgnOidqc2VyY3knLCdcXHUwNDA4JzonSnNlcmN5JywnXFx1MDQzQSc6J2tjeScsJ1xcdTA0MUEnOidLY3knLCdcXHUwNDVDJzona2pjeScsJ1xcdTA0MEMnOidLSmN5JywnXFx1MDQzQic6J2xjeScsJ1xcdTA0MUInOidMY3knLCdcXHUwNDU5JzonbGpjeScsJ1xcdTA0MDknOidMSmN5JywnXFx1MDQzQyc6J21jeScsJ1xcdTA0MUMnOidNY3knLCdcXHUwNDNEJzonbmN5JywnXFx1MDQxRCc6J05jeScsJ1xcdTA0NUEnOiduamN5JywnXFx1MDQwQSc6J05KY3knLCdcXHUwNDNFJzonb2N5JywnXFx1MDQxRSc6J09jeScsJ1xcdTA0M0YnOidwY3knLCdcXHUwNDFGJzonUGN5JywnXFx1MDQ0MCc6J3JjeScsJ1xcdTA0MjAnOidSY3knLCdcXHUwNDQxJzonc2N5JywnXFx1MDQyMSc6J1NjeScsJ1xcdTA0NDInOid0Y3knLCdcXHUwNDIyJzonVGN5JywnXFx1MDQ1Qic6J3RzaGN5JywnXFx1MDQwQic6J1RTSGN5JywnXFx1MDQ0Myc6J3VjeScsJ1xcdTA0MjMnOidVY3knLCdcXHUwNDVFJzondWJyY3knLCdcXHUwNDBFJzonVWJyY3knLCdcXHUwNDQ0JzonZmN5JywnXFx1MDQyNCc6J0ZjeScsJ1xcdTA0NDUnOidraGN5JywnXFx1MDQyNSc6J0tIY3knLCdcXHUwNDQ2JzondHNjeScsJ1xcdTA0MjYnOidUU2N5JywnXFx1MDQ0Nyc6J2NoY3knLCdcXHUwNDI3JzonQ0hjeScsJ1xcdTA0NUYnOidkemN5JywnXFx1MDQwRic6J0RaY3knLCdcXHUwNDQ4Jzonc2hjeScsJ1xcdTA0MjgnOidTSGN5JywnXFx1MDQ0OSc6J3NoY2hjeScsJ1xcdTA0MjknOidTSENIY3knLCdcXHUwNDRBJzonaGFyZGN5JywnXFx1MDQyQSc6J0hBUkRjeScsJ1xcdTA0NEInOid5Y3knLCdcXHUwNDJCJzonWWN5JywnXFx1MDQ0Qyc6J3NvZnRjeScsJ1xcdTA0MkMnOidTT0ZUY3knLCdcXHUwNDREJzonZWN5JywnXFx1MDQyRCc6J0VjeScsJ1xcdTA0NEUnOid5dWN5JywnXFx1MDQyRSc6J1lVY3knLCdcXHUwNDRGJzoneWFjeScsJ1xcdTA0MkYnOidZQWN5JywnXFx1MjEzNSc6J2FsZXBoJywnXFx1MjEzNic6J2JldGgnLCdcXHUyMTM3JzonZ2ltZWwnLCdcXHUyMTM4JzonZGFsZXRoJ307XG5cblx0dmFyIHJlZ2V4RXNjYXBlID0gL1tcIiYnPD5gXS9nO1xuXHR2YXIgZXNjYXBlTWFwID0ge1xuXHRcdCdcIic6ICcmcXVvdDsnLFxuXHRcdCcmJzogJyZhbXA7Jyxcblx0XHQnXFwnJzogJyYjeDI3OycsXG5cdFx0JzwnOiAnJmx0OycsXG5cdFx0Ly8gU2VlIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kczogaW4gSFRNTCwgdGhlXG5cdFx0Ly8gZm9sbG93aW5nIGlzIG5vdCBzdHJpY3RseSBuZWNlc3NhcnkgdW5sZXNzIGl04oCZcyBwYXJ0IG9mIGEgdGFnIG9yIGFuXG5cdFx0Ly8gdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBXZeKAmXJlIG9ubHkgZXNjYXBpbmcgaXQgdG8gc3VwcG9ydCB0aG9zZVxuXHRcdC8vIHNpdHVhdGlvbnMsIGFuZCBmb3IgWE1MIHN1cHBvcnQuXG5cdFx0Jz4nOiAnJmd0OycsXG5cdFx0Ly8gSW4gSW50ZXJuZXQgRXhwbG9yZXIg4omkIDgsIHRoZSBiYWNrdGljayBjaGFyYWN0ZXIgY2FuIGJlIHVzZWRcblx0XHQvLyB0byBicmVhayBvdXQgb2YgKHVuKXF1b3RlZCBhdHRyaWJ1dGUgdmFsdWVzIG9yIEhUTUwgY29tbWVudHMuXG5cdFx0Ly8gU2VlIGh0dHA6Ly9odG1sNXNlYy5vcmcvIzEwMiwgaHR0cDovL2h0bWw1c2VjLm9yZy8jMTA4LCBhbmRcblx0XHQvLyBodHRwOi8vaHRtbDVzZWMub3JnLyMxMzMuXG5cdFx0J2AnOiAnJiN4NjA7J1xuXHR9O1xuXG5cdHZhciByZWdleEludmFsaWRFbnRpdHkgPSAvJiMoPzpbeFhdW15hLWZBLUYwLTldfFteMC05eFhdKS87XG5cdHZhciByZWdleEludmFsaWRSYXdDb2RlUG9pbnQgPSAvW1xcMC1cXHgwOFxceDBCXFx4MEUtXFx4MUZcXHg3Ri1cXHg5RlxcdUZERDAtXFx1RkRFRlxcdUZGRkVcXHVGRkZGXXxbXFx1RDgzRlxcdUQ4N0ZcXHVEOEJGXFx1RDhGRlxcdUQ5M0ZcXHVEOTdGXFx1RDlCRlxcdUQ5RkZcXHVEQTNGXFx1REE3RlxcdURBQkZcXHVEQUZGXFx1REIzRlxcdURCN0ZcXHVEQkJGXFx1REJGRl1bXFx1REZGRVxcdURGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdLztcblx0dmFyIHJlZ2V4RGVjb2RlID0gLyYoQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbHxEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3d8Q2xvY2t3aXNlQ29udG91ckludGVncmFsfE5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyfE5vdFNxdWFyZVN1cGVyc2V0RXF1YWx8RGlhY3JpdGljYWxEb3VibGVBY3V0ZXxOb3RSaWdodFRyaWFuZ2xlRXF1YWx8Tm90U3VjY2VlZHNTbGFudEVxdWFsfE5vdFByZWNlZGVzU2xhbnRFcXVhbHxDbG9zZUN1cmx5RG91YmxlUXVvdGV8TmVnYXRpdmVWZXJ5VGhpblNwYWNlfERvdWJsZUNvbnRvdXJJbnRlZ3JhbHxGaWxsZWRWZXJ5U21hbGxTcXVhcmV8Q2FwaXRhbERpZmZlcmVudGlhbER8T3BlbkN1cmx5RG91YmxlUXVvdGV8RW1wdHlWZXJ5U21hbGxTcXVhcmV8TmVzdGVkR3JlYXRlckdyZWF0ZXJ8RG91YmxlTG9uZ1JpZ2h0QXJyb3d8Tm90TGVmdFRyaWFuZ2xlRXF1YWx8Tm90R3JlYXRlclNsYW50RXF1YWx8UmV2ZXJzZVVwRXF1aWxpYnJpdW18RG91YmxlTGVmdFJpZ2h0QXJyb3d8Tm90U3F1YXJlU3Vic2V0RXF1YWx8Tm90RG91YmxlVmVydGljYWxCYXJ8UmlnaHRBcnJvd0xlZnRBcnJvd3xOb3RHcmVhdGVyRnVsbEVxdWFsfE5vdFJpZ2h0VHJpYW5nbGVCYXJ8U3F1YXJlU3VwZXJzZXRFcXVhbHxEb3duTGVmdFJpZ2h0VmVjdG9yfERvdWJsZUxvbmdMZWZ0QXJyb3d8bGVmdHJpZ2h0c3F1aWdhcnJvd3xMZWZ0QXJyb3dSaWdodEFycm93fE5lZ2F0aXZlTWVkaXVtU3BhY2V8YmxhY2t0cmlhbmdsZXJpZ2h0fFJpZ2h0RG93blZlY3RvckJhcnxQcmVjZWRlc1NsYW50RXF1YWx8UmlnaHREb3VibGVCcmFja2V0fFN1Y2NlZWRzU2xhbnRFcXVhbHxOb3RMZWZ0VHJpYW5nbGVCYXJ8UmlnaHRUcmlhbmdsZUVxdWFsfFNxdWFyZUludGVyc2VjdGlvbnxSaWdodERvd25UZWVWZWN0b3J8UmV2ZXJzZUVxdWlsaWJyaXVtfE5lZ2F0aXZlVGhpY2tTcGFjZXxsb25nbGVmdHJpZ2h0YXJyb3d8TG9uZ2xlZnRyaWdodGFycm93fExvbmdMZWZ0UmlnaHRBcnJvd3xEb3duUmlnaHRUZWVWZWN0b3J8RG93blJpZ2h0VmVjdG9yQmFyfEdyZWF0ZXJTbGFudEVxdWFsfFNxdWFyZVN1YnNldEVxdWFsfExlZnREb3duVmVjdG9yQmFyfExlZnREb3VibGVCcmFja2V0fFZlcnRpY2FsU2VwYXJhdG9yfHJpZ2h0bGVmdGhhcnBvb25zfE5vdEdyZWF0ZXJHcmVhdGVyfE5vdFNxdWFyZVN1cGVyc2V0fGJsYWNrdHJpYW5nbGVsZWZ0fGJsYWNrdHJpYW5nbGVkb3dufE5lZ2F0aXZlVGhpblNwYWNlfExlZnREb3duVGVlVmVjdG9yfE5vdExlc3NTbGFudEVxdWFsfGxlZnRyaWdodGhhcnBvb25zfERvdWJsZVVwRG93bkFycm93fERvdWJsZVZlcnRpY2FsQmFyfExlZnRUcmlhbmdsZUVxdWFsfEZpbGxlZFNtYWxsU3F1YXJlfHR3b2hlYWRyaWdodGFycm93fE5vdE5lc3RlZExlc3NMZXNzfERvd25MZWZ0VGVlVmVjdG9yfERvd25MZWZ0VmVjdG9yQmFyfFJpZ2h0QW5nbGVCcmFja2V0fE5vdFRpbGRlRnVsbEVxdWFsfE5vdFJldmVyc2VFbGVtZW50fFJpZ2h0VXBEb3duVmVjdG9yfERpYWNyaXRpY2FsVGlsZGV8Tm90U3VjY2VlZHNUaWxkZXxjaXJjbGVhcnJvd3JpZ2h0fE5vdFByZWNlZGVzRXF1YWx8cmlnaHRoYXJwb29uZG93bnxEb3VibGVSaWdodEFycm93fE5vdFN1Y2NlZWRzRXF1YWx8Tm9uQnJlYWtpbmdTcGFjZXxOb3RSaWdodFRyaWFuZ2xlfExlc3NFcXVhbEdyZWF0ZXJ8UmlnaHRVcFRlZVZlY3RvcnxMZWZ0QW5nbGVCcmFja2V0fEdyZWF0ZXJGdWxsRXF1YWx8RG93bkFycm93VXBBcnJvd3xSaWdodFVwVmVjdG9yQmFyfHR3b2hlYWRsZWZ0YXJyb3d8R3JlYXRlckVxdWFsTGVzc3xkb3duaGFycG9vbnJpZ2h0fFJpZ2h0VHJpYW5nbGVCYXJ8bnRyaWFuZ2xlcmlnaHRlcXxOb3RTdXBlcnNldEVxdWFsfExlZnRVcERvd25WZWN0b3J8RGlhY3JpdGljYWxBY3V0ZXxyaWdodHJpZ2h0YXJyb3dzfHZhcnRyaWFuZ2xlcmlnaHR8VXBBcnJvd0Rvd25BcnJvd3xEaWFjcml0aWNhbEdyYXZlfFVuZGVyUGFyZW50aGVzaXN8RW1wdHlTbWFsbFNxdWFyZXxMZWZ0VXBWZWN0b3JCYXJ8bGVmdHJpZ2h0YXJyb3dzfERvd25SaWdodFZlY3Rvcnxkb3duaGFycG9vbmxlZnR8dHJpYW5nbGVyaWdodGVxfFNob3J0UmlnaHRBcnJvd3xPdmVyUGFyZW50aGVzaXN8RG91YmxlTGVmdEFycm93fERvdWJsZURvd25BcnJvd3xOb3RTcXVhcmVTdWJzZXR8YmlndHJpYW5nbGVkb3dufG50cmlhbmdsZWxlZnRlcXxVcHBlclJpZ2h0QXJyb3d8Y3VydmVhcnJvd3JpZ2h0fHZhcnRyaWFuZ2xlbGVmdHxOb3RMZWZ0VHJpYW5nbGV8bmxlZnRyaWdodGFycm93fExvd2VyUmlnaHRBcnJvd3xOb3RIdW1wRG93bkh1bXB8Tm90R3JlYXRlclRpbGRlfHJpZ2h0dGhyZWV0aW1lc3xMZWZ0VXBUZWVWZWN0b3J8Tm90R3JlYXRlckVxdWFsfHN0cmFpZ2h0ZXBzaWxvbnxMZWZ0VHJpYW5nbGVCYXJ8cmlnaHRzcXVpZ2Fycm93fENvbnRvdXJJbnRlZ3JhbHxyaWdodGxlZnRhcnJvd3N8Q2xvc2VDdXJseVF1b3RlfFJpZ2h0RG93blZlY3RvcnxMZWZ0UmlnaHRWZWN0b3J8bkxlZnRyaWdodGFycm93fGxlZnRoYXJwb29uZG93bnxjaXJjbGVhcnJvd2xlZnR8U3F1YXJlU3VwZXJzZXR8T3BlbkN1cmx5UXVvdGV8aG9va3JpZ2h0YXJyb3d8SG9yaXpvbnRhbExpbmV8RGlhY3JpdGljYWxEb3R8Tm90TGVzc0dyZWF0ZXJ8bnRyaWFuZ2xlcmlnaHR8RG91YmxlUmlnaHRUZWV8SW52aXNpYmxlQ29tbWF8SW52aXNpYmxlVGltZXN8TG93ZXJMZWZ0QXJyb3d8RG93bkxlZnRWZWN0b3J8Tm90U3Vic2V0RXF1YWx8Y3VydmVhcnJvd2xlZnR8dHJpYW5nbGVsZWZ0ZXF8Tm90VmVydGljYWxCYXJ8VGlsZGVGdWxsRXF1YWx8ZG93bmRvd25hcnJvd3N8Tm90R3JlYXRlckxlc3N8UmlnaHRUZWVWZWN0b3J8WmVyb1dpZHRoU3BhY2V8bG9vcGFycm93cmlnaHR8TG9uZ1JpZ2h0QXJyb3d8ZG91YmxlYmFyd2VkZ2V8U2hvcnRMZWZ0QXJyb3d8U2hvcnREb3duQXJyb3d8UmlnaHRWZWN0b3JCYXJ8R3JlYXRlckdyZWF0ZXJ8UmV2ZXJzZUVsZW1lbnR8cmlnaHRoYXJwb29udXB8TGVzc1NsYW50RXF1YWx8bGVmdHRocmVldGltZXN8dXBoYXJwb29ucmlnaHR8cmlnaHRhcnJvd3RhaWx8TGVmdERvd25WZWN0b3J8TG9uZ3JpZ2h0YXJyb3d8TmVzdGVkTGVzc0xlc3N8VXBwZXJMZWZ0QXJyb3d8bnNob3J0cGFyYWxsZWx8bGVmdGxlZnRhcnJvd3N8bGVmdHJpZ2h0YXJyb3d8TGVmdHJpZ2h0YXJyb3d8TGVmdFJpZ2h0QXJyb3d8bG9uZ3JpZ2h0YXJyb3d8dXBoYXJwb29ubGVmdHxSaWdodEFycm93QmFyfEFwcGx5RnVuY3Rpb258TGVmdFRlZVZlY3RvcnxsZWZ0YXJyb3d0YWlsfE5vdEVxdWFsVGlsZGV8dmFyc3Vic2V0bmVxcXx2YXJzdXBzZXRuZXFxfFJpZ2h0VGVlQXJyb3d8U3VjY2VlZHNFcXVhbHxTdWNjZWVkc1RpbGRlfExlZnRWZWN0b3JCYXJ8U3VwZXJzZXRFcXVhbHxob29rbGVmdGFycm93fERpZmZlcmVudGlhbER8VmVydGljYWxUaWxkZXxWZXJ5VGhpblNwYWNlfGJsYWNrdHJpYW5nbGV8YmlndHJpYW5nbGV1cHxMZXNzRnVsbEVxdWFsfGRpdmlkZW9udGltZXN8bGVmdGhhcnBvb251cHxVcEVxdWlsaWJyaXVtfG50cmlhbmdsZWxlZnR8UmlnaHRUcmlhbmdsZXxtZWFzdXJlZGFuZ2xlfHNob3J0cGFyYWxsZWx8bG9uZ2xlZnRhcnJvd3xMb25nbGVmdGFycm93fExvbmdMZWZ0QXJyb3d8RG91YmxlTGVmdFRlZXxQb2luY2FyZXBsYW5lfFByZWNlZGVzRXF1YWx8dHJpYW5nbGVyaWdodHxEb3VibGVVcEFycm93fFJpZ2h0VXBWZWN0b3J8ZmFsbGluZ2RvdHNlcXxsb29wYXJyb3dsZWZ0fFByZWNlZGVzVGlsZGV8Tm90VGlsZGVFcXVhbHxOb3RUaWxkZVRpbGRlfHNtYWxsc2V0bWludXN8UHJvcG9ydGlvbmFsfHRyaWFuZ2xlbGVmdHx0cmlhbmdsZWRvd258VW5kZXJCcmFja2V0fE5vdEh1bXBFcXVhbHxleHBvbmVudGlhbGV8RXhwb25lbnRpYWxFfE5vdExlc3NUaWxkZXxIaWxiZXJ0U3BhY2V8UmlnaHRDZWlsaW5nfGJsYWNrbG96ZW5nZXx2YXJzdXBzZXRuZXF8SHVtcERvd25IdW1wfEdyZWF0ZXJFcXVhbHxWZXJ0aWNhbExpbmV8TGVmdFRlZUFycm93fE5vdExlc3NFcXVhbHxEb3duVGVlQXJyb3d8TGVmdFRyaWFuZ2xlfHZhcnN1YnNldG5lcXxJbnRlcnNlY3Rpb258Tm90Q29uZ3J1ZW50fERvd25BcnJvd0JhcnxMZWZ0VXBWZWN0b3J8TGVmdEFycm93QmFyfHJpc2luZ2RvdHNlcXxHcmVhdGVyVGlsZGV8Um91bmRJbXBsaWVzfFNxdWFyZVN1YnNldHxTaG9ydFVwQXJyb3d8Tm90U3VwZXJzZXR8cXVhdGVybmlvbnN8cHJlY25hcHByb3h8YmFja2Vwc2lsb258cHJlY2N1cmx5ZXF8T3ZlckJyYWNrZXR8YmxhY2tzcXVhcmV8TWVkaXVtU3BhY2V8VmVydGljYWxCYXJ8Y2lyY2xlZGNpcmN8Y2lyY2xlZGRhc2h8Q2lyY2xlTWludXN8Q2lyY2xlVGltZXN8TGVzc0dyZWF0ZXJ8Y3VybHllcXByZWN8Y3VybHllcXN1Y2N8ZGlhbW9uZHN1aXR8VXBEb3duQXJyb3d8VXBkb3duYXJyb3d8UnVsZURlbGF5ZWR8UnJpZ2h0YXJyb3d8dXBkb3duYXJyb3d8UmlnaHRWZWN0b3J8blJpZ2h0YXJyb3d8bnJpZ2h0YXJyb3d8ZXFzbGFudGxlc3N8TGVmdENlaWxpbmd8RXF1aWxpYnJpdW18U21hbGxDaXJjbGV8ZXhwZWN0YXRpb258Tm90U3VjY2VlZHN8dGhpY2thcHByb3h8R3JlYXRlckxlc3N8U3F1YXJlVW5pb258Tm90UHJlY2VkZXN8Tm90TGVzc0xlc3N8c3RyYWlnaHRwaGl8c3VjY25hcHByb3h8c3VjY2N1cmx5ZXF8U3Vic2V0RXF1YWx8c3FzdXBzZXRlcXxQcm9wb3J0aW9ufExhcGxhY2V0cmZ8SW1hZ2luYXJ5SXxzdXBzZXRuZXFxfE5vdEdyZWF0ZXJ8Z3RyZXFxbGVzc3xOb3RFbGVtZW50fFRoaWNrU3BhY2V8VGlsZGVFcXVhbHxUaWxkZVRpbGRlfEZvdXJpZXJ0cmZ8cm1vdXN0YWNoZXxFcXVhbFRpbGRlfGVxc2xhbnRndHJ8VW5kZXJCcmFjZXxMZWZ0VmVjdG9yfFVwQXJyb3dCYXJ8bkxlZnRhcnJvd3xuc3Vic2V0ZXFxfHN1YnNldG5lcXF8bnN1cHNldGVxcXxubGVmdGFycm93fHN1Y2NhcHByb3h8bGVzc2FwcHJveHxVcFRlZUFycm93fHVwdXBhcnJvd3N8Y3VybHl3ZWRnZXxsZXNzZXFxZ3RyfHZhcmVwc2lsb258dmFybm90aGluZ3xSaWdodEZsb29yfGNvbXBsZW1lbnR8Q2lyY2xlUGx1c3xzcXN1YnNldGVxfExsZWZ0YXJyb3d8Y2lyY2xlZGFzdHxSaWdodEFycm93fFJpZ2h0YXJyb3d8cmlnaHRhcnJvd3xsbW91c3RhY2hlfEJlcm5vdWxsaXN8cHJlY2FwcHJveHxtYXBzdG9sZWZ0fG1hcHN0b2Rvd258bG9uZ21hcHN0b3xkb3RzcXVhcmV8ZG93bmFycm93fERvdWJsZURvdHxuc3Vic2V0ZXF8c3Vwc2V0bmVxfGxlZnRhcnJvd3xuc3Vwc2V0ZXF8c3Vic2V0bmVxfFRoaW5TcGFjZXxuZ2Vxc2xhbnR8c3Vic2V0ZXFxfEh1bXBFcXVhbHxOb3RTdWJzZXR8dHJpYW5nbGVxfE5vdEN1cENhcHxsZXNzZXFndHJ8aGVhcnRzdWl0fFRyaXBsZURvdHxMZWZ0YXJyb3d8Q29wcm9kdWN0fENvbmdydWVudHx2YXJwcm9wdG98Y29tcGxleGVzfGd2ZXJ0bmVxcXxMZWZ0QXJyb3d8TGVzc1RpbGRlfHN1cHNldGVxcXxNaW51c1BsdXN8Q2lyY2xlRG90fG5sZXFzbGFudHxOb3RFeGlzdHN8Z3RyZXFsZXNzfG5wYXJhbGxlbHxVbmlvblBsdXN8TGVmdEZsb29yfGNoZWNrbWFya3xDZW50ZXJEb3R8Y2VudGVyZG90fE1lbGxpbnRyZnxndHJhcHByb3h8Ymlnb3RpbWVzfE92ZXJCcmFjZXxzcGFkZXN1aXR8dGhlcmVmb3JlfHBpdGNoZm9ya3xyYXRpb25hbHN8UGx1c01pbnVzfEJhY2tzbGFzaHxUaGVyZWZvcmV8RG93bkJyZXZlfGJhY2tzaW1lcXxiYWNrcHJpbWV8RG93bkFycm93fG5zaG9ydG1pZHxEb3duYXJyb3d8bHZlcnRuZXFxfGVxdnBhcnNsfGltYWdsaW5lfGltYWdwYXJ0fGluZmludGllfGludGVnZXJzfEludGVncmFsfGludGVyY2FsfExlc3NMZXNzfFVhcnJvY2lyfGludGxhcmhrfHNxc3Vwc2V0fGFuZ21zZGFmfHNxc3Vic2V0fGxsY29ybmVyfHZhcnRoZXRhfGN1cGJyY2FwfGxuYXBwcm94fFN1cGVyc2V0fFN1Y2hUaGF0fHN1Y2Nuc2ltfHN1Y2NuZXFxfGFuZ21zZGFnfGJpZ3VwbHVzfGN1cmx5dmVlfHRycGV6aXVtfFN1Y2NlZWRzfE5vdFRpbGRlfGJpZ3dlZGdlfGFuZ21zZGFofGFuZ3J0dmJkfHRyaW1pbnVzfGN3Y29uaW50fGZwYXJ0aW50fGxyY29ybmVyfHNtZXBhcnNsfHN1YnNldGVxfHVyY29ybmVyfGx1cmRzaGFyfGxhZW1wdHl2fEREb3RyYWhkfGFwcHJveGVxfGxkcnVzaGFyfGF3Y29uaW50fG1hcHN0b3VwfGJhY2tjb25nfHNob3J0bWlkfHRyaWFuZ2xlfGdlcXNsYW50fGdlc2RvdG9sfHRpbWVzYmFyfGNpcmNsZWRSfGNpcmNsZWRTfHNldG1pbnVzfG11bHRpbWFwfG5hdHVyYWxzfHNjcG9saW50fG5jb25nZG90fFJpZ2h0VGVlfGJveG1pbnVzfGduYXBwcm94fGJveHRpbWVzfGFuZHNsb3BlfHRoaWNrc2ltfGFuZ21zZGFhfHZhcnNpZ21hfGNpcmZuaW50fHJ0cmlsdHJpfGFuZ21zZGFifHJwcG9saW50fGFuZ21zZGFjfGJhcndlZGdlfGRyYmthcm93fGNsdWJzdWl0fHRoZXRhc3ltfGJzb2xoc3VifGNhcGJyY3VwfGR6aWdyYXJyfGRvdGVxZG90fERvdEVxdWFsfGRvdG1pbnVzfFVuZGVyQmFyfE5vdEVxdWFsfHJlYWxwYXJ0fG90aW1lc2FzfHVsY29ybmVyfGhrc2Vhcm93fGhrc3dhcm93fHBhcmFsbGVsfFBhcnRpYWxEfGVsaW50ZXJzfGVtcHR5c2V0fHBsdXNhY2lyfGJicmt0YnJrfGFuZ21zZGFkfHBvaW50aW50fGJpZ29wbHVzfGFuZ21zZGFlfFByZWNlZGVzfGJpZ3NxY3VwfHZhcmthcHBhfG5vdGluZG90fHN1cHNldGVxfHByZWNuZXFxfHByZWNuc2ltfHByb2ZhbGFyfHByb2ZsaW5lfHByb2ZzdXJmfGxlcXNsYW50fGxlc2RvdG9yfHJhZW1wdHl2fHN1YnBsdXN8bm90bml2Ynxub3RuaXZjfHN1YnJhcnJ8emlncmFycnx2emlnemFnfHN1Ym11bHR8c3ViZWRvdHxFbGVtZW50fGJldHdlZW58Y2lyc2NpcnxsYXJyYmZzfGxhcnJzaW18bG90aW1lc3xsYnJrc2xkfGxicmtzbHV8bG96ZW5nZXxsZHJkaGFyfGRia2Fyb3d8YmlnY2lyY3xlcHNpbG9ufHNpbXJhcnJ8c2ltcGx1c3xsdHF1ZXN0fEVwc2lsb258bHVydWhhcnxndHF1ZXN0fG1hbHRlc2V8bnBvbGludHxlcWNvbG9ufG5wcmVjZXF8Ymlnb2RvdHxkZGFnZ2VyfGd0cmxlc3N8Ym5lcXVpdnxoYXJyY2lyfGRkb3RzZXF8ZXF1aXZERHxiYWNrc2ltfGRlbXB0eXZ8bnNxc3ViZXxuc3FzdXBlfFVwc2lsb258bnN1YnNldHx1cHNpbG9ufG1pbnVzZHV8bnN1Y2NlcXxzd2Fycm93fG5zdXBzZXR8Y29sb25lcXxzZWFycm93fGJveHBsdXN8bmFwcHJveHxuYXR1cmFsfGFzeW1wZXF8YWxlZnN5bXxjb25nZG90fG5lYXJyb3d8Ymlnc3RhcnxkaWFtb25kfHN1cHBsdXN8dHJpdGltZXxMZWZ0VGVlfG52aW5maW58dHJpcGx1c3xOZXdMaW5lfG52bHRyaWV8bnZydHJpZXxud2Fycm93fG5leGlzdHN8RGlhbW9uZHxydWx1aGFyfEltcGxpZXN8c3VwbXVsdHxhbmd6YXJyfHN1cGxhcnJ8c3VwaHN1YnxxdWVzdGVxfGJlY2F1c2V8ZGlnYW1tYXxCZWNhdXNlfG9sY3Jvc3N8YmVtcHR5dnxvbWljcm9ufE9taWNyb258cm90aW1lc3xOb0JyZWFrfGludHByb2R8YW5ncnR2YnxvcmRlcm9mfHV3YW5nbGV8c3VwaHNvbHxsZXNkb3RvfG9yc2xvcGV8RG93blRlZXxyZWFsaW5lfGN1ZGFycmx8cmRsZGhhcnxPdmVyQmFyfHN1cGVkb3R8bGVzc2RvdHxzdXBkc3VifHRvcGZvcmt8c3VjY3NpbXxyYnJrc2x1fHJicmtzbGR8cGVydGVua3xjdWRhcnJyfGlzaW5kb3R8cGxhbmNraHxsZXNzZ3RyfHBsdXNjaXJ8Z2VzZG90b3xwbHVzc2ltfHBsdXN0d298bGVzc3NpbXxjdWxhcnJwfHJhcnJzaW18Q2F5bGV5c3xub3RpbnZhfG5vdGludmJ8bm90aW52Y3xVcEFycm93fFVwYXJyb3d8dXBhcnJvd3xOb3RMZXNzfGR3YW5nbGV8cHJlY3NpbXxQcm9kdWN0fGN1cmFycm18Q2NvbmludHxkb3RwbHVzfHJhcnJiZnN8Y2N1cHNzbXxDZWRpbGxhfGNlbXB0eXZ8bm90bml2YXxxdWF0aW50fGZyYWMzNXxmcmFjMzh8ZnJhYzQ1fGZyYWM1NnxmcmFjNTh8ZnJhYzc4fHRyaWRvdHx4b3BsdXN8Z2FjdXRlfGdhbW1hZHxHYW1tYWR8bGZpc2h0fGxmbG9vcnxiaWdjdXB8c3FzdXBlfGdicmV2ZXxHYnJldmV8bGhhcnVsfHNxc3ViZXxzcWN1cHN8R2NlZGlsfGFwYWNpcnxsbGhhcmR8bG1pZG90fExtaWRvdHxsbW91c3R8YW5kYW5kfHNxY2Fwc3xhcHByb3h8QWJyZXZlfHNwYWRlc3xjaXJjZXF8dHByaW1lfGRpdmlkZXx0b3BjaXJ8QXNzaWdufHRvcGJvdHxnZXNkb3R8ZGl2b254fHh1cGx1c3x0aW1lc2R8Z2VzbGVzfGF0aWxkZXxzb2xiYXJ8U09GVGN5fGxvcGx1c3x0aW1lc2J8bG93YXN0fGxvd2JhcnxkbGNvcm58ZGxjcm9wfHNvZnRjeXxkb2xsYXJ8bHBhcmx0fHRoa3NpbXxscmhhcmR8QXRpbGRlfGxzYXF1b3xzbWFzaHB8YmlndmVlfHRoaW5zcHx3cmVhdGh8Ymthcm93fGxzcXVvcnxsc3Ryb2t8THN0cm9rfGx0aHJlZXxsdGltZXN8bHRsYXJyfERvdERvdHxzaW1kb3R8bHRyUGFyfHdlaWVycHx4c3FjdXB8YW5nbXNkfHNpZ21hdnxzaWdtYWZ8emVldHJmfFpjYXJvbnx6Y2Fyb258bWFwc3RvfHZzdXBuZXx0aGV0YXZ8Y2lybWlkfG1hcmtlcnxtY29tbWF8WmFjdXRlfHZzdWJuRXx0aGVyZTR8Z3RsUGFyfHZzdWJuZXxib3R0b218Z3RyYXJyfFNIQ0hjeXxzaGNoY3l8bWlkYXN0fG1pZGNpcnxtaWRkb3R8bWludXNifG1pbnVzZHxndHJkb3R8Ym93dGllfHNmcm93bnxtbnBsdXN8bW9kZWxzfGNvbG9uZXxzZXN3YXJ8Q29sb25lfG1zdHBvc3xzZWFyaGt8Z3Ryc2ltfG5hY3V0ZXxOYWN1dGV8Ym94Ym94fHRlbHJlY3xoYWlyc3B8VGNlZGlsfG5idW1wZXxzY25zaW18bmNhcm9ufE5jYXJvbnxuY2VkaWx8TmNlZGlsfGhhbWlsdHxTY2VkaWx8bmVhcmhrfGhhcmRjeXxIQVJEY3l8dGNlZGlsfFRjYXJvbnxjb21tYXR8bmVxdWl2fG5lc2Vhcnx0Y2Fyb258dGFyZ2V0fGhlYXJ0c3xuZXhpc3R8dmFycmhvfHNjZWRpbHxTY2Fyb258c2Nhcm9ufGhlbGxpcHxTYWN1dGV8c2FjdXRlfGhlcmNvbnxzd253YXJ8Y29tcGZufHJ0aW1lc3xydGhyZWV8cnNxdW9yfHJzYXF1b3x6YWN1dGV8d2VkZ2VxfGhvbXRodHxiYXJ2ZWV8YmFyd2VkfEJhcndlZHxycGFyZ3R8aG9yYmFyfGNvbmludHxzd2FyaGt8cm9wbHVzfG5sdHJpZXxoc2xhc2h8aHN0cm9rfEhzdHJva3xybW91c3R8Q29uaW50fGJwcmltZXxoeWJ1bGx8aHlwaGVufGlhY3V0ZXxJYWN1dGV8c3Vwc3VwfHN1cHN1YnxzdXBzaW18dmFycGhpfGNvcHJvZHxicnZiYXJ8YWdyYXZlfFN1cHNldHxzdXBzZXR8aWdyYXZlfElncmF2ZXxub3RpbkV8QWdyYXZlfGlpaWludHxpaW5maW58Y29weXNyfHdlZGJhcnxWZXJiYXJ8dmFuZ3J0fGJlY2F1c3xpbmNhcmV8dmVyYmFyfGlub2RvdHxidWxsZXR8ZHJjb3JufGludGNhbHxkcmNyb3B8Y3VsYXJyfHZlbGxpcHxVdGlsZGV8YnVtcGVxfGN1cGNhcHxkc3Ryb2t8RHN0cm9rfEN1cENhcHxjdXBjdXB8Y3VwZG90fGVhY3V0ZXxFYWN1dGV8c3VwZG90fGlxdWVzdHxlYXN0ZXJ8ZWNhcm9ufEVjYXJvbnxlY29sb258aXNpbnN2fHV0aWxkZXxpdGlsZGV8SXRpbGRlfGN1cmFycnxzdWNjZXF8QnVtcGVxfGNhY3V0ZXx1bGNyb3B8bnBhcnNsfENhY3V0ZXxucHJjdWV8ZWdyYXZlfEVncmF2ZXxucmFycmN8bnJhcnJ3fHN1YnN1cHxzdWJzdWJ8bnJ0cmllfGpzZXJjeXxuc2NjdWV8SnNlcmN5fGthcHBhdnxrY2VkaWx8S2NlZGlsfHN1YnNpbXx1bGNvcm58bnNpbWVxfGVnc2RvdHx2ZWViYXJ8a2dyZWVufGNhcGFuZHxlbHNkb3R8U3Vic2V0fHN1YnNldHxjdXJyZW58YWFjdXRlfGxhY3V0ZXxMYWN1dGV8ZW1wdHl2fG50aWxkZXxOdGlsZGV8bGFncmFufGxhbWJkYXxMYW1iZGF8Y2FwY2FwfFVncmF2ZXxsYW5nbGV8c3ViZG90fGVtc3AxM3xudW1lcm98ZW1zcDE0fG52ZGFzaHxudkRhc2h8blZkYXNofG5WRGFzaHx1Z3JhdmV8dWZpc2h0fG52SGFycnxsYXJyZnN8bnZsQXJyfGxhcnJoa3xsYXJybHB8bGFycnBsfG52ckFycnxVZGJsYWN8bndhcmhrfGxhcnJ0bHxud25lYXJ8b2FjdXRlfE9hY3V0ZXxsYXRhaWx8bEF0YWlsfHNzdGFyZnxsYnJhY2V8b2RibGFjfE9kYmxhY3xsYnJhY2t8dWRibGFjfG9kc29sZHxlcGFyc2x8bGNhcm9ufExjYXJvbnxvZ3JhdmV8T2dyYXZlfGxjZWRpbHxMY2VkaWx8QWFjdXRlfHNzbWlsZXxzc2V0bW58c3F1YXJmfGxkcXVvcnxjYXBjdXB8b21pbnVzfGN5bGN0eXxyaGFydWx8ZXFjaXJjfGRhZ2dlcnxyZmxvb3J8cmZpc2h0fERhZ2dlcnxkYWxldGh8ZXF1YWxzfG9yaWdvZnxjYXBkb3R8ZXF1ZXN0fGRjYXJvbnxEY2Fyb258cmRxdW9yfG9zbGFzaHxPc2xhc2h8b3RpbGRlfE90aWxkZXxvdGltZXN8T3RpbWVzfHVyY3JvcHxVYnJldmV8dWJyZXZlfFlhY3V0ZXxVYWN1dGV8dWFjdXRlfFJjZWRpbHxyY2VkaWx8dXJjb3JufHBhcnNpbXxSY2Fyb258VmRhc2hsfHJjYXJvbnxUc3Ryb2t8cGVyY250fHBlcmlvZHxwZXJtaWx8RXhpc3RzfHlhY3V0ZXxyYnJhY2t8cmJyYWNlfHBobW1hdHxjY2Fyb258Q2Nhcm9ufHBsYW5ja3xjY2VkaWx8cGxhbmt2fHRzdHJva3xmZW1hbGV8cGx1c2RvfHBsdXNkdXxmZmlsaWd8cGx1c21ufGZmbGxpZ3xDY2VkaWx8ckF0YWlsfGRmaXNodHxiZXJub3V8cmF0YWlsfFJhcnJ0bHxyYXJydGx8YW5nc3BofHJhcnJwbHxyYXJybHB8cmFycmhrfHh3ZWRnZXx4b3RpbWV8Zm9yYWxsfEZvckFsbHxWdmRhc2h8dnN1cG5FfHByZWNlcXxiaWdjYXB8ZnJhYzEyfGZyYWMxM3xmcmFjMTR8cHJpbWVzfHJhcnJmc3xwcm5zaW18ZnJhYzE1fFNxdWFyZXxmcmFjMTZ8c3F1YXJlfGxlc2RvdHxmcmFjMTh8ZnJhYzIzfHByb3B0b3xwcnVyZWx8cmFycmFwfHJhbmdsZXxwdW5jc3B8ZnJhYzI1fFJhY3V0ZXxxcHJpbWV8cmFjdXRlfGxlc2dlc3xmcmFjMzR8YWJyZXZlfEFFbGlnfGVxc2ltfHV0ZG90fHNldG1ufHVydHJpfEVxdWFsfFVyaW5nfHNlQXJyfHVyaW5nfHNlYXJyfGRhc2h2fERhc2h2fG11bWFwfG5hYmxhfGlvZ29ufElvZ29ufHNkb3RlfHNkb3RifHNjc2ltfG5hcGlkfG5hcG9zfGVxdWl2fG5hdHVyfEFjaXJjfGRibGFjfGVyYXJyfG5idW1wfGlwcm9kfGVyRG90fHVjaXJjfGF3aW50fGVzZG90fGFuZ3J0fG5jb25nfGlzaW5FfHNjbmFwfFNjaXJjfHNjaXJjfG5kYXNofGlzaW5zfFVicmN5fG5lYXJyfG5lQXJyfGlzaW52fG5lZG90fHVicmN5fGFjdXRlfFljaXJjfGl1a2N5fEl1a2N5fHh1dHJpfG5lc2ltfGNhcmV0fGpjaXJjfEpjaXJjfGNhcm9ufHR3aXh0fGRkYXJyfHNjY3VlfGV4aXN0fGptYXRofHNicXVvfG5nZXFxfGFuZ3N0fGNjYXBzfGxjZWlsfG5nc2ltfFVwVGVlfGRlbHRhfERlbHRhfHJ0cmlmfG5oYXJyfG5oQXJyfG5ocGFyfHJ0cmllfGp1a2N5fEp1a2N5fGthcHBhfHJzcXVvfEthcHBhfG5sYXJyfG5sQXJyfFRTSGN5fHJyYXJyfGFvZ29ufEFvZ29ufGZmbGlnfHhyYXJyfHRzaGN5fGNjaXJjfG5sZXFxfGZpbGlnfHVwc2lofG5sZXNzfGRoYXJsfG5sc2ltfGZqbGlnfHJvcGFyfG5sdHJpfGRoYXJyfHJvYnJrfHJvYXJyfGZsbGlnfGZsdG5zfHJvYW5nfHJubWlkfHN1Ym5FfHN1Ym5lfGxBYXJyfHRyaXNifENjaXJjfGFjaXJjfGNjdXBzfGJsYW5rfFZEYXNofGZvcmt2fFZkYXNofGxhbmdkfGNlZGlsfGJsazEyfGJsazE0fGxhcXVvfHN0cm5zfGRpYW1zfG5vdGlufHZEYXNofGxhcnJifGJsazM0fGJsb2NrfGRpc2lufHVwbHVzfHZkYXNofHZCYXJ2fGFlbGlnfHN0YXJmfFdlZGdlfGNoZWNrfHhyQXJyfGxhdGVzfGxiYXJyfGxCYXJyfG5vdG5pfGxiYnJrfGJjb25nfGZyYXNsfGxicmtlfGZyb3dufHZydHJpfHZwcm9wfHZuc3VwfGdhbW1hfEdhbW1hfHdlZGdlfHhvZG90fGJkcXVvfHNyYXJyfGRvdGVxfGxkcXVvfGJveGRsfGJveGRMfGdjaXJjfEdjaXJjfGJveERsfGJveERMfGJveGRyfGJveGRSfGJveERyfFRSQURFfHRyYWRlfHJsaGFyfGJveERSfHZuc3VifG5wYXJ0fHZsdHJpfHJsYXJyfGJveGhkfGJveGhEfG5wcmVjfGdlc2NjfG5yYXJyfG5yQXJyfGJveEhkfGJveEhEfGJveGh1fGJveGhVfG5ydHJpfGJveEh1fGNsdWJzfGJveEhVfHRpbWVzfGNvbG9ufENvbG9ufGdpbWVsfHhsQXJyfFRpbGRlfG5zaW1lfHRpbGRlfG5zbWlkfG5zcGFyfFRIT1JOfHRob3JufHhsYXJyfG5zdWJlfG5zdWJFfHRoa2FwfHhoQXJyfGNvbW1hfG5zdWNjfGJveHVsfGJveHVMfG5zdXBlfG5zdXBFfGduZXFxfGduc2ltfGJveFVsfGJveFVMfGdyYXZlfGJveHVyfGJveHVSfGJveFVyfGJveFVSfGxlc2NjfGFuZ2xlfGJlcHNpfGJveHZofHZhcnBpfGJveHZIfG51bXNwfFRoZXRhfGdzaW1lfGdzaW1sfHRoZXRhfGJveFZofGJveFZIfGJveHZsfGd0Y2lyfGd0ZG90fGJveHZMfGJveFZsfGJveFZMfGNyYXJyfGNyb3NzfENyb3NzfG52c2ltfGJveHZyfG53YXJyfG53QXJyfHNxc3VwfGR0ZG90fFVvZ29ufGxoYXJkfGxoYXJ1fGR0cmlmfG9jaXJjfE9jaXJjfGxoYmxrfGR1YXJyfG9kYXNofHNxc3VifEhhY2VrfHNxY3VwfGxsYXJyfGR1aGFyfG9lbGlnfE9FbGlnfG9mY2lyfGJveHZSfHVvZ29ufGxsdHJpfGJveFZyfGNzdWJlfHV1YXJyfG9oYmFyfGNzdXBlfGN0ZG90fG9sYXJyfG9sY2lyfGhhcnJ3fG9saW5lfHNxY2FwfG9tYWNyfE9tYWNyfG9tZWdhfE9tZWdhfGJveFZSfGFsZXBofGxuZXFxfGxuc2ltfGxvYW5nfGxvYXJyfHJoYXJ1fGxvYnJrfGhjaXJjfG9wZXJwfG9wbHVzfHJoYXJkfEhjaXJjfG9yYXJyfFVuaW9ufG9yZGVyfGVjaXJjfEVjaXJjfGN1ZXByfHN6bGlnfGN1ZXNjfGJyZXZlfHJlYWxzfGVERG90fEJyZXZlfGhvYXJyfGxvcGFyfHV0cmlmfHJkcXVvfFVtYWNyfHVtYWNyfGVmRG90fHN3QXJyfHVsdHJpfGFscGhhfHJjZWlsfG92YmFyfHN3YXJyfFdjaXJjfHdjaXJjfHNtdGVzfHNtaWxlfGJzZW1pfGxyYXJyfGFyaW5nfHBhcnNsfGxyaGFyfGJzaW1lfHVoYmxrfGxydHJpfGN1cG9yfEFyaW5nfHVoYXJyfHVoYXJsfHNsYXJyfHJicmtlfGJzb2xifGxzaW1lfHJiYnJrfFJCYXJyfGxzaW1nfHBob25lfHJCYXJyfHJiYXJyfGljaXJjfGxzcXVvfEljaXJjfGVtYWNyfEVtYWNyfHJhdGlvfHNpbW5lfHBsdXNifHNpbWxFfHNpbWdFfHNpbWVxfHBsdXNlfGx0Y2lyfGx0ZG90fGVtcHR5fHhoYXJyfHhkdHJpfGlleGNsfEFscGhhfGx0cmllfHJhcnJ3fHBvdW5kfGx0cmlmfHhjaXJjfGJ1bXBlfHByY3VlfGJ1bXBFfGFzeW1wfGFtYWNyfGN1dmVlfFNpZ21hfHNpZ21hfGlpaW50fHVkaGFyfGlpb3RhfGlqbGlnfElKbGlnfHN1cG5FfGltYWNyfEltYWNyfHByaW1lfFByaW1lfGltYWdlfHBybmFwfGVvZ29ufEVvZ29ufHJhcnJjfG1kYXNofG1ERG90fGN1d2VkfGltYXRofHN1cG5lfGltcGVkfEFtYWNyfHVkYXJyfHByc2ltfG1pY3JvfHJhcnJifGN3aW50fHJhcXVvfGluZmlufGVwbHVzfHJhbmdlfHJhbmdkfFVjaXJjfHJhZGljfG1pbnVzfGFtYWxnfHZlZWVxfHJBYXJyfGVwc2l2fHljaXJjfHF1ZXN0fHNoYXJwfHF1b3R8enduanxRc2NyfHJhY2V8cXNjcnxRb3BmfHFvcGZ8cWludHxyYW5nfFJhbmd8WnNjcnx6c2NyfFpvcGZ8em9wZnxyYXJyfHJBcnJ8UmFycnxQc2NyfHBzY3J8cHJvcHxwcm9kfHBybkV8cHJlY3xaSGN5fHpoY3l8cHJhcHxaZXRhfHpldGF8UG9wZnxwb3BmfFpkb3R8cGx1c3x6ZG90fFl1bWx8eXVtbHxwaGl2fFlVY3l8eXVjeXxZc2NyfHlzY3J8cGVycHxZb3BmfHlvcGZ8cGFydHxwYXJhfFlJY3l8T3VtbHxyY3VifHlpY3l8WUFjeXxyZGNhfG91bWx8b3NvbHxPc2NyfHJkc2h8eWFjeXxyZWFsfG9zY3J8eHZlZXxhbmRkfHJlY3R8YW5kdnxYc2NyfG9yb3J8b3JkbXxvcmRmfHhzY3J8YW5nZXxhb3BmfEFvcGZ8ckhhcnxYb3BmfG9wYXJ8T29wZnx4b3BmfHhuaXN8cmhvdnxvb3BmfG9taWR8eG1hcHxvaW50fGFwaWR8YXBvc3xvZ29ufGFzY3J8QXNjcnxvZG90fG9kaXZ8eGN1cHx4Y2FwfG9jaXJ8b2FzdHxudmx0fG52bGV8bnZndHxudmdlfG52YXB8V3Njcnx3c2NyfGF1bWx8bnRsZ3xudGdsfG5zdXB8bnN1Ynxuc2ltfE5zY3J8bnNjcnxuc2NlfFdvcGZ8cmluZ3xucHJlfHdvcGZ8bnBhcnxBdW1sfEJhcnZ8YmJya3xOb3BmfG5vcGZ8bm1pZHxuTHR2fGJldGF8cm9wZnxSb3BmfEJldGF8YmV0aHxubGVzfHJwYXJ8bmxlcXxibm90fGJOb3R8bmxkcnxOSmN5fHJzY3J8UnNjcnxWc2NyfHZzY3J8cnNxYnxuamN5fGJvcGZ8bmlzZHxCb3BmfHJ0cml8Vm9wZnxuR3R2fG5ndHJ8dm9wZnxib3hofGJveEh8Ym94dnxuZ2VzfG5nZXF8Ym94Vnxic2NyfHNjYXB8QnNjcnxic2ltfFZlcnR8dmVydHxic29sfGJ1bGx8YnVtcHxjYXBzfGNkb3R8bmN1cHxzY25FfG5jYXB8bmJzcHxuYXBFfENkb3R8Y2VudHxzZG90fFZiYXJ8bmFuZ3x2QmFyfGNoY3l8TXNjcnxtc2NyfHNlY3R8c2VtaXxDSGN5fE1vcGZ8bW9wZnxzZXh0fGNpcmN8Y2lyZXxtbGRyfG1sY3B8Y2lyRXxjb21wfHNoY3l8U0hjeXx2QXJyfHZhcnJ8Y29uZ3xjb3BmfENvcGZ8Y29weXxDT1BZfG1hbHR8bWFsZXxtYWNyfGx2bkV8Y3NjcnxsdHJpfHNpbWV8bHRjY3xzaW1nfENzY3J8c2ltbHxjc3VifFV1bWx8bHNxYnxsc2ltfHV1bWx8Y3N1cHxMc2NyfGxzY3J8dXRyaXxzbWlkfGxwYXJ8Y3Vwc3xzbXRlfGxvemZ8ZGFycnxMb3BmfFVzY3J8c29sYnxsb3BmfHNvcGZ8U29wZnxsbmVxfHVzY3J8c3BhcnxkQXJyfGxuYXB8RGFycnxkYXNofFNxcnR8TEpjeXxsamN5fGxIYXJ8ZEhhcnxVcHNpfHVwc2l8ZGlhbXxsZXNnfGRqY3l8REpjeXxsZXFxfGRvcGZ8RG9wZnxkc2NyfERzY3J8ZHNjeXxsZHNofGxkY2F8c3F1ZnxEU2N5fHNzY3J8U3Njcnxkc29sfGxjdWJ8bGF0ZXxzdGFyfFN0YXJ8VW9wZnxMYXJyfGxBcnJ8bGFycnx1b3BmfGR0cml8ZHpjeXxzdWJlfHN1YkV8TGFuZ3xsYW5nfEtzY3J8a3NjcnxLb3BmfGtvcGZ8S0pjeXxramN5fEtIY3l8a2hjeXxEWmN5fGVjaXJ8ZWRvdHxlRG90fEpzY3J8anNjcnxzdWNjfEpvcGZ8am9wZnxFZG90fHVIYXJ8ZW1zcHxlbnNwfEl1bWx8aXVtbHxlb3BmfGlzaW58SXNjcnxpc2NyfEVvcGZ8ZXBhcnxzdW5nfGVwc2l8ZXNjcnxzdXAxfHN1cDJ8c3VwM3xJb3RhfGlvdGF8c3VwZXxzdXBFfElvcGZ8aW9wZnxJT2N5fGlvY3l8RXNjcnxlc2ltfEVzaW18aW1vZnxVYXJyfFFVT1R8dUFycnx1YXJyfGV1bWx8SUVjeXxpZWN5fElkb3R8RXVtbHxldXJvfGV4Y2x8SHNjcnxoc2NyfEhvcGZ8aG9wZnxUU2N5fHRzY3l8VHNjcnxoYmFyfHRzY3J8ZmxhdHx0YnJrfGZub2Z8aEFycnxoYXJyfGhhbGZ8Zm9wZnxGb3BmfHRkb3R8Z3ZuRXxmb3JrfHRyaWV8Z3RjY3xmc2NyfEZzY3J8Z2RvdHxnc2ltfEdzY3J8Z3NjcnxHb3BmfGdvcGZ8Z25lcXxHZG90fHRvc2F8Z25hcHxUb3BmfHRvcGZ8Z2VxcXx0b2VhfEdKY3l8Z2pjeXx0aW50fGdlc2x8bWlkfFNmcnxnZ2d8dG9wfGdlc3xnbGF8Z2xFfGdsanxnZXF8Z25lfGdFbHxnZWx8Z25FfEdjeXxnY3l8Z2FwfFRmcnx0ZnJ8VGN5fHRjeXxIYXR8VGF1fEZmcnx0YXV8VGFifGhmcnxIZnJ8ZmZyfEZjeXxmY3l8aWN5fEljeXxpZmZ8RVRIfGV0aHxpZnJ8SWZyfEV0YXxldGF8aW50fEludHxTdXB8c3VwfHVjeXxVY3l8U3VtfHN1bXxqY3l8RU5HfHVmcnxVZnJ8ZW5nfEpjeXxqZnJ8ZWxzfGVsbHxlZ3N8RWZyfGVmcnxKZnJ8dW1sfGtjeXxLY3l8RWN5fGVjeXxrZnJ8S2ZyfGxhcHxTdWJ8c3VifGxhdHxsY3l8TGN5fGxlZ3xEb3R8ZG90fGxFZ3xsZXF8bGVzfHNxdXxkaXZ8ZGllfGxmcnxMZnJ8bGdFfERmcnxkZnJ8RGVsfGRlZ3xEY3l8ZGN5fGxuZXxsbkV8c29sfGxvenxzbXR8Q3VwfGxybXxjdXB8bHNofExzaHxzaW18c2h5fG1hcHxNYXB8bWN5fE1jeXxtZnJ8TWZyfG1ob3xnZnJ8R2ZyfHNmcnxjaXJ8Q2hpfGNoaXxuYXB8Q2ZyfHZjeXxWY3l8Y2ZyfFNjeXxzY3l8bmN5fE5jeXx2ZWV8VmVlfENhcHxjYXB8bmZyfHNjRXxzY2V8TmZyfG5nZXxuZ0V8bkdnfHZmcnxWZnJ8bmd0fGJvdHxuR3R8bmlzfG5pdnxSc2h8cnNofG5sZXxubEV8Ym5lfEJmcnxiZnJ8bkxsfG5sdHxuTHR8QmN5fGJjeXxub3R8Tm90fHJsbXx3ZnJ8V2ZyfG5wcnxuc2N8bnVtfG9jeXxhc3R8T2N5fG9mcnx4ZnJ8WGZyfE9mcnxvZ3R8b2htfGFwRXxvbHR8UmhvfGFwZXxyaG98UmZyfHJmcnxvcmR8UkVHfGFuZ3xyZWd8b3J2fEFuZHxhbmR8QU1QfFJjeXxhbXB8QWZyfHljeXxZY3l8eWVufHlmcnxZZnJ8cmN5fHBhcnxwY3l8UGN5fHBmcnxQZnJ8cGhpfFBoaXxhZnJ8QWN5fGFjeXx6Y3l8WmN5fHBpdnxhY0V8YWNkfHpmcnxaZnJ8cHJlfHByRXxwc2l8UHNpfHFmcnxRZnJ8endqfE9yfGdlfEdnfGd0fGdnfGVsfG9TfGx0fEx0fExUfFJlfGxnfGdsfGVnfG5lfEltfGl0fGxlfEREfHdwfHdyfG51fE51fGRkfGxFfFNjfHNjfHBpfFBpfGVlfGFmfGxsfExsfHJ4fGdFfHhpfHBtfFhpfGljfHByfFByfGlufG5pfG1wfG11fGFjfE11fG9yfGFwfEd0fEdUfGlpKTt8JihBYWN1dGV8QWdyYXZlfEF0aWxkZXxDY2VkaWx8RWFjdXRlfEVncmF2ZXxJYWN1dGV8SWdyYXZlfE50aWxkZXxPYWN1dGV8T2dyYXZlfE9zbGFzaHxPdGlsZGV8VWFjdXRlfFVncmF2ZXxZYWN1dGV8YWFjdXRlfGFncmF2ZXxhdGlsZGV8YnJ2YmFyfGNjZWRpbHxjdXJyZW58ZGl2aWRlfGVhY3V0ZXxlZ3JhdmV8ZnJhYzEyfGZyYWMxNHxmcmFjMzR8aWFjdXRlfGlncmF2ZXxpcXVlc3R8bWlkZG90fG50aWxkZXxvYWN1dGV8b2dyYXZlfG9zbGFzaHxvdGlsZGV8cGx1c21ufHVhY3V0ZXx1Z3JhdmV8eWFjdXRlfEFFbGlnfEFjaXJjfEFyaW5nfEVjaXJjfEljaXJjfE9jaXJjfFRIT1JOfFVjaXJjfGFjaXJjfGFjdXRlfGFlbGlnfGFyaW5nfGNlZGlsfGVjaXJjfGljaXJjfGlleGNsfGxhcXVvfG1pY3JvfG9jaXJjfHBvdW5kfHJhcXVvfHN6bGlnfHRob3JufHRpbWVzfHVjaXJjfEF1bWx8Q09QWXxFdW1sfEl1bWx8T3VtbHxRVU9UfFV1bWx8YXVtbHxjZW50fGNvcHl8ZXVtbHxpdW1sfG1hY3J8bmJzcHxvcmRmfG9yZG18b3VtbHxwYXJhfHF1b3R8c2VjdHxzdXAxfHN1cDJ8c3VwM3x1dW1sfHl1bWx8QU1QfEVUSHxSRUd8YW1wfGRlZ3xldGh8bm90fHJlZ3xzaHl8dW1sfHllbnxHVHxMVHxndHxsdCkoPyE7KShbPWEtekEtWjAtOV0/KXwmIyhbMC05XSspKDs/KXwmI1t4WF0oW2EtZkEtRjAtOV0rKSg7Pyl8JihbMC05YS16QS1aXSspL2c7XG5cdHZhciBkZWNvZGVNYXAgPSB7J2FhY3V0ZSc6J1xceEUxJywnQWFjdXRlJzonXFx4QzEnLCdhYnJldmUnOidcXHUwMTAzJywnQWJyZXZlJzonXFx1MDEwMicsJ2FjJzonXFx1MjIzRScsJ2FjZCc6J1xcdTIyM0YnLCdhY0UnOidcXHUyMjNFXFx1MDMzMycsJ2FjaXJjJzonXFx4RTInLCdBY2lyYyc6J1xceEMyJywnYWN1dGUnOidcXHhCNCcsJ2FjeSc6J1xcdTA0MzAnLCdBY3knOidcXHUwNDEwJywnYWVsaWcnOidcXHhFNicsJ0FFbGlnJzonXFx4QzYnLCdhZic6J1xcdTIwNjEnLCdhZnInOidcXHVEODM1XFx1REQxRScsJ0Fmcic6J1xcdUQ4MzVcXHVERDA0JywnYWdyYXZlJzonXFx4RTAnLCdBZ3JhdmUnOidcXHhDMCcsJ2FsZWZzeW0nOidcXHUyMTM1JywnYWxlcGgnOidcXHUyMTM1JywnYWxwaGEnOidcXHUwM0IxJywnQWxwaGEnOidcXHUwMzkxJywnYW1hY3InOidcXHUwMTAxJywnQW1hY3InOidcXHUwMTAwJywnYW1hbGcnOidcXHUyQTNGJywnYW1wJzonJicsJ0FNUCc6JyYnLCdhbmQnOidcXHUyMjI3JywnQW5kJzonXFx1MkE1MycsJ2FuZGFuZCc6J1xcdTJBNTUnLCdhbmRkJzonXFx1MkE1QycsJ2FuZHNsb3BlJzonXFx1MkE1OCcsJ2FuZHYnOidcXHUyQTVBJywnYW5nJzonXFx1MjIyMCcsJ2FuZ2UnOidcXHUyOUE0JywnYW5nbGUnOidcXHUyMjIwJywnYW5nbXNkJzonXFx1MjIyMScsJ2FuZ21zZGFhJzonXFx1MjlBOCcsJ2FuZ21zZGFiJzonXFx1MjlBOScsJ2FuZ21zZGFjJzonXFx1MjlBQScsJ2FuZ21zZGFkJzonXFx1MjlBQicsJ2FuZ21zZGFlJzonXFx1MjlBQycsJ2FuZ21zZGFmJzonXFx1MjlBRCcsJ2FuZ21zZGFnJzonXFx1MjlBRScsJ2FuZ21zZGFoJzonXFx1MjlBRicsJ2FuZ3J0JzonXFx1MjIxRicsJ2FuZ3J0dmInOidcXHUyMkJFJywnYW5ncnR2YmQnOidcXHUyOTlEJywnYW5nc3BoJzonXFx1MjIyMicsJ2FuZ3N0JzonXFx4QzUnLCdhbmd6YXJyJzonXFx1MjM3QycsJ2FvZ29uJzonXFx1MDEwNScsJ0FvZ29uJzonXFx1MDEwNCcsJ2FvcGYnOidcXHVEODM1XFx1REQ1MicsJ0FvcGYnOidcXHVEODM1XFx1REQzOCcsJ2FwJzonXFx1MjI0OCcsJ2FwYWNpcic6J1xcdTJBNkYnLCdhcGUnOidcXHUyMjRBJywnYXBFJzonXFx1MkE3MCcsJ2FwaWQnOidcXHUyMjRCJywnYXBvcyc6J1xcJycsJ0FwcGx5RnVuY3Rpb24nOidcXHUyMDYxJywnYXBwcm94JzonXFx1MjI0OCcsJ2FwcHJveGVxJzonXFx1MjI0QScsJ2FyaW5nJzonXFx4RTUnLCdBcmluZyc6J1xceEM1JywnYXNjcic6J1xcdUQ4MzVcXHVEQ0I2JywnQXNjcic6J1xcdUQ4MzVcXHVEQzlDJywnQXNzaWduJzonXFx1MjI1NCcsJ2FzdCc6JyonLCdhc3ltcCc6J1xcdTIyNDgnLCdhc3ltcGVxJzonXFx1MjI0RCcsJ2F0aWxkZSc6J1xceEUzJywnQXRpbGRlJzonXFx4QzMnLCdhdW1sJzonXFx4RTQnLCdBdW1sJzonXFx4QzQnLCdhd2NvbmludCc6J1xcdTIyMzMnLCdhd2ludCc6J1xcdTJBMTEnLCdiYWNrY29uZyc6J1xcdTIyNEMnLCdiYWNrZXBzaWxvbic6J1xcdTAzRjYnLCdiYWNrcHJpbWUnOidcXHUyMDM1JywnYmFja3NpbSc6J1xcdTIyM0QnLCdiYWNrc2ltZXEnOidcXHUyMkNEJywnQmFja3NsYXNoJzonXFx1MjIxNicsJ0JhcnYnOidcXHUyQUU3JywnYmFydmVlJzonXFx1MjJCRCcsJ2JhcndlZCc6J1xcdTIzMDUnLCdCYXJ3ZWQnOidcXHUyMzA2JywnYmFyd2VkZ2UnOidcXHUyMzA1JywnYmJyayc6J1xcdTIzQjUnLCdiYnJrdGJyayc6J1xcdTIzQjYnLCdiY29uZyc6J1xcdTIyNEMnLCdiY3knOidcXHUwNDMxJywnQmN5JzonXFx1MDQxMScsJ2JkcXVvJzonXFx1MjAxRScsJ2JlY2F1cyc6J1xcdTIyMzUnLCdiZWNhdXNlJzonXFx1MjIzNScsJ0JlY2F1c2UnOidcXHUyMjM1JywnYmVtcHR5dic6J1xcdTI5QjAnLCdiZXBzaSc6J1xcdTAzRjYnLCdiZXJub3UnOidcXHUyMTJDJywnQmVybm91bGxpcyc6J1xcdTIxMkMnLCdiZXRhJzonXFx1MDNCMicsJ0JldGEnOidcXHUwMzkyJywnYmV0aCc6J1xcdTIxMzYnLCdiZXR3ZWVuJzonXFx1MjI2QycsJ2Jmcic6J1xcdUQ4MzVcXHVERDFGJywnQmZyJzonXFx1RDgzNVxcdUREMDUnLCdiaWdjYXAnOidcXHUyMkMyJywnYmlnY2lyYyc6J1xcdTI1RUYnLCdiaWdjdXAnOidcXHUyMkMzJywnYmlnb2RvdCc6J1xcdTJBMDAnLCdiaWdvcGx1cyc6J1xcdTJBMDEnLCdiaWdvdGltZXMnOidcXHUyQTAyJywnYmlnc3FjdXAnOidcXHUyQTA2JywnYmlnc3Rhcic6J1xcdTI2MDUnLCdiaWd0cmlhbmdsZWRvd24nOidcXHUyNUJEJywnYmlndHJpYW5nbGV1cCc6J1xcdTI1QjMnLCdiaWd1cGx1cyc6J1xcdTJBMDQnLCdiaWd2ZWUnOidcXHUyMkMxJywnYmlnd2VkZ2UnOidcXHUyMkMwJywnYmthcm93JzonXFx1MjkwRCcsJ2JsYWNrbG96ZW5nZSc6J1xcdTI5RUInLCdibGFja3NxdWFyZSc6J1xcdTI1QUEnLCdibGFja3RyaWFuZ2xlJzonXFx1MjVCNCcsJ2JsYWNrdHJpYW5nbGVkb3duJzonXFx1MjVCRScsJ2JsYWNrdHJpYW5nbGVsZWZ0JzonXFx1MjVDMicsJ2JsYWNrdHJpYW5nbGVyaWdodCc6J1xcdTI1QjgnLCdibGFuayc6J1xcdTI0MjMnLCdibGsxMic6J1xcdTI1OTInLCdibGsxNCc6J1xcdTI1OTEnLCdibGszNCc6J1xcdTI1OTMnLCdibG9jayc6J1xcdTI1ODgnLCdibmUnOic9XFx1MjBFNScsJ2JuZXF1aXYnOidcXHUyMjYxXFx1MjBFNScsJ2Jub3QnOidcXHUyMzEwJywnYk5vdCc6J1xcdTJBRUQnLCdib3BmJzonXFx1RDgzNVxcdURENTMnLCdCb3BmJzonXFx1RDgzNVxcdUREMzknLCdib3QnOidcXHUyMkE1JywnYm90dG9tJzonXFx1MjJBNScsJ2Jvd3RpZSc6J1xcdTIyQzgnLCdib3hib3gnOidcXHUyOUM5JywnYm94ZGwnOidcXHUyNTEwJywnYm94ZEwnOidcXHUyNTU1JywnYm94RGwnOidcXHUyNTU2JywnYm94REwnOidcXHUyNTU3JywnYm94ZHInOidcXHUyNTBDJywnYm94ZFInOidcXHUyNTUyJywnYm94RHInOidcXHUyNTUzJywnYm94RFInOidcXHUyNTU0JywnYm94aCc6J1xcdTI1MDAnLCdib3hIJzonXFx1MjU1MCcsJ2JveGhkJzonXFx1MjUyQycsJ2JveGhEJzonXFx1MjU2NScsJ2JveEhkJzonXFx1MjU2NCcsJ2JveEhEJzonXFx1MjU2NicsJ2JveGh1JzonXFx1MjUzNCcsJ2JveGhVJzonXFx1MjU2OCcsJ2JveEh1JzonXFx1MjU2NycsJ2JveEhVJzonXFx1MjU2OScsJ2JveG1pbnVzJzonXFx1MjI5RicsJ2JveHBsdXMnOidcXHUyMjlFJywnYm94dGltZXMnOidcXHUyMkEwJywnYm94dWwnOidcXHUyNTE4JywnYm94dUwnOidcXHUyNTVCJywnYm94VWwnOidcXHUyNTVDJywnYm94VUwnOidcXHUyNTVEJywnYm94dXInOidcXHUyNTE0JywnYm94dVInOidcXHUyNTU4JywnYm94VXInOidcXHUyNTU5JywnYm94VVInOidcXHUyNTVBJywnYm94dic6J1xcdTI1MDInLCdib3hWJzonXFx1MjU1MScsJ2JveHZoJzonXFx1MjUzQycsJ2JveHZIJzonXFx1MjU2QScsJ2JveFZoJzonXFx1MjU2QicsJ2JveFZIJzonXFx1MjU2QycsJ2JveHZsJzonXFx1MjUyNCcsJ2JveHZMJzonXFx1MjU2MScsJ2JveFZsJzonXFx1MjU2MicsJ2JveFZMJzonXFx1MjU2MycsJ2JveHZyJzonXFx1MjUxQycsJ2JveHZSJzonXFx1MjU1RScsJ2JveFZyJzonXFx1MjU1RicsJ2JveFZSJzonXFx1MjU2MCcsJ2JwcmltZSc6J1xcdTIwMzUnLCdicmV2ZSc6J1xcdTAyRDgnLCdCcmV2ZSc6J1xcdTAyRDgnLCdicnZiYXInOidcXHhBNicsJ2JzY3InOidcXHVEODM1XFx1RENCNycsJ0JzY3InOidcXHUyMTJDJywnYnNlbWknOidcXHUyMDRGJywnYnNpbSc6J1xcdTIyM0QnLCdic2ltZSc6J1xcdTIyQ0QnLCdic29sJzonXFxcXCcsJ2Jzb2xiJzonXFx1MjlDNScsJ2Jzb2xoc3ViJzonXFx1MjdDOCcsJ2J1bGwnOidcXHUyMDIyJywnYnVsbGV0JzonXFx1MjAyMicsJ2J1bXAnOidcXHUyMjRFJywnYnVtcGUnOidcXHUyMjRGJywnYnVtcEUnOidcXHUyQUFFJywnYnVtcGVxJzonXFx1MjI0RicsJ0J1bXBlcSc6J1xcdTIyNEUnLCdjYWN1dGUnOidcXHUwMTA3JywnQ2FjdXRlJzonXFx1MDEwNicsJ2NhcCc6J1xcdTIyMjknLCdDYXAnOidcXHUyMkQyJywnY2FwYW5kJzonXFx1MkE0NCcsJ2NhcGJyY3VwJzonXFx1MkE0OScsJ2NhcGNhcCc6J1xcdTJBNEInLCdjYXBjdXAnOidcXHUyQTQ3JywnY2FwZG90JzonXFx1MkE0MCcsJ0NhcGl0YWxEaWZmZXJlbnRpYWxEJzonXFx1MjE0NScsJ2NhcHMnOidcXHUyMjI5XFx1RkUwMCcsJ2NhcmV0JzonXFx1MjA0MScsJ2Nhcm9uJzonXFx1MDJDNycsJ0NheWxleXMnOidcXHUyMTJEJywnY2NhcHMnOidcXHUyQTREJywnY2Nhcm9uJzonXFx1MDEwRCcsJ0NjYXJvbic6J1xcdTAxMEMnLCdjY2VkaWwnOidcXHhFNycsJ0NjZWRpbCc6J1xceEM3JywnY2NpcmMnOidcXHUwMTA5JywnQ2NpcmMnOidcXHUwMTA4JywnQ2NvbmludCc6J1xcdTIyMzAnLCdjY3Vwcyc6J1xcdTJBNEMnLCdjY3Vwc3NtJzonXFx1MkE1MCcsJ2Nkb3QnOidcXHUwMTBCJywnQ2RvdCc6J1xcdTAxMEEnLCdjZWRpbCc6J1xceEI4JywnQ2VkaWxsYSc6J1xceEI4JywnY2VtcHR5dic6J1xcdTI5QjInLCdjZW50JzonXFx4QTInLCdjZW50ZXJkb3QnOidcXHhCNycsJ0NlbnRlckRvdCc6J1xceEI3JywnY2ZyJzonXFx1RDgzNVxcdUREMjAnLCdDZnInOidcXHUyMTJEJywnY2hjeSc6J1xcdTA0NDcnLCdDSGN5JzonXFx1MDQyNycsJ2NoZWNrJzonXFx1MjcxMycsJ2NoZWNrbWFyayc6J1xcdTI3MTMnLCdjaGknOidcXHUwM0M3JywnQ2hpJzonXFx1MDNBNycsJ2Npcic6J1xcdTI1Q0InLCdjaXJjJzonXFx1MDJDNicsJ2NpcmNlcSc6J1xcdTIyNTcnLCdjaXJjbGVhcnJvd2xlZnQnOidcXHUyMUJBJywnY2lyY2xlYXJyb3dyaWdodCc6J1xcdTIxQkInLCdjaXJjbGVkYXN0JzonXFx1MjI5QicsJ2NpcmNsZWRjaXJjJzonXFx1MjI5QScsJ2NpcmNsZWRkYXNoJzonXFx1MjI5RCcsJ0NpcmNsZURvdCc6J1xcdTIyOTknLCdjaXJjbGVkUic6J1xceEFFJywnY2lyY2xlZFMnOidcXHUyNEM4JywnQ2lyY2xlTWludXMnOidcXHUyMjk2JywnQ2lyY2xlUGx1cyc6J1xcdTIyOTUnLCdDaXJjbGVUaW1lcyc6J1xcdTIyOTcnLCdjaXJlJzonXFx1MjI1NycsJ2NpckUnOidcXHUyOUMzJywnY2lyZm5pbnQnOidcXHUyQTEwJywnY2lybWlkJzonXFx1MkFFRicsJ2NpcnNjaXInOidcXHUyOUMyJywnQ2xvY2t3aXNlQ29udG91ckludGVncmFsJzonXFx1MjIzMicsJ0Nsb3NlQ3VybHlEb3VibGVRdW90ZSc6J1xcdTIwMUQnLCdDbG9zZUN1cmx5UXVvdGUnOidcXHUyMDE5JywnY2x1YnMnOidcXHUyNjYzJywnY2x1YnN1aXQnOidcXHUyNjYzJywnY29sb24nOic6JywnQ29sb24nOidcXHUyMjM3JywnY29sb25lJzonXFx1MjI1NCcsJ0NvbG9uZSc6J1xcdTJBNzQnLCdjb2xvbmVxJzonXFx1MjI1NCcsJ2NvbW1hJzonLCcsJ2NvbW1hdCc6J0AnLCdjb21wJzonXFx1MjIwMScsJ2NvbXBmbic6J1xcdTIyMTgnLCdjb21wbGVtZW50JzonXFx1MjIwMScsJ2NvbXBsZXhlcyc6J1xcdTIxMDInLCdjb25nJzonXFx1MjI0NScsJ2Nvbmdkb3QnOidcXHUyQTZEJywnQ29uZ3J1ZW50JzonXFx1MjI2MScsJ2NvbmludCc6J1xcdTIyMkUnLCdDb25pbnQnOidcXHUyMjJGJywnQ29udG91ckludGVncmFsJzonXFx1MjIyRScsJ2NvcGYnOidcXHVEODM1XFx1REQ1NCcsJ0NvcGYnOidcXHUyMTAyJywnY29wcm9kJzonXFx1MjIxMCcsJ0NvcHJvZHVjdCc6J1xcdTIyMTAnLCdjb3B5JzonXFx4QTknLCdDT1BZJzonXFx4QTknLCdjb3B5c3InOidcXHUyMTE3JywnQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCc6J1xcdTIyMzMnLCdjcmFycic6J1xcdTIxQjUnLCdjcm9zcyc6J1xcdTI3MTcnLCdDcm9zcyc6J1xcdTJBMkYnLCdjc2NyJzonXFx1RDgzNVxcdURDQjgnLCdDc2NyJzonXFx1RDgzNVxcdURDOUUnLCdjc3ViJzonXFx1MkFDRicsJ2NzdWJlJzonXFx1MkFEMScsJ2NzdXAnOidcXHUyQUQwJywnY3N1cGUnOidcXHUyQUQyJywnY3Rkb3QnOidcXHUyMkVGJywnY3VkYXJybCc6J1xcdTI5MzgnLCdjdWRhcnJyJzonXFx1MjkzNScsJ2N1ZXByJzonXFx1MjJERScsJ2N1ZXNjJzonXFx1MjJERicsJ2N1bGFycic6J1xcdTIxQjYnLCdjdWxhcnJwJzonXFx1MjkzRCcsJ2N1cCc6J1xcdTIyMkEnLCdDdXAnOidcXHUyMkQzJywnY3VwYnJjYXAnOidcXHUyQTQ4JywnY3VwY2FwJzonXFx1MkE0NicsJ0N1cENhcCc6J1xcdTIyNEQnLCdjdXBjdXAnOidcXHUyQTRBJywnY3VwZG90JzonXFx1MjI4RCcsJ2N1cG9yJzonXFx1MkE0NScsJ2N1cHMnOidcXHUyMjJBXFx1RkUwMCcsJ2N1cmFycic6J1xcdTIxQjcnLCdjdXJhcnJtJzonXFx1MjkzQycsJ2N1cmx5ZXFwcmVjJzonXFx1MjJERScsJ2N1cmx5ZXFzdWNjJzonXFx1MjJERicsJ2N1cmx5dmVlJzonXFx1MjJDRScsJ2N1cmx5d2VkZ2UnOidcXHUyMkNGJywnY3VycmVuJzonXFx4QTQnLCdjdXJ2ZWFycm93bGVmdCc6J1xcdTIxQjYnLCdjdXJ2ZWFycm93cmlnaHQnOidcXHUyMUI3JywnY3V2ZWUnOidcXHUyMkNFJywnY3V3ZWQnOidcXHUyMkNGJywnY3djb25pbnQnOidcXHUyMjMyJywnY3dpbnQnOidcXHUyMjMxJywnY3lsY3R5JzonXFx1MjMyRCcsJ2RhZ2dlcic6J1xcdTIwMjAnLCdEYWdnZXInOidcXHUyMDIxJywnZGFsZXRoJzonXFx1MjEzOCcsJ2RhcnInOidcXHUyMTkzJywnZEFycic6J1xcdTIxRDMnLCdEYXJyJzonXFx1MjFBMScsJ2Rhc2gnOidcXHUyMDEwJywnZGFzaHYnOidcXHUyMkEzJywnRGFzaHYnOidcXHUyQUU0JywnZGJrYXJvdyc6J1xcdTI5MEYnLCdkYmxhYyc6J1xcdTAyREQnLCdkY2Fyb24nOidcXHUwMTBGJywnRGNhcm9uJzonXFx1MDEwRScsJ2RjeSc6J1xcdTA0MzQnLCdEY3knOidcXHUwNDE0JywnZGQnOidcXHUyMTQ2JywnREQnOidcXHUyMTQ1JywnZGRhZ2dlcic6J1xcdTIwMjEnLCdkZGFycic6J1xcdTIxQ0EnLCdERG90cmFoZCc6J1xcdTI5MTEnLCdkZG90c2VxJzonXFx1MkE3NycsJ2RlZyc6J1xceEIwJywnRGVsJzonXFx1MjIwNycsJ2RlbHRhJzonXFx1MDNCNCcsJ0RlbHRhJzonXFx1MDM5NCcsJ2RlbXB0eXYnOidcXHUyOUIxJywnZGZpc2h0JzonXFx1Mjk3RicsJ2Rmcic6J1xcdUQ4MzVcXHVERDIxJywnRGZyJzonXFx1RDgzNVxcdUREMDcnLCdkSGFyJzonXFx1Mjk2NScsJ2RoYXJsJzonXFx1MjFDMycsJ2RoYXJyJzonXFx1MjFDMicsJ0RpYWNyaXRpY2FsQWN1dGUnOidcXHhCNCcsJ0RpYWNyaXRpY2FsRG90JzonXFx1MDJEOScsJ0RpYWNyaXRpY2FsRG91YmxlQWN1dGUnOidcXHUwMkREJywnRGlhY3JpdGljYWxHcmF2ZSc6J2AnLCdEaWFjcml0aWNhbFRpbGRlJzonXFx1MDJEQycsJ2RpYW0nOidcXHUyMkM0JywnZGlhbW9uZCc6J1xcdTIyQzQnLCdEaWFtb25kJzonXFx1MjJDNCcsJ2RpYW1vbmRzdWl0JzonXFx1MjY2NicsJ2RpYW1zJzonXFx1MjY2NicsJ2RpZSc6J1xceEE4JywnRGlmZmVyZW50aWFsRCc6J1xcdTIxNDYnLCdkaWdhbW1hJzonXFx1MDNERCcsJ2Rpc2luJzonXFx1MjJGMicsJ2Rpdic6J1xceEY3JywnZGl2aWRlJzonXFx4RjcnLCdkaXZpZGVvbnRpbWVzJzonXFx1MjJDNycsJ2Rpdm9ueCc6J1xcdTIyQzcnLCdkamN5JzonXFx1MDQ1MicsJ0RKY3knOidcXHUwNDAyJywnZGxjb3JuJzonXFx1MjMxRScsJ2RsY3JvcCc6J1xcdTIzMEQnLCdkb2xsYXInOickJywnZG9wZic6J1xcdUQ4MzVcXHVERDU1JywnRG9wZic6J1xcdUQ4MzVcXHVERDNCJywnZG90JzonXFx1MDJEOScsJ0RvdCc6J1xceEE4JywnRG90RG90JzonXFx1MjBEQycsJ2RvdGVxJzonXFx1MjI1MCcsJ2RvdGVxZG90JzonXFx1MjI1MScsJ0RvdEVxdWFsJzonXFx1MjI1MCcsJ2RvdG1pbnVzJzonXFx1MjIzOCcsJ2RvdHBsdXMnOidcXHUyMjE0JywnZG90c3F1YXJlJzonXFx1MjJBMScsJ2RvdWJsZWJhcndlZGdlJzonXFx1MjMwNicsJ0RvdWJsZUNvbnRvdXJJbnRlZ3JhbCc6J1xcdTIyMkYnLCdEb3VibGVEb3QnOidcXHhBOCcsJ0RvdWJsZURvd25BcnJvdyc6J1xcdTIxRDMnLCdEb3VibGVMZWZ0QXJyb3cnOidcXHUyMUQwJywnRG91YmxlTGVmdFJpZ2h0QXJyb3cnOidcXHUyMUQ0JywnRG91YmxlTGVmdFRlZSc6J1xcdTJBRTQnLCdEb3VibGVMb25nTGVmdEFycm93JzonXFx1MjdGOCcsJ0RvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdyc6J1xcdTI3RkEnLCdEb3VibGVMb25nUmlnaHRBcnJvdyc6J1xcdTI3RjknLCdEb3VibGVSaWdodEFycm93JzonXFx1MjFEMicsJ0RvdWJsZVJpZ2h0VGVlJzonXFx1MjJBOCcsJ0RvdWJsZVVwQXJyb3cnOidcXHUyMUQxJywnRG91YmxlVXBEb3duQXJyb3cnOidcXHUyMUQ1JywnRG91YmxlVmVydGljYWxCYXInOidcXHUyMjI1JywnZG93bmFycm93JzonXFx1MjE5MycsJ0Rvd25hcnJvdyc6J1xcdTIxRDMnLCdEb3duQXJyb3cnOidcXHUyMTkzJywnRG93bkFycm93QmFyJzonXFx1MjkxMycsJ0Rvd25BcnJvd1VwQXJyb3cnOidcXHUyMUY1JywnRG93bkJyZXZlJzonXFx1MDMxMScsJ2Rvd25kb3duYXJyb3dzJzonXFx1MjFDQScsJ2Rvd25oYXJwb29ubGVmdCc6J1xcdTIxQzMnLCdkb3duaGFycG9vbnJpZ2h0JzonXFx1MjFDMicsJ0Rvd25MZWZ0UmlnaHRWZWN0b3InOidcXHUyOTUwJywnRG93bkxlZnRUZWVWZWN0b3InOidcXHUyOTVFJywnRG93bkxlZnRWZWN0b3InOidcXHUyMUJEJywnRG93bkxlZnRWZWN0b3JCYXInOidcXHUyOTU2JywnRG93blJpZ2h0VGVlVmVjdG9yJzonXFx1Mjk1RicsJ0Rvd25SaWdodFZlY3Rvcic6J1xcdTIxQzEnLCdEb3duUmlnaHRWZWN0b3JCYXInOidcXHUyOTU3JywnRG93blRlZSc6J1xcdTIyQTQnLCdEb3duVGVlQXJyb3cnOidcXHUyMUE3JywnZHJia2Fyb3cnOidcXHUyOTEwJywnZHJjb3JuJzonXFx1MjMxRicsJ2RyY3JvcCc6J1xcdTIzMEMnLCdkc2NyJzonXFx1RDgzNVxcdURDQjknLCdEc2NyJzonXFx1RDgzNVxcdURDOUYnLCdkc2N5JzonXFx1MDQ1NScsJ0RTY3knOidcXHUwNDA1JywnZHNvbCc6J1xcdTI5RjYnLCdkc3Ryb2snOidcXHUwMTExJywnRHN0cm9rJzonXFx1MDExMCcsJ2R0ZG90JzonXFx1MjJGMScsJ2R0cmknOidcXHUyNUJGJywnZHRyaWYnOidcXHUyNUJFJywnZHVhcnInOidcXHUyMUY1JywnZHVoYXInOidcXHUyOTZGJywnZHdhbmdsZSc6J1xcdTI5QTYnLCdkemN5JzonXFx1MDQ1RicsJ0RaY3knOidcXHUwNDBGJywnZHppZ3JhcnInOidcXHUyN0ZGJywnZWFjdXRlJzonXFx4RTknLCdFYWN1dGUnOidcXHhDOScsJ2Vhc3Rlcic6J1xcdTJBNkUnLCdlY2Fyb24nOidcXHUwMTFCJywnRWNhcm9uJzonXFx1MDExQScsJ2VjaXInOidcXHUyMjU2JywnZWNpcmMnOidcXHhFQScsJ0VjaXJjJzonXFx4Q0EnLCdlY29sb24nOidcXHUyMjU1JywnZWN5JzonXFx1MDQ0RCcsJ0VjeSc6J1xcdTA0MkQnLCdlRERvdCc6J1xcdTJBNzcnLCdlZG90JzonXFx1MDExNycsJ2VEb3QnOidcXHUyMjUxJywnRWRvdCc6J1xcdTAxMTYnLCdlZSc6J1xcdTIxNDcnLCdlZkRvdCc6J1xcdTIyNTInLCdlZnInOidcXHVEODM1XFx1REQyMicsJ0Vmcic6J1xcdUQ4MzVcXHVERDA4JywnZWcnOidcXHUyQTlBJywnZWdyYXZlJzonXFx4RTgnLCdFZ3JhdmUnOidcXHhDOCcsJ2Vncyc6J1xcdTJBOTYnLCdlZ3Nkb3QnOidcXHUyQTk4JywnZWwnOidcXHUyQTk5JywnRWxlbWVudCc6J1xcdTIyMDgnLCdlbGludGVycyc6J1xcdTIzRTcnLCdlbGwnOidcXHUyMTEzJywnZWxzJzonXFx1MkE5NScsJ2Vsc2RvdCc6J1xcdTJBOTcnLCdlbWFjcic6J1xcdTAxMTMnLCdFbWFjcic6J1xcdTAxMTInLCdlbXB0eSc6J1xcdTIyMDUnLCdlbXB0eXNldCc6J1xcdTIyMDUnLCdFbXB0eVNtYWxsU3F1YXJlJzonXFx1MjVGQicsJ2VtcHR5dic6J1xcdTIyMDUnLCdFbXB0eVZlcnlTbWFsbFNxdWFyZSc6J1xcdTI1QUInLCdlbXNwJzonXFx1MjAwMycsJ2Vtc3AxMyc6J1xcdTIwMDQnLCdlbXNwMTQnOidcXHUyMDA1JywnZW5nJzonXFx1MDE0QicsJ0VORyc6J1xcdTAxNEEnLCdlbnNwJzonXFx1MjAwMicsJ2VvZ29uJzonXFx1MDExOScsJ0VvZ29uJzonXFx1MDExOCcsJ2VvcGYnOidcXHVEODM1XFx1REQ1NicsJ0VvcGYnOidcXHVEODM1XFx1REQzQycsJ2VwYXInOidcXHUyMkQ1JywnZXBhcnNsJzonXFx1MjlFMycsJ2VwbHVzJzonXFx1MkE3MScsJ2Vwc2knOidcXHUwM0I1JywnZXBzaWxvbic6J1xcdTAzQjUnLCdFcHNpbG9uJzonXFx1MDM5NScsJ2Vwc2l2JzonXFx1MDNGNScsJ2VxY2lyYyc6J1xcdTIyNTYnLCdlcWNvbG9uJzonXFx1MjI1NScsJ2Vxc2ltJzonXFx1MjI0MicsJ2Vxc2xhbnRndHInOidcXHUyQTk2JywnZXFzbGFudGxlc3MnOidcXHUyQTk1JywnRXF1YWwnOidcXHUyQTc1JywnZXF1YWxzJzonPScsJ0VxdWFsVGlsZGUnOidcXHUyMjQyJywnZXF1ZXN0JzonXFx1MjI1RicsJ0VxdWlsaWJyaXVtJzonXFx1MjFDQycsJ2VxdWl2JzonXFx1MjI2MScsJ2VxdWl2REQnOidcXHUyQTc4JywnZXF2cGFyc2wnOidcXHUyOUU1JywnZXJhcnInOidcXHUyOTcxJywnZXJEb3QnOidcXHUyMjUzJywnZXNjcic6J1xcdTIxMkYnLCdFc2NyJzonXFx1MjEzMCcsJ2VzZG90JzonXFx1MjI1MCcsJ2VzaW0nOidcXHUyMjQyJywnRXNpbSc6J1xcdTJBNzMnLCdldGEnOidcXHUwM0I3JywnRXRhJzonXFx1MDM5NycsJ2V0aCc6J1xceEYwJywnRVRIJzonXFx4RDAnLCdldW1sJzonXFx4RUInLCdFdW1sJzonXFx4Q0InLCdldXJvJzonXFx1MjBBQycsJ2V4Y2wnOichJywnZXhpc3QnOidcXHUyMjAzJywnRXhpc3RzJzonXFx1MjIwMycsJ2V4cGVjdGF0aW9uJzonXFx1MjEzMCcsJ2V4cG9uZW50aWFsZSc6J1xcdTIxNDcnLCdFeHBvbmVudGlhbEUnOidcXHUyMTQ3JywnZmFsbGluZ2RvdHNlcSc6J1xcdTIyNTInLCdmY3knOidcXHUwNDQ0JywnRmN5JzonXFx1MDQyNCcsJ2ZlbWFsZSc6J1xcdTI2NDAnLCdmZmlsaWcnOidcXHVGQjAzJywnZmZsaWcnOidcXHVGQjAwJywnZmZsbGlnJzonXFx1RkIwNCcsJ2Zmcic6J1xcdUQ4MzVcXHVERDIzJywnRmZyJzonXFx1RDgzNVxcdUREMDknLCdmaWxpZyc6J1xcdUZCMDEnLCdGaWxsZWRTbWFsbFNxdWFyZSc6J1xcdTI1RkMnLCdGaWxsZWRWZXJ5U21hbGxTcXVhcmUnOidcXHUyNUFBJywnZmpsaWcnOidmaicsJ2ZsYXQnOidcXHUyNjZEJywnZmxsaWcnOidcXHVGQjAyJywnZmx0bnMnOidcXHUyNUIxJywnZm5vZic6J1xcdTAxOTInLCdmb3BmJzonXFx1RDgzNVxcdURENTcnLCdGb3BmJzonXFx1RDgzNVxcdUREM0QnLCdmb3JhbGwnOidcXHUyMjAwJywnRm9yQWxsJzonXFx1MjIwMCcsJ2ZvcmsnOidcXHUyMkQ0JywnZm9ya3YnOidcXHUyQUQ5JywnRm91cmllcnRyZic6J1xcdTIxMzEnLCdmcGFydGludCc6J1xcdTJBMEQnLCdmcmFjMTInOidcXHhCRCcsJ2ZyYWMxMyc6J1xcdTIxNTMnLCdmcmFjMTQnOidcXHhCQycsJ2ZyYWMxNSc6J1xcdTIxNTUnLCdmcmFjMTYnOidcXHUyMTU5JywnZnJhYzE4JzonXFx1MjE1QicsJ2ZyYWMyMyc6J1xcdTIxNTQnLCdmcmFjMjUnOidcXHUyMTU2JywnZnJhYzM0JzonXFx4QkUnLCdmcmFjMzUnOidcXHUyMTU3JywnZnJhYzM4JzonXFx1MjE1QycsJ2ZyYWM0NSc6J1xcdTIxNTgnLCdmcmFjNTYnOidcXHUyMTVBJywnZnJhYzU4JzonXFx1MjE1RCcsJ2ZyYWM3OCc6J1xcdTIxNUUnLCdmcmFzbCc6J1xcdTIwNDQnLCdmcm93bic6J1xcdTIzMjInLCdmc2NyJzonXFx1RDgzNVxcdURDQkInLCdGc2NyJzonXFx1MjEzMScsJ2dhY3V0ZSc6J1xcdTAxRjUnLCdnYW1tYSc6J1xcdTAzQjMnLCdHYW1tYSc6J1xcdTAzOTMnLCdnYW1tYWQnOidcXHUwM0REJywnR2FtbWFkJzonXFx1MDNEQycsJ2dhcCc6J1xcdTJBODYnLCdnYnJldmUnOidcXHUwMTFGJywnR2JyZXZlJzonXFx1MDExRScsJ0djZWRpbCc6J1xcdTAxMjInLCdnY2lyYyc6J1xcdTAxMUQnLCdHY2lyYyc6J1xcdTAxMUMnLCdnY3knOidcXHUwNDMzJywnR2N5JzonXFx1MDQxMycsJ2dkb3QnOidcXHUwMTIxJywnR2RvdCc6J1xcdTAxMjAnLCdnZSc6J1xcdTIyNjUnLCdnRSc6J1xcdTIyNjcnLCdnZWwnOidcXHUyMkRCJywnZ0VsJzonXFx1MkE4QycsJ2dlcSc6J1xcdTIyNjUnLCdnZXFxJzonXFx1MjI2NycsJ2dlcXNsYW50JzonXFx1MkE3RScsJ2dlcyc6J1xcdTJBN0UnLCdnZXNjYyc6J1xcdTJBQTknLCdnZXNkb3QnOidcXHUyQTgwJywnZ2VzZG90byc6J1xcdTJBODInLCdnZXNkb3RvbCc6J1xcdTJBODQnLCdnZXNsJzonXFx1MjJEQlxcdUZFMDAnLCdnZXNsZXMnOidcXHUyQTk0JywnZ2ZyJzonXFx1RDgzNVxcdUREMjQnLCdHZnInOidcXHVEODM1XFx1REQwQScsJ2dnJzonXFx1MjI2QicsJ0dnJzonXFx1MjJEOScsJ2dnZyc6J1xcdTIyRDknLCdnaW1lbCc6J1xcdTIxMzcnLCdnamN5JzonXFx1MDQ1MycsJ0dKY3knOidcXHUwNDAzJywnZ2wnOidcXHUyMjc3JywnZ2xhJzonXFx1MkFBNScsJ2dsRSc6J1xcdTJBOTInLCdnbGonOidcXHUyQUE0JywnZ25hcCc6J1xcdTJBOEEnLCdnbmFwcHJveCc6J1xcdTJBOEEnLCdnbmUnOidcXHUyQTg4JywnZ25FJzonXFx1MjI2OScsJ2duZXEnOidcXHUyQTg4JywnZ25lcXEnOidcXHUyMjY5JywnZ25zaW0nOidcXHUyMkU3JywnZ29wZic6J1xcdUQ4MzVcXHVERDU4JywnR29wZic6J1xcdUQ4MzVcXHVERDNFJywnZ3JhdmUnOidgJywnR3JlYXRlckVxdWFsJzonXFx1MjI2NScsJ0dyZWF0ZXJFcXVhbExlc3MnOidcXHUyMkRCJywnR3JlYXRlckZ1bGxFcXVhbCc6J1xcdTIyNjcnLCdHcmVhdGVyR3JlYXRlcic6J1xcdTJBQTInLCdHcmVhdGVyTGVzcyc6J1xcdTIyNzcnLCdHcmVhdGVyU2xhbnRFcXVhbCc6J1xcdTJBN0UnLCdHcmVhdGVyVGlsZGUnOidcXHUyMjczJywnZ3Njcic6J1xcdTIxMEEnLCdHc2NyJzonXFx1RDgzNVxcdURDQTInLCdnc2ltJzonXFx1MjI3MycsJ2dzaW1lJzonXFx1MkE4RScsJ2dzaW1sJzonXFx1MkE5MCcsJ2d0JzonPicsJ0d0JzonXFx1MjI2QicsJ0dUJzonPicsJ2d0Y2MnOidcXHUyQUE3JywnZ3RjaXInOidcXHUyQTdBJywnZ3Rkb3QnOidcXHUyMkQ3JywnZ3RsUGFyJzonXFx1Mjk5NScsJ2d0cXVlc3QnOidcXHUyQTdDJywnZ3RyYXBwcm94JzonXFx1MkE4NicsJ2d0cmFycic6J1xcdTI5NzgnLCdndHJkb3QnOidcXHUyMkQ3JywnZ3RyZXFsZXNzJzonXFx1MjJEQicsJ2d0cmVxcWxlc3MnOidcXHUyQThDJywnZ3RybGVzcyc6J1xcdTIyNzcnLCdndHJzaW0nOidcXHUyMjczJywnZ3ZlcnRuZXFxJzonXFx1MjI2OVxcdUZFMDAnLCdndm5FJzonXFx1MjI2OVxcdUZFMDAnLCdIYWNlayc6J1xcdTAyQzcnLCdoYWlyc3AnOidcXHUyMDBBJywnaGFsZic6J1xceEJEJywnaGFtaWx0JzonXFx1MjEwQicsJ2hhcmRjeSc6J1xcdTA0NEEnLCdIQVJEY3knOidcXHUwNDJBJywnaGFycic6J1xcdTIxOTQnLCdoQXJyJzonXFx1MjFENCcsJ2hhcnJjaXInOidcXHUyOTQ4JywnaGFycncnOidcXHUyMUFEJywnSGF0JzonXicsJ2hiYXInOidcXHUyMTBGJywnaGNpcmMnOidcXHUwMTI1JywnSGNpcmMnOidcXHUwMTI0JywnaGVhcnRzJzonXFx1MjY2NScsJ2hlYXJ0c3VpdCc6J1xcdTI2NjUnLCdoZWxsaXAnOidcXHUyMDI2JywnaGVyY29uJzonXFx1MjJCOScsJ2hmcic6J1xcdUQ4MzVcXHVERDI1JywnSGZyJzonXFx1MjEwQycsJ0hpbGJlcnRTcGFjZSc6J1xcdTIxMEInLCdoa3NlYXJvdyc6J1xcdTI5MjUnLCdoa3N3YXJvdyc6J1xcdTI5MjYnLCdob2Fycic6J1xcdTIxRkYnLCdob210aHQnOidcXHUyMjNCJywnaG9va2xlZnRhcnJvdyc6J1xcdTIxQTknLCdob29rcmlnaHRhcnJvdyc6J1xcdTIxQUEnLCdob3BmJzonXFx1RDgzNVxcdURENTknLCdIb3BmJzonXFx1MjEwRCcsJ2hvcmJhcic6J1xcdTIwMTUnLCdIb3Jpem9udGFsTGluZSc6J1xcdTI1MDAnLCdoc2NyJzonXFx1RDgzNVxcdURDQkQnLCdIc2NyJzonXFx1MjEwQicsJ2hzbGFzaCc6J1xcdTIxMEYnLCdoc3Ryb2snOidcXHUwMTI3JywnSHN0cm9rJzonXFx1MDEyNicsJ0h1bXBEb3duSHVtcCc6J1xcdTIyNEUnLCdIdW1wRXF1YWwnOidcXHUyMjRGJywnaHlidWxsJzonXFx1MjA0MycsJ2h5cGhlbic6J1xcdTIwMTAnLCdpYWN1dGUnOidcXHhFRCcsJ0lhY3V0ZSc6J1xceENEJywnaWMnOidcXHUyMDYzJywnaWNpcmMnOidcXHhFRScsJ0ljaXJjJzonXFx4Q0UnLCdpY3knOidcXHUwNDM4JywnSWN5JzonXFx1MDQxOCcsJ0lkb3QnOidcXHUwMTMwJywnaWVjeSc6J1xcdTA0MzUnLCdJRWN5JzonXFx1MDQxNScsJ2lleGNsJzonXFx4QTEnLCdpZmYnOidcXHUyMUQ0JywnaWZyJzonXFx1RDgzNVxcdUREMjYnLCdJZnInOidcXHUyMTExJywnaWdyYXZlJzonXFx4RUMnLCdJZ3JhdmUnOidcXHhDQycsJ2lpJzonXFx1MjE0OCcsJ2lpaWludCc6J1xcdTJBMEMnLCdpaWludCc6J1xcdTIyMkQnLCdpaW5maW4nOidcXHUyOURDJywnaWlvdGEnOidcXHUyMTI5JywnaWpsaWcnOidcXHUwMTMzJywnSUpsaWcnOidcXHUwMTMyJywnSW0nOidcXHUyMTExJywnaW1hY3InOidcXHUwMTJCJywnSW1hY3InOidcXHUwMTJBJywnaW1hZ2UnOidcXHUyMTExJywnSW1hZ2luYXJ5SSc6J1xcdTIxNDgnLCdpbWFnbGluZSc6J1xcdTIxMTAnLCdpbWFncGFydCc6J1xcdTIxMTEnLCdpbWF0aCc6J1xcdTAxMzEnLCdpbW9mJzonXFx1MjJCNycsJ2ltcGVkJzonXFx1MDFCNScsJ0ltcGxpZXMnOidcXHUyMUQyJywnaW4nOidcXHUyMjA4JywnaW5jYXJlJzonXFx1MjEwNScsJ2luZmluJzonXFx1MjIxRScsJ2luZmludGllJzonXFx1MjlERCcsJ2lub2RvdCc6J1xcdTAxMzEnLCdpbnQnOidcXHUyMjJCJywnSW50JzonXFx1MjIyQycsJ2ludGNhbCc6J1xcdTIyQkEnLCdpbnRlZ2Vycyc6J1xcdTIxMjQnLCdJbnRlZ3JhbCc6J1xcdTIyMkInLCdpbnRlcmNhbCc6J1xcdTIyQkEnLCdJbnRlcnNlY3Rpb24nOidcXHUyMkMyJywnaW50bGFyaGsnOidcXHUyQTE3JywnaW50cHJvZCc6J1xcdTJBM0MnLCdJbnZpc2libGVDb21tYSc6J1xcdTIwNjMnLCdJbnZpc2libGVUaW1lcyc6J1xcdTIwNjInLCdpb2N5JzonXFx1MDQ1MScsJ0lPY3knOidcXHUwNDAxJywnaW9nb24nOidcXHUwMTJGJywnSW9nb24nOidcXHUwMTJFJywnaW9wZic6J1xcdUQ4MzVcXHVERDVBJywnSW9wZic6J1xcdUQ4MzVcXHVERDQwJywnaW90YSc6J1xcdTAzQjknLCdJb3RhJzonXFx1MDM5OScsJ2lwcm9kJzonXFx1MkEzQycsJ2lxdWVzdCc6J1xceEJGJywnaXNjcic6J1xcdUQ4MzVcXHVEQ0JFJywnSXNjcic6J1xcdTIxMTAnLCdpc2luJzonXFx1MjIwOCcsJ2lzaW5kb3QnOidcXHUyMkY1JywnaXNpbkUnOidcXHUyMkY5JywnaXNpbnMnOidcXHUyMkY0JywnaXNpbnN2JzonXFx1MjJGMycsJ2lzaW52JzonXFx1MjIwOCcsJ2l0JzonXFx1MjA2MicsJ2l0aWxkZSc6J1xcdTAxMjknLCdJdGlsZGUnOidcXHUwMTI4JywnaXVrY3knOidcXHUwNDU2JywnSXVrY3knOidcXHUwNDA2JywnaXVtbCc6J1xceEVGJywnSXVtbCc6J1xceENGJywnamNpcmMnOidcXHUwMTM1JywnSmNpcmMnOidcXHUwMTM0JywnamN5JzonXFx1MDQzOScsJ0pjeSc6J1xcdTA0MTknLCdqZnInOidcXHVEODM1XFx1REQyNycsJ0pmcic6J1xcdUQ4MzVcXHVERDBEJywnam1hdGgnOidcXHUwMjM3Jywnam9wZic6J1xcdUQ4MzVcXHVERDVCJywnSm9wZic6J1xcdUQ4MzVcXHVERDQxJywnanNjcic6J1xcdUQ4MzVcXHVEQ0JGJywnSnNjcic6J1xcdUQ4MzVcXHVEQ0E1JywnanNlcmN5JzonXFx1MDQ1OCcsJ0pzZXJjeSc6J1xcdTA0MDgnLCdqdWtjeSc6J1xcdTA0NTQnLCdKdWtjeSc6J1xcdTA0MDQnLCdrYXBwYSc6J1xcdTAzQkEnLCdLYXBwYSc6J1xcdTAzOUEnLCdrYXBwYXYnOidcXHUwM0YwJywna2NlZGlsJzonXFx1MDEzNycsJ0tjZWRpbCc6J1xcdTAxMzYnLCdrY3knOidcXHUwNDNBJywnS2N5JzonXFx1MDQxQScsJ2tmcic6J1xcdUQ4MzVcXHVERDI4JywnS2ZyJzonXFx1RDgzNVxcdUREMEUnLCdrZ3JlZW4nOidcXHUwMTM4Jywna2hjeSc6J1xcdTA0NDUnLCdLSGN5JzonXFx1MDQyNScsJ2tqY3knOidcXHUwNDVDJywnS0pjeSc6J1xcdTA0MEMnLCdrb3BmJzonXFx1RDgzNVxcdURENUMnLCdLb3BmJzonXFx1RDgzNVxcdURENDInLCdrc2NyJzonXFx1RDgzNVxcdURDQzAnLCdLc2NyJzonXFx1RDgzNVxcdURDQTYnLCdsQWFycic6J1xcdTIxREEnLCdsYWN1dGUnOidcXHUwMTNBJywnTGFjdXRlJzonXFx1MDEzOScsJ2xhZW1wdHl2JzonXFx1MjlCNCcsJ2xhZ3Jhbic6J1xcdTIxMTInLCdsYW1iZGEnOidcXHUwM0JCJywnTGFtYmRhJzonXFx1MDM5QicsJ2xhbmcnOidcXHUyN0U4JywnTGFuZyc6J1xcdTI3RUEnLCdsYW5nZCc6J1xcdTI5OTEnLCdsYW5nbGUnOidcXHUyN0U4JywnbGFwJzonXFx1MkE4NScsJ0xhcGxhY2V0cmYnOidcXHUyMTEyJywnbGFxdW8nOidcXHhBQicsJ2xhcnInOidcXHUyMTkwJywnbEFycic6J1xcdTIxRDAnLCdMYXJyJzonXFx1MjE5RScsJ2xhcnJiJzonXFx1MjFFNCcsJ2xhcnJiZnMnOidcXHUyOTFGJywnbGFycmZzJzonXFx1MjkxRCcsJ2xhcnJoayc6J1xcdTIxQTknLCdsYXJybHAnOidcXHUyMUFCJywnbGFycnBsJzonXFx1MjkzOScsJ2xhcnJzaW0nOidcXHUyOTczJywnbGFycnRsJzonXFx1MjFBMicsJ2xhdCc6J1xcdTJBQUInLCdsYXRhaWwnOidcXHUyOTE5JywnbEF0YWlsJzonXFx1MjkxQicsJ2xhdGUnOidcXHUyQUFEJywnbGF0ZXMnOidcXHUyQUFEXFx1RkUwMCcsJ2xiYXJyJzonXFx1MjkwQycsJ2xCYXJyJzonXFx1MjkwRScsJ2xiYnJrJzonXFx1Mjc3MicsJ2xicmFjZSc6J3snLCdsYnJhY2snOidbJywnbGJya2UnOidcXHUyOThCJywnbGJya3NsZCc6J1xcdTI5OEYnLCdsYnJrc2x1JzonXFx1Mjk4RCcsJ2xjYXJvbic6J1xcdTAxM0UnLCdMY2Fyb24nOidcXHUwMTNEJywnbGNlZGlsJzonXFx1MDEzQycsJ0xjZWRpbCc6J1xcdTAxM0InLCdsY2VpbCc6J1xcdTIzMDgnLCdsY3ViJzoneycsJ2xjeSc6J1xcdTA0M0InLCdMY3knOidcXHUwNDFCJywnbGRjYSc6J1xcdTI5MzYnLCdsZHF1byc6J1xcdTIwMUMnLCdsZHF1b3InOidcXHUyMDFFJywnbGRyZGhhcic6J1xcdTI5NjcnLCdsZHJ1c2hhcic6J1xcdTI5NEInLCdsZHNoJzonXFx1MjFCMicsJ2xlJzonXFx1MjI2NCcsJ2xFJzonXFx1MjI2NicsJ0xlZnRBbmdsZUJyYWNrZXQnOidcXHUyN0U4JywnbGVmdGFycm93JzonXFx1MjE5MCcsJ0xlZnRhcnJvdyc6J1xcdTIxRDAnLCdMZWZ0QXJyb3cnOidcXHUyMTkwJywnTGVmdEFycm93QmFyJzonXFx1MjFFNCcsJ0xlZnRBcnJvd1JpZ2h0QXJyb3cnOidcXHUyMUM2JywnbGVmdGFycm93dGFpbCc6J1xcdTIxQTInLCdMZWZ0Q2VpbGluZyc6J1xcdTIzMDgnLCdMZWZ0RG91YmxlQnJhY2tldCc6J1xcdTI3RTYnLCdMZWZ0RG93blRlZVZlY3Rvcic6J1xcdTI5NjEnLCdMZWZ0RG93blZlY3Rvcic6J1xcdTIxQzMnLCdMZWZ0RG93blZlY3RvckJhcic6J1xcdTI5NTknLCdMZWZ0Rmxvb3InOidcXHUyMzBBJywnbGVmdGhhcnBvb25kb3duJzonXFx1MjFCRCcsJ2xlZnRoYXJwb29udXAnOidcXHUyMUJDJywnbGVmdGxlZnRhcnJvd3MnOidcXHUyMUM3JywnbGVmdHJpZ2h0YXJyb3cnOidcXHUyMTk0JywnTGVmdHJpZ2h0YXJyb3cnOidcXHUyMUQ0JywnTGVmdFJpZ2h0QXJyb3cnOidcXHUyMTk0JywnbGVmdHJpZ2h0YXJyb3dzJzonXFx1MjFDNicsJ2xlZnRyaWdodGhhcnBvb25zJzonXFx1MjFDQicsJ2xlZnRyaWdodHNxdWlnYXJyb3cnOidcXHUyMUFEJywnTGVmdFJpZ2h0VmVjdG9yJzonXFx1Mjk0RScsJ0xlZnRUZWUnOidcXHUyMkEzJywnTGVmdFRlZUFycm93JzonXFx1MjFBNCcsJ0xlZnRUZWVWZWN0b3InOidcXHUyOTVBJywnbGVmdHRocmVldGltZXMnOidcXHUyMkNCJywnTGVmdFRyaWFuZ2xlJzonXFx1MjJCMicsJ0xlZnRUcmlhbmdsZUJhcic6J1xcdTI5Q0YnLCdMZWZ0VHJpYW5nbGVFcXVhbCc6J1xcdTIyQjQnLCdMZWZ0VXBEb3duVmVjdG9yJzonXFx1Mjk1MScsJ0xlZnRVcFRlZVZlY3Rvcic6J1xcdTI5NjAnLCdMZWZ0VXBWZWN0b3InOidcXHUyMUJGJywnTGVmdFVwVmVjdG9yQmFyJzonXFx1Mjk1OCcsJ0xlZnRWZWN0b3InOidcXHUyMUJDJywnTGVmdFZlY3RvckJhcic6J1xcdTI5NTInLCdsZWcnOidcXHUyMkRBJywnbEVnJzonXFx1MkE4QicsJ2xlcSc6J1xcdTIyNjQnLCdsZXFxJzonXFx1MjI2NicsJ2xlcXNsYW50JzonXFx1MkE3RCcsJ2xlcyc6J1xcdTJBN0QnLCdsZXNjYyc6J1xcdTJBQTgnLCdsZXNkb3QnOidcXHUyQTdGJywnbGVzZG90byc6J1xcdTJBODEnLCdsZXNkb3Rvcic6J1xcdTJBODMnLCdsZXNnJzonXFx1MjJEQVxcdUZFMDAnLCdsZXNnZXMnOidcXHUyQTkzJywnbGVzc2FwcHJveCc6J1xcdTJBODUnLCdsZXNzZG90JzonXFx1MjJENicsJ2xlc3NlcWd0cic6J1xcdTIyREEnLCdsZXNzZXFxZ3RyJzonXFx1MkE4QicsJ0xlc3NFcXVhbEdyZWF0ZXInOidcXHUyMkRBJywnTGVzc0Z1bGxFcXVhbCc6J1xcdTIyNjYnLCdMZXNzR3JlYXRlcic6J1xcdTIyNzYnLCdsZXNzZ3RyJzonXFx1MjI3NicsJ0xlc3NMZXNzJzonXFx1MkFBMScsJ2xlc3NzaW0nOidcXHUyMjcyJywnTGVzc1NsYW50RXF1YWwnOidcXHUyQTdEJywnTGVzc1RpbGRlJzonXFx1MjI3MicsJ2xmaXNodCc6J1xcdTI5N0MnLCdsZmxvb3InOidcXHUyMzBBJywnbGZyJzonXFx1RDgzNVxcdUREMjknLCdMZnInOidcXHVEODM1XFx1REQwRicsJ2xnJzonXFx1MjI3NicsJ2xnRSc6J1xcdTJBOTEnLCdsSGFyJzonXFx1Mjk2MicsJ2xoYXJkJzonXFx1MjFCRCcsJ2xoYXJ1JzonXFx1MjFCQycsJ2xoYXJ1bCc6J1xcdTI5NkEnLCdsaGJsayc6J1xcdTI1ODQnLCdsamN5JzonXFx1MDQ1OScsJ0xKY3knOidcXHUwNDA5JywnbGwnOidcXHUyMjZBJywnTGwnOidcXHUyMkQ4JywnbGxhcnInOidcXHUyMUM3JywnbGxjb3JuZXInOidcXHUyMzFFJywnTGxlZnRhcnJvdyc6J1xcdTIxREEnLCdsbGhhcmQnOidcXHUyOTZCJywnbGx0cmknOidcXHUyNUZBJywnbG1pZG90JzonXFx1MDE0MCcsJ0xtaWRvdCc6J1xcdTAxM0YnLCdsbW91c3QnOidcXHUyM0IwJywnbG1vdXN0YWNoZSc6J1xcdTIzQjAnLCdsbmFwJzonXFx1MkE4OScsJ2xuYXBwcm94JzonXFx1MkE4OScsJ2xuZSc6J1xcdTJBODcnLCdsbkUnOidcXHUyMjY4JywnbG5lcSc6J1xcdTJBODcnLCdsbmVxcSc6J1xcdTIyNjgnLCdsbnNpbSc6J1xcdTIyRTYnLCdsb2FuZyc6J1xcdTI3RUMnLCdsb2Fycic6J1xcdTIxRkQnLCdsb2Jyayc6J1xcdTI3RTYnLCdsb25nbGVmdGFycm93JzonXFx1MjdGNScsJ0xvbmdsZWZ0YXJyb3cnOidcXHUyN0Y4JywnTG9uZ0xlZnRBcnJvdyc6J1xcdTI3RjUnLCdsb25nbGVmdHJpZ2h0YXJyb3cnOidcXHUyN0Y3JywnTG9uZ2xlZnRyaWdodGFycm93JzonXFx1MjdGQScsJ0xvbmdMZWZ0UmlnaHRBcnJvdyc6J1xcdTI3RjcnLCdsb25nbWFwc3RvJzonXFx1MjdGQycsJ2xvbmdyaWdodGFycm93JzonXFx1MjdGNicsJ0xvbmdyaWdodGFycm93JzonXFx1MjdGOScsJ0xvbmdSaWdodEFycm93JzonXFx1MjdGNicsJ2xvb3BhcnJvd2xlZnQnOidcXHUyMUFCJywnbG9vcGFycm93cmlnaHQnOidcXHUyMUFDJywnbG9wYXInOidcXHUyOTg1JywnbG9wZic6J1xcdUQ4MzVcXHVERDVEJywnTG9wZic6J1xcdUQ4MzVcXHVERDQzJywnbG9wbHVzJzonXFx1MkEyRCcsJ2xvdGltZXMnOidcXHUyQTM0JywnbG93YXN0JzonXFx1MjIxNycsJ2xvd2Jhcic6J18nLCdMb3dlckxlZnRBcnJvdyc6J1xcdTIxOTknLCdMb3dlclJpZ2h0QXJyb3cnOidcXHUyMTk4JywnbG96JzonXFx1MjVDQScsJ2xvemVuZ2UnOidcXHUyNUNBJywnbG96Zic6J1xcdTI5RUInLCdscGFyJzonKCcsJ2xwYXJsdCc6J1xcdTI5OTMnLCdscmFycic6J1xcdTIxQzYnLCdscmNvcm5lcic6J1xcdTIzMUYnLCdscmhhcic6J1xcdTIxQ0InLCdscmhhcmQnOidcXHUyOTZEJywnbHJtJzonXFx1MjAwRScsJ2xydHJpJzonXFx1MjJCRicsJ2xzYXF1byc6J1xcdTIwMzknLCdsc2NyJzonXFx1RDgzNVxcdURDQzEnLCdMc2NyJzonXFx1MjExMicsJ2xzaCc6J1xcdTIxQjAnLCdMc2gnOidcXHUyMUIwJywnbHNpbSc6J1xcdTIyNzInLCdsc2ltZSc6J1xcdTJBOEQnLCdsc2ltZyc6J1xcdTJBOEYnLCdsc3FiJzonWycsJ2xzcXVvJzonXFx1MjAxOCcsJ2xzcXVvcic6J1xcdTIwMUEnLCdsc3Ryb2snOidcXHUwMTQyJywnTHN0cm9rJzonXFx1MDE0MScsJ2x0JzonPCcsJ0x0JzonXFx1MjI2QScsJ0xUJzonPCcsJ2x0Y2MnOidcXHUyQUE2JywnbHRjaXInOidcXHUyQTc5JywnbHRkb3QnOidcXHUyMkQ2JywnbHRocmVlJzonXFx1MjJDQicsJ2x0aW1lcyc6J1xcdTIyQzknLCdsdGxhcnInOidcXHUyOTc2JywnbHRxdWVzdCc6J1xcdTJBN0InLCdsdHJpJzonXFx1MjVDMycsJ2x0cmllJzonXFx1MjJCNCcsJ2x0cmlmJzonXFx1MjVDMicsJ2x0clBhcic6J1xcdTI5OTYnLCdsdXJkc2hhcic6J1xcdTI5NEEnLCdsdXJ1aGFyJzonXFx1Mjk2NicsJ2x2ZXJ0bmVxcSc6J1xcdTIyNjhcXHVGRTAwJywnbHZuRSc6J1xcdTIyNjhcXHVGRTAwJywnbWFjcic6J1xceEFGJywnbWFsZSc6J1xcdTI2NDInLCdtYWx0JzonXFx1MjcyMCcsJ21hbHRlc2UnOidcXHUyNzIwJywnbWFwJzonXFx1MjFBNicsJ01hcCc6J1xcdTI5MDUnLCdtYXBzdG8nOidcXHUyMUE2JywnbWFwc3RvZG93bic6J1xcdTIxQTcnLCdtYXBzdG9sZWZ0JzonXFx1MjFBNCcsJ21hcHN0b3VwJzonXFx1MjFBNScsJ21hcmtlcic6J1xcdTI1QUUnLCdtY29tbWEnOidcXHUyQTI5JywnbWN5JzonXFx1MDQzQycsJ01jeSc6J1xcdTA0MUMnLCdtZGFzaCc6J1xcdTIwMTQnLCdtRERvdCc6J1xcdTIyM0EnLCdtZWFzdXJlZGFuZ2xlJzonXFx1MjIyMScsJ01lZGl1bVNwYWNlJzonXFx1MjA1RicsJ01lbGxpbnRyZic6J1xcdTIxMzMnLCdtZnInOidcXHVEODM1XFx1REQyQScsJ01mcic6J1xcdUQ4MzVcXHVERDEwJywnbWhvJzonXFx1MjEyNycsJ21pY3JvJzonXFx4QjUnLCdtaWQnOidcXHUyMjIzJywnbWlkYXN0JzonKicsJ21pZGNpcic6J1xcdTJBRjAnLCdtaWRkb3QnOidcXHhCNycsJ21pbnVzJzonXFx1MjIxMicsJ21pbnVzYic6J1xcdTIyOUYnLCdtaW51c2QnOidcXHUyMjM4JywnbWludXNkdSc6J1xcdTJBMkEnLCdNaW51c1BsdXMnOidcXHUyMjEzJywnbWxjcCc6J1xcdTJBREInLCdtbGRyJzonXFx1MjAyNicsJ21ucGx1cyc6J1xcdTIyMTMnLCdtb2RlbHMnOidcXHUyMkE3JywnbW9wZic6J1xcdUQ4MzVcXHVERDVFJywnTW9wZic6J1xcdUQ4MzVcXHVERDQ0JywnbXAnOidcXHUyMjEzJywnbXNjcic6J1xcdUQ4MzVcXHVEQ0MyJywnTXNjcic6J1xcdTIxMzMnLCdtc3Rwb3MnOidcXHUyMjNFJywnbXUnOidcXHUwM0JDJywnTXUnOidcXHUwMzlDJywnbXVsdGltYXAnOidcXHUyMkI4JywnbXVtYXAnOidcXHUyMkI4JywnbmFibGEnOidcXHUyMjA3JywnbmFjdXRlJzonXFx1MDE0NCcsJ05hY3V0ZSc6J1xcdTAxNDMnLCduYW5nJzonXFx1MjIyMFxcdTIwRDInLCduYXAnOidcXHUyMjQ5JywnbmFwRSc6J1xcdTJBNzBcXHUwMzM4JywnbmFwaWQnOidcXHUyMjRCXFx1MDMzOCcsJ25hcG9zJzonXFx1MDE0OScsJ25hcHByb3gnOidcXHUyMjQ5JywnbmF0dXInOidcXHUyNjZFJywnbmF0dXJhbCc6J1xcdTI2NkUnLCduYXR1cmFscyc6J1xcdTIxMTUnLCduYnNwJzonXFx4QTAnLCduYnVtcCc6J1xcdTIyNEVcXHUwMzM4JywnbmJ1bXBlJzonXFx1MjI0RlxcdTAzMzgnLCduY2FwJzonXFx1MkE0MycsJ25jYXJvbic6J1xcdTAxNDgnLCdOY2Fyb24nOidcXHUwMTQ3JywnbmNlZGlsJzonXFx1MDE0NicsJ05jZWRpbCc6J1xcdTAxNDUnLCduY29uZyc6J1xcdTIyNDcnLCduY29uZ2RvdCc6J1xcdTJBNkRcXHUwMzM4JywnbmN1cCc6J1xcdTJBNDInLCduY3knOidcXHUwNDNEJywnTmN5JzonXFx1MDQxRCcsJ25kYXNoJzonXFx1MjAxMycsJ25lJzonXFx1MjI2MCcsJ25lYXJoayc6J1xcdTI5MjQnLCduZWFycic6J1xcdTIxOTcnLCduZUFycic6J1xcdTIxRDcnLCduZWFycm93JzonXFx1MjE5NycsJ25lZG90JzonXFx1MjI1MFxcdTAzMzgnLCdOZWdhdGl2ZU1lZGl1bVNwYWNlJzonXFx1MjAwQicsJ05lZ2F0aXZlVGhpY2tTcGFjZSc6J1xcdTIwMEInLCdOZWdhdGl2ZVRoaW5TcGFjZSc6J1xcdTIwMEInLCdOZWdhdGl2ZVZlcnlUaGluU3BhY2UnOidcXHUyMDBCJywnbmVxdWl2JzonXFx1MjI2MicsJ25lc2Vhcic6J1xcdTI5MjgnLCduZXNpbSc6J1xcdTIyNDJcXHUwMzM4JywnTmVzdGVkR3JlYXRlckdyZWF0ZXInOidcXHUyMjZCJywnTmVzdGVkTGVzc0xlc3MnOidcXHUyMjZBJywnTmV3TGluZSc6J1xcbicsJ25leGlzdCc6J1xcdTIyMDQnLCduZXhpc3RzJzonXFx1MjIwNCcsJ25mcic6J1xcdUQ4MzVcXHVERDJCJywnTmZyJzonXFx1RDgzNVxcdUREMTEnLCduZ2UnOidcXHUyMjcxJywnbmdFJzonXFx1MjI2N1xcdTAzMzgnLCduZ2VxJzonXFx1MjI3MScsJ25nZXFxJzonXFx1MjI2N1xcdTAzMzgnLCduZ2Vxc2xhbnQnOidcXHUyQTdFXFx1MDMzOCcsJ25nZXMnOidcXHUyQTdFXFx1MDMzOCcsJ25HZyc6J1xcdTIyRDlcXHUwMzM4JywnbmdzaW0nOidcXHUyMjc1Jywnbmd0JzonXFx1MjI2RicsJ25HdCc6J1xcdTIyNkJcXHUyMEQyJywnbmd0cic6J1xcdTIyNkYnLCduR3R2JzonXFx1MjI2QlxcdTAzMzgnLCduaGFycic6J1xcdTIxQUUnLCduaEFycic6J1xcdTIxQ0UnLCduaHBhcic6J1xcdTJBRjInLCduaSc6J1xcdTIyMEInLCduaXMnOidcXHUyMkZDJywnbmlzZCc6J1xcdTIyRkEnLCduaXYnOidcXHUyMjBCJywnbmpjeSc6J1xcdTA0NUEnLCdOSmN5JzonXFx1MDQwQScsJ25sYXJyJzonXFx1MjE5QScsJ25sQXJyJzonXFx1MjFDRCcsJ25sZHInOidcXHUyMDI1JywnbmxlJzonXFx1MjI3MCcsJ25sRSc6J1xcdTIyNjZcXHUwMzM4JywnbmxlZnRhcnJvdyc6J1xcdTIxOUEnLCduTGVmdGFycm93JzonXFx1MjFDRCcsJ25sZWZ0cmlnaHRhcnJvdyc6J1xcdTIxQUUnLCduTGVmdHJpZ2h0YXJyb3cnOidcXHUyMUNFJywnbmxlcSc6J1xcdTIyNzAnLCdubGVxcSc6J1xcdTIyNjZcXHUwMzM4JywnbmxlcXNsYW50JzonXFx1MkE3RFxcdTAzMzgnLCdubGVzJzonXFx1MkE3RFxcdTAzMzgnLCdubGVzcyc6J1xcdTIyNkUnLCduTGwnOidcXHUyMkQ4XFx1MDMzOCcsJ25sc2ltJzonXFx1MjI3NCcsJ25sdCc6J1xcdTIyNkUnLCduTHQnOidcXHUyMjZBXFx1MjBEMicsJ25sdHJpJzonXFx1MjJFQScsJ25sdHJpZSc6J1xcdTIyRUMnLCduTHR2JzonXFx1MjI2QVxcdTAzMzgnLCdubWlkJzonXFx1MjIyNCcsJ05vQnJlYWsnOidcXHUyMDYwJywnTm9uQnJlYWtpbmdTcGFjZSc6J1xceEEwJywnbm9wZic6J1xcdUQ4MzVcXHVERDVGJywnTm9wZic6J1xcdTIxMTUnLCdub3QnOidcXHhBQycsJ05vdCc6J1xcdTJBRUMnLCdOb3RDb25ncnVlbnQnOidcXHUyMjYyJywnTm90Q3VwQ2FwJzonXFx1MjI2RCcsJ05vdERvdWJsZVZlcnRpY2FsQmFyJzonXFx1MjIyNicsJ05vdEVsZW1lbnQnOidcXHUyMjA5JywnTm90RXF1YWwnOidcXHUyMjYwJywnTm90RXF1YWxUaWxkZSc6J1xcdTIyNDJcXHUwMzM4JywnTm90RXhpc3RzJzonXFx1MjIwNCcsJ05vdEdyZWF0ZXInOidcXHUyMjZGJywnTm90R3JlYXRlckVxdWFsJzonXFx1MjI3MScsJ05vdEdyZWF0ZXJGdWxsRXF1YWwnOidcXHUyMjY3XFx1MDMzOCcsJ05vdEdyZWF0ZXJHcmVhdGVyJzonXFx1MjI2QlxcdTAzMzgnLCdOb3RHcmVhdGVyTGVzcyc6J1xcdTIyNzknLCdOb3RHcmVhdGVyU2xhbnRFcXVhbCc6J1xcdTJBN0VcXHUwMzM4JywnTm90R3JlYXRlclRpbGRlJzonXFx1MjI3NScsJ05vdEh1bXBEb3duSHVtcCc6J1xcdTIyNEVcXHUwMzM4JywnTm90SHVtcEVxdWFsJzonXFx1MjI0RlxcdTAzMzgnLCdub3Rpbic6J1xcdTIyMDknLCdub3RpbmRvdCc6J1xcdTIyRjVcXHUwMzM4Jywnbm90aW5FJzonXFx1MjJGOVxcdTAzMzgnLCdub3RpbnZhJzonXFx1MjIwOScsJ25vdGludmInOidcXHUyMkY3Jywnbm90aW52Yyc6J1xcdTIyRjYnLCdOb3RMZWZ0VHJpYW5nbGUnOidcXHUyMkVBJywnTm90TGVmdFRyaWFuZ2xlQmFyJzonXFx1MjlDRlxcdTAzMzgnLCdOb3RMZWZ0VHJpYW5nbGVFcXVhbCc6J1xcdTIyRUMnLCdOb3RMZXNzJzonXFx1MjI2RScsJ05vdExlc3NFcXVhbCc6J1xcdTIyNzAnLCdOb3RMZXNzR3JlYXRlcic6J1xcdTIyNzgnLCdOb3RMZXNzTGVzcyc6J1xcdTIyNkFcXHUwMzM4JywnTm90TGVzc1NsYW50RXF1YWwnOidcXHUyQTdEXFx1MDMzOCcsJ05vdExlc3NUaWxkZSc6J1xcdTIyNzQnLCdOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcic6J1xcdTJBQTJcXHUwMzM4JywnTm90TmVzdGVkTGVzc0xlc3MnOidcXHUyQUExXFx1MDMzOCcsJ25vdG5pJzonXFx1MjIwQycsJ25vdG5pdmEnOidcXHUyMjBDJywnbm90bml2Yic6J1xcdTIyRkUnLCdub3RuaXZjJzonXFx1MjJGRCcsJ05vdFByZWNlZGVzJzonXFx1MjI4MCcsJ05vdFByZWNlZGVzRXF1YWwnOidcXHUyQUFGXFx1MDMzOCcsJ05vdFByZWNlZGVzU2xhbnRFcXVhbCc6J1xcdTIyRTAnLCdOb3RSZXZlcnNlRWxlbWVudCc6J1xcdTIyMEMnLCdOb3RSaWdodFRyaWFuZ2xlJzonXFx1MjJFQicsJ05vdFJpZ2h0VHJpYW5nbGVCYXInOidcXHUyOUQwXFx1MDMzOCcsJ05vdFJpZ2h0VHJpYW5nbGVFcXVhbCc6J1xcdTIyRUQnLCdOb3RTcXVhcmVTdWJzZXQnOidcXHUyMjhGXFx1MDMzOCcsJ05vdFNxdWFyZVN1YnNldEVxdWFsJzonXFx1MjJFMicsJ05vdFNxdWFyZVN1cGVyc2V0JzonXFx1MjI5MFxcdTAzMzgnLCdOb3RTcXVhcmVTdXBlcnNldEVxdWFsJzonXFx1MjJFMycsJ05vdFN1YnNldCc6J1xcdTIyODJcXHUyMEQyJywnTm90U3Vic2V0RXF1YWwnOidcXHUyMjg4JywnTm90U3VjY2VlZHMnOidcXHUyMjgxJywnTm90U3VjY2VlZHNFcXVhbCc6J1xcdTJBQjBcXHUwMzM4JywnTm90U3VjY2VlZHNTbGFudEVxdWFsJzonXFx1MjJFMScsJ05vdFN1Y2NlZWRzVGlsZGUnOidcXHUyMjdGXFx1MDMzOCcsJ05vdFN1cGVyc2V0JzonXFx1MjI4M1xcdTIwRDInLCdOb3RTdXBlcnNldEVxdWFsJzonXFx1MjI4OScsJ05vdFRpbGRlJzonXFx1MjI0MScsJ05vdFRpbGRlRXF1YWwnOidcXHUyMjQ0JywnTm90VGlsZGVGdWxsRXF1YWwnOidcXHUyMjQ3JywnTm90VGlsZGVUaWxkZSc6J1xcdTIyNDknLCdOb3RWZXJ0aWNhbEJhcic6J1xcdTIyMjQnLCducGFyJzonXFx1MjIyNicsJ25wYXJhbGxlbCc6J1xcdTIyMjYnLCducGFyc2wnOidcXHUyQUZEXFx1MjBFNScsJ25wYXJ0JzonXFx1MjIwMlxcdTAzMzgnLCducG9saW50JzonXFx1MkExNCcsJ25wcic6J1xcdTIyODAnLCducHJjdWUnOidcXHUyMkUwJywnbnByZSc6J1xcdTJBQUZcXHUwMzM4JywnbnByZWMnOidcXHUyMjgwJywnbnByZWNlcSc6J1xcdTJBQUZcXHUwMzM4JywnbnJhcnInOidcXHUyMTlCJywnbnJBcnInOidcXHUyMUNGJywnbnJhcnJjJzonXFx1MjkzM1xcdTAzMzgnLCducmFycncnOidcXHUyMTlEXFx1MDMzOCcsJ25yaWdodGFycm93JzonXFx1MjE5QicsJ25SaWdodGFycm93JzonXFx1MjFDRicsJ25ydHJpJzonXFx1MjJFQicsJ25ydHJpZSc6J1xcdTIyRUQnLCduc2MnOidcXHUyMjgxJywnbnNjY3VlJzonXFx1MjJFMScsJ25zY2UnOidcXHUyQUIwXFx1MDMzOCcsJ25zY3InOidcXHVEODM1XFx1RENDMycsJ05zY3InOidcXHVEODM1XFx1RENBOScsJ25zaG9ydG1pZCc6J1xcdTIyMjQnLCduc2hvcnRwYXJhbGxlbCc6J1xcdTIyMjYnLCduc2ltJzonXFx1MjI0MScsJ25zaW1lJzonXFx1MjI0NCcsJ25zaW1lcSc6J1xcdTIyNDQnLCduc21pZCc6J1xcdTIyMjQnLCduc3Bhcic6J1xcdTIyMjYnLCduc3FzdWJlJzonXFx1MjJFMicsJ25zcXN1cGUnOidcXHUyMkUzJywnbnN1Yic6J1xcdTIyODQnLCduc3ViZSc6J1xcdTIyODgnLCduc3ViRSc6J1xcdTJBQzVcXHUwMzM4JywnbnN1YnNldCc6J1xcdTIyODJcXHUyMEQyJywnbnN1YnNldGVxJzonXFx1MjI4OCcsJ25zdWJzZXRlcXEnOidcXHUyQUM1XFx1MDMzOCcsJ25zdWNjJzonXFx1MjI4MScsJ25zdWNjZXEnOidcXHUyQUIwXFx1MDMzOCcsJ25zdXAnOidcXHUyMjg1JywnbnN1cGUnOidcXHUyMjg5JywnbnN1cEUnOidcXHUyQUM2XFx1MDMzOCcsJ25zdXBzZXQnOidcXHUyMjgzXFx1MjBEMicsJ25zdXBzZXRlcSc6J1xcdTIyODknLCduc3Vwc2V0ZXFxJzonXFx1MkFDNlxcdTAzMzgnLCdudGdsJzonXFx1MjI3OScsJ250aWxkZSc6J1xceEYxJywnTnRpbGRlJzonXFx4RDEnLCdudGxnJzonXFx1MjI3OCcsJ250cmlhbmdsZWxlZnQnOidcXHUyMkVBJywnbnRyaWFuZ2xlbGVmdGVxJzonXFx1MjJFQycsJ250cmlhbmdsZXJpZ2h0JzonXFx1MjJFQicsJ250cmlhbmdsZXJpZ2h0ZXEnOidcXHUyMkVEJywnbnUnOidcXHUwM0JEJywnTnUnOidcXHUwMzlEJywnbnVtJzonIycsJ251bWVybyc6J1xcdTIxMTYnLCdudW1zcCc6J1xcdTIwMDcnLCdudmFwJzonXFx1MjI0RFxcdTIwRDInLCdudmRhc2gnOidcXHUyMkFDJywnbnZEYXNoJzonXFx1MjJBRCcsJ25WZGFzaCc6J1xcdTIyQUUnLCduVkRhc2gnOidcXHUyMkFGJywnbnZnZSc6J1xcdTIyNjVcXHUyMEQyJywnbnZndCc6Jz5cXHUyMEQyJywnbnZIYXJyJzonXFx1MjkwNCcsJ252aW5maW4nOidcXHUyOURFJywnbnZsQXJyJzonXFx1MjkwMicsJ252bGUnOidcXHUyMjY0XFx1MjBEMicsJ252bHQnOic8XFx1MjBEMicsJ252bHRyaWUnOidcXHUyMkI0XFx1MjBEMicsJ252ckFycic6J1xcdTI5MDMnLCdudnJ0cmllJzonXFx1MjJCNVxcdTIwRDInLCdudnNpbSc6J1xcdTIyM0NcXHUyMEQyJywnbndhcmhrJzonXFx1MjkyMycsJ253YXJyJzonXFx1MjE5NicsJ253QXJyJzonXFx1MjFENicsJ253YXJyb3cnOidcXHUyMTk2JywnbnduZWFyJzonXFx1MjkyNycsJ29hY3V0ZSc6J1xceEYzJywnT2FjdXRlJzonXFx4RDMnLCdvYXN0JzonXFx1MjI5QicsJ29jaXInOidcXHUyMjlBJywnb2NpcmMnOidcXHhGNCcsJ09jaXJjJzonXFx4RDQnLCdvY3knOidcXHUwNDNFJywnT2N5JzonXFx1MDQxRScsJ29kYXNoJzonXFx1MjI5RCcsJ29kYmxhYyc6J1xcdTAxNTEnLCdPZGJsYWMnOidcXHUwMTUwJywnb2Rpdic6J1xcdTJBMzgnLCdvZG90JzonXFx1MjI5OScsJ29kc29sZCc6J1xcdTI5QkMnLCdvZWxpZyc6J1xcdTAxNTMnLCdPRWxpZyc6J1xcdTAxNTInLCdvZmNpcic6J1xcdTI5QkYnLCdvZnInOidcXHVEODM1XFx1REQyQycsJ09mcic6J1xcdUQ4MzVcXHVERDEyJywnb2dvbic6J1xcdTAyREInLCdvZ3JhdmUnOidcXHhGMicsJ09ncmF2ZSc6J1xceEQyJywnb2d0JzonXFx1MjlDMScsJ29oYmFyJzonXFx1MjlCNScsJ29obSc6J1xcdTAzQTknLCdvaW50JzonXFx1MjIyRScsJ29sYXJyJzonXFx1MjFCQScsJ29sY2lyJzonXFx1MjlCRScsJ29sY3Jvc3MnOidcXHUyOUJCJywnb2xpbmUnOidcXHUyMDNFJywnb2x0JzonXFx1MjlDMCcsJ29tYWNyJzonXFx1MDE0RCcsJ09tYWNyJzonXFx1MDE0QycsJ29tZWdhJzonXFx1MDNDOScsJ09tZWdhJzonXFx1MDNBOScsJ29taWNyb24nOidcXHUwM0JGJywnT21pY3Jvbic6J1xcdTAzOUYnLCdvbWlkJzonXFx1MjlCNicsJ29taW51cyc6J1xcdTIyOTYnLCdvb3BmJzonXFx1RDgzNVxcdURENjAnLCdPb3BmJzonXFx1RDgzNVxcdURENDYnLCdvcGFyJzonXFx1MjlCNycsJ09wZW5DdXJseURvdWJsZVF1b3RlJzonXFx1MjAxQycsJ09wZW5DdXJseVF1b3RlJzonXFx1MjAxOCcsJ29wZXJwJzonXFx1MjlCOScsJ29wbHVzJzonXFx1MjI5NScsJ29yJzonXFx1MjIyOCcsJ09yJzonXFx1MkE1NCcsJ29yYXJyJzonXFx1MjFCQicsJ29yZCc6J1xcdTJBNUQnLCdvcmRlcic6J1xcdTIxMzQnLCdvcmRlcm9mJzonXFx1MjEzNCcsJ29yZGYnOidcXHhBQScsJ29yZG0nOidcXHhCQScsJ29yaWdvZic6J1xcdTIyQjYnLCdvcm9yJzonXFx1MkE1NicsJ29yc2xvcGUnOidcXHUyQTU3Jywnb3J2JzonXFx1MkE1QicsJ29TJzonXFx1MjRDOCcsJ29zY3InOidcXHUyMTM0JywnT3Njcic6J1xcdUQ4MzVcXHVEQ0FBJywnb3NsYXNoJzonXFx4RjgnLCdPc2xhc2gnOidcXHhEOCcsJ29zb2wnOidcXHUyMjk4Jywnb3RpbGRlJzonXFx4RjUnLCdPdGlsZGUnOidcXHhENScsJ290aW1lcyc6J1xcdTIyOTcnLCdPdGltZXMnOidcXHUyQTM3Jywnb3RpbWVzYXMnOidcXHUyQTM2Jywnb3VtbCc6J1xceEY2JywnT3VtbCc6J1xceEQ2Jywnb3ZiYXInOidcXHUyMzNEJywnT3ZlckJhcic6J1xcdTIwM0UnLCdPdmVyQnJhY2UnOidcXHUyM0RFJywnT3ZlckJyYWNrZXQnOidcXHUyM0I0JywnT3ZlclBhcmVudGhlc2lzJzonXFx1MjNEQycsJ3Bhcic6J1xcdTIyMjUnLCdwYXJhJzonXFx4QjYnLCdwYXJhbGxlbCc6J1xcdTIyMjUnLCdwYXJzaW0nOidcXHUyQUYzJywncGFyc2wnOidcXHUyQUZEJywncGFydCc6J1xcdTIyMDInLCdQYXJ0aWFsRCc6J1xcdTIyMDInLCdwY3knOidcXHUwNDNGJywnUGN5JzonXFx1MDQxRicsJ3BlcmNudCc6JyUnLCdwZXJpb2QnOicuJywncGVybWlsJzonXFx1MjAzMCcsJ3BlcnAnOidcXHUyMkE1JywncGVydGVuayc6J1xcdTIwMzEnLCdwZnInOidcXHVEODM1XFx1REQyRCcsJ1Bmcic6J1xcdUQ4MzVcXHVERDEzJywncGhpJzonXFx1MDNDNicsJ1BoaSc6J1xcdTAzQTYnLCdwaGl2JzonXFx1MDNENScsJ3BobW1hdCc6J1xcdTIxMzMnLCdwaG9uZSc6J1xcdTI2MEUnLCdwaSc6J1xcdTAzQzAnLCdQaSc6J1xcdTAzQTAnLCdwaXRjaGZvcmsnOidcXHUyMkQ0JywncGl2JzonXFx1MDNENicsJ3BsYW5jayc6J1xcdTIxMEYnLCdwbGFuY2toJzonXFx1MjEwRScsJ3BsYW5rdic6J1xcdTIxMEYnLCdwbHVzJzonKycsJ3BsdXNhY2lyJzonXFx1MkEyMycsJ3BsdXNiJzonXFx1MjI5RScsJ3BsdXNjaXInOidcXHUyQTIyJywncGx1c2RvJzonXFx1MjIxNCcsJ3BsdXNkdSc6J1xcdTJBMjUnLCdwbHVzZSc6J1xcdTJBNzInLCdQbHVzTWludXMnOidcXHhCMScsJ3BsdXNtbic6J1xceEIxJywncGx1c3NpbSc6J1xcdTJBMjYnLCdwbHVzdHdvJzonXFx1MkEyNycsJ3BtJzonXFx4QjEnLCdQb2luY2FyZXBsYW5lJzonXFx1MjEwQycsJ3BvaW50aW50JzonXFx1MkExNScsJ3BvcGYnOidcXHVEODM1XFx1REQ2MScsJ1BvcGYnOidcXHUyMTE5JywncG91bmQnOidcXHhBMycsJ3ByJzonXFx1MjI3QScsJ1ByJzonXFx1MkFCQicsJ3ByYXAnOidcXHUyQUI3JywncHJjdWUnOidcXHUyMjdDJywncHJlJzonXFx1MkFBRicsJ3ByRSc6J1xcdTJBQjMnLCdwcmVjJzonXFx1MjI3QScsJ3ByZWNhcHByb3gnOidcXHUyQUI3JywncHJlY2N1cmx5ZXEnOidcXHUyMjdDJywnUHJlY2VkZXMnOidcXHUyMjdBJywnUHJlY2VkZXNFcXVhbCc6J1xcdTJBQUYnLCdQcmVjZWRlc1NsYW50RXF1YWwnOidcXHUyMjdDJywnUHJlY2VkZXNUaWxkZSc6J1xcdTIyN0UnLCdwcmVjZXEnOidcXHUyQUFGJywncHJlY25hcHByb3gnOidcXHUyQUI5JywncHJlY25lcXEnOidcXHUyQUI1JywncHJlY25zaW0nOidcXHUyMkU4JywncHJlY3NpbSc6J1xcdTIyN0UnLCdwcmltZSc6J1xcdTIwMzInLCdQcmltZSc6J1xcdTIwMzMnLCdwcmltZXMnOidcXHUyMTE5JywncHJuYXAnOidcXHUyQUI5JywncHJuRSc6J1xcdTJBQjUnLCdwcm5zaW0nOidcXHUyMkU4JywncHJvZCc6J1xcdTIyMEYnLCdQcm9kdWN0JzonXFx1MjIwRicsJ3Byb2ZhbGFyJzonXFx1MjMyRScsJ3Byb2ZsaW5lJzonXFx1MjMxMicsJ3Byb2ZzdXJmJzonXFx1MjMxMycsJ3Byb3AnOidcXHUyMjFEJywnUHJvcG9ydGlvbic6J1xcdTIyMzcnLCdQcm9wb3J0aW9uYWwnOidcXHUyMjFEJywncHJvcHRvJzonXFx1MjIxRCcsJ3Byc2ltJzonXFx1MjI3RScsJ3BydXJlbCc6J1xcdTIyQjAnLCdwc2NyJzonXFx1RDgzNVxcdURDQzUnLCdQc2NyJzonXFx1RDgzNVxcdURDQUInLCdwc2knOidcXHUwM0M4JywnUHNpJzonXFx1MDNBOCcsJ3B1bmNzcCc6J1xcdTIwMDgnLCdxZnInOidcXHVEODM1XFx1REQyRScsJ1Fmcic6J1xcdUQ4MzVcXHVERDE0JywncWludCc6J1xcdTJBMEMnLCdxb3BmJzonXFx1RDgzNVxcdURENjInLCdRb3BmJzonXFx1MjExQScsJ3FwcmltZSc6J1xcdTIwNTcnLCdxc2NyJzonXFx1RDgzNVxcdURDQzYnLCdRc2NyJzonXFx1RDgzNVxcdURDQUMnLCdxdWF0ZXJuaW9ucyc6J1xcdTIxMEQnLCdxdWF0aW50JzonXFx1MkExNicsJ3F1ZXN0JzonPycsJ3F1ZXN0ZXEnOidcXHUyMjVGJywncXVvdCc6J1wiJywnUVVPVCc6J1wiJywnckFhcnInOidcXHUyMURCJywncmFjZSc6J1xcdTIyM0RcXHUwMzMxJywncmFjdXRlJzonXFx1MDE1NScsJ1JhY3V0ZSc6J1xcdTAxNTQnLCdyYWRpYyc6J1xcdTIyMUEnLCdyYWVtcHR5dic6J1xcdTI5QjMnLCdyYW5nJzonXFx1MjdFOScsJ1JhbmcnOidcXHUyN0VCJywncmFuZ2QnOidcXHUyOTkyJywncmFuZ2UnOidcXHUyOUE1JywncmFuZ2xlJzonXFx1MjdFOScsJ3JhcXVvJzonXFx4QkInLCdyYXJyJzonXFx1MjE5MicsJ3JBcnInOidcXHUyMUQyJywnUmFycic6J1xcdTIxQTAnLCdyYXJyYXAnOidcXHUyOTc1JywncmFycmInOidcXHUyMUU1JywncmFycmJmcyc6J1xcdTI5MjAnLCdyYXJyYyc6J1xcdTI5MzMnLCdyYXJyZnMnOidcXHUyOTFFJywncmFycmhrJzonXFx1MjFBQScsJ3JhcnJscCc6J1xcdTIxQUMnLCdyYXJycGwnOidcXHUyOTQ1JywncmFycnNpbSc6J1xcdTI5NzQnLCdyYXJydGwnOidcXHUyMUEzJywnUmFycnRsJzonXFx1MjkxNicsJ3JhcnJ3JzonXFx1MjE5RCcsJ3JhdGFpbCc6J1xcdTI5MUEnLCdyQXRhaWwnOidcXHUyOTFDJywncmF0aW8nOidcXHUyMjM2JywncmF0aW9uYWxzJzonXFx1MjExQScsJ3JiYXJyJzonXFx1MjkwRCcsJ3JCYXJyJzonXFx1MjkwRicsJ1JCYXJyJzonXFx1MjkxMCcsJ3JiYnJrJzonXFx1Mjc3MycsJ3JicmFjZSc6J30nLCdyYnJhY2snOiddJywncmJya2UnOidcXHUyOThDJywncmJya3NsZCc6J1xcdTI5OEUnLCdyYnJrc2x1JzonXFx1Mjk5MCcsJ3JjYXJvbic6J1xcdTAxNTknLCdSY2Fyb24nOidcXHUwMTU4JywncmNlZGlsJzonXFx1MDE1NycsJ1JjZWRpbCc6J1xcdTAxNTYnLCdyY2VpbCc6J1xcdTIzMDknLCdyY3ViJzonfScsJ3JjeSc6J1xcdTA0NDAnLCdSY3knOidcXHUwNDIwJywncmRjYSc6J1xcdTI5MzcnLCdyZGxkaGFyJzonXFx1Mjk2OScsJ3JkcXVvJzonXFx1MjAxRCcsJ3JkcXVvcic6J1xcdTIwMUQnLCdyZHNoJzonXFx1MjFCMycsJ1JlJzonXFx1MjExQycsJ3JlYWwnOidcXHUyMTFDJywncmVhbGluZSc6J1xcdTIxMUInLCdyZWFscGFydCc6J1xcdTIxMUMnLCdyZWFscyc6J1xcdTIxMUQnLCdyZWN0JzonXFx1MjVBRCcsJ3JlZyc6J1xceEFFJywnUkVHJzonXFx4QUUnLCdSZXZlcnNlRWxlbWVudCc6J1xcdTIyMEInLCdSZXZlcnNlRXF1aWxpYnJpdW0nOidcXHUyMUNCJywnUmV2ZXJzZVVwRXF1aWxpYnJpdW0nOidcXHUyOTZGJywncmZpc2h0JzonXFx1Mjk3RCcsJ3JmbG9vcic6J1xcdTIzMEInLCdyZnInOidcXHVEODM1XFx1REQyRicsJ1Jmcic6J1xcdTIxMUMnLCdySGFyJzonXFx1Mjk2NCcsJ3JoYXJkJzonXFx1MjFDMScsJ3JoYXJ1JzonXFx1MjFDMCcsJ3JoYXJ1bCc6J1xcdTI5NkMnLCdyaG8nOidcXHUwM0MxJywnUmhvJzonXFx1MDNBMScsJ3Job3YnOidcXHUwM0YxJywnUmlnaHRBbmdsZUJyYWNrZXQnOidcXHUyN0U5JywncmlnaHRhcnJvdyc6J1xcdTIxOTInLCdSaWdodGFycm93JzonXFx1MjFEMicsJ1JpZ2h0QXJyb3cnOidcXHUyMTkyJywnUmlnaHRBcnJvd0Jhcic6J1xcdTIxRTUnLCdSaWdodEFycm93TGVmdEFycm93JzonXFx1MjFDNCcsJ3JpZ2h0YXJyb3d0YWlsJzonXFx1MjFBMycsJ1JpZ2h0Q2VpbGluZyc6J1xcdTIzMDknLCdSaWdodERvdWJsZUJyYWNrZXQnOidcXHUyN0U3JywnUmlnaHREb3duVGVlVmVjdG9yJzonXFx1Mjk1RCcsJ1JpZ2h0RG93blZlY3Rvcic6J1xcdTIxQzInLCdSaWdodERvd25WZWN0b3JCYXInOidcXHUyOTU1JywnUmlnaHRGbG9vcic6J1xcdTIzMEInLCdyaWdodGhhcnBvb25kb3duJzonXFx1MjFDMScsJ3JpZ2h0aGFycG9vbnVwJzonXFx1MjFDMCcsJ3JpZ2h0bGVmdGFycm93cyc6J1xcdTIxQzQnLCdyaWdodGxlZnRoYXJwb29ucyc6J1xcdTIxQ0MnLCdyaWdodHJpZ2h0YXJyb3dzJzonXFx1MjFDOScsJ3JpZ2h0c3F1aWdhcnJvdyc6J1xcdTIxOUQnLCdSaWdodFRlZSc6J1xcdTIyQTInLCdSaWdodFRlZUFycm93JzonXFx1MjFBNicsJ1JpZ2h0VGVlVmVjdG9yJzonXFx1Mjk1QicsJ3JpZ2h0dGhyZWV0aW1lcyc6J1xcdTIyQ0MnLCdSaWdodFRyaWFuZ2xlJzonXFx1MjJCMycsJ1JpZ2h0VHJpYW5nbGVCYXInOidcXHUyOUQwJywnUmlnaHRUcmlhbmdsZUVxdWFsJzonXFx1MjJCNScsJ1JpZ2h0VXBEb3duVmVjdG9yJzonXFx1Mjk0RicsJ1JpZ2h0VXBUZWVWZWN0b3InOidcXHUyOTVDJywnUmlnaHRVcFZlY3Rvcic6J1xcdTIxQkUnLCdSaWdodFVwVmVjdG9yQmFyJzonXFx1Mjk1NCcsJ1JpZ2h0VmVjdG9yJzonXFx1MjFDMCcsJ1JpZ2h0VmVjdG9yQmFyJzonXFx1Mjk1MycsJ3JpbmcnOidcXHUwMkRBJywncmlzaW5nZG90c2VxJzonXFx1MjI1MycsJ3JsYXJyJzonXFx1MjFDNCcsJ3JsaGFyJzonXFx1MjFDQycsJ3JsbSc6J1xcdTIwMEYnLCdybW91c3QnOidcXHUyM0IxJywncm1vdXN0YWNoZSc6J1xcdTIzQjEnLCdybm1pZCc6J1xcdTJBRUUnLCdyb2FuZyc6J1xcdTI3RUQnLCdyb2Fycic6J1xcdTIxRkUnLCdyb2Jyayc6J1xcdTI3RTcnLCdyb3Bhcic6J1xcdTI5ODYnLCdyb3BmJzonXFx1RDgzNVxcdURENjMnLCdSb3BmJzonXFx1MjExRCcsJ3JvcGx1cyc6J1xcdTJBMkUnLCdyb3RpbWVzJzonXFx1MkEzNScsJ1JvdW5kSW1wbGllcyc6J1xcdTI5NzAnLCdycGFyJzonKScsJ3JwYXJndCc6J1xcdTI5OTQnLCdycHBvbGludCc6J1xcdTJBMTInLCdycmFycic6J1xcdTIxQzknLCdScmlnaHRhcnJvdyc6J1xcdTIxREInLCdyc2FxdW8nOidcXHUyMDNBJywncnNjcic6J1xcdUQ4MzVcXHVEQ0M3JywnUnNjcic6J1xcdTIxMUInLCdyc2gnOidcXHUyMUIxJywnUnNoJzonXFx1MjFCMScsJ3JzcWInOiddJywncnNxdW8nOidcXHUyMDE5JywncnNxdW9yJzonXFx1MjAxOScsJ3J0aHJlZSc6J1xcdTIyQ0MnLCdydGltZXMnOidcXHUyMkNBJywncnRyaSc6J1xcdTI1QjknLCdydHJpZSc6J1xcdTIyQjUnLCdydHJpZic6J1xcdTI1QjgnLCdydHJpbHRyaSc6J1xcdTI5Q0UnLCdSdWxlRGVsYXllZCc6J1xcdTI5RjQnLCdydWx1aGFyJzonXFx1Mjk2OCcsJ3J4JzonXFx1MjExRScsJ3NhY3V0ZSc6J1xcdTAxNUInLCdTYWN1dGUnOidcXHUwMTVBJywnc2JxdW8nOidcXHUyMDFBJywnc2MnOidcXHUyMjdCJywnU2MnOidcXHUyQUJDJywnc2NhcCc6J1xcdTJBQjgnLCdzY2Fyb24nOidcXHUwMTYxJywnU2Nhcm9uJzonXFx1MDE2MCcsJ3NjY3VlJzonXFx1MjI3RCcsJ3NjZSc6J1xcdTJBQjAnLCdzY0UnOidcXHUyQUI0Jywnc2NlZGlsJzonXFx1MDE1RicsJ1NjZWRpbCc6J1xcdTAxNUUnLCdzY2lyYyc6J1xcdTAxNUQnLCdTY2lyYyc6J1xcdTAxNUMnLCdzY25hcCc6J1xcdTJBQkEnLCdzY25FJzonXFx1MkFCNicsJ3NjbnNpbSc6J1xcdTIyRTknLCdzY3BvbGludCc6J1xcdTJBMTMnLCdzY3NpbSc6J1xcdTIyN0YnLCdzY3knOidcXHUwNDQxJywnU2N5JzonXFx1MDQyMScsJ3Nkb3QnOidcXHUyMkM1Jywnc2RvdGInOidcXHUyMkExJywnc2RvdGUnOidcXHUyQTY2Jywnc2VhcmhrJzonXFx1MjkyNScsJ3NlYXJyJzonXFx1MjE5OCcsJ3NlQXJyJzonXFx1MjFEOCcsJ3NlYXJyb3cnOidcXHUyMTk4Jywnc2VjdCc6J1xceEE3Jywnc2VtaSc6JzsnLCdzZXN3YXInOidcXHUyOTI5Jywnc2V0bWludXMnOidcXHUyMjE2Jywnc2V0bW4nOidcXHUyMjE2Jywnc2V4dCc6J1xcdTI3MzYnLCdzZnInOidcXHVEODM1XFx1REQzMCcsJ1Nmcic6J1xcdUQ4MzVcXHVERDE2Jywnc2Zyb3duJzonXFx1MjMyMicsJ3NoYXJwJzonXFx1MjY2RicsJ3NoY2hjeSc6J1xcdTA0NDknLCdTSENIY3knOidcXHUwNDI5Jywnc2hjeSc6J1xcdTA0NDgnLCdTSGN5JzonXFx1MDQyOCcsJ1Nob3J0RG93bkFycm93JzonXFx1MjE5MycsJ1Nob3J0TGVmdEFycm93JzonXFx1MjE5MCcsJ3Nob3J0bWlkJzonXFx1MjIyMycsJ3Nob3J0cGFyYWxsZWwnOidcXHUyMjI1JywnU2hvcnRSaWdodEFycm93JzonXFx1MjE5MicsJ1Nob3J0VXBBcnJvdyc6J1xcdTIxOTEnLCdzaHknOidcXHhBRCcsJ3NpZ21hJzonXFx1MDNDMycsJ1NpZ21hJzonXFx1MDNBMycsJ3NpZ21hZic6J1xcdTAzQzInLCdzaWdtYXYnOidcXHUwM0MyJywnc2ltJzonXFx1MjIzQycsJ3NpbWRvdCc6J1xcdTJBNkEnLCdzaW1lJzonXFx1MjI0MycsJ3NpbWVxJzonXFx1MjI0MycsJ3NpbWcnOidcXHUyQTlFJywnc2ltZ0UnOidcXHUyQUEwJywnc2ltbCc6J1xcdTJBOUQnLCdzaW1sRSc6J1xcdTJBOUYnLCdzaW1uZSc6J1xcdTIyNDYnLCdzaW1wbHVzJzonXFx1MkEyNCcsJ3NpbXJhcnInOidcXHUyOTcyJywnc2xhcnInOidcXHUyMTkwJywnU21hbGxDaXJjbGUnOidcXHUyMjE4Jywnc21hbGxzZXRtaW51cyc6J1xcdTIyMTYnLCdzbWFzaHAnOidcXHUyQTMzJywnc21lcGFyc2wnOidcXHUyOUU0Jywnc21pZCc6J1xcdTIyMjMnLCdzbWlsZSc6J1xcdTIzMjMnLCdzbXQnOidcXHUyQUFBJywnc210ZSc6J1xcdTJBQUMnLCdzbXRlcyc6J1xcdTJBQUNcXHVGRTAwJywnc29mdGN5JzonXFx1MDQ0QycsJ1NPRlRjeSc6J1xcdTA0MkMnLCdzb2wnOicvJywnc29sYic6J1xcdTI5QzQnLCdzb2xiYXInOidcXHUyMzNGJywnc29wZic6J1xcdUQ4MzVcXHVERDY0JywnU29wZic6J1xcdUQ4MzVcXHVERDRBJywnc3BhZGVzJzonXFx1MjY2MCcsJ3NwYWRlc3VpdCc6J1xcdTI2NjAnLCdzcGFyJzonXFx1MjIyNScsJ3NxY2FwJzonXFx1MjI5MycsJ3NxY2Fwcyc6J1xcdTIyOTNcXHVGRTAwJywnc3FjdXAnOidcXHUyMjk0Jywnc3FjdXBzJzonXFx1MjI5NFxcdUZFMDAnLCdTcXJ0JzonXFx1MjIxQScsJ3Nxc3ViJzonXFx1MjI4RicsJ3Nxc3ViZSc6J1xcdTIyOTEnLCdzcXN1YnNldCc6J1xcdTIyOEYnLCdzcXN1YnNldGVxJzonXFx1MjI5MScsJ3Nxc3VwJzonXFx1MjI5MCcsJ3Nxc3VwZSc6J1xcdTIyOTInLCdzcXN1cHNldCc6J1xcdTIyOTAnLCdzcXN1cHNldGVxJzonXFx1MjI5MicsJ3NxdSc6J1xcdTI1QTEnLCdzcXVhcmUnOidcXHUyNUExJywnU3F1YXJlJzonXFx1MjVBMScsJ1NxdWFyZUludGVyc2VjdGlvbic6J1xcdTIyOTMnLCdTcXVhcmVTdWJzZXQnOidcXHUyMjhGJywnU3F1YXJlU3Vic2V0RXF1YWwnOidcXHUyMjkxJywnU3F1YXJlU3VwZXJzZXQnOidcXHUyMjkwJywnU3F1YXJlU3VwZXJzZXRFcXVhbCc6J1xcdTIyOTInLCdTcXVhcmVVbmlvbic6J1xcdTIyOTQnLCdzcXVhcmYnOidcXHUyNUFBJywnc3F1Zic6J1xcdTI1QUEnLCdzcmFycic6J1xcdTIxOTInLCdzc2NyJzonXFx1RDgzNVxcdURDQzgnLCdTc2NyJzonXFx1RDgzNVxcdURDQUUnLCdzc2V0bW4nOidcXHUyMjE2Jywnc3NtaWxlJzonXFx1MjMyMycsJ3NzdGFyZic6J1xcdTIyQzYnLCdzdGFyJzonXFx1MjYwNicsJ1N0YXInOidcXHUyMkM2Jywnc3RhcmYnOidcXHUyNjA1Jywnc3RyYWlnaHRlcHNpbG9uJzonXFx1MDNGNScsJ3N0cmFpZ2h0cGhpJzonXFx1MDNENScsJ3N0cm5zJzonXFx4QUYnLCdzdWInOidcXHUyMjgyJywnU3ViJzonXFx1MjJEMCcsJ3N1YmRvdCc6J1xcdTJBQkQnLCdzdWJlJzonXFx1MjI4NicsJ3N1YkUnOidcXHUyQUM1Jywnc3ViZWRvdCc6J1xcdTJBQzMnLCdzdWJtdWx0JzonXFx1MkFDMScsJ3N1Ym5lJzonXFx1MjI4QScsJ3N1Ym5FJzonXFx1MkFDQicsJ3N1YnBsdXMnOidcXHUyQUJGJywnc3VicmFycic6J1xcdTI5NzknLCdzdWJzZXQnOidcXHUyMjgyJywnU3Vic2V0JzonXFx1MjJEMCcsJ3N1YnNldGVxJzonXFx1MjI4NicsJ3N1YnNldGVxcSc6J1xcdTJBQzUnLCdTdWJzZXRFcXVhbCc6J1xcdTIyODYnLCdzdWJzZXRuZXEnOidcXHUyMjhBJywnc3Vic2V0bmVxcSc6J1xcdTJBQ0InLCdzdWJzaW0nOidcXHUyQUM3Jywnc3Vic3ViJzonXFx1MkFENScsJ3N1YnN1cCc6J1xcdTJBRDMnLCdzdWNjJzonXFx1MjI3QicsJ3N1Y2NhcHByb3gnOidcXHUyQUI4Jywnc3VjY2N1cmx5ZXEnOidcXHUyMjdEJywnU3VjY2VlZHMnOidcXHUyMjdCJywnU3VjY2VlZHNFcXVhbCc6J1xcdTJBQjAnLCdTdWNjZWVkc1NsYW50RXF1YWwnOidcXHUyMjdEJywnU3VjY2VlZHNUaWxkZSc6J1xcdTIyN0YnLCdzdWNjZXEnOidcXHUyQUIwJywnc3VjY25hcHByb3gnOidcXHUyQUJBJywnc3VjY25lcXEnOidcXHUyQUI2Jywnc3VjY25zaW0nOidcXHUyMkU5Jywnc3VjY3NpbSc6J1xcdTIyN0YnLCdTdWNoVGhhdCc6J1xcdTIyMEInLCdzdW0nOidcXHUyMjExJywnU3VtJzonXFx1MjIxMScsJ3N1bmcnOidcXHUyNjZBJywnc3VwJzonXFx1MjI4MycsJ1N1cCc6J1xcdTIyRDEnLCdzdXAxJzonXFx4QjknLCdzdXAyJzonXFx4QjInLCdzdXAzJzonXFx4QjMnLCdzdXBkb3QnOidcXHUyQUJFJywnc3VwZHN1Yic6J1xcdTJBRDgnLCdzdXBlJzonXFx1MjI4NycsJ3N1cEUnOidcXHUyQUM2Jywnc3VwZWRvdCc6J1xcdTJBQzQnLCdTdXBlcnNldCc6J1xcdTIyODMnLCdTdXBlcnNldEVxdWFsJzonXFx1MjI4NycsJ3N1cGhzb2wnOidcXHUyN0M5Jywnc3VwaHN1Yic6J1xcdTJBRDcnLCdzdXBsYXJyJzonXFx1Mjk3QicsJ3N1cG11bHQnOidcXHUyQUMyJywnc3VwbmUnOidcXHUyMjhCJywnc3VwbkUnOidcXHUyQUNDJywnc3VwcGx1cyc6J1xcdTJBQzAnLCdzdXBzZXQnOidcXHUyMjgzJywnU3Vwc2V0JzonXFx1MjJEMScsJ3N1cHNldGVxJzonXFx1MjI4NycsJ3N1cHNldGVxcSc6J1xcdTJBQzYnLCdzdXBzZXRuZXEnOidcXHUyMjhCJywnc3Vwc2V0bmVxcSc6J1xcdTJBQ0MnLCdzdXBzaW0nOidcXHUyQUM4Jywnc3Vwc3ViJzonXFx1MkFENCcsJ3N1cHN1cCc6J1xcdTJBRDYnLCdzd2FyaGsnOidcXHUyOTI2Jywnc3dhcnInOidcXHUyMTk5Jywnc3dBcnInOidcXHUyMUQ5Jywnc3dhcnJvdyc6J1xcdTIxOTknLCdzd253YXInOidcXHUyOTJBJywnc3psaWcnOidcXHhERicsJ1RhYic6J1xcdCcsJ3RhcmdldCc6J1xcdTIzMTYnLCd0YXUnOidcXHUwM0M0JywnVGF1JzonXFx1MDNBNCcsJ3RicmsnOidcXHUyM0I0JywndGNhcm9uJzonXFx1MDE2NScsJ1RjYXJvbic6J1xcdTAxNjQnLCd0Y2VkaWwnOidcXHUwMTYzJywnVGNlZGlsJzonXFx1MDE2MicsJ3RjeSc6J1xcdTA0NDInLCdUY3knOidcXHUwNDIyJywndGRvdCc6J1xcdTIwREInLCd0ZWxyZWMnOidcXHUyMzE1JywndGZyJzonXFx1RDgzNVxcdUREMzEnLCdUZnInOidcXHVEODM1XFx1REQxNycsJ3RoZXJlNCc6J1xcdTIyMzQnLCd0aGVyZWZvcmUnOidcXHUyMjM0JywnVGhlcmVmb3JlJzonXFx1MjIzNCcsJ3RoZXRhJzonXFx1MDNCOCcsJ1RoZXRhJzonXFx1MDM5OCcsJ3RoZXRhc3ltJzonXFx1MDNEMScsJ3RoZXRhdic6J1xcdTAzRDEnLCd0aGlja2FwcHJveCc6J1xcdTIyNDgnLCd0aGlja3NpbSc6J1xcdTIyM0MnLCdUaGlja1NwYWNlJzonXFx1MjA1RlxcdTIwMEEnLCd0aGluc3AnOidcXHUyMDA5JywnVGhpblNwYWNlJzonXFx1MjAwOScsJ3Roa2FwJzonXFx1MjI0OCcsJ3Roa3NpbSc6J1xcdTIyM0MnLCd0aG9ybic6J1xceEZFJywnVEhPUk4nOidcXHhERScsJ3RpbGRlJzonXFx1MDJEQycsJ1RpbGRlJzonXFx1MjIzQycsJ1RpbGRlRXF1YWwnOidcXHUyMjQzJywnVGlsZGVGdWxsRXF1YWwnOidcXHUyMjQ1JywnVGlsZGVUaWxkZSc6J1xcdTIyNDgnLCd0aW1lcyc6J1xceEQ3JywndGltZXNiJzonXFx1MjJBMCcsJ3RpbWVzYmFyJzonXFx1MkEzMScsJ3RpbWVzZCc6J1xcdTJBMzAnLCd0aW50JzonXFx1MjIyRCcsJ3RvZWEnOidcXHUyOTI4JywndG9wJzonXFx1MjJBNCcsJ3RvcGJvdCc6J1xcdTIzMzYnLCd0b3BjaXInOidcXHUyQUYxJywndG9wZic6J1xcdUQ4MzVcXHVERDY1JywnVG9wZic6J1xcdUQ4MzVcXHVERDRCJywndG9wZm9yayc6J1xcdTJBREEnLCd0b3NhJzonXFx1MjkyOScsJ3RwcmltZSc6J1xcdTIwMzQnLCd0cmFkZSc6J1xcdTIxMjInLCdUUkFERSc6J1xcdTIxMjInLCd0cmlhbmdsZSc6J1xcdTI1QjUnLCd0cmlhbmdsZWRvd24nOidcXHUyNUJGJywndHJpYW5nbGVsZWZ0JzonXFx1MjVDMycsJ3RyaWFuZ2xlbGVmdGVxJzonXFx1MjJCNCcsJ3RyaWFuZ2xlcSc6J1xcdTIyNUMnLCd0cmlhbmdsZXJpZ2h0JzonXFx1MjVCOScsJ3RyaWFuZ2xlcmlnaHRlcSc6J1xcdTIyQjUnLCd0cmlkb3QnOidcXHUyNUVDJywndHJpZSc6J1xcdTIyNUMnLCd0cmltaW51cyc6J1xcdTJBM0EnLCdUcmlwbGVEb3QnOidcXHUyMERCJywndHJpcGx1cyc6J1xcdTJBMzknLCd0cmlzYic6J1xcdTI5Q0QnLCd0cml0aW1lJzonXFx1MkEzQicsJ3RycGV6aXVtJzonXFx1MjNFMicsJ3RzY3InOidcXHVEODM1XFx1RENDOScsJ1RzY3InOidcXHVEODM1XFx1RENBRicsJ3RzY3knOidcXHUwNDQ2JywnVFNjeSc6J1xcdTA0MjYnLCd0c2hjeSc6J1xcdTA0NUInLCdUU0hjeSc6J1xcdTA0MEInLCd0c3Ryb2snOidcXHUwMTY3JywnVHN0cm9rJzonXFx1MDE2NicsJ3R3aXh0JzonXFx1MjI2QycsJ3R3b2hlYWRsZWZ0YXJyb3cnOidcXHUyMTlFJywndHdvaGVhZHJpZ2h0YXJyb3cnOidcXHUyMUEwJywndWFjdXRlJzonXFx4RkEnLCdVYWN1dGUnOidcXHhEQScsJ3VhcnInOidcXHUyMTkxJywndUFycic6J1xcdTIxRDEnLCdVYXJyJzonXFx1MjE5RicsJ1VhcnJvY2lyJzonXFx1Mjk0OScsJ3VicmN5JzonXFx1MDQ1RScsJ1VicmN5JzonXFx1MDQwRScsJ3VicmV2ZSc6J1xcdTAxNkQnLCdVYnJldmUnOidcXHUwMTZDJywndWNpcmMnOidcXHhGQicsJ1VjaXJjJzonXFx4REInLCd1Y3knOidcXHUwNDQzJywnVWN5JzonXFx1MDQyMycsJ3VkYXJyJzonXFx1MjFDNScsJ3VkYmxhYyc6J1xcdTAxNzEnLCdVZGJsYWMnOidcXHUwMTcwJywndWRoYXInOidcXHUyOTZFJywndWZpc2h0JzonXFx1Mjk3RScsJ3Vmcic6J1xcdUQ4MzVcXHVERDMyJywnVWZyJzonXFx1RDgzNVxcdUREMTgnLCd1Z3JhdmUnOidcXHhGOScsJ1VncmF2ZSc6J1xceEQ5JywndUhhcic6J1xcdTI5NjMnLCd1aGFybCc6J1xcdTIxQkYnLCd1aGFycic6J1xcdTIxQkUnLCd1aGJsayc6J1xcdTI1ODAnLCd1bGNvcm4nOidcXHUyMzFDJywndWxjb3JuZXInOidcXHUyMzFDJywndWxjcm9wJzonXFx1MjMwRicsJ3VsdHJpJzonXFx1MjVGOCcsJ3VtYWNyJzonXFx1MDE2QicsJ1VtYWNyJzonXFx1MDE2QScsJ3VtbCc6J1xceEE4JywnVW5kZXJCYXInOidfJywnVW5kZXJCcmFjZSc6J1xcdTIzREYnLCdVbmRlckJyYWNrZXQnOidcXHUyM0I1JywnVW5kZXJQYXJlbnRoZXNpcyc6J1xcdTIzREQnLCdVbmlvbic6J1xcdTIyQzMnLCdVbmlvblBsdXMnOidcXHUyMjhFJywndW9nb24nOidcXHUwMTczJywnVW9nb24nOidcXHUwMTcyJywndW9wZic6J1xcdUQ4MzVcXHVERDY2JywnVW9wZic6J1xcdUQ4MzVcXHVERDRDJywndXBhcnJvdyc6J1xcdTIxOTEnLCdVcGFycm93JzonXFx1MjFEMScsJ1VwQXJyb3cnOidcXHUyMTkxJywnVXBBcnJvd0Jhcic6J1xcdTI5MTInLCdVcEFycm93RG93bkFycm93JzonXFx1MjFDNScsJ3VwZG93bmFycm93JzonXFx1MjE5NScsJ1VwZG93bmFycm93JzonXFx1MjFENScsJ1VwRG93bkFycm93JzonXFx1MjE5NScsJ1VwRXF1aWxpYnJpdW0nOidcXHUyOTZFJywndXBoYXJwb29ubGVmdCc6J1xcdTIxQkYnLCd1cGhhcnBvb25yaWdodCc6J1xcdTIxQkUnLCd1cGx1cyc6J1xcdTIyOEUnLCdVcHBlckxlZnRBcnJvdyc6J1xcdTIxOTYnLCdVcHBlclJpZ2h0QXJyb3cnOidcXHUyMTk3JywndXBzaSc6J1xcdTAzQzUnLCdVcHNpJzonXFx1MDNEMicsJ3Vwc2loJzonXFx1MDNEMicsJ3Vwc2lsb24nOidcXHUwM0M1JywnVXBzaWxvbic6J1xcdTAzQTUnLCdVcFRlZSc6J1xcdTIyQTUnLCdVcFRlZUFycm93JzonXFx1MjFBNScsJ3VwdXBhcnJvd3MnOidcXHUyMUM4JywndXJjb3JuJzonXFx1MjMxRCcsJ3VyY29ybmVyJzonXFx1MjMxRCcsJ3VyY3JvcCc6J1xcdTIzMEUnLCd1cmluZyc6J1xcdTAxNkYnLCdVcmluZyc6J1xcdTAxNkUnLCd1cnRyaSc6J1xcdTI1RjknLCd1c2NyJzonXFx1RDgzNVxcdURDQ0EnLCdVc2NyJzonXFx1RDgzNVxcdURDQjAnLCd1dGRvdCc6J1xcdTIyRjAnLCd1dGlsZGUnOidcXHUwMTY5JywnVXRpbGRlJzonXFx1MDE2OCcsJ3V0cmknOidcXHUyNUI1JywndXRyaWYnOidcXHUyNUI0JywndXVhcnInOidcXHUyMUM4JywndXVtbCc6J1xceEZDJywnVXVtbCc6J1xceERDJywndXdhbmdsZSc6J1xcdTI5QTcnLCd2YW5ncnQnOidcXHUyOTlDJywndmFyZXBzaWxvbic6J1xcdTAzRjUnLCd2YXJrYXBwYSc6J1xcdTAzRjAnLCd2YXJub3RoaW5nJzonXFx1MjIwNScsJ3ZhcnBoaSc6J1xcdTAzRDUnLCd2YXJwaSc6J1xcdTAzRDYnLCd2YXJwcm9wdG8nOidcXHUyMjFEJywndmFycic6J1xcdTIxOTUnLCd2QXJyJzonXFx1MjFENScsJ3ZhcnJobyc6J1xcdTAzRjEnLCd2YXJzaWdtYSc6J1xcdTAzQzInLCd2YXJzdWJzZXRuZXEnOidcXHUyMjhBXFx1RkUwMCcsJ3ZhcnN1YnNldG5lcXEnOidcXHUyQUNCXFx1RkUwMCcsJ3ZhcnN1cHNldG5lcSc6J1xcdTIyOEJcXHVGRTAwJywndmFyc3Vwc2V0bmVxcSc6J1xcdTJBQ0NcXHVGRTAwJywndmFydGhldGEnOidcXHUwM0QxJywndmFydHJpYW5nbGVsZWZ0JzonXFx1MjJCMicsJ3ZhcnRyaWFuZ2xlcmlnaHQnOidcXHUyMkIzJywndkJhcic6J1xcdTJBRTgnLCdWYmFyJzonXFx1MkFFQicsJ3ZCYXJ2JzonXFx1MkFFOScsJ3ZjeSc6J1xcdTA0MzInLCdWY3knOidcXHUwNDEyJywndmRhc2gnOidcXHUyMkEyJywndkRhc2gnOidcXHUyMkE4JywnVmRhc2gnOidcXHUyMkE5JywnVkRhc2gnOidcXHUyMkFCJywnVmRhc2hsJzonXFx1MkFFNicsJ3ZlZSc6J1xcdTIyMjgnLCdWZWUnOidcXHUyMkMxJywndmVlYmFyJzonXFx1MjJCQicsJ3ZlZWVxJzonXFx1MjI1QScsJ3ZlbGxpcCc6J1xcdTIyRUUnLCd2ZXJiYXInOid8JywnVmVyYmFyJzonXFx1MjAxNicsJ3ZlcnQnOid8JywnVmVydCc6J1xcdTIwMTYnLCdWZXJ0aWNhbEJhcic6J1xcdTIyMjMnLCdWZXJ0aWNhbExpbmUnOid8JywnVmVydGljYWxTZXBhcmF0b3InOidcXHUyNzU4JywnVmVydGljYWxUaWxkZSc6J1xcdTIyNDAnLCdWZXJ5VGhpblNwYWNlJzonXFx1MjAwQScsJ3Zmcic6J1xcdUQ4MzVcXHVERDMzJywnVmZyJzonXFx1RDgzNVxcdUREMTknLCd2bHRyaSc6J1xcdTIyQjInLCd2bnN1Yic6J1xcdTIyODJcXHUyMEQyJywndm5zdXAnOidcXHUyMjgzXFx1MjBEMicsJ3ZvcGYnOidcXHVEODM1XFx1REQ2NycsJ1ZvcGYnOidcXHVEODM1XFx1REQ0RCcsJ3Zwcm9wJzonXFx1MjIxRCcsJ3ZydHJpJzonXFx1MjJCMycsJ3ZzY3InOidcXHVEODM1XFx1RENDQicsJ1ZzY3InOidcXHVEODM1XFx1RENCMScsJ3ZzdWJuZSc6J1xcdTIyOEFcXHVGRTAwJywndnN1Ym5FJzonXFx1MkFDQlxcdUZFMDAnLCd2c3VwbmUnOidcXHUyMjhCXFx1RkUwMCcsJ3ZzdXBuRSc6J1xcdTJBQ0NcXHVGRTAwJywnVnZkYXNoJzonXFx1MjJBQScsJ3Z6aWd6YWcnOidcXHUyOTlBJywnd2NpcmMnOidcXHUwMTc1JywnV2NpcmMnOidcXHUwMTc0Jywnd2VkYmFyJzonXFx1MkE1RicsJ3dlZGdlJzonXFx1MjIyNycsJ1dlZGdlJzonXFx1MjJDMCcsJ3dlZGdlcSc6J1xcdTIyNTknLCd3ZWllcnAnOidcXHUyMTE4Jywnd2ZyJzonXFx1RDgzNVxcdUREMzQnLCdXZnInOidcXHVEODM1XFx1REQxQScsJ3dvcGYnOidcXHVEODM1XFx1REQ2OCcsJ1dvcGYnOidcXHVEODM1XFx1REQ0RScsJ3dwJzonXFx1MjExOCcsJ3dyJzonXFx1MjI0MCcsJ3dyZWF0aCc6J1xcdTIyNDAnLCd3c2NyJzonXFx1RDgzNVxcdURDQ0MnLCdXc2NyJzonXFx1RDgzNVxcdURDQjInLCd4Y2FwJzonXFx1MjJDMicsJ3hjaXJjJzonXFx1MjVFRicsJ3hjdXAnOidcXHUyMkMzJywneGR0cmknOidcXHUyNUJEJywneGZyJzonXFx1RDgzNVxcdUREMzUnLCdYZnInOidcXHVEODM1XFx1REQxQicsJ3hoYXJyJzonXFx1MjdGNycsJ3hoQXJyJzonXFx1MjdGQScsJ3hpJzonXFx1MDNCRScsJ1hpJzonXFx1MDM5RScsJ3hsYXJyJzonXFx1MjdGNScsJ3hsQXJyJzonXFx1MjdGOCcsJ3htYXAnOidcXHUyN0ZDJywneG5pcyc6J1xcdTIyRkInLCd4b2RvdCc6J1xcdTJBMDAnLCd4b3BmJzonXFx1RDgzNVxcdURENjknLCdYb3BmJzonXFx1RDgzNVxcdURENEYnLCd4b3BsdXMnOidcXHUyQTAxJywneG90aW1lJzonXFx1MkEwMicsJ3hyYXJyJzonXFx1MjdGNicsJ3hyQXJyJzonXFx1MjdGOScsJ3hzY3InOidcXHVEODM1XFx1RENDRCcsJ1hzY3InOidcXHVEODM1XFx1RENCMycsJ3hzcWN1cCc6J1xcdTJBMDYnLCd4dXBsdXMnOidcXHUyQTA0JywneHV0cmknOidcXHUyNUIzJywneHZlZSc6J1xcdTIyQzEnLCd4d2VkZ2UnOidcXHUyMkMwJywneWFjdXRlJzonXFx4RkQnLCdZYWN1dGUnOidcXHhERCcsJ3lhY3knOidcXHUwNDRGJywnWUFjeSc6J1xcdTA0MkYnLCd5Y2lyYyc6J1xcdTAxNzcnLCdZY2lyYyc6J1xcdTAxNzYnLCd5Y3knOidcXHUwNDRCJywnWWN5JzonXFx1MDQyQicsJ3llbic6J1xceEE1JywneWZyJzonXFx1RDgzNVxcdUREMzYnLCdZZnInOidcXHVEODM1XFx1REQxQycsJ3lpY3knOidcXHUwNDU3JywnWUljeSc6J1xcdTA0MDcnLCd5b3BmJzonXFx1RDgzNVxcdURENkEnLCdZb3BmJzonXFx1RDgzNVxcdURENTAnLCd5c2NyJzonXFx1RDgzNVxcdURDQ0UnLCdZc2NyJzonXFx1RDgzNVxcdURDQjQnLCd5dWN5JzonXFx1MDQ0RScsJ1lVY3knOidcXHUwNDJFJywneXVtbCc6J1xceEZGJywnWXVtbCc6J1xcdTAxNzgnLCd6YWN1dGUnOidcXHUwMTdBJywnWmFjdXRlJzonXFx1MDE3OScsJ3pjYXJvbic6J1xcdTAxN0UnLCdaY2Fyb24nOidcXHUwMTdEJywnemN5JzonXFx1MDQzNycsJ1pjeSc6J1xcdTA0MTcnLCd6ZG90JzonXFx1MDE3QycsJ1pkb3QnOidcXHUwMTdCJywnemVldHJmJzonXFx1MjEyOCcsJ1plcm9XaWR0aFNwYWNlJzonXFx1MjAwQicsJ3pldGEnOidcXHUwM0I2JywnWmV0YSc6J1xcdTAzOTYnLCd6ZnInOidcXHVEODM1XFx1REQzNycsJ1pmcic6J1xcdTIxMjgnLCd6aGN5JzonXFx1MDQzNicsJ1pIY3knOidcXHUwNDE2JywnemlncmFycic6J1xcdTIxREQnLCd6b3BmJzonXFx1RDgzNVxcdURENkInLCdab3BmJzonXFx1MjEyNCcsJ3pzY3InOidcXHVEODM1XFx1RENDRicsJ1pzY3InOidcXHVEODM1XFx1RENCNScsJ3p3aic6J1xcdTIwMEQnLCd6d25qJzonXFx1MjAwQyd9O1xuXHR2YXIgZGVjb2RlTWFwTGVnYWN5ID0geydhYWN1dGUnOidcXHhFMScsJ0FhY3V0ZSc6J1xceEMxJywnYWNpcmMnOidcXHhFMicsJ0FjaXJjJzonXFx4QzInLCdhY3V0ZSc6J1xceEI0JywnYWVsaWcnOidcXHhFNicsJ0FFbGlnJzonXFx4QzYnLCdhZ3JhdmUnOidcXHhFMCcsJ0FncmF2ZSc6J1xceEMwJywnYW1wJzonJicsJ0FNUCc6JyYnLCdhcmluZyc6J1xceEU1JywnQXJpbmcnOidcXHhDNScsJ2F0aWxkZSc6J1xceEUzJywnQXRpbGRlJzonXFx4QzMnLCdhdW1sJzonXFx4RTQnLCdBdW1sJzonXFx4QzQnLCdicnZiYXInOidcXHhBNicsJ2NjZWRpbCc6J1xceEU3JywnQ2NlZGlsJzonXFx4QzcnLCdjZWRpbCc6J1xceEI4JywnY2VudCc6J1xceEEyJywnY29weSc6J1xceEE5JywnQ09QWSc6J1xceEE5JywnY3VycmVuJzonXFx4QTQnLCdkZWcnOidcXHhCMCcsJ2RpdmlkZSc6J1xceEY3JywnZWFjdXRlJzonXFx4RTknLCdFYWN1dGUnOidcXHhDOScsJ2VjaXJjJzonXFx4RUEnLCdFY2lyYyc6J1xceENBJywnZWdyYXZlJzonXFx4RTgnLCdFZ3JhdmUnOidcXHhDOCcsJ2V0aCc6J1xceEYwJywnRVRIJzonXFx4RDAnLCdldW1sJzonXFx4RUInLCdFdW1sJzonXFx4Q0InLCdmcmFjMTInOidcXHhCRCcsJ2ZyYWMxNCc6J1xceEJDJywnZnJhYzM0JzonXFx4QkUnLCdndCc6Jz4nLCdHVCc6Jz4nLCdpYWN1dGUnOidcXHhFRCcsJ0lhY3V0ZSc6J1xceENEJywnaWNpcmMnOidcXHhFRScsJ0ljaXJjJzonXFx4Q0UnLCdpZXhjbCc6J1xceEExJywnaWdyYXZlJzonXFx4RUMnLCdJZ3JhdmUnOidcXHhDQycsJ2lxdWVzdCc6J1xceEJGJywnaXVtbCc6J1xceEVGJywnSXVtbCc6J1xceENGJywnbGFxdW8nOidcXHhBQicsJ2x0JzonPCcsJ0xUJzonPCcsJ21hY3InOidcXHhBRicsJ21pY3JvJzonXFx4QjUnLCdtaWRkb3QnOidcXHhCNycsJ25ic3AnOidcXHhBMCcsJ25vdCc6J1xceEFDJywnbnRpbGRlJzonXFx4RjEnLCdOdGlsZGUnOidcXHhEMScsJ29hY3V0ZSc6J1xceEYzJywnT2FjdXRlJzonXFx4RDMnLCdvY2lyYyc6J1xceEY0JywnT2NpcmMnOidcXHhENCcsJ29ncmF2ZSc6J1xceEYyJywnT2dyYXZlJzonXFx4RDInLCdvcmRmJzonXFx4QUEnLCdvcmRtJzonXFx4QkEnLCdvc2xhc2gnOidcXHhGOCcsJ09zbGFzaCc6J1xceEQ4Jywnb3RpbGRlJzonXFx4RjUnLCdPdGlsZGUnOidcXHhENScsJ291bWwnOidcXHhGNicsJ091bWwnOidcXHhENicsJ3BhcmEnOidcXHhCNicsJ3BsdXNtbic6J1xceEIxJywncG91bmQnOidcXHhBMycsJ3F1b3QnOidcIicsJ1FVT1QnOidcIicsJ3JhcXVvJzonXFx4QkInLCdyZWcnOidcXHhBRScsJ1JFRyc6J1xceEFFJywnc2VjdCc6J1xceEE3Jywnc2h5JzonXFx4QUQnLCdzdXAxJzonXFx4QjknLCdzdXAyJzonXFx4QjInLCdzdXAzJzonXFx4QjMnLCdzemxpZyc6J1xceERGJywndGhvcm4nOidcXHhGRScsJ1RIT1JOJzonXFx4REUnLCd0aW1lcyc6J1xceEQ3JywndWFjdXRlJzonXFx4RkEnLCdVYWN1dGUnOidcXHhEQScsJ3VjaXJjJzonXFx4RkInLCdVY2lyYyc6J1xceERCJywndWdyYXZlJzonXFx4RjknLCdVZ3JhdmUnOidcXHhEOScsJ3VtbCc6J1xceEE4JywndXVtbCc6J1xceEZDJywnVXVtbCc6J1xceERDJywneWFjdXRlJzonXFx4RkQnLCdZYWN1dGUnOidcXHhERCcsJ3llbic6J1xceEE1JywneXVtbCc6J1xceEZGJ307XG5cdHZhciBkZWNvZGVNYXBOdW1lcmljID0geycwJzonXFx1RkZGRCcsJzEyOCc6J1xcdTIwQUMnLCcxMzAnOidcXHUyMDFBJywnMTMxJzonXFx1MDE5MicsJzEzMic6J1xcdTIwMUUnLCcxMzMnOidcXHUyMDI2JywnMTM0JzonXFx1MjAyMCcsJzEzNSc6J1xcdTIwMjEnLCcxMzYnOidcXHUwMkM2JywnMTM3JzonXFx1MjAzMCcsJzEzOCc6J1xcdTAxNjAnLCcxMzknOidcXHUyMDM5JywnMTQwJzonXFx1MDE1MicsJzE0Mic6J1xcdTAxN0QnLCcxNDUnOidcXHUyMDE4JywnMTQ2JzonXFx1MjAxOScsJzE0Nyc6J1xcdTIwMUMnLCcxNDgnOidcXHUyMDFEJywnMTQ5JzonXFx1MjAyMicsJzE1MCc6J1xcdTIwMTMnLCcxNTEnOidcXHUyMDE0JywnMTUyJzonXFx1MDJEQycsJzE1Myc6J1xcdTIxMjInLCcxNTQnOidcXHUwMTYxJywnMTU1JzonXFx1MjAzQScsJzE1Nic6J1xcdTAxNTMnLCcxNTgnOidcXHUwMTdFJywnMTU5JzonXFx1MDE3OCd9O1xuXHR2YXIgaW52YWxpZFJlZmVyZW5jZUNvZGVQb2ludHMgPSBbMSwyLDMsNCw1LDYsNyw4LDExLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDEyNywxMjgsMTI5LDEzMCwxMzEsMTMyLDEzMywxMzQsMTM1LDEzNiwxMzcsMTM4LDEzOSwxNDAsMTQxLDE0MiwxNDMsMTQ0LDE0NSwxNDYsMTQ3LDE0OCwxNDksMTUwLDE1MSwxNTIsMTUzLDE1NCwxNTUsMTU2LDE1NywxNTgsMTU5LDY0OTc2LDY0OTc3LDY0OTc4LDY0OTc5LDY0OTgwLDY0OTgxLDY0OTgyLDY0OTgzLDY0OTg0LDY0OTg1LDY0OTg2LDY0OTg3LDY0OTg4LDY0OTg5LDY0OTkwLDY0OTkxLDY0OTkyLDY0OTkzLDY0OTk0LDY0OTk1LDY0OTk2LDY0OTk3LDY0OTk4LDY0OTk5LDY1MDAwLDY1MDAxLDY1MDAyLDY1MDAzLDY1MDA0LDY1MDA1LDY1MDA2LDY1MDA3LDY1NTM0LDY1NTM1LDEzMTA3MCwxMzEwNzEsMTk2NjA2LDE5NjYwNywyNjIxNDIsMjYyMTQzLDMyNzY3OCwzMjc2NzksMzkzMjE0LDM5MzIxNSw0NTg3NTAsNDU4NzUxLDUyNDI4Niw1MjQyODcsNTg5ODIyLDU4OTgyMyw2NTUzNTgsNjU1MzU5LDcyMDg5NCw3MjA4OTUsNzg2NDMwLDc4NjQzMSw4NTE5NjYsODUxOTY3LDkxNzUwMiw5MTc1MDMsOTgzMDM4LDk4MzAzOSwxMDQ4NTc0LDEwNDg1NzUsMTExNDExMCwxMTE0MTExXTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuXHR2YXIgb2JqZWN0ID0ge307XG5cdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcblx0dmFyIGhhcyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHlOYW1lKSB7XG5cdFx0cmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eU5hbWUpO1xuXHR9O1xuXG5cdHZhciBjb250YWlucyA9IGZ1bmN0aW9uKGFycmF5LCB2YWx1ZSkge1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdGlmIChhcnJheVtpbmRleF0gPT0gdmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHR2YXIgbWVyZ2UgPSBmdW5jdGlvbihvcHRpb25zLCBkZWZhdWx0cykge1xuXHRcdGlmICghb3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIGRlZmF1bHRzO1xuXHRcdH1cblx0XHR2YXIgcmVzdWx0ID0ge307XG5cdFx0dmFyIGtleTtcblx0XHRmb3IgKGtleSBpbiBkZWZhdWx0cykge1xuXHRcdFx0Ly8gQSBgaGFzT3duUHJvcGVydHlgIGNoZWNrIGlzIG5vdCBuZWVkZWQgaGVyZSwgc2luY2Ugb25seSByZWNvZ25pemVkXG5cdFx0XHQvLyBvcHRpb24gbmFtZXMgYXJlIHVzZWQgYW55d2F5LiBBbnkgb3RoZXJzIGFyZSBpZ25vcmVkLlxuXHRcdFx0cmVzdWx0W2tleV0gPSBoYXMob3B0aW9ucywga2V5KSA/IG9wdGlvbnNba2V5XSA6IGRlZmF1bHRzW2tleV07XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0Ly8gTW9kaWZpZWQgdmVyc2lvbiBvZiBgdWNzMmVuY29kZWA7IHNlZSBodHRwczovL210aHMuYmUvcHVueWNvZGUuXG5cdHZhciBjb2RlUG9pbnRUb1N5bWJvbCA9IGZ1bmN0aW9uKGNvZGVQb2ludCwgc3RyaWN0KSB7XG5cdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdGlmICgoY29kZVBvaW50ID49IDB4RDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhERkZGKSB8fCBjb2RlUG9pbnQgPiAweDEwRkZGRikge1xuXHRcdFx0Ly8gU2VlIGlzc3VlICM0OlxuXHRcdFx0Ly8g4oCcT3RoZXJ3aXNlLCBpZiB0aGUgbnVtYmVyIGlzIGluIHRoZSByYW5nZSAweEQ4MDAgdG8gMHhERkZGIG9yIGlzXG5cdFx0XHQvLyBncmVhdGVyIHRoYW4gMHgxMEZGRkYsIHRoZW4gdGhpcyBpcyBhIHBhcnNlIGVycm9yLiBSZXR1cm4gYSBVK0ZGRkRcblx0XHRcdC8vIFJFUExBQ0VNRU5UIENIQVJBQ1RFUi7igJ1cblx0XHRcdGlmIChzdHJpY3QpIHtcblx0XHRcdFx0cGFyc2VFcnJvcignY2hhcmFjdGVyIHJlZmVyZW5jZSBvdXRzaWRlIHRoZSBwZXJtaXNzaWJsZSBVbmljb2RlIHJhbmdlJyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJ1xcdUZGRkQnO1xuXHRcdH1cblx0XHRpZiAoaGFzKGRlY29kZU1hcE51bWVyaWMsIGNvZGVQb2ludCkpIHtcblx0XHRcdGlmIChzdHJpY3QpIHtcblx0XHRcdFx0cGFyc2VFcnJvcignZGlzYWxsb3dlZCBjaGFyYWN0ZXIgcmVmZXJlbmNlJyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGVjb2RlTWFwTnVtZXJpY1tjb2RlUG9pbnRdO1xuXHRcdH1cblx0XHRpZiAoc3RyaWN0ICYmIGNvbnRhaW5zKGludmFsaWRSZWZlcmVuY2VDb2RlUG9pbnRzLCBjb2RlUG9pbnQpKSB7XG5cdFx0XHRwYXJzZUVycm9yKCdkaXNhbGxvd2VkIGNoYXJhY3RlciByZWZlcmVuY2UnKTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuXHRcdFx0Y29kZVBvaW50IC09IDB4MTAwMDA7XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRjtcblx0XHR9XG5cdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH07XG5cblx0dmFyIGhleEVzY2FwZSA9IGZ1bmN0aW9uKGNvZGVQb2ludCkge1xuXHRcdHJldHVybiAnJiN4JyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArICc7Jztcblx0fTtcblxuXHR2YXIgZGVjRXNjYXBlID0gZnVuY3Rpb24oY29kZVBvaW50KSB7XG5cdFx0cmV0dXJuICcmIycgKyBjb2RlUG9pbnQgKyAnOyc7XG5cdH07XG5cblx0dmFyIHBhcnNlRXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdFx0dGhyb3cgRXJyb3IoJ1BhcnNlIGVycm9yOiAnICsgbWVzc2FnZSk7XG5cdH07XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIGVuY29kZSA9IGZ1bmN0aW9uKHN0cmluZywgb3B0aW9ucykge1xuXHRcdG9wdGlvbnMgPSBtZXJnZShvcHRpb25zLCBlbmNvZGUub3B0aW9ucyk7XG5cdFx0dmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xuXHRcdGlmIChzdHJpY3QgJiYgcmVnZXhJbnZhbGlkUmF3Q29kZVBvaW50LnRlc3Qoc3RyaW5nKSkge1xuXHRcdFx0cGFyc2VFcnJvcignZm9yYmlkZGVuIGNvZGUgcG9pbnQnKTtcblx0XHR9XG5cdFx0dmFyIGVuY29kZUV2ZXJ5dGhpbmcgPSBvcHRpb25zLmVuY29kZUV2ZXJ5dGhpbmc7XG5cdFx0dmFyIHVzZU5hbWVkUmVmZXJlbmNlcyA9IG9wdGlvbnMudXNlTmFtZWRSZWZlcmVuY2VzO1xuXHRcdHZhciBhbGxvd1Vuc2FmZVN5bWJvbHMgPSBvcHRpb25zLmFsbG93VW5zYWZlU3ltYm9scztcblx0XHR2YXIgZXNjYXBlQ29kZVBvaW50ID0gb3B0aW9ucy5kZWNpbWFsID8gZGVjRXNjYXBlIDogaGV4RXNjYXBlO1xuXG5cdFx0dmFyIGVzY2FwZUJtcFN5bWJvbCA9IGZ1bmN0aW9uKHN5bWJvbCkge1xuXHRcdFx0cmV0dXJuIGVzY2FwZUNvZGVQb2ludChzeW1ib2wuY2hhckNvZGVBdCgwKSk7XG5cdFx0fTtcblxuXHRcdGlmIChlbmNvZGVFdmVyeXRoaW5nKSB7XG5cdFx0XHQvLyBFbmNvZGUgQVNDSUkgc3ltYm9scy5cblx0XHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4QXNjaWlXaGl0ZWxpc3QsIGZ1bmN0aW9uKHN5bWJvbCkge1xuXHRcdFx0XHQvLyBVc2UgbmFtZWQgcmVmZXJlbmNlcyBpZiByZXF1ZXN0ZWQgJiBwb3NzaWJsZS5cblx0XHRcdFx0aWYgKHVzZU5hbWVkUmVmZXJlbmNlcyAmJiBoYXMoZW5jb2RlTWFwLCBzeW1ib2wpKSB7XG5cdFx0XHRcdFx0cmV0dXJuICcmJyArIGVuY29kZU1hcFtzeW1ib2xdICsgJzsnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBlc2NhcGVCbXBTeW1ib2woc3ltYm9sKTtcblx0XHRcdH0pO1xuXHRcdFx0Ly8gU2hvcnRlbiBhIGZldyBlc2NhcGVzIHRoYXQgcmVwcmVzZW50IHR3byBzeW1ib2xzLCBvZiB3aGljaCBhdCBsZWFzdCBvbmVcblx0XHRcdC8vIGlzIHdpdGhpbiB0aGUgQVNDSUkgcmFuZ2UuXG5cdFx0XHRpZiAodXNlTmFtZWRSZWZlcmVuY2VzKSB7XG5cdFx0XHRcdHN0cmluZyA9IHN0cmluZ1xuXHRcdFx0XHRcdC5yZXBsYWNlKC8mZ3Q7XFx1MjBEMi9nLCAnJm52Z3Q7Jylcblx0XHRcdFx0XHQucmVwbGFjZSgvJmx0O1xcdTIwRDIvZywgJyZudmx0OycpXG5cdFx0XHRcdFx0LnJlcGxhY2UoLyYjeDY2OyYjeDZBOy9nLCAnJmZqbGlnOycpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRW5jb2RlIG5vbi1BU0NJSSBzeW1ib2xzLlxuXHRcdFx0aWYgKHVzZU5hbWVkUmVmZXJlbmNlcykge1xuXHRcdFx0XHQvLyBFbmNvZGUgbm9uLUFTQ0lJIHN5bWJvbHMgdGhhdCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIG5hbWVkIHJlZmVyZW5jZS5cblx0XHRcdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhFbmNvZGVOb25Bc2NpaSwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRcdFx0Ly8gTm90ZTogdGhlcmUgaXMgbm8gbmVlZCB0byBjaGVjayBgaGFzKGVuY29kZU1hcCwgc3RyaW5nKWAgaGVyZS5cblx0XHRcdFx0XHRyZXR1cm4gJyYnICsgZW5jb2RlTWFwW3N0cmluZ10gKyAnOyc7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTm90ZTogYW55IHJlbWFpbmluZyBub24tQVNDSUkgc3ltYm9scyBhcmUgaGFuZGxlZCBvdXRzaWRlIG9mIHRoZSBgaWZgLlxuXHRcdH0gZWxzZSBpZiAodXNlTmFtZWRSZWZlcmVuY2VzKSB7XG5cdFx0XHQvLyBBcHBseSBuYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlcy5cblx0XHRcdC8vIEVuY29kZSBgPD5cIicmYCB1c2luZyBuYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlcy5cblx0XHRcdGlmICghYWxsb3dVbnNhZmVTeW1ib2xzKSB7XG5cdFx0XHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4RXNjYXBlLCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyYnICsgZW5jb2RlTWFwW3N0cmluZ10gKyAnOyc7IC8vIG5vIG5lZWQgdG8gY2hlY2sgYGhhcygpYCBoZXJlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU2hvcnRlbiBlc2NhcGVzIHRoYXQgcmVwcmVzZW50IHR3byBzeW1ib2xzLCBvZiB3aGljaCBhdCBsZWFzdCBvbmUgaXNcblx0XHRcdC8vIGA8PlwiJyZgLlxuXHRcdFx0c3RyaW5nID0gc3RyaW5nXG5cdFx0XHRcdC5yZXBsYWNlKC8mZ3Q7XFx1MjBEMi9nLCAnJm52Z3Q7Jylcblx0XHRcdFx0LnJlcGxhY2UoLyZsdDtcXHUyMEQyL2csICcmbnZsdDsnKTtcblx0XHRcdC8vIEVuY29kZSBub24tQVNDSUkgc3ltYm9scyB0aGF0IGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgbmFtZWQgcmVmZXJlbmNlLlxuXHRcdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhFbmNvZGVOb25Bc2NpaSwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRcdC8vIE5vdGU6IHRoZXJlIGlzIG5vIG5lZWQgdG8gY2hlY2sgYGhhcyhlbmNvZGVNYXAsIHN0cmluZylgIGhlcmUuXG5cdFx0XHRcdHJldHVybiAnJicgKyBlbmNvZGVNYXBbc3RyaW5nXSArICc7Jztcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoIWFsbG93VW5zYWZlU3ltYm9scykge1xuXHRcdFx0Ly8gRW5jb2RlIGA8PlwiJyZgIHVzaW5nIGhleGFkZWNpbWFsIGVzY2FwZXMsIG5vdyB0aGF0IHRoZXnigJlyZSBub3QgaGFuZGxlZFxuXHRcdFx0Ly8gdXNpbmcgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZXMuXG5cdFx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleEVzY2FwZSwgZXNjYXBlQm1wU3ltYm9sKTtcblx0XHR9XG5cdFx0cmV0dXJuIHN0cmluZ1xuXHRcdFx0Ly8gRW5jb2RlIGFzdHJhbCBzeW1ib2xzLlxuXHRcdFx0LnJlcGxhY2UocmVnZXhBc3RyYWxTeW1ib2xzLCBmdW5jdGlvbigkMCkge1xuXHRcdFx0XHQvLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcblx0XHRcdFx0dmFyIGhpZ2ggPSAkMC5jaGFyQ29kZUF0KDApO1xuXHRcdFx0XHR2YXIgbG93ID0gJDAuY2hhckNvZGVBdCgxKTtcblx0XHRcdFx0dmFyIGNvZGVQb2ludCA9IChoaWdoIC0gMHhEODAwKSAqIDB4NDAwICsgbG93IC0gMHhEQzAwICsgMHgxMDAwMDtcblx0XHRcdFx0cmV0dXJuIGVzY2FwZUNvZGVQb2ludChjb2RlUG9pbnQpO1xuXHRcdFx0fSlcblx0XHRcdC8vIEVuY29kZSBhbnkgcmVtYWluaW5nIEJNUCBzeW1ib2xzIHRoYXQgYXJlIG5vdCBwcmludGFibGUgQVNDSUkgc3ltYm9sc1xuXHRcdFx0Ly8gdXNpbmcgYSBoZXhhZGVjaW1hbCBlc2NhcGUuXG5cdFx0XHQucmVwbGFjZShyZWdleEJtcFdoaXRlbGlzdCwgZXNjYXBlQm1wU3ltYm9sKTtcblx0fTtcblx0Ly8gRXhwb3NlIGRlZmF1bHQgb3B0aW9ucyAoc28gdGhleSBjYW4gYmUgb3ZlcnJpZGRlbiBnbG9iYWxseSkuXG5cdGVuY29kZS5vcHRpb25zID0ge1xuXHRcdCdhbGxvd1Vuc2FmZVN5bWJvbHMnOiBmYWxzZSxcblx0XHQnZW5jb2RlRXZlcnl0aGluZyc6IGZhbHNlLFxuXHRcdCdzdHJpY3QnOiBmYWxzZSxcblx0XHQndXNlTmFtZWRSZWZlcmVuY2VzJzogZmFsc2UsXG5cdFx0J2RlY2ltYWwnIDogZmFsc2Vcblx0fTtcblxuXHR2YXIgZGVjb2RlID0gZnVuY3Rpb24oaHRtbCwgb3B0aW9ucykge1xuXHRcdG9wdGlvbnMgPSBtZXJnZShvcHRpb25zLCBkZWNvZGUub3B0aW9ucyk7XG5cdFx0dmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xuXHRcdGlmIChzdHJpY3QgJiYgcmVnZXhJbnZhbGlkRW50aXR5LnRlc3QoaHRtbCkpIHtcblx0XHRcdHBhcnNlRXJyb3IoJ21hbGZvcm1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlJyk7XG5cdFx0fVxuXHRcdHJldHVybiBodG1sLnJlcGxhY2UocmVnZXhEZWNvZGUsIGZ1bmN0aW9uKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2LCAkNywgJDgpIHtcblx0XHRcdHZhciBjb2RlUG9pbnQ7XG5cdFx0XHR2YXIgc2VtaWNvbG9uO1xuXHRcdFx0dmFyIGRlY0RpZ2l0cztcblx0XHRcdHZhciBoZXhEaWdpdHM7XG5cdFx0XHR2YXIgcmVmZXJlbmNlO1xuXHRcdFx0dmFyIG5leHQ7XG5cblx0XHRcdGlmICgkMSkge1xuXHRcdFx0XHRyZWZlcmVuY2UgPSAkMTtcblx0XHRcdFx0Ly8gTm90ZTogdGhlcmUgaXMgbm8gbmVlZCB0byBjaGVjayBgaGFzKGRlY29kZU1hcCwgcmVmZXJlbmNlKWAuXG5cdFx0XHRcdHJldHVybiBkZWNvZGVNYXBbcmVmZXJlbmNlXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCQyKSB7XG5cdFx0XHRcdC8vIERlY29kZSBuYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlcyB3aXRob3V0IHRyYWlsaW5nIGA7YCwgZS5nLiBgJmFtcGAuXG5cdFx0XHRcdC8vIFRoaXMgaXMgb25seSBhIHBhcnNlIGVycm9yIGlmIGl0IGdldHMgY29udmVydGVkIHRvIGAmYCwgb3IgaWYgaXQgaXNcblx0XHRcdFx0Ly8gZm9sbG93ZWQgYnkgYD1gIGluIGFuIGF0dHJpYnV0ZSBjb250ZXh0LlxuXHRcdFx0XHRyZWZlcmVuY2UgPSAkMjtcblx0XHRcdFx0bmV4dCA9ICQzO1xuXHRcdFx0XHRpZiAobmV4dCAmJiBvcHRpb25zLmlzQXR0cmlidXRlVmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoc3RyaWN0ICYmIG5leHQgPT0gJz0nKSB7XG5cdFx0XHRcdFx0XHRwYXJzZUVycm9yKCdgJmAgZGlkIG5vdCBzdGFydCBhIGNoYXJhY3RlciByZWZlcmVuY2UnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuICQwO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChzdHJpY3QpIHtcblx0XHRcdFx0XHRcdHBhcnNlRXJyb3IoXG5cdFx0XHRcdFx0XHRcdCduYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlIHdhcyBub3QgdGVybWluYXRlZCBieSBhIHNlbWljb2xvbidcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIE5vdGU6IHRoZXJlIGlzIG5vIG5lZWQgdG8gY2hlY2sgYGhhcyhkZWNvZGVNYXBMZWdhY3ksIHJlZmVyZW5jZSlgLlxuXHRcdFx0XHRcdHJldHVybiBkZWNvZGVNYXBMZWdhY3lbcmVmZXJlbmNlXSArIChuZXh0IHx8ICcnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoJDQpIHtcblx0XHRcdFx0Ly8gRGVjb2RlIGRlY2ltYWwgZXNjYXBlcywgZS5nLiBgJiMxMTk1NTg7YC5cblx0XHRcdFx0ZGVjRGlnaXRzID0gJDQ7XG5cdFx0XHRcdHNlbWljb2xvbiA9ICQ1O1xuXHRcdFx0XHRpZiAoc3RyaWN0ICYmICFzZW1pY29sb24pIHtcblx0XHRcdFx0XHRwYXJzZUVycm9yKCdjaGFyYWN0ZXIgcmVmZXJlbmNlIHdhcyBub3QgdGVybWluYXRlZCBieSBhIHNlbWljb2xvbicpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvZGVQb2ludCA9IHBhcnNlSW50KGRlY0RpZ2l0cywgMTApO1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50VG9TeW1ib2woY29kZVBvaW50LCBzdHJpY3QpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoJDYpIHtcblx0XHRcdFx0Ly8gRGVjb2RlIGhleGFkZWNpbWFsIGVzY2FwZXMsIGUuZy4gYCYjeDFEMzA2O2AuXG5cdFx0XHRcdGhleERpZ2l0cyA9ICQ2O1xuXHRcdFx0XHRzZW1pY29sb24gPSAkNztcblx0XHRcdFx0aWYgKHN0cmljdCAmJiAhc2VtaWNvbG9uKSB7XG5cdFx0XHRcdFx0cGFyc2VFcnJvcignY2hhcmFjdGVyIHJlZmVyZW5jZSB3YXMgbm90IHRlcm1pbmF0ZWQgYnkgYSBzZW1pY29sb24nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb2RlUG9pbnQgPSBwYXJzZUludChoZXhEaWdpdHMsIDE2KTtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludFRvU3ltYm9sKGNvZGVQb2ludCwgc3RyaWN0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgd2XigJlyZSBzdGlsbCBoZXJlLCBgaWYgKCQ3KWAgaXMgaW1wbGllZDsgaXTigJlzIGFuIGFtYmlndW91c1xuXHRcdFx0Ly8gYW1wZXJzYW5kIGZvciBzdXJlLiBodHRwczovL210aHMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHNcblx0XHRcdGlmIChzdHJpY3QpIHtcblx0XHRcdFx0cGFyc2VFcnJvcihcblx0XHRcdFx0XHQnbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZSB3YXMgbm90IHRlcm1pbmF0ZWQgYnkgYSBzZW1pY29sb24nXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJDA7XG5cdFx0fSk7XG5cdH07XG5cdC8vIEV4cG9zZSBkZWZhdWx0IG9wdGlvbnMgKHNvIHRoZXkgY2FuIGJlIG92ZXJyaWRkZW4gZ2xvYmFsbHkpLlxuXHRkZWNvZGUub3B0aW9ucyA9IHtcblx0XHQnaXNBdHRyaWJ1dGVWYWx1ZSc6IGZhbHNlLFxuXHRcdCdzdHJpY3QnOiBmYWxzZVxuXHR9O1xuXG5cdHZhciBlc2NhcGUgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVnZXhFc2NhcGUsIGZ1bmN0aW9uKCQwKSB7XG5cdFx0XHQvLyBOb3RlOiB0aGVyZSBpcyBubyBuZWVkIHRvIGNoZWNrIGBoYXMoZXNjYXBlTWFwLCAkMClgIGhlcmUuXG5cdFx0XHRyZXR1cm4gZXNjYXBlTWFwWyQwXTtcblx0XHR9KTtcblx0fTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgaGUgPSB7XG5cdFx0J3ZlcnNpb24nOiAnMS4yLjAnLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZXNjYXBlJzogZXNjYXBlLFxuXHRcdCd1bmVzY2FwZSc6IGRlY29kZVxuXHR9O1xuXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGhlO1xuXHRcdH0pO1xuXHR9XHRlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcblx0XHRpZiAoZnJlZU1vZHVsZSkgeyAvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBoZTtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yICh2YXIga2V5IGluIGhlKSB7XG5cdFx0XHRcdGhhcyhoZSwga2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IGhlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QuaGUgPSBoZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIExvZGFzaCA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIENvcHlyaWdodCBPcGVuSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL29wZW5qc2Yub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuOyhmdW5jdGlvbigpIHtcblxuICAvKiogVXNlZCBhcyBhIHNhZmUgcmVmZXJlbmNlIGZvciBgdW5kZWZpbmVkYCBpbiBwcmUtRVM1IGVudmlyb25tZW50cy4gKi9cbiAgdmFyIHVuZGVmaW5lZDtcblxuICAvKiogVXNlZCBhcyB0aGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuICovXG4gIHZhciBWRVJTSU9OID0gJzQuMTcuMjEnO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xuICB2YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuICAvKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG4gIHZhciBDT1JFX0VSUk9SX1RFWFQgPSAnVW5zdXBwb3J0ZWQgY29yZS1qcyB1c2UuIFRyeSBodHRwczovL25wbXMuaW8vc2VhcmNoP3E9cG9ueWZpbGwuJyxcbiAgICAgIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJyxcbiAgICAgIElOVkFMSURfVEVNUExfVkFSX0VSUk9SX1RFWFQgPSAnSW52YWxpZCBgdmFyaWFibGVgIG9wdGlvbiBwYXNzZWQgaW50byBgXy50ZW1wbGF0ZWAnO1xuXG4gIC8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbiAgdmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbiAgdmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIGludGVybmFsIGFyZ3VtZW50IHBsYWNlaG9sZGVyLiAqL1xuICB2YXIgUExBQ0VIT0xERVIgPSAnX19sb2Rhc2hfcGxhY2Vob2xkZXJfXyc7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbiAgdmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbiAgdmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICB2YXIgV1JBUF9CSU5EX0ZMQUcgPSAxLFxuICAgICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICAgIFdSQVBfQ1VSUllfQk9VTkRfRkxBRyA9IDQsXG4gICAgICBXUkFQX0NVUlJZX0ZMQUcgPSA4LFxuICAgICAgV1JBUF9DVVJSWV9SSUdIVF9GTEFHID0gMTYsXG4gICAgICBXUkFQX1BBUlRJQUxfRkxBRyA9IDMyLFxuICAgICAgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgPSA2NCxcbiAgICAgIFdSQVBfQVJZX0ZMQUcgPSAxMjgsXG4gICAgICBXUkFQX1JFQVJHX0ZMQUcgPSAyNTYsXG4gICAgICBXUkFQX0ZMSVBfRkxBRyA9IDUxMjtcblxuICAvKiogVXNlZCBhcyBkZWZhdWx0IG9wdGlvbnMgZm9yIGBfLnRydW5jYXRlYC4gKi9cbiAgdmFyIERFRkFVTFRfVFJVTkNfTEVOR1RIID0gMzAsXG4gICAgICBERUZBVUxUX1RSVU5DX09NSVNTSU9OID0gJy4uLic7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xuICB2YXIgSE9UX0NPVU5UID0gODAwLFxuICAgICAgSE9UX1NQQU4gPSAxNjtcblxuICAvKiogVXNlZCB0byBpbmRpY2F0ZSB0aGUgdHlwZSBvZiBsYXp5IGl0ZXJhdGVlcy4gKi9cbiAgdmFyIExBWllfRklMVEVSX0ZMQUcgPSAxLFxuICAgICAgTEFaWV9NQVBfRkxBRyA9IDIsXG4gICAgICBMQVpZX1dISUxFX0ZMQUcgPSAzO1xuXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xuICB2YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICAgIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxLFxuICAgICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCxcbiAgICAgIE5BTiA9IDAgLyAwO1xuXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHRoZSBtYXhpbXVtIGxlbmd0aCBhbmQgaW5kZXggb2YgYW4gYXJyYXkuICovXG4gIHZhciBNQVhfQVJSQVlfTEVOR1RIID0gNDI5NDk2NzI5NSxcbiAgICAgIE1BWF9BUlJBWV9JTkRFWCA9IE1BWF9BUlJBWV9MRU5HVEggLSAxLFxuICAgICAgSEFMRl9NQVhfQVJSQVlfTEVOR1RIID0gTUFYX0FSUkFZX0xFTkdUSCA+Pj4gMTtcblxuICAvKiogVXNlZCB0byBhc3NvY2lhdGUgd3JhcCBtZXRob2RzIHdpdGggdGhlaXIgYml0IGZsYWdzLiAqL1xuICB2YXIgd3JhcEZsYWdzID0gW1xuICAgIFsnYXJ5JywgV1JBUF9BUllfRkxBR10sXG4gICAgWydiaW5kJywgV1JBUF9CSU5EX0ZMQUddLFxuICAgIFsnYmluZEtleScsIFdSQVBfQklORF9LRVlfRkxBR10sXG4gICAgWydjdXJyeScsIFdSQVBfQ1VSUllfRkxBR10sXG4gICAgWydjdXJyeVJpZ2h0JywgV1JBUF9DVVJSWV9SSUdIVF9GTEFHXSxcbiAgICBbJ2ZsaXAnLCBXUkFQX0ZMSVBfRkxBR10sXG4gICAgWydwYXJ0aWFsJywgV1JBUF9QQVJUSUFMX0ZMQUddLFxuICAgIFsncGFydGlhbFJpZ2h0JywgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUddLFxuICAgIFsncmVhcmcnLCBXUkFQX1JFQVJHX0ZMQUddXG4gIF07XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICB2YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICAgIGRvbUV4Y1RhZyA9ICdbb2JqZWN0IERPTUV4Y2VwdGlvbl0nLFxuICAgICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nLFxuICAgICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJyxcbiAgICAgIHdlYWtTZXRUYWcgPSAnW29iamVjdCBXZWFrU2V0XSc7XG5cbiAgdmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuICAvKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlLiAqL1xuICB2YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlZEh0bWwgPSAvJig/OmFtcHxsdHxndHxxdW90fCMzOSk7L2csXG4gICAgICByZVVuZXNjYXBlZEh0bWwgPSAvWyY8PlwiJ10vZyxcbiAgICAgIHJlSGFzRXNjYXBlZEh0bWwgPSBSZWdFeHAocmVFc2NhcGVkSHRtbC5zb3VyY2UpLFxuICAgICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG4gIHZhciByZUVzY2FwZSA9IC88JS0oW1xcc1xcU10rPyklPi9nLFxuICAgICAgcmVFdmFsdWF0ZSA9IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAgICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gICAqL1xuICB2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nLFxuICAgICAgcmVIYXNSZWdFeHBDaGFyID0gUmVnRXhwKHJlUmVnRXhwQ2hhci5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgd2hpdGVzcGFjZS4gKi9cbiAgdmFyIHJlVHJpbVN0YXJ0ID0gL15cXHMrLztcblxuICAvKiogVXNlZCB0byBtYXRjaCBhIHNpbmdsZSB3aGl0ZXNwYWNlIGNoYXJhY3Rlci4gKi9cbiAgdmFyIHJlV2hpdGVzcGFjZSA9IC9cXHMvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHdyYXAgZGV0YWlsIGNvbW1lbnRzLiAqL1xuICB2YXIgcmVXcmFwQ29tbWVudCA9IC9cXHsoPzpcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoIC4rXFxdIFxcKlxcLyk/XFxuPy8sXG4gICAgICByZVdyYXBEZXRhaWxzID0gL1xce1xcblxcL1xcKiBcXFt3cmFwcGVkIHdpdGggKC4rKVxcXSBcXCovLFxuICAgICAgcmVTcGxpdERldGFpbHMgPSAvLD8gJiAvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHdvcmRzIGNvbXBvc2VkIG9mIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgcmVBc2NpaVdvcmQgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gdmFsaWRhdGUgdGhlIGB2YWxpZGF0ZWAgb3B0aW9uIGluIGBfLnRlbXBsYXRlYCB2YXJpYWJsZS5cbiAgICpcbiAgICogRm9yYmlkcyBjaGFyYWN0ZXJzIHdoaWNoIGNvdWxkIHBvdGVudGlhbGx5IGNoYW5nZSB0aGUgbWVhbmluZyBvZiB0aGUgZnVuY3Rpb24gYXJndW1lbnQgZGVmaW5pdGlvbjpcbiAgICogLSBcIigpLFwiIChtb2RpZmljYXRpb24gb2YgZnVuY3Rpb24gcGFyYW1ldGVycylcbiAgICogLSBcIj1cIiAoZGVmYXVsdCB2YWx1ZSlcbiAgICogLSBcIltde31cIiAoZGVzdHJ1Y3R1cmluZyBvZiBmdW5jdGlvbiBwYXJhbWV0ZXJzKVxuICAgKiAtIFwiL1wiIChiZWdpbm5pbmcgb2YgYSBjb21tZW50KVxuICAgKiAtIHdoaXRlc3BhY2VcbiAgICovXG4gIHZhciByZUZvcmJpZGRlbklkZW50aWZpZXJDaGFycyA9IC9bKCk9LHt9XFxbXFxdXFwvXFxzXS87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG4gIHZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaFxuICAgKiBbRVMgdGVtcGxhdGUgZGVsaW1pdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHMpLlxuICAgKi9cbiAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG4gIHZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG4gIHZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggTGF0aW4gVW5pY29kZSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXG4gIHZhciByZUxhdGluID0gL1tcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx4ZmZcXHUwMTAwLVxcdTAxN2ZdL2c7XG5cbiAgLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xuICB2YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbiAgdmFyIHJlVW5lc2NhcGVkU3RyaW5nID0gL1snXFxuXFxyXFx1MjAyOFxcdTIwMjlcXFxcXS9nO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbiAgdmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgICByc0RpbmdiYXRSYW5nZSA9ICdcXFxcdTI3MDAtXFxcXHUyN2JmJyxcbiAgICAgIHJzTG93ZXJSYW5nZSA9ICdhLXpcXFxceGRmLVxcXFx4ZjZcXFxceGY4LVxcXFx4ZmYnLFxuICAgICAgcnNNYXRoT3BSYW5nZSA9ICdcXFxceGFjXFxcXHhiMVxcXFx4ZDdcXFxceGY3JyxcbiAgICAgIHJzTm9uQ2hhclJhbmdlID0gJ1xcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHhiZicsXG4gICAgICByc1B1bmN0dWF0aW9uUmFuZ2UgPSAnXFxcXHUyMDAwLVxcXFx1MjA2ZicsXG4gICAgICByc1NwYWNlUmFuZ2UgPSAnIFxcXFx0XFxcXHgwYlxcXFxmXFxcXHhhMFxcXFx1ZmVmZlxcXFxuXFxcXHJcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdTE2ODBcXFxcdTE4MGVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMGFcXFxcdTIwMmZcXFxcdTIwNWZcXFxcdTMwMDAnLFxuICAgICAgcnNVcHBlclJhbmdlID0gJ0EtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZScsXG4gICAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZicsXG4gICAgICByc0JyZWFrUmFuZ2UgPSByc01hdGhPcFJhbmdlICsgcnNOb25DaGFyUmFuZ2UgKyByc1B1bmN0dWF0aW9uUmFuZ2UgKyByc1NwYWNlUmFuZ2U7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xuICB2YXIgcnNBcG9zID0gXCJbJ1xcdTIwMTldXCIsXG4gICAgICByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgICByc0JyZWFrID0gJ1snICsgcnNCcmVha1JhbmdlICsgJ10nLFxuICAgICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJyxcbiAgICAgIHJzRGlnaXRzID0gJ1xcXFxkKycsXG4gICAgICByc0RpbmdiYXQgPSAnWycgKyByc0RpbmdiYXRSYW5nZSArICddJyxcbiAgICAgIHJzTG93ZXIgPSAnWycgKyByc0xvd2VyUmFuZ2UgKyAnXScsXG4gICAgICByc01pc2MgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArIHJzQnJlYWtSYW5nZSArIHJzRGlnaXRzICsgcnNEaW5nYmF0UmFuZ2UgKyByc0xvd2VyUmFuZ2UgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICAgIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8gKyAnfCcgKyByc0ZpdHogKyAnKScsXG4gICAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICAgIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICAgIHJzVXBwZXIgPSAnWycgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xuICB2YXIgcnNNaXNjTG93ZXIgPSAnKD86JyArIHJzTG93ZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgICByc01pc2NVcHBlciA9ICcoPzonICsgcnNVcHBlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICAgIHJzT3B0Q29udHJMb3dlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OmR8bGx8bXxyZXxzfHR8dmUpKT8nLFxuICAgICAgcnNPcHRDb250clVwcGVyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86RHxMTHxNfFJFfFN8VHxWRSkpPycsXG4gICAgICByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICAgIHJzT3JkTG93ZXIgPSAnXFxcXGQqKD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxcXGR0aCkoPz1cXFxcYnxbQS1aX10pJyxcbiAgICAgIHJzT3JkVXBwZXIgPSAnXFxcXGQqKD86MVNUfDJORHwzUkR8KD8hWzEyM10pXFxcXGRUSCkoPz1cXFxcYnxbYS16X10pJyxcbiAgICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICAgIHJzRW1vamkgPSAnKD86JyArIFtyc0RpbmdiYXQsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzU2VxLFxuICAgICAgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYXBvc3Ryb3BoZXMuICovXG4gIHZhciByZUFwb3MgPSBSZWdFeHAocnNBcG9zLCAnZycpO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykgYW5kXG4gICAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3MgZm9yIHN5bWJvbHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrc19mb3JfU3ltYm9scykuXG4gICAqL1xuICB2YXIgcmVDb21ib01hcmsgPSBSZWdFeHAocnNDb21ibywgJ2cnKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqL1xuICB2YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggY29tcGxleCBvciBjb21wb3VuZCB3b3Jkcy4gKi9cbiAgdmFyIHJlVW5pY29kZVdvcmQgPSBSZWdFeHAoW1xuICAgIHJzVXBwZXIgKyAnPycgKyByc0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gICAgcnNNaXNjVXBwZXIgKyAnKycgKyByc09wdENvbnRyVXBwZXIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyICsgcnNNaXNjTG93ZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICAgIHJzVXBwZXIgKyAnPycgKyByc01pc2NMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlcixcbiAgICByc1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyLFxuICAgIHJzT3JkVXBwZXIsXG4gICAgcnNPcmRMb3dlcixcbiAgICByc0RpZ2l0cyxcbiAgICByc0Vtb2ppXG4gIF0uam9pbignfCcpLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHdpdGggW3plcm8td2lkdGggam9pbmVycyBvciBjb2RlIHBvaW50cyBmcm9tIHRoZSBhc3RyYWwgcGxhbmVzXShodHRwOi8vZWV2LmVlL2Jsb2cvMjAxNS8wOS8xMi9kYXJrLWNvcm5lcnMtb2YtdW5pY29kZS8pLiAqL1xuICB2YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvUmFuZ2UgKyByc1ZhclJhbmdlICsgJ10nKTtcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB0aGF0IG5lZWQgYSBtb3JlIHJvYnVzdCByZWdleHAgdG8gbWF0Y2ggd29yZHMuICovXG4gIHZhciByZUhhc1VuaWNvZGVXb3JkID0gL1thLXpdW0EtWl18W0EtWl17Mn1bYS16XXxbMC05XVthLXpBLVpdfFthLXpBLVpdWzAtOV18W15hLXpBLVowLTkgXS87XG5cbiAgLyoqIFVzZWQgdG8gYXNzaWduIGRlZmF1bHQgYGNvbnRleHRgIG9iamVjdCBwcm9wZXJ0aWVzLiAqL1xuICB2YXIgY29udGV4dFByb3BzID0gW1xuICAgICdBcnJheScsICdCdWZmZXInLCAnRGF0YVZpZXcnLCAnRGF0ZScsICdFcnJvcicsICdGbG9hdDMyQXJyYXknLCAnRmxvYXQ2NEFycmF5JyxcbiAgICAnRnVuY3Rpb24nLCAnSW50OEFycmF5JywgJ0ludDE2QXJyYXknLCAnSW50MzJBcnJheScsICdNYXAnLCAnTWF0aCcsICdPYmplY3QnLFxuICAgICdQcm9taXNlJywgJ1JlZ0V4cCcsICdTZXQnLCAnU3RyaW5nJywgJ1N5bWJvbCcsICdUeXBlRXJyb3InLCAnVWludDhBcnJheScsXG4gICAgJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ1VpbnQxNkFycmF5JywgJ1VpbnQzMkFycmF5JywgJ1dlYWtNYXAnLFxuICAgICdfJywgJ2NsZWFyVGltZW91dCcsICdpc0Zpbml0ZScsICdwYXJzZUludCcsICdzZXRUaW1lb3V0J1xuICBdO1xuXG4gIC8qKiBVc2VkIHRvIG1ha2UgdGVtcGxhdGUgc291cmNlVVJMcyBlYXNpZXIgdG8gaWRlbnRpZnkuICovXG4gIHZhciB0ZW1wbGF0ZUNvdW50ZXIgPSAtMTtcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG4gIHZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xuICB0eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICB0eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbiAgdmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbiAgY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbiAgY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBMYXRpbiBVbmljb2RlIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy4gKi9cbiAgdmFyIGRlYnVycmVkTGV0dGVycyA9IHtcbiAgICAvLyBMYXRpbi0xIFN1cHBsZW1lbnQgYmxvY2suXG4gICAgJ1xceGMwJzogJ0EnLCAgJ1xceGMxJzogJ0EnLCAnXFx4YzInOiAnQScsICdcXHhjMyc6ICdBJywgJ1xceGM0JzogJ0EnLCAnXFx4YzUnOiAnQScsXG4gICAgJ1xceGUwJzogJ2EnLCAgJ1xceGUxJzogJ2EnLCAnXFx4ZTInOiAnYScsICdcXHhlMyc6ICdhJywgJ1xceGU0JzogJ2EnLCAnXFx4ZTUnOiAnYScsXG4gICAgJ1xceGM3JzogJ0MnLCAgJ1xceGU3JzogJ2MnLFxuICAgICdcXHhkMCc6ICdEJywgICdcXHhmMCc6ICdkJyxcbiAgICAnXFx4YzgnOiAnRScsICAnXFx4YzknOiAnRScsICdcXHhjYSc6ICdFJywgJ1xceGNiJzogJ0UnLFxuICAgICdcXHhlOCc6ICdlJywgICdcXHhlOSc6ICdlJywgJ1xceGVhJzogJ2UnLCAnXFx4ZWInOiAnZScsXG4gICAgJ1xceGNjJzogJ0knLCAgJ1xceGNkJzogJ0knLCAnXFx4Y2UnOiAnSScsICdcXHhjZic6ICdJJyxcbiAgICAnXFx4ZWMnOiAnaScsICAnXFx4ZWQnOiAnaScsICdcXHhlZSc6ICdpJywgJ1xceGVmJzogJ2knLFxuICAgICdcXHhkMSc6ICdOJywgICdcXHhmMSc6ICduJyxcbiAgICAnXFx4ZDInOiAnTycsICAnXFx4ZDMnOiAnTycsICdcXHhkNCc6ICdPJywgJ1xceGQ1JzogJ08nLCAnXFx4ZDYnOiAnTycsICdcXHhkOCc6ICdPJyxcbiAgICAnXFx4ZjInOiAnbycsICAnXFx4ZjMnOiAnbycsICdcXHhmNCc6ICdvJywgJ1xceGY1JzogJ28nLCAnXFx4ZjYnOiAnbycsICdcXHhmOCc6ICdvJyxcbiAgICAnXFx4ZDknOiAnVScsICAnXFx4ZGEnOiAnVScsICdcXHhkYic6ICdVJywgJ1xceGRjJzogJ1UnLFxuICAgICdcXHhmOSc6ICd1JywgICdcXHhmYSc6ICd1JywgJ1xceGZiJzogJ3UnLCAnXFx4ZmMnOiAndScsXG4gICAgJ1xceGRkJzogJ1knLCAgJ1xceGZkJzogJ3knLCAnXFx4ZmYnOiAneScsXG4gICAgJ1xceGM2JzogJ0FlJywgJ1xceGU2JzogJ2FlJyxcbiAgICAnXFx4ZGUnOiAnVGgnLCAnXFx4ZmUnOiAndGgnLFxuICAgICdcXHhkZic6ICdzcycsXG4gICAgLy8gTGF0aW4gRXh0ZW5kZWQtQSBibG9jay5cbiAgICAnXFx1MDEwMCc6ICdBJywgICdcXHUwMTAyJzogJ0EnLCAnXFx1MDEwNCc6ICdBJyxcbiAgICAnXFx1MDEwMSc6ICdhJywgICdcXHUwMTAzJzogJ2EnLCAnXFx1MDEwNSc6ICdhJyxcbiAgICAnXFx1MDEwNic6ICdDJywgICdcXHUwMTA4JzogJ0MnLCAnXFx1MDEwYSc6ICdDJywgJ1xcdTAxMGMnOiAnQycsXG4gICAgJ1xcdTAxMDcnOiAnYycsICAnXFx1MDEwOSc6ICdjJywgJ1xcdTAxMGInOiAnYycsICdcXHUwMTBkJzogJ2MnLFxuICAgICdcXHUwMTBlJzogJ0QnLCAgJ1xcdTAxMTAnOiAnRCcsICdcXHUwMTBmJzogJ2QnLCAnXFx1MDExMSc6ICdkJyxcbiAgICAnXFx1MDExMic6ICdFJywgICdcXHUwMTE0JzogJ0UnLCAnXFx1MDExNic6ICdFJywgJ1xcdTAxMTgnOiAnRScsICdcXHUwMTFhJzogJ0UnLFxuICAgICdcXHUwMTEzJzogJ2UnLCAgJ1xcdTAxMTUnOiAnZScsICdcXHUwMTE3JzogJ2UnLCAnXFx1MDExOSc6ICdlJywgJ1xcdTAxMWInOiAnZScsXG4gICAgJ1xcdTAxMWMnOiAnRycsICAnXFx1MDExZSc6ICdHJywgJ1xcdTAxMjAnOiAnRycsICdcXHUwMTIyJzogJ0cnLFxuICAgICdcXHUwMTFkJzogJ2cnLCAgJ1xcdTAxMWYnOiAnZycsICdcXHUwMTIxJzogJ2cnLCAnXFx1MDEyMyc6ICdnJyxcbiAgICAnXFx1MDEyNCc6ICdIJywgICdcXHUwMTI2JzogJ0gnLCAnXFx1MDEyNSc6ICdoJywgJ1xcdTAxMjcnOiAnaCcsXG4gICAgJ1xcdTAxMjgnOiAnSScsICAnXFx1MDEyYSc6ICdJJywgJ1xcdTAxMmMnOiAnSScsICdcXHUwMTJlJzogJ0knLCAnXFx1MDEzMCc6ICdJJyxcbiAgICAnXFx1MDEyOSc6ICdpJywgICdcXHUwMTJiJzogJ2knLCAnXFx1MDEyZCc6ICdpJywgJ1xcdTAxMmYnOiAnaScsICdcXHUwMTMxJzogJ2knLFxuICAgICdcXHUwMTM0JzogJ0onLCAgJ1xcdTAxMzUnOiAnaicsXG4gICAgJ1xcdTAxMzYnOiAnSycsICAnXFx1MDEzNyc6ICdrJywgJ1xcdTAxMzgnOiAnaycsXG4gICAgJ1xcdTAxMzknOiAnTCcsICAnXFx1MDEzYic6ICdMJywgJ1xcdTAxM2QnOiAnTCcsICdcXHUwMTNmJzogJ0wnLCAnXFx1MDE0MSc6ICdMJyxcbiAgICAnXFx1MDEzYSc6ICdsJywgICdcXHUwMTNjJzogJ2wnLCAnXFx1MDEzZSc6ICdsJywgJ1xcdTAxNDAnOiAnbCcsICdcXHUwMTQyJzogJ2wnLFxuICAgICdcXHUwMTQzJzogJ04nLCAgJ1xcdTAxNDUnOiAnTicsICdcXHUwMTQ3JzogJ04nLCAnXFx1MDE0YSc6ICdOJyxcbiAgICAnXFx1MDE0NCc6ICduJywgICdcXHUwMTQ2JzogJ24nLCAnXFx1MDE0OCc6ICduJywgJ1xcdTAxNGInOiAnbicsXG4gICAgJ1xcdTAxNGMnOiAnTycsICAnXFx1MDE0ZSc6ICdPJywgJ1xcdTAxNTAnOiAnTycsXG4gICAgJ1xcdTAxNGQnOiAnbycsICAnXFx1MDE0Zic6ICdvJywgJ1xcdTAxNTEnOiAnbycsXG4gICAgJ1xcdTAxNTQnOiAnUicsICAnXFx1MDE1Nic6ICdSJywgJ1xcdTAxNTgnOiAnUicsXG4gICAgJ1xcdTAxNTUnOiAncicsICAnXFx1MDE1Nyc6ICdyJywgJ1xcdTAxNTknOiAncicsXG4gICAgJ1xcdTAxNWEnOiAnUycsICAnXFx1MDE1Yyc6ICdTJywgJ1xcdTAxNWUnOiAnUycsICdcXHUwMTYwJzogJ1MnLFxuICAgICdcXHUwMTViJzogJ3MnLCAgJ1xcdTAxNWQnOiAncycsICdcXHUwMTVmJzogJ3MnLCAnXFx1MDE2MSc6ICdzJyxcbiAgICAnXFx1MDE2Mic6ICdUJywgICdcXHUwMTY0JzogJ1QnLCAnXFx1MDE2Nic6ICdUJyxcbiAgICAnXFx1MDE2Myc6ICd0JywgICdcXHUwMTY1JzogJ3QnLCAnXFx1MDE2Nyc6ICd0JyxcbiAgICAnXFx1MDE2OCc6ICdVJywgICdcXHUwMTZhJzogJ1UnLCAnXFx1MDE2Yyc6ICdVJywgJ1xcdTAxNmUnOiAnVScsICdcXHUwMTcwJzogJ1UnLCAnXFx1MDE3Mic6ICdVJyxcbiAgICAnXFx1MDE2OSc6ICd1JywgICdcXHUwMTZiJzogJ3UnLCAnXFx1MDE2ZCc6ICd1JywgJ1xcdTAxNmYnOiAndScsICdcXHUwMTcxJzogJ3UnLCAnXFx1MDE3Myc6ICd1JyxcbiAgICAnXFx1MDE3NCc6ICdXJywgICdcXHUwMTc1JzogJ3cnLFxuICAgICdcXHUwMTc2JzogJ1knLCAgJ1xcdTAxNzcnOiAneScsICdcXHUwMTc4JzogJ1knLFxuICAgICdcXHUwMTc5JzogJ1onLCAgJ1xcdTAxN2InOiAnWicsICdcXHUwMTdkJzogJ1onLFxuICAgICdcXHUwMTdhJzogJ3onLCAgJ1xcdTAxN2MnOiAneicsICdcXHUwMTdlJzogJ3onLFxuICAgICdcXHUwMTMyJzogJ0lKJywgJ1xcdTAxMzMnOiAnaWonLFxuICAgICdcXHUwMTUyJzogJ09lJywgJ1xcdTAxNTMnOiAnb2UnLFxuICAgICdcXHUwMTQ5JzogXCInblwiLCAnXFx1MDE3Zic6ICdzJ1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuICovXG4gIHZhciBodG1sRXNjYXBlcyA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5OydcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgaHRtbFVuZXNjYXBlcyA9IHtcbiAgICAnJmFtcDsnOiAnJicsXG4gICAgJyZsdDsnOiAnPCcsXG4gICAgJyZndDsnOiAnPicsXG4gICAgJyZxdW90Oyc6ICdcIicsXG4gICAgJyYjMzk7JzogXCInXCJcbiAgfTtcblxuICAvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbiAgdmFyIHN0cmluZ0VzY2FwZXMgPSB7XG4gICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgXCInXCI6IFwiJ1wiLFxuICAgICdcXG4nOiAnbicsXG4gICAgJ1xccic6ICdyJyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbiAgdmFyIGZyZWVQYXJzZUZsb2F0ID0gcGFyc2VGbG9hdCxcbiAgICAgIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG4gIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xuICB2YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuICAvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbiAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbiAgdmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbiAgdmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuICAvKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbiAgdmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbiAgLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG4gIHZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgICAgaWYgKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiB0eXBlcztcbiAgICAgIH1cblxuICAgICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9KCkpO1xuXG4gIC8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG4gIHZhciBub2RlSXNBcnJheUJ1ZmZlciA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzQXJyYXlCdWZmZXIsXG4gICAgICBub2RlSXNEYXRlID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNEYXRlLFxuICAgICAgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXAsXG4gICAgICBub2RlSXNSZWdFeHAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1JlZ0V4cCxcbiAgICAgIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0LFxuICAgICAgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUFnZ3JlZ2F0b3JgIGZvciBhcnJheXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5QWdncmVnYXRvcihhcnJheSwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUVhY2hSaWdodChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZXZlcnlgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RXZlcnkoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoIXByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogc3BlY2lmeWluZyBhbiBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlJbmNsdWRlcyhhcnJheSwgdmFsdWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgcmV0dXJuICEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgMCkgPiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5SW5jbHVkZXNXaXRoKGFycmF5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgYXJyYXlbaW5kZXhdKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgKiBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAgICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgICB9XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gICAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlSZWR1Y2VSaWdodChhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbLS1sZW5ndGhdO1xuICAgIH1cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgKiBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAqICBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpemUgb2YgYW4gQVNDSUkgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAgICovXG4gIHZhciBhc2NpaVNpemUgPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBBU0NJSSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXNjaWlUb0FycmF5KHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcuc3BsaXQoJycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyBhbiBBU0NJSSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFzY2lpV29yZHMoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZUFzY2lpV29yZCkgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmZpbmRLZXlgIGFuZCBgXy5maW5kTGFzdEtleWAsXG4gICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmBcbiAgICogdXNpbmcgYGVhY2hGdW5jYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZm91bmQgZWxlbWVudCBvciBpdHMga2V5LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUZpbmRLZXkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBlYWNoRnVuYykge1xuICAgIHZhciByZXN1bHQ7XG4gICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAgICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiYXNlSW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUluZGV4T2ZXaXRoKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4LCBjb21wYXJhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVhbmAgYW5kIGBfLm1lYW5CeWAgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZU1lYW4oYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiBsZW5ndGggPyAoYmFzZVN1bShhcnJheSwgaXRlcmF0ZWUpIC8gbGVuZ3RoKSA6IE5BTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eU9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUHJvcGVydHlPZihvYmplY3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCwgd2l0aG91dCBzdXBwb3J0XG4gICAqIGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYCB1c2luZyBgZWFjaEZ1bmNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5pdEFjY3VtIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IG9yIGxhc3QgZWxlbWVudCBvZlxuICAgKiAgYGNvbGxlY3Rpb25gIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgZWFjaEZ1bmMpIHtcbiAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaW5pdEFjY3VtXG4gICAgICAgID8gKGluaXRBY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgICAgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydEJ5YCB3aGljaCB1c2VzIGBjb21wYXJlcmAgdG8gZGVmaW5lIHRoZVxuICAgKiBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nXG4gICAqIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIFRoZSBmdW5jdGlvbiB0byBkZWZpbmUgc29ydCBvcmRlci5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlU29ydEJ5KGFycmF5LCBjb21wYXJlcikge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc3VtYCBhbmQgYF8uc3VtQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVN1bShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgcmVzdWx0LFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBpdGVyYXRlZShhcnJheVtpbmRleF0pO1xuICAgICAgaWYgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGN1cnJlbnQgOiAocmVzdWx0ICsgY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICAgKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvUGFpcnNgIGFuZCBgXy50b1BhaXJzSW5gIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXlcbiAgICogb2Yga2V5LXZhbHVlIHBhaXJzIGZvciBgb2JqZWN0YCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBgcHJvcHNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRvUGFpcnMob2JqZWN0LCBwcm9wcykge1xuICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gW2tleSwgb2JqZWN0W2tleV1dO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRyaW1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVHJpbShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nXG4gICAgICA/IHN0cmluZy5zbGljZSgwLCB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSArIDEpLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKVxuICAgICAgOiBzdHJpbmc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICAgKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAgICogb2YgYHByb3BzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICAgIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltU3RhcnRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHN0cmluZyBzeW1ib2xcbiAgICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNoclN5bWJvbHMsIHN0clN5bWJvbHNbaW5kZXhdLCAwKSA+IC0xKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltRW5kYCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHN0cmluZyBzeW1ib2xcbiAgICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCB1bm1hdGNoZWQgc3RyaW5nIHN5bWJvbC5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgIHZhciBpbmRleCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4LS0gJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBgcGxhY2Vob2xkZXJgIG9jY3VycmVuY2VzIGluIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBjb3VudC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvdW50SG9sZGVycyhhcnJheSwgcGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSAwO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoYXJyYXlbbGVuZ3RoXSA9PT0gcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgKytyZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgTGF0aW4tMSBTdXBwbGVtZW50IGFuZCBMYXRpbiBFeHRlbmRlZC1BXG4gICAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gICAqL1xuICB2YXIgZGVidXJyTGV0dGVyID0gYmFzZVByb3BlcnR5T2YoZGVidXJyZWRMZXR0ZXJzKTtcblxuICAvKipcbiAgICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgdmFyIGVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbEVzY2FwZXMpO1xuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIGEgd29yZCBjb21wb3NlZCBvZiBVbmljb2RlIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSB3b3JkIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNVbmljb2RlV29yZChzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVIYXNVbmljb2RlV29yZC50ZXN0KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYGl0ZXJhdG9yYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZXJhdG9yIFRoZSBpdGVyYXRvciB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGl0ZXJhdG9yVG9BcnJheShpdGVyYXRvcikge1xuICAgIHZhciBkYXRhLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICghKGRhdGEgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGRhdGEudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBgcGxhY2Vob2xkZXJgIGVsZW1lbnRzIGluIGBhcnJheWAgd2l0aCBhbiBpbnRlcm5hbCBwbGFjZWhvbGRlclxuICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGVpciBpbmRleGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byByZXBsYWNlLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZUhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAodmFsdWUgPT09IHBsYWNlaG9sZGVyIHx8IHZhbHVlID09PSBQTEFDRUhPTERFUikge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBQTEFDRUhPTERFUjtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHNldGAgdG8gaXRzIHZhbHVlLXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIHNldFRvUGFpcnMoc2V0KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSBbdmFsdWUsIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAgICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5sYXN0SW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaWN0TGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggKyAxO1xuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2Ygc3ltYm9scyBpbiBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5nU2l6ZShzdHJpbmcpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHVuaWNvZGVTaXplKHN0cmluZylcbiAgICAgIDogYXNjaWlTaXplKHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyB1bmljb2RlVG9BcnJheShzdHJpbmcpXG4gICAgICA6IGFzY2lpVG9BcnJheShzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2VcbiAgICogY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gdHJpbW1lZEVuZEluZGV4KHN0cmluZykge1xuICAgIHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSAmJiByZVdoaXRlc3BhY2UudGVzdChzdHJpbmcuY2hhckF0KGluZGV4KSkpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udW5lc2NhcGVgIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIHZhciB1bmVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbFVuZXNjYXBlcyk7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpemUgb2YgYSBVbmljb2RlIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlU2l6ZShzdHJpbmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gcmVVbmljb2RlLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKHJlVW5pY29kZS50ZXN0KHN0cmluZykpIHtcbiAgICAgICsrcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgVW5pY29kZSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyBhIFVuaWNvZGUgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlV29yZHMoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGVXb3JkKSB8fCBbXTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdXNpbmcgdGhlIGBjb250ZXh0YCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDEuMS4wXG4gICAqIEBjYXRlZ29yeSBVdGlsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1yb290XSBUaGUgY29udGV4dCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIG5ldyBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5taXhpbih7ICdmb28nOiBfLmNvbnN0YW50KCdmb28nKSB9KTtcbiAgICpcbiAgICogdmFyIGxvZGFzaCA9IF8ucnVuSW5Db250ZXh0KCk7XG4gICAqIGxvZGFzaC5taXhpbih7ICdiYXInOiBsb2Rhc2guY29uc3RhbnQoJ2JhcicpIH0pO1xuICAgKlxuICAgKiBfLmlzRnVuY3Rpb24oXy5mb28pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqIF8uaXNGdW5jdGlvbihfLmJhcik7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5mb28pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guYmFyKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiAvLyBDcmVhdGUgYSBzdXBlZC11cCBgZGVmZXJgIGluIE5vZGUuanMuXG4gICAqIHZhciBkZWZlciA9IF8ucnVuSW5Db250ZXh0KHsgJ3NldFRpbWVvdXQnOiBzZXRJbW1lZGlhdGUgfSkuZGVmZXI7XG4gICAqL1xuICB2YXIgcnVuSW5Db250ZXh0ID0gKGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0KSB7XG4gICAgY29udGV4dCA9IGNvbnRleHQgPT0gbnVsbCA/IHJvb3QgOiBfLmRlZmF1bHRzKHJvb3QuT2JqZWN0KCksIGNvbnRleHQsIF8ucGljayhyb290LCBjb250ZXh0UHJvcHMpKTtcblxuICAgIC8qKiBCdWlsdC1pbiBjb25zdHJ1Y3RvciByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBBcnJheSA9IGNvbnRleHQuQXJyYXksXG4gICAgICAgIERhdGUgPSBjb250ZXh0LkRhdGUsXG4gICAgICAgIEVycm9yID0gY29udGV4dC5FcnJvcixcbiAgICAgICAgRnVuY3Rpb24gPSBjb250ZXh0LkZ1bmN0aW9uLFxuICAgICAgICBNYXRoID0gY29udGV4dC5NYXRoLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0Lk9iamVjdCxcbiAgICAgICAgUmVnRXhwID0gY29udGV4dC5SZWdFeHAsXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHQuU3RyaW5nLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0LlR5cGVFcnJvcjtcblxuICAgIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICAgICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgICAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG4gICAgdmFyIGNvcmVKc0RhdGEgPSBjb250ZXh0WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbiAgICB2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgICAvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLiAqL1xuICAgIHZhciBpZENvdW50ZXIgPSAwO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbiAgICB2YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gICAgICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAgICAgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICAgKiBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgdmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG4gICAgdmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgYF9gIHJlZmVyZW5jZSBpbiBgXy5ub0NvbmZsaWN0YC4gKi9cbiAgICB2YXIgb2xkRGFzaCA9IHJvb3QuXztcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG4gICAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgICAgIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gICAgICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbiAgICApO1xuXG4gICAgLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyBjb250ZXh0LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICAgICAgU3ltYm9sID0gY29udGV4dC5TeW1ib2wsXG4gICAgICAgIFVpbnQ4QXJyYXkgPSBjb250ZXh0LlVpbnQ4QXJyYXksXG4gICAgICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkLFxuICAgICAgICBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KSxcbiAgICAgICAgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSxcbiAgICAgICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICAgICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgICAgIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1JdGVyYXRvciA9IFN5bWJvbCA/IFN5bWJvbC5pdGVyYXRvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgICAgICBmdW5jKHt9LCAnJywge30pO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfSgpKTtcblxuICAgIC8qKiBNb2NrZWQgYnVpbHQtaW5zLiAqL1xuICAgIHZhciBjdHhDbGVhclRpbWVvdXQgPSBjb250ZXh0LmNsZWFyVGltZW91dCAhPT0gcm9vdC5jbGVhclRpbWVvdXQgJiYgY29udGV4dC5jbGVhclRpbWVvdXQsXG4gICAgICAgIGN0eE5vdyA9IERhdGUgJiYgRGF0ZS5ub3cgIT09IHJvb3QuRGF0ZS5ub3cgJiYgRGF0ZS5ub3csXG4gICAgICAgIGN0eFNldFRpbWVvdXQgPSBjb250ZXh0LnNldFRpbWVvdXQgIT09IHJvb3Quc2V0VGltZW91dCAmJiBjb250ZXh0LnNldFRpbWVvdXQ7XG5cbiAgICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG4gICAgdmFyIG5hdGl2ZUNlaWwgPSBNYXRoLmNlaWwsXG4gICAgICAgIG5hdGl2ZUZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgICAgICBuYXRpdmVJc0Zpbml0ZSA9IGNvbnRleHQuaXNGaW5pdGUsXG4gICAgICAgIG5hdGl2ZUpvaW4gPSBhcnJheVByb3RvLmpvaW4sXG4gICAgICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpLFxuICAgICAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXG4gICAgICAgIG5hdGl2ZU5vdyA9IERhdGUubm93LFxuICAgICAgICBuYXRpdmVQYXJzZUludCA9IGNvbnRleHQucGFyc2VJbnQsXG4gICAgICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tLFxuICAgICAgICBuYXRpdmVSZXZlcnNlID0gYXJyYXlQcm90by5yZXZlcnNlO1xuXG4gICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xuICAgIHZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShjb250ZXh0LCAnRGF0YVZpZXcnKSxcbiAgICAgICAgTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdNYXAnKSxcbiAgICAgICAgUHJvbWlzZSA9IGdldE5hdGl2ZShjb250ZXh0LCAnUHJvbWlzZScpLFxuICAgICAgICBTZXQgPSBnZXROYXRpdmUoY29udGV4dCwgJ1NldCcpLFxuICAgICAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdXZWFrTWFwJyksXG4gICAgICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuICAgIC8qKiBVc2VkIHRvIHN0b3JlIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICAgIHZhciBtZXRhTWFwID0gV2Vha01hcCAmJiBuZXcgV2Vha01hcDtcblxuICAgIC8qKiBVc2VkIHRvIGxvb2t1cCB1bm1pbmlmaWVkIGZ1bmN0aW9uIG5hbWVzLiAqL1xuICAgIHZhciByZWFsTmFtZXMgPSB7fTtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG4gICAgdmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICAgICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgICAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4gICAgLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG4gICAgdmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBpbXBsaWNpdCBtZXRob2RcbiAgICAgKiBjaGFpbiBzZXF1ZW5jZXMuIE1ldGhvZHMgdGhhdCBvcGVyYXRlIG9uIGFuZCByZXR1cm4gYXJyYXlzLCBjb2xsZWN0aW9ucyxcbiAgICAgKiBhbmQgZnVuY3Rpb25zIGNhbiBiZSBjaGFpbmVkIHRvZ2V0aGVyLiBNZXRob2RzIHRoYXQgcmV0cmlldmUgYSBzaW5nbGUgdmFsdWVcbiAgICAgKiBvciBtYXkgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlIHdpbGwgYXV0b21hdGljYWxseSBlbmQgdGhlIGNoYWluIHNlcXVlbmNlXG4gICAgICogYW5kIHJldHVybiB0aGUgdW53cmFwcGVkIHZhbHVlLiBPdGhlcndpc2UsIHRoZSB2YWx1ZSBtdXN0IGJlIHVud3JhcHBlZFxuICAgICAqIHdpdGggYF8jdmFsdWVgLlxuICAgICAqXG4gICAgICogRXhwbGljaXQgY2hhaW4gc2VxdWVuY2VzLCB3aGljaCBtdXN0IGJlIHVud3JhcHBlZCB3aXRoIGBfI3ZhbHVlYCwgbWF5IGJlXG4gICAgICogZW5hYmxlZCB1c2luZyBgXy5jaGFpbmAuXG4gICAgICpcbiAgICAgKiBUaGUgZXhlY3V0aW9uIG9mIGNoYWluZWQgbWV0aG9kcyBpcyBsYXp5LCB0aGF0IGlzLCBpdCdzIGRlZmVycmVkIHVudGlsXG4gICAgICogYF8jdmFsdWVgIGlzIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBMYXp5IGV2YWx1YXRpb24gYWxsb3dzIHNldmVyYWwgbWV0aG9kcyB0byBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbi5cbiAgICAgKiBTaG9ydGN1dCBmdXNpb24gaXMgYW4gb3B0aW1pemF0aW9uIHRvIG1lcmdlIGl0ZXJhdGVlIGNhbGxzOyB0aGlzIGF2b2lkc1xuICAgICAqIHRoZSBjcmVhdGlvbiBvZiBpbnRlcm1lZGlhdGUgYXJyYXlzIGFuZCBjYW4gZ3JlYXRseSByZWR1Y2UgdGhlIG51bWJlciBvZlxuICAgICAqIGl0ZXJhdGVlIGV4ZWN1dGlvbnMuIFNlY3Rpb25zIG9mIGEgY2hhaW4gc2VxdWVuY2UgcXVhbGlmeSBmb3Igc2hvcnRjdXRcbiAgICAgKiBmdXNpb24gaWYgdGhlIHNlY3Rpb24gaXMgYXBwbGllZCB0byBhbiBhcnJheSBhbmQgaXRlcmF0ZWVzIGFjY2VwdCBvbmx5XG4gICAgICogb25lIGFyZ3VtZW50LiBUaGUgaGV1cmlzdGljIGZvciB3aGV0aGVyIGEgc2VjdGlvbiBxdWFsaWZpZXMgZm9yIHNob3J0Y3V0XG4gICAgICogZnVzaW9uIGlzIHN1YmplY3QgdG8gY2hhbmdlLlxuICAgICAqXG4gICAgICogQ2hhaW5pbmcgaXMgc3VwcG9ydGVkIGluIGN1c3RvbSBidWlsZHMgYXMgbG9uZyBhcyB0aGUgYF8jdmFsdWVgIG1ldGhvZCBpc1xuICAgICAqIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24gdG8gbG9kYXNoIG1ldGhvZHMsIHdyYXBwZXJzIGhhdmUgYEFycmF5YCBhbmQgYFN0cmluZ2AgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGBBcnJheWAgbWV0aG9kcyBhcmU6XG4gICAgICogYGNvbmNhdGAsIGBqb2luYCwgYHBvcGAsIGBwdXNoYCwgYHNoaWZ0YCwgYHNvcnRgLCBgc3BsaWNlYCwgYW5kIGB1bnNoaWZ0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgYFN0cmluZ2AgbWV0aG9kcyBhcmU6XG4gICAgICogYHJlcGxhY2VgIGFuZCBgc3BsaXRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24gYXJlOlxuICAgICAqIGBhdGAsIGBjb21wYWN0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGRyb3BXaGlsZWAsIGBmaWx0ZXJgLCBgZmluZGAsXG4gICAgICogYGZpbmRMYXN0YCwgYGhlYWRgLCBgaW5pdGlhbGAsIGBsYXN0YCwgYG1hcGAsIGByZWplY3RgLCBgcmV2ZXJzZWAsIGBzbGljZWAsXG4gICAgICogYHRhaWxgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYW5kIGB0b0FycmF5YFxuICAgICAqXG4gICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhZnRlcmAsIGBhcnlgLCBgYXNzaWduYCwgYGFzc2lnbkluYCwgYGFzc2lnbkluV2l0aGAsIGBhc3NpZ25XaXRoYCwgYGF0YCxcbiAgICAgKiBgYmVmb3JlYCwgYGJpbmRgLCBgYmluZEFsbGAsIGBiaW5kS2V5YCwgYGNhc3RBcnJheWAsIGBjaGFpbmAsIGBjaHVua2AsXG4gICAgICogYGNvbW1pdGAsIGBjb21wYWN0YCwgYGNvbmNhdGAsIGBjb25mb3Jtc2AsIGBjb25zdGFudGAsIGBjb3VudEJ5YCwgYGNyZWF0ZWAsXG4gICAgICogYGN1cnJ5YCwgYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBkZWZlcmAsIGBkZWxheWAsXG4gICAgICogYGRpZmZlcmVuY2VgLCBgZGlmZmVyZW5jZUJ5YCwgYGRpZmZlcmVuY2VXaXRoYCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCxcbiAgICAgKiBgZHJvcFJpZ2h0V2hpbGVgLCBgZHJvcFdoaWxlYCwgYGV4dGVuZGAsIGBleHRlbmRXaXRoYCwgYGZpbGxgLCBgZmlsdGVyYCxcbiAgICAgKiBgZmxhdE1hcGAsIGBmbGF0TWFwRGVlcGAsIGBmbGF0TWFwRGVwdGhgLCBgZmxhdHRlbmAsIGBmbGF0dGVuRGVlcGAsXG4gICAgICogYGZsYXR0ZW5EZXB0aGAsIGBmbGlwYCwgYGZsb3dgLCBgZmxvd1JpZ2h0YCwgYGZyb21QYWlyc2AsIGBmdW5jdGlvbnNgLFxuICAgICAqIGBmdW5jdGlvbnNJbmAsIGBncm91cEJ5YCwgYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludGVyc2VjdGlvbkJ5YCxcbiAgICAgKiBgaW50ZXJzZWN0aW9uV2l0aGAsIGBpbnZlcnRgLCBgaW52ZXJ0QnlgLCBgaW52b2tlTWFwYCwgYGl0ZXJhdGVlYCwgYGtleUJ5YCxcbiAgICAgKiBga2V5c2AsIGBrZXlzSW5gLCBgbWFwYCwgYG1hcEtleXNgLCBgbWFwVmFsdWVzYCwgYG1hdGNoZXNgLCBgbWF0Y2hlc1Byb3BlcnR5YCxcbiAgICAgKiBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtZXJnZVdpdGhgLCBgbWV0aG9kYCwgYG1ldGhvZE9mYCwgYG1peGluYCwgYG5lZ2F0ZWAsXG4gICAgICogYG50aEFyZ2AsIGBvbWl0YCwgYG9taXRCeWAsIGBvbmNlYCwgYG9yZGVyQnlgLCBgb3ZlcmAsIGBvdmVyQXJnc2AsXG4gICAgICogYG92ZXJFdmVyeWAsIGBvdmVyU29tZWAsIGBwYXJ0aWFsYCwgYHBhcnRpYWxSaWdodGAsIGBwYXJ0aXRpb25gLCBgcGlja2AsXG4gICAgICogYHBpY2tCeWAsIGBwbGFudGAsIGBwcm9wZXJ0eWAsIGBwcm9wZXJ0eU9mYCwgYHB1bGxgLCBgcHVsbEFsbGAsIGBwdWxsQWxsQnlgLFxuICAgICAqIGBwdWxsQWxsV2l0aGAsIGBwdWxsQXRgLCBgcHVzaGAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlYXJnYCwgYHJlamVjdGAsXG4gICAgICogYHJlbW92ZWAsIGByZXN0YCwgYHJldmVyc2VgLCBgc2FtcGxlU2l6ZWAsIGBzZXRgLCBgc2V0V2l0aGAsIGBzaHVmZmxlYCxcbiAgICAgKiBgc2xpY2VgLCBgc29ydGAsIGBzb3J0QnlgLCBgc3BsaWNlYCwgYHNwcmVhZGAsIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAgICAgKiBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aHJ1YCwgYHRvQXJyYXlgLFxuICAgICAqIGB0b1BhaXJzYCwgYHRvUGFpcnNJbmAsIGB0b1BhdGhgLCBgdG9QbGFpbk9iamVjdGAsIGB0cmFuc2Zvcm1gLCBgdW5hcnlgLFxuICAgICAqIGB1bmlvbmAsIGB1bmlvbkJ5YCwgYHVuaW9uV2l0aGAsIGB1bmlxYCwgYHVuaXFCeWAsIGB1bmlxV2l0aGAsIGB1bnNldGAsXG4gICAgICogYHVuc2hpZnRgLCBgdW56aXBgLCBgdW56aXBXaXRoYCwgYHVwZGF0ZWAsIGB1cGRhdGVXaXRoYCwgYHZhbHVlc2AsXG4gICAgICogYHZhbHVlc0luYCwgYHdpdGhvdXRgLCBgd3JhcGAsIGB4b3JgLCBgeG9yQnlgLCBgeG9yV2l0aGAsIGB6aXBgLFxuICAgICAqIGB6aXBPYmplY3RgLCBgemlwT2JqZWN0RGVlcGAsIGFuZCBgemlwV2l0aGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBhcmUgKipub3QqKiBjaGFpbmFibGUgYnkgZGVmYXVsdCBhcmU6XG4gICAgICogYGFkZGAsIGBhdHRlbXB0YCwgYGNhbWVsQ2FzZWAsIGBjYXBpdGFsaXplYCwgYGNlaWxgLCBgY2xhbXBgLCBgY2xvbmVgLFxuICAgICAqIGBjbG9uZURlZXBgLCBgY2xvbmVEZWVwV2l0aGAsIGBjbG9uZVdpdGhgLCBgY29uZm9ybXNUb2AsIGBkZWJ1cnJgLFxuICAgICAqIGBkZWZhdWx0VG9gLCBgZGl2aWRlYCwgYGVhY2hgLCBgZWFjaFJpZ2h0YCwgYGVuZHNXaXRoYCwgYGVxYCwgYGVzY2FwZWAsXG4gICAgICogYGVzY2FwZVJlZ0V4cGAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsIGBmaW5kS2V5YCwgYGZpbmRMYXN0YCxcbiAgICAgKiBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBmaXJzdGAsIGBmbG9vcmAsIGBmb3JFYWNoYCwgYGZvckVhY2hSaWdodGAsXG4gICAgICogYGZvckluYCwgYGZvckluUmlnaHRgLCBgZm9yT3duYCwgYGZvck93blJpZ2h0YCwgYGdldGAsIGBndGAsIGBndGVgLCBgaGFzYCxcbiAgICAgKiBgaGFzSW5gLCBgaGVhZGAsIGBpZGVudGl0eWAsIGBpbmNsdWRlc2AsIGBpbmRleE9mYCwgYGluUmFuZ2VgLCBgaW52b2tlYCxcbiAgICAgKiBgaXNBcmd1bWVudHNgLCBgaXNBcnJheWAsIGBpc0FycmF5QnVmZmVyYCwgYGlzQXJyYXlMaWtlYCwgYGlzQXJyYXlMaWtlT2JqZWN0YCxcbiAgICAgKiBgaXNCb29sZWFuYCwgYGlzQnVmZmVyYCwgYGlzRGF0ZWAsIGBpc0VsZW1lbnRgLCBgaXNFbXB0eWAsIGBpc0VxdWFsYCxcbiAgICAgKiBgaXNFcXVhbFdpdGhgLCBgaXNFcnJvcmAsIGBpc0Zpbml0ZWAsIGBpc0Z1bmN0aW9uYCwgYGlzSW50ZWdlcmAsIGBpc0xlbmd0aGAsXG4gICAgICogYGlzTWFwYCwgYGlzTWF0Y2hgLCBgaXNNYXRjaFdpdGhgLCBgaXNOYU5gLCBgaXNOYXRpdmVgLCBgaXNOaWxgLCBgaXNOdWxsYCxcbiAgICAgKiBgaXNOdW1iZXJgLCBgaXNPYmplY3RgLCBgaXNPYmplY3RMaWtlYCwgYGlzUGxhaW5PYmplY3RgLCBgaXNSZWdFeHBgLFxuICAgICAqIGBpc1NhZmVJbnRlZ2VyYCwgYGlzU2V0YCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGlzVHlwZWRBcnJheWAsXG4gICAgICogYGlzV2Vha01hcGAsIGBpc1dlYWtTZXRgLCBgam9pbmAsIGBrZWJhYkNhc2VgLCBgbGFzdGAsIGBsYXN0SW5kZXhPZmAsXG4gICAgICogYGxvd2VyQ2FzZWAsIGBsb3dlckZpcnN0YCwgYGx0YCwgYGx0ZWAsIGBtYXhgLCBgbWF4QnlgLCBgbWVhbmAsIGBtZWFuQnlgLFxuICAgICAqIGBtaW5gLCBgbWluQnlgLCBgbXVsdGlwbHlgLCBgbm9Db25mbGljdGAsIGBub29wYCwgYG5vd2AsIGBudGhgLCBgcGFkYCxcbiAgICAgKiBgcGFkRW5kYCwgYHBhZFN0YXJ0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCwgYHJlZHVjZVJpZ2h0YCxcbiAgICAgKiBgcmVwZWF0YCwgYHJlc3VsdGAsIGByb3VuZGAsIGBydW5JbkNvbnRleHRgLCBgc2FtcGxlYCwgYHNoaWZ0YCwgYHNpemVgLFxuICAgICAqIGBzbmFrZUNhc2VgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBzb3J0ZWRJbmRleEJ5YCwgYHNvcnRlZExhc3RJbmRleGAsXG4gICAgICogYHNvcnRlZExhc3RJbmRleEJ5YCwgYHN0YXJ0Q2FzZWAsIGBzdGFydHNXaXRoYCwgYHN0dWJBcnJheWAsIGBzdHViRmFsc2VgLFxuICAgICAqIGBzdHViT2JqZWN0YCwgYHN0dWJTdHJpbmdgLCBgc3R1YlRydWVgLCBgc3VidHJhY3RgLCBgc3VtYCwgYHN1bUJ5YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdGltZXNgLCBgdG9GaW5pdGVgLCBgdG9JbnRlZ2VyYCwgYHRvSlNPTmAsIGB0b0xlbmd0aGAsXG4gICAgICogYHRvTG93ZXJgLCBgdG9OdW1iZXJgLCBgdG9TYWZlSW50ZWdlcmAsIGB0b1N0cmluZ2AsIGB0b1VwcGVyYCwgYHRyaW1gLFxuICAgICAqIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGB0cnVuY2F0ZWAsIGB1bmVzY2FwZWAsIGB1bmlxdWVJZGAsIGB1cHBlckNhc2VgLFxuICAgICAqIGB1cHBlckZpcnN0YCwgYHZhbHVlYCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIEBuYW1lIF9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICAgICAqXG4gICAgICogLy8gUmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogd3JhcHBlZC5yZWR1Y2UoXy5hZGQpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIC8vIFJldHVybnMgYSB3cmFwcGVkIHZhbHVlLlxuICAgICAqIHZhciBzcXVhcmVzID0gd3JhcHBlZC5tYXAoc3F1YXJlKTtcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMudmFsdWUoKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaCh2YWx1ZSkge1xuICAgICAgaWYgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTG9kYXNoV3JhcHBlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpIHtcbiAgICAgICAgICByZXR1cm4gd3JhcHBlckNsb25lKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gICAgICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIHZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgICAgIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiB3aG9zZSBwcm90b3R5cGUgY2hhaW4gc2VxdWVuY2Ugd3JhcHBlcnMgaW5oZXJpdCBmcm9tLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTG9kYXNoKCkge1xuICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBjb25zdHJ1Y3RvciBmb3IgY3JlYXRpbmcgYGxvZGFzaGAgd3JhcHBlciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NoYWluQWxsXSBFbmFibGUgZXhwbGljaXQgbWV0aG9kIGNoYWluIHNlcXVlbmNlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2Rhc2hXcmFwcGVyKHZhbHVlLCBjaGFpbkFsbCkge1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICAgICAgdGhpcy5fX2NoYWluX18gPSAhIWNoYWluQWxsO1xuICAgICAgdGhpcy5fX2luZGV4X18gPSAwO1xuICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgbG9kYXNoIGFyZSBsaWtlIHRob3NlIGluXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKSBhcyB3ZWxsIGFzIEVTMjAxNSB0ZW1wbGF0ZSBzdHJpbmdzLiBDaGFuZ2UgdGhlXG4gICAgICogZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogcmVFc2NhcGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2V2YWx1YXRlJzogcmVFdmFsdWF0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGluamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgJ2ltcG9ydHMnOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgICdfJzogbG9kYXNoXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEVuc3VyZSB3cmFwcGVycyBhcmUgaW5zdGFuY2VzIG9mIGBiYXNlTG9kYXNoYC5cbiAgICBsb2Rhc2gucHJvdG90eXBlID0gYmFzZUxvZGFzaC5wcm90b3R5cGU7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGxvZGFzaDtcblxuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2Rhc2hXcmFwcGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxhenkgd3JhcHBlciBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgbGF6eSBldmFsdWF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExhenlXcmFwcGVyKHZhbHVlKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICB0aGlzLl9fZGlyX18gPSAxO1xuICAgICAgdGhpcy5fX2ZpbHRlcmVkX18gPSBmYWxzZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlZXNfXyA9IFtdO1xuICAgICAgdGhpcy5fX3Rha2VDb3VudF9fID0gTUFYX0FSUkFZX0xFTkdUSDtcbiAgICAgIHRoaXMuX192aWV3c19fID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBsYXp5IHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbG9uZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5Q2xvbmUoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMuX193cmFwcGVkX18pO1xuICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHRoaXMuX19hY3Rpb25zX18pO1xuICAgICAgcmVzdWx0Ll9fZGlyX18gPSB0aGlzLl9fZGlyX187XG4gICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdGhpcy5fX2ZpbHRlcmVkX187XG4gICAgICByZXN1bHQuX19pdGVyYXRlZXNfXyA9IGNvcHlBcnJheSh0aGlzLl9faXRlcmF0ZWVzX18pO1xuICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSB0aGlzLl9fdGFrZUNvdW50X187XG4gICAgICByZXN1bHQuX192aWV3c19fID0gY29weUFycmF5KHRoaXMuX192aWV3c19fKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgdGhlIGRpcmVjdGlvbiBvZiBsYXp5IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyByZXZlcnNlZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5UmV2ZXJzZSgpIHtcbiAgICAgIGlmICh0aGlzLl9fZmlsdGVyZWRfXykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICByZXN1bHQuX19kaXJfXyA9IC0xO1xuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gKj0gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSB1bndyYXBwZWQgdmFsdWUgZnJvbSBpdHMgbGF6eSB3cmFwcGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVZhbHVlKCkge1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5fX3dyYXBwZWRfXy52YWx1ZSgpLFxuICAgICAgICAgIGRpciA9IHRoaXMuX19kaXJfXyxcbiAgICAgICAgICBpc0FyciA9IGlzQXJyYXkoYXJyYXkpLFxuICAgICAgICAgIGlzUmlnaHQgPSBkaXIgPCAwLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGlzQXJyID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICB2aWV3ID0gZ2V0VmlldygwLCBhcnJMZW5ndGgsIHRoaXMuX192aWV3c19fKSxcbiAgICAgICAgICBzdGFydCA9IHZpZXcuc3RhcnQsXG4gICAgICAgICAgZW5kID0gdmlldy5lbmQsXG4gICAgICAgICAgbGVuZ3RoID0gZW5kIC0gc3RhcnQsXG4gICAgICAgICAgaW5kZXggPSBpc1JpZ2h0ID8gZW5kIDogKHN0YXJ0IC0gMSksXG4gICAgICAgICAgaXRlcmF0ZWVzID0gdGhpcy5fX2l0ZXJhdGVlc19fLFxuICAgICAgICAgIGl0ZXJMZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICB0YWtlQ291bnQgPSBuYXRpdmVNaW4obGVuZ3RoLCB0aGlzLl9fdGFrZUNvdW50X18pO1xuXG4gICAgICBpZiAoIWlzQXJyIHx8ICghaXNSaWdodCAmJiBhcnJMZW5ndGggPT0gbGVuZ3RoICYmIHRha2VDb3VudCA9PSBsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKGFycmF5LCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAobGVuZ3RoLS0gJiYgcmVzSW5kZXggPCB0YWtlQ291bnQpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuXG4gICAgICAgIHZhciBpdGVySW5kZXggPSAtMSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIHdoaWxlICgrK2l0ZXJJbmRleCA8IGl0ZXJMZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGl0ZXJhdGVlc1tpdGVySW5kZXhdLFxuICAgICAgICAgICAgICBpdGVyYXRlZSA9IGRhdGEuaXRlcmF0ZWUsXG4gICAgICAgICAgICAgIHR5cGUgPSBkYXRhLnR5cGUsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9NQVBfRkxBRykge1xuICAgICAgICAgICAgdmFsdWUgPSBjb21wdXRlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFjb21wdXRlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRykge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIGBMYXp5V3JhcHBlcmAgaXMgYW4gaW5zdGFuY2Ugb2YgYGJhc2VMb2Rhc2hgLlxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExhenlXcmFwcGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICAgICAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG4gICAgSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG4gICAgSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbiAgICBIYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuICAgIEhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG4gICAgSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICAgICAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgICAgICBkYXRhLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICAgICAgfVxuICAgICAgLS10aGlzLnNpemU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgKyt0aGlzLnNpemU7XG4gICAgICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAgICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgYWRkXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQGFsaWFzIHB1c2hcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICAgICAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICAgICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICAgICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gICAgICB9XG4gICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG4gICAgU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcbiAgICBTdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG4gICAgU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuICAgIFN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcbiAgICBTdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICAgICAgKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zYW1wbGVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2FtcGxlKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2Jhc2VSYW5kb20oMCwgbGVuZ3RoIC0gMSldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zYW1wbGVTaXplYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2FtcGxlU2l6ZShhcnJheSwgbikge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSksIGJhc2VDbGFtcChuLCAwLCBhcnJheS5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTaHVmZmxlKGFycmF5KSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAgICAgKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFnZ3JlZ2F0ZXMgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIG9uIGBhY2N1bXVsYXRvcmAgd2l0aCBrZXlzIHRyYW5zZm9ybWVkXG4gICAgICogYnkgYGl0ZXJhdGVlYCBhbmQgdmFsdWVzIHNldCBieSBgc2V0dGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFnZ3JlZ2F0b3IoY29sbGVjdGlvbiwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gICAgICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICAgICAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICAgICAqIHZhbHVlIGNoZWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcGlja2VkIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBdChvYmplY3QsIHBhdGhzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICBza2lwID0gb2JqZWN0ID09IG51bGw7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBza2lwID8gdW5kZWZpbmVkIDogZ2V0KG9iamVjdCwgcGF0aHNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xhbXBgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICAgICAgaWYgKG51bWJlciA9PT0gbnVtYmVyKSB7XG4gICAgICAgIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbnVtYmVyID0gbnVtYmVyIDw9IHVwcGVyID8gbnVtYmVyIDogdXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvd2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBudW1iZXIgPSBudW1iZXIgPj0gbG93ZXIgPyBudW1iZXIgOiBsb3dlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gICAgICogdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgMSAtIERlZXAgY2xvbmVcbiAgICAgKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAgICAgKiAgNCAtIENsb25lIHN5bWJvbHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgICAgIGlzRmxhdCA9IGJpdG1hc2sgJiBDTE9ORV9GTEFUX0ZMQUcsXG4gICAgICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcbiAgICAgICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZDtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICAgICAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN1YlZhbHVlLCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gICAgICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgICAgIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb25mb3Jtc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb25mb3Jtcyhzb3VyY2UpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMoc291cmNlKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBwcm9wcyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbmZvcm1zVG9gIHdoaWNoIGFjY2VwdHMgYHByb3BzYCB0byBjaGVjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgY29uZm9ybXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwgcHJvcHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbbGVuZ3RoXSxcbiAgICAgICAgICAgIHByZWRpY2F0ZSA9IHNvdXJjZVtrZXldLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICBpZiAoKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkgfHwgIXByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRlbGF5YCBhbmQgYF8uZGVmZXJgIHdoaWNoIGFjY2VwdHMgYGFyZ3NgXG4gICAgICogdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8T2JqZWN0fSBSZXR1cm5zIHRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGVsYXkoZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgd2FpdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRpZmZlcmVuY2VgIHdpdGhvdXQgc3VwcG9ydFxuICAgICAqIGZvciBleGNsdWRpbmcgbXVsdGlwbGUgYXJyYXlzIG9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFsdWVzID0gYXJyYXlNYXAodmFsdWVzLCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh2YWx1ZXMubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzID0gbmV3IFNldENhY2hlKHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPT0gbnVsbCA/IHZhbHVlIDogaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgdmFyIHZhbHVlc0luZGV4ID0gdmFsdWVzTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICh2YWx1ZXNJbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzW3ZhbHVlc0luZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5jbHVkZXModmFsdWVzLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hSaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2hSaWdodCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd25SaWdodCwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ldmVyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFdmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9ICEhcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLm1heGAgYW5kIGBfLm1pbmAgd2hpY2ggYWNjZXB0cyBhXG4gICAgICogYGNvbXBhcmF0b3JgIHRvIGRldGVybWluZSB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFeHRyZW11bShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY3VycmVudCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICBpZiAoY3VycmVudCAhPSBudWxsICYmIChjb21wdXRlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gKGN1cnJlbnQgPT09IGN1cnJlbnQgJiYgIWlzU3ltYm9sKGN1cnJlbnQpKVxuICAgICAgICAgICAgICA6IGNvbXBhcmF0b3IoY3VycmVudCwgY29tcHV0ZWQpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgdmFyIGNvbXB1dGVkID0gY3VycmVudCxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsbGAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBzdGFydCA9IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gICAgICB9XG4gICAgICBlbmQgPSAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gbGVuZ3RoKSA/IGxlbmd0aCA6IHRvSW50ZWdlcihlbmQpO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVuZCA9IHN0YXJ0ID4gZW5kID8gMCA6IHRvTGVuZ3RoKGVuZCk7XG4gICAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgYXJyYXlbc3RhcnQrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gICAgICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICAgICAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUZvcmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzXG4gICAgICogaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yUmlnaHQgPSBjcmVhdGVCYXNlRm9yKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93blJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd25SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JSaWdodChvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mdW5jdGlvbnNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2ZcbiAgICAgKiBgb2JqZWN0YCBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmaWx0ZXJlZCBmcm9tIGBwcm9wc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBmaWx0ZXIuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRnVuY3Rpb25zKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIHJldHVybiBhcnJheUZpbHRlcihwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG9iamVjdFtrZXldKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gICAgICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgICAgIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgICAgIH1cbiAgICAgIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICAgICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmd0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc2Agd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VIYXMob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pblJhbmdlYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbnVtYmVyYCBpcyBpbiB0aGUgcmFuZ2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiBudW1iZXIgPj0gbmF0aXZlTWluKHN0YXJ0LCBlbmQpICYmIG51bWJlciA8IG5hdGl2ZU1heChzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCwgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHNoYXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludGVyc2VjdGlvbihhcnJheXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5jbHVkZXMgPSBjb21wYXJhdG9yID8gYXJyYXlJbmNsdWRlc1dpdGggOiBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5c1swXS5sZW5ndGgsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgICAgICBvdGhJbmRleCA9IG90aExlbmd0aCxcbiAgICAgICAgICBjYWNoZXMgPSBBcnJheShvdGhMZW5ndGgpLFxuICAgICAgICAgIG1heExlbmd0aCA9IEluZmluaXR5LFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAob3RoSW5kZXgtLSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcnJheXNbb3RoSW5kZXhdO1xuICAgICAgICBpZiAob3RoSW5kZXggJiYgaXRlcmF0ZWUpIHtcbiAgICAgICAgICBhcnJheSA9IGFycmF5TWFwKGFycmF5LCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhMZW5ndGggPSBuYXRpdmVNaW4oYXJyYXkubGVuZ3RoLCBtYXhMZW5ndGgpO1xuICAgICAgICBjYWNoZXNbb3RoSW5kZXhdID0gIWNvbXBhcmF0b3IgJiYgKGl0ZXJhdGVlIHx8IChsZW5ndGggPj0gMTIwICYmIGFycmF5Lmxlbmd0aCA+PSAxMjApKVxuICAgICAgICAgID8gbmV3IFNldENhY2hlKG90aEluZGV4ICYmIGFycmF5KVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYXJyYXkgPSBhcnJheXNbMF07XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHNlZW4gPSBjYWNoZXNbMF07XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA8IG1heExlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmICghKHNlZW5cbiAgICAgICAgICAgICAgPyBjYWNoZUhhcyhzZWVuLCBjb21wdXRlZClcbiAgICAgICAgICAgICAgOiBpbmNsdWRlcyhyZXN1bHQsIGNvbXB1dGVkLCBjb21wYXJhdG9yKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgtLW90aEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNbb3RoSW5kZXhdO1xuICAgICAgICAgICAgaWYgKCEoY2FjaGVcbiAgICAgICAgICAgICAgICAgID8gY2FjaGVIYXMoY2FjaGUsIGNvbXB1dGVkKVxuICAgICAgICAgICAgICAgICAgOiBpbmNsdWRlcyhhcnJheXNbb3RoSW5kZXhdLCBjb21wdXRlZCwgY29tcGFyYXRvcikpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmludmVydGAgYW5kIGBfLmludmVydEJ5YCB3aGljaCBpbnZlcnRzXG4gICAgICogYG9iamVjdGAgd2l0aCB2YWx1ZXMgdHJhbnNmb3JtZWQgYnkgYGl0ZXJhdGVlYCBhbmQgc2V0IGJ5IGBzZXR0ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0gdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludmVydGVyKG9iamVjdCwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCBpdGVyYXRlZSh2YWx1ZSksIGtleSwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmludm9rZWAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogbWV0aG9kIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICAgICAgdmFyIGZ1bmMgPSBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG4gICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogYXBwbHkoZnVuYywgb2JqZWN0LCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcnJheUJ1ZmZlcmAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0FycmF5QnVmZmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcnJheUJ1ZmZlclRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0RhdGVgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGRhdGUgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gZGF0ZVRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gICAgICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gICAgICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICAgICAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gICAgICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICAgICAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICAgICAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICAgICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgICAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICAgICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzU2FtZVRhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1JlZ0V4cGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzUmVnRXhwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSByZWdleHBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNTZXRgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1NldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAgICAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgICAgIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICAgICAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmx0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VMdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gICAgICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gICAgICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgICAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgICAgID8gY3VzdG9taXplcihzYWZlR2V0KG9iamVjdCwga2V5KSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgICAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpLFxuICAgICAgICAgIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksXG4gICAgICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHNyY1ZhbHVlKSxcbiAgICAgICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgaXNGdW5jdGlvbihvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5udGhgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG50aCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU50aChhcnJheSwgbikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG4gKz0gbiA8IDAgPyBsZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIGlzSW5kZXgobiwgbGVuZ3RoKSA/IGFycmF5W25dIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm9yZGVyQnlgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gICAgICBpZiAoaXRlcmF0ZWVzLmxlbmd0aCkge1xuICAgICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoaXRlcmF0ZWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2VHZXQodmFsdWUsIGl0ZXJhdGVlLmxlbmd0aCA9PT0gMSA/IGl0ZXJhdGVlWzBdIDogaXRlcmF0ZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXRlcmF0ZWU7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW2lkZW50aXR5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGNyaXRlcmlhID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyAnY3JpdGVyaWEnOiBjcml0ZXJpYSwgJ2luZGV4JzogKytpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucGlja2Agd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gICAgICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgICAgICByZXR1cm4gaGFzSW4ob2JqZWN0LCBwYXRoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mICBgXy5waWNrQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBwYXRoKSkge1xuICAgICAgICAgIGJhc2VTZXQocmVzdWx0LCBjYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBbGxCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgICAqIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleE9mID0gY29tcGFyYXRvciA/IGJhc2VJbmRleE9mV2l0aCA6IGJhc2VJbmRleE9mLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICBzZWVuID0gYXJyYXk7XG5cbiAgICAgIGlmIChhcnJheSA9PT0gdmFsdWVzKSB7XG4gICAgICAgIHZhbHVlcyA9IGNvcHlBcnJheSh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHNlZW4gPSBhcnJheU1hcChhcnJheSwgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZnJvbUluZGV4ID0gMCxcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzW2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB3aGlsZSAoKGZyb21JbmRleCA9IGluZGV4T2Yoc2VlbiwgY29tcHV0ZWQsIGZyb21JbmRleCwgY29tcGFyYXRvcikpID4gLTEpIHtcbiAgICAgICAgICBpZiAoc2VlbiAhPT0gYXJyYXkpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKHNlZW4sIGZyb21JbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBmcm9tSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHVsbEF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBpbmRleGVzIG9yIGNhcHR1cmluZyB0aGUgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBpbmRleGVzIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBpbmRleGVzLmxlbmd0aCA6IDAsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKGxlbmd0aCA9PSBsYXN0SW5kZXggfHwgaW5kZXggIT09IHByZXZpb3VzKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzID0gaW5kZXg7XG4gICAgICAgICAgaWYgKGlzSW5kZXgoaW5kZXgpKSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgsIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlVW5zZXQoYXJyYXksIGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5kb21gIHdpdGhvdXQgc3VwcG9ydCBmb3IgcmV0dXJuaW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpIHtcbiAgICAgIHJldHVybiBsb3dlciArIG5hdGl2ZUZsb29yKG5hdGl2ZVJhbmRvbSgpICogKHVwcGVyIC0gbG93ZXIgKyAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZ2VgIGFuZCBgXy5yYW5nZVJpZ2h0YCB3aGljaCBkb2Vzbid0XG4gICAgICogY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KG5hdGl2ZUNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XSA9IHN0YXJ0O1xuICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXBlYXRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVwZWF0KHN0cmluZywgbikge1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgaWYgKCFzdHJpbmcgfHwgbiA8IDEgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIC8vIExldmVyYWdlIHRoZSBleHBvbmVudGlhdGlvbiBieSBzcXVhcmluZyBhbGdvcml0aG0gZm9yIGEgZmFzdGVyIHJlcGVhdC5cbiAgICAgIC8vIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FeHBvbmVudGlhdGlvbl9ieV9zcXVhcmluZyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgZG8ge1xuICAgICAgICBpZiAobiAlIDIpIHtcbiAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBuYXRpdmVGbG9vcihuIC8gMik7XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgc3RyaW5nICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAobik7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2FtcGxlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2FtcGxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBhcnJheVNhbXBsZSh2YWx1ZXMoY29sbGVjdGlvbikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNhbXBsZVNpemVgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNhbXBsZVNpemUoY29sbGVjdGlvbiwgbikge1xuICAgICAgdmFyIGFycmF5ID0gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGFycmF5LCBiYXNlQ2xhbXAobiwgMCwgYXJyYXkubGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICAgICAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycgfHwga2V5ID09PSAnY29uc3RydWN0b3InIHx8IGtleSA9PT0gJ3Byb3RvdHlwZScpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXREYXRhYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGJhc2VTZXREYXRhID0gIW1ldGFNYXAgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIGRhdGEpIHtcbiAgICAgIG1ldGFNYXAuc2V0KGZ1bmMsIGRhdGEpO1xuICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2h1ZmZsZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKHZhbHVlcyhjb2xsZWN0aW9uKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IGVuZCA+IGxlbmd0aCA/IGxlbmd0aCA6IGVuZDtcbiAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gICAgICBzdGFydCA+Pj49IDA7XG5cbiAgICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb21lYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQgPSBwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuICFyZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRJbmRleGAgYW5kIGBfLnNvcnRlZExhc3RJbmRleGAgd2hpY2hcbiAgICAgKiBwZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggb2YgYGFycmF5YCB0byBkZXRlcm1pbmUgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWBcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCByZXRIaWdoZXN0KSB7XG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IGxvdyA6IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PT0gdmFsdWUgJiYgaGlnaCA8PSBIQUxGX01BWF9BUlJBWV9MRU5HVEgpIHtcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxLFxuICAgICAgICAgICAgICBjb21wdXRlZCA9IGFycmF5W21pZF07XG5cbiAgICAgICAgICBpZiAoY29tcHV0ZWQgIT09IG51bGwgJiYgIWlzU3ltYm9sKGNvbXB1dGVkKSAmJlxuICAgICAgICAgICAgICAocmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSkpKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGlkZW50aXR5LCByZXRIaWdoZXN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRJbmRleEJ5YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4QnlgXG4gICAgICogd2hpY2ggaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlXG4gICAgICogdGhlaXIgc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gaXRlcmF0ZWUodmFsdWUpO1xuICAgICAgdmFyIHZhbElzTmFOID0gdmFsdWUgIT09IHZhbHVlLFxuICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpLFxuICAgICAgICAgIHZhbElzVW5kZWZpbmVkID0gdmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgdmFyIG1pZCA9IG5hdGl2ZUZsb29yKChsb3cgKyBoaWdoKSAvIDIpLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZShhcnJheVttaWRdKSxcbiAgICAgICAgICAgIG90aElzRGVmaW5lZCA9IGNvbXB1dGVkICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBvdGhJc051bGwgPSBjb21wdXRlZCA9PT0gbnVsbCxcbiAgICAgICAgICAgIG90aElzUmVmbGV4aXZlID0gY29tcHV0ZWQgPT09IGNvbXB1dGVkLFxuICAgICAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChjb21wdXRlZCk7XG5cbiAgICAgICAgaWYgKHZhbElzTmFOKSB7XG4gICAgICAgICAgdmFyIHNldExvdyA9IHJldEhpZ2hlc3QgfHwgb3RoSXNSZWZsZXhpdmU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNVbmRlZmluZWQpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiAocmV0SGlnaGVzdCB8fCBvdGhJc0RlZmluZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzTnVsbCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAocmV0SGlnaGVzdCB8fCAhb3RoSXNOdWxsKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1N5bWJvbCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAhb3RoSXNOdWxsICYmIChyZXRIaWdoZXN0IHx8ICFvdGhJc1N5bWJvbCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3RoSXNOdWxsIHx8IG90aElzU3ltYm9sKSB7XG4gICAgICAgICAgc2V0TG93ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0TG93ID0gcmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldExvdykge1xuICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZU1pbihoaWdoLCBNQVhfQVJSQVlfSU5ERVgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZFVuaXFgIGFuZCBgXy5zb3J0ZWRVbmlxQnlgIHdpdGhvdXRcbiAgICAgKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRVbmlxKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIGlmICghaW5kZXggfHwgIWVxKGNvbXB1dGVkLCBzZWVuKSkge1xuICAgICAgICAgIHZhciBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9OdW1iZXJgIHdoaWNoIGRvZXNuJ3QgZW5zdXJlIGNvcnJlY3RcbiAgICAgKiBjb252ZXJzaW9ucyBvZiBiaW5hcnksIGhleGFkZWNpbWFsLCBvciBvY3RhbCBzdHJpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVG9OdW1iZXIodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gTkFOO1xuICAgICAgfVxuICAgICAgcmV0dXJuICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAgICAgKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICAgICAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgc2VlbiA9IHJlc3VsdDtcblxuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgICAgIHZhciBzZXQgPSBpdGVyYXRlZSA/IG51bGwgOiBjcmVhdGVTZXQoYXJyYXkpO1xuICAgICAgICBpZiAoc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgICAgICBzZWVuID0gbmV3IFNldENhY2hlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlZW4gPSBpdGVyYXRlZSA/IFtdIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWluY2x1ZGVzKHNlZW4sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgICAgIGlmIChzZWVuICE9PSByZXN1bHQpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bnNldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHByb3BlcnR5IHBhdGggdG8gdW5zZXQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBkZWxldGUgb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51cGRhdGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIHVwZGF0ZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHJldHVybiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdXBkYXRlcihiYXNlR2V0KG9iamVjdCwgcGF0aCkpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZHJvcFdoaWxlYCBhbmQgYF8udGFrZVdoaWxlYFxuICAgICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRHJvcF0gU3BlY2lmeSBkcm9wcGluZyBlbGVtZW50cyBpbnN0ZWFkIG9mIHRha2luZyB0aGVtLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgaXNEcm9wLCBmcm9tUmlnaHQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcblxuICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkgJiZcbiAgICAgICAgcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge31cblxuICAgICAgcmV0dXJuIGlzRHJvcFxuICAgICAgICA/IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IDAgOiBpbmRleCksIChmcm9tUmlnaHQgPyBpbmRleCArIDEgOiBsZW5ndGgpKVxuICAgICAgICA6IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IDApLCAoZnJvbVJpZ2h0ID8gbGVuZ3RoIDogaW5kZXgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgd3JhcHBlclZhbHVlYCB3aGljaCByZXR1cm5zIHRoZSByZXN1bHQgb2ZcbiAgICAgKiBwZXJmb3JtaW5nIGEgc2VxdWVuY2Ugb2YgYWN0aW9ucyBvbiB0aGUgdW53cmFwcGVkIGB2YWx1ZWAsIHdoZXJlIGVhY2hcbiAgICAgKiBzdWNjZXNzaXZlIGFjdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFjdGlvbnMgQWN0aW9ucyB0byBwZXJmb3JtIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVdyYXBwZXJWYWx1ZSh2YWx1ZSwgYWN0aW9ucykge1xuICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC52YWx1ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKGFjdGlvbnMsIGZ1bmN0aW9uKHJlc3VsdCwgYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb24uZnVuYy5hcHBseShhY3Rpb24udGhpc0FyZywgYXJyYXlQdXNoKFtyZXN1bHRdLCBhY3Rpb24uYXJncykpO1xuICAgICAgfSwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ueG9yYCwgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlWG9yKGFycmF5cywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VVbmlxKGFycmF5c1swXSkgOiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tpbmRleF0sXG4gICAgICAgICAgICBvdGhJbmRleCA9IC0xO1xuXG4gICAgICAgIHdoaWxlICgrK290aEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG90aEluZGV4ICE9IGluZGV4KSB7XG4gICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gYmFzZURpZmZlcmVuY2UocmVzdWx0W2luZGV4XSB8fCBhcnJheSwgYXJyYXlzW290aEluZGV4XSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKHJlc3VsdCwgMSksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uemlwT2JqZWN0YCB3aGljaCBhc3NpZ25zIHZhbHVlcyB1c2luZyBgYXNzaWduRnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25GdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVppcE9iamVjdChwcm9wcywgdmFsdWVzLCBhc3NpZ25GdW5jKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgdmFsc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGluZGV4IDwgdmFsc0xlbmd0aCA/IHZhbHVlc1tpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGFzc2lnbkZ1bmMocmVzdWx0LCBwcm9wc1tpbmRleF0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBhbiBlbXB0eSBhcnJheSBpZiBpdCdzIG5vdCBhbiBhcnJheSBsaWtlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIHRoZSBjYXN0IGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYGlkZW50aXR5YCBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgYGJhc2VSZXN0YCBhbGlhcyB3aGljaCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBgaWRlbnRpdHlgIGJ5IG1vZHVsZVxuICAgICAqIHJlcGxhY2VtZW50IHBsdWdpbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHZhciBjYXN0UmVzdCA9IGJhc2VSZXN0O1xuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdFNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQ7XG4gICAgICByZXR1cm4gKCFzdGFydCAmJiBlbmQgPj0gbGVuZ3RoKSA/IGFycmF5IDogYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2xvYmFsIFtgY2xlYXJUaW1lb3V0YF0oaHR0cHM6Ly9tZG4uaW8vY2xlYXJUaW1lb3V0KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ8T2JqZWN0fSBpZCBUaGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3Qgb2YgdGhlIHRpbWVyIHRvIGNsZWFyLlxuICAgICAqL1xuICAgIHZhciBjbGVhclRpbWVvdXQgPSBjdHhDbGVhclRpbWVvdXQgfHwgZnVuY3Rpb24oaWQpIHtcbiAgICAgIHJldHVybiByb290LmNsZWFyVGltZW91dChpZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gICAgICBidWZmZXIuY29weShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gICAgICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICAgICAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gICAgICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gICAgICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gICAgICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgICAgIHZhciB2YWxJc0RlZmluZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpO1xuXG4gICAgICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlcixcbiAgICAgICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2wob3RoZXIpO1xuXG4gICAgICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICAgICAodmFsSXNTeW1ib2wgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICF2YWxJc1JlZmxleGl2ZSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wgJiYgIW90aElzU3ltYm9sICYmIHZhbHVlIDwgb3RoZXIpIHx8XG4gICAgICAgICAgICAob3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIW90aElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICFvdGhJc1JlZmxleGl2ZSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gICAgICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXG4gICAgICpcbiAgICAgKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICAgICAqIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXJcbiAgICAgKiBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW5bXXxzdHJpbmdbXX0gb3JkZXJzIFRoZSBvcmRlciB0byBzb3J0IGJ5IGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgICAgIGxlbmd0aCA9IG9iakNyaXRlcmlhLmxlbmd0aCxcbiAgICAgICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY29tcGFyZUFzY2VuZGluZyhvYmpDcml0ZXJpYVtpbmRleF0sIG90aENyaXRlcmlhW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xuICAgICAgICAgIHJldHVybiByZXN1bHQgKiAob3JkZXIgPT0gJ2Rlc2MnID8gLTEgOiAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRml4ZXMgYW4gYEFycmF5I3NvcnRgIGJ1ZyBpbiB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIGFwcGxpY2F0aW9uc1xuICAgICAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgICAgIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMsXG4gICAgICogcGxhY2Vob2xkZXJzLCBhbmQgcHJvdmlkZWQgYXJndW1lbnRzIGludG8gYSBzaW5nbGUgYXJyYXkgb2YgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKSB7XG4gICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZWZ0TGVuZ3RoICsgcmFuZ2VMZW5ndGgpLFxuICAgICAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcblxuICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W2hvbGRlcnNbYXJnc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChyYW5nZUxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtsZWZ0SW5kZXgrK10gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBjb21wb3NlQXJnc2AgZXhjZXB0IHRoYXQgdGhlIGFyZ3VtZW50cyBjb21wb3NpdGlvblxuICAgICAqIGlzIHRhaWxvcmVkIGZvciBgXy5wYXJ0aWFsUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBob2xkZXJzSW5kZXggPSAtMSxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgcmlnaHRJbmRleCA9IC0xLFxuICAgICAgICAgIHJpZ2h0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShyYW5nZUxlbmd0aCArIHJpZ2h0TGVuZ3RoKSxcbiAgICAgICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XG5cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IHJhbmdlTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFthcmdzSW5kZXhdID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgfVxuICAgICAgdmFyIG9mZnNldCA9IGFyZ3NJbmRleDtcbiAgICAgIHdoaWxlICgrK3JpZ2h0SW5kZXggPCByaWdodExlbmd0aCkge1xuICAgICAgICByZXN1bHRbb2Zmc2V0ICsgcmlnaHRJbmRleF0gPSBwYXJ0aWFsc1tyaWdodEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2hvbGRlcnNJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgaWYgKGlzVW5jdXJyaWVkIHx8IGFyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbb2Zmc2V0ICsgaG9sZGVyc1tob2xkZXJzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICAgICAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICAgICAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgICAgIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05ldykge1xuICAgICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBvd24gYW5kIGluaGVyaXRlZCBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICAgICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5ncm91cEJ5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpbml0aWFsaXplcl0gVGhlIGFjY3VtdWxhdG9yIG9iamVjdCBpbml0aWFsaXplci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyLCBpbml0aWFsaXplcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5QWdncmVnYXRvciA6IGJhc2VBZ2dyZWdhdG9yLFxuICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBpbml0aWFsaXplciA/IGluaXRpYWxpemVyKCkgOiB7fTtcblxuICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBzZXR0ZXIsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYWNjdW11bGF0b3IpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5sb3dlckZpcnN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBTdHJpbmdgIGNhc2UgbWV0aG9kIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhc2VGaXJzdChtZXRob2ROYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgICAgICA/IHN0cmluZ1RvQXJyYXkoc3RyaW5nKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIHZhciBjaHIgPSBzdHJTeW1ib2xzXG4gICAgICAgICAgPyBzdHJTeW1ib2xzWzBdXG4gICAgICAgICAgOiBzdHJpbmcuY2hhckF0KDApO1xuXG4gICAgICAgIHZhciB0cmFpbGluZyA9IHN0clN5bWJvbHNcbiAgICAgICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAxKS5qb2luKCcnKVxuICAgICAgICAgIDogc3RyaW5nLnNsaWNlKDEpO1xuXG4gICAgICAgIHJldHVybiBjaHJbbWV0aG9kTmFtZV0oKSArIHRyYWlsaW5nO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5jYW1lbENhc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSBlYWNoIHdvcmQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBhcnJheVJlZHVjZSh3b3JkcyhkZWJ1cnIoc3RyaW5nKS5yZXBsYWNlKHJlQXBvcywgJycpKSwgY2FsbGJhY2ssICcnKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYW4gaW5zdGFuY2Ugb2YgYEN0b3JgIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgKiB3aGV0aGVyIGl0IHdhcyBpbnZva2VkIGFzIHBhcnQgb2YgYSBgbmV3YCBleHByZXNzaW9uIG9yIGJ5IGBjYWxsYCBvciBgYXBwbHlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBDdG9yIFRoZSBjb25zdHJ1Y3RvciB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3RvcihDdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFVzZSBhIGBzd2l0Y2hgIHN0YXRlbWVudCB0byB3b3JrIHdpdGggY2xhc3MgY29uc3RydWN0b3JzLiBTZWVcbiAgICAgICAgLy8gaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1mdW5jdGlvbi1vYmplY3RzLWNhbGwtdGhpc2FyZ3VtZW50LWFyZ3VtZW50c2xpc3RcbiAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQ3RvcjtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcbiAgICAgICAgICBjYXNlIDc6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdLCBhcmdzWzZdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKEN0b3IucHJvdG90eXBlKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IEN0b3IuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuXG4gICAgICAgIC8vIE1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBlbmFibGUgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJpdHkgVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KSB7XG4gICAgICB2YXIgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aCxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpO1xuXG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBob2xkZXJzID0gKGxlbmd0aCA8IDMgJiYgYXJnc1swXSAhPT0gcGxhY2Vob2xkZXIgJiYgYXJnc1tsZW5ndGggLSAxXSAhPT0gcGxhY2Vob2xkZXIpXG4gICAgICAgICAgPyBbXVxuICAgICAgICAgIDogcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuXG4gICAgICAgIGxlbmd0aCAtPSBob2xkZXJzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFyZ3MsIGhvbGRlcnMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSAtIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmRJbmRleEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNvbGxlY3Rpb24gaW5kZXguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGaW5kKGZpbmRJbmRleEZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgICB2YXIgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG4gICAgICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgICAgIGNvbGxlY3Rpb24gPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gZmluZEluZGV4RnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCk7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gaXRlcmFibGVbaXRlcmF0ZWUgPyBjb2xsZWN0aW9uW2luZGV4XSA6IGluZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZsb3dgIG9yIGBfLmZsb3dSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsb3cgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmxvdyhmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmbGF0UmVzdChmdW5jdGlvbihmdW5jcykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gZnVuY3MubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICBwcmVyZXEgPSBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS50aHJ1O1xuXG4gICAgICAgIGlmIChmcm9tUmlnaHQpIHtcbiAgICAgICAgICBmdW5jcy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGZ1bmNzW2luZGV4XTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJlcmVxICYmICF3cmFwcGVyICYmIGdldEZ1bmNOYW1lKGZ1bmMpID09ICd3cmFwcGVyJykge1xuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBuZXcgTG9kYXNoV3JhcHBlcihbXSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gd3JhcHBlciA/IGluZGV4IDogbGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGZ1bmMgPSBmdW5jc1tpbmRleF07XG5cbiAgICAgICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICAgICAgZGF0YSA9IGZ1bmNOYW1lID09ICd3cmFwcGVyJyA/IGdldERhdGEoZnVuYykgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoZGF0YSAmJiBpc0xhemlhYmxlKGRhdGFbMF0pICYmXG4gICAgICAgICAgICAgICAgZGF0YVsxXSA9PSAoV1JBUF9BUllfRkxBRyB8IFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfUEFSVElBTF9GTEFHIHwgV1JBUF9SRUFSR19GTEFHKSAmJlxuICAgICAgICAgICAgICAgICFkYXRhWzRdLmxlbmd0aCAmJiBkYXRhWzldID09IDFcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gd3JhcHBlcltnZXRGdW5jTmFtZShkYXRhWzBdKV0uYXBwbHkod3JhcHBlciwgZGF0YVszXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdyYXBwZXIgPSAoZnVuYy5sZW5ndGggPT0gMSAmJiBpc0xhemlhYmxlKGZ1bmMpKVxuICAgICAgICAgICAgICA/IHdyYXBwZXJbZnVuY05hbWVdKClcbiAgICAgICAgICAgICAgOiB3cmFwcGVyLnRocnUoZnVuYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgdmFsdWUgPSBhcmdzWzBdO1xuXG4gICAgICAgICAgaWYgKHdyYXBwZXIgJiYgYXJncy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXIucGxhbnQodmFsdWUpLnZhbHVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGxlbmd0aCA/IGZ1bmNzW2luZGV4XS5hcHBseSh0aGlzLCBhcmdzKSA6IHZhbHVlO1xuXG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmNzW2luZGV4XS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AsIHBhcnRpYWwgYXBwbGljYXRpb24sIGFuZCBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzUmlnaHRdIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkXG4gICAgICogIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNSaWdodF0gVGhlIGBwYXJ0aWFsc1JpZ2h0YCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUh5YnJpZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0FyeSA9IGJpdG1hc2sgJiBXUkFQX0FSWV9GTEFHLFxuICAgICAgICAgIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHLFxuICAgICAgICAgIGlzQ3VycmllZCA9IGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSxcbiAgICAgICAgICBpc0ZsaXAgPSBiaXRtYXNrICYgV1JBUF9GTElQX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDdXJyaWVkKSB7XG4gICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpLFxuICAgICAgICAgICAgICBob2xkZXJzQ291bnQgPSBjb3VudEhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFscykge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHNSaWdodCkge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgaXNDdXJyaWVkKTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggLT0gaG9sZGVyc0NvdW50O1xuICAgICAgICBpZiAoaXNDdXJyaWVkICYmIGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgdmFyIG5ld0hvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHRoaXNBcmcsXG4gICAgICAgICAgICBhcmdzLCBuZXdIb2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkgLSBsZW5ndGhcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLFxuICAgICAgICAgICAgZm4gPSBpc0JpbmRLZXkgPyB0aGlzQmluZGluZ1tmdW5jXSA6IGZ1bmM7XG5cbiAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICAgIGlmIChhcmdQb3MpIHtcbiAgICAgICAgICBhcmdzID0gcmVvcmRlcihhcmdzLCBhcmdQb3MpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRmxpcCAmJiBsZW5ndGggPiAxKSB7XG4gICAgICAgICAgYXJncy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJ5ICYmIGFyeSA8IGxlbmd0aCkge1xuICAgICAgICAgIGFyZ3MubGVuZ3RoID0gYXJ5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpIHtcbiAgICAgICAgICBmbiA9IEN0b3IgfHwgY3JlYXRlQ3Rvcihmbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmludmVydEJ5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRvSXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgaXRlcmF0ZWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludmVydGVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmVydGVyKHNldHRlciwgdG9JdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZlcnRlcihvYmplY3QsIHNldHRlciwgdG9JdGVyYXRlZShpdGVyYXRlZSksIHt9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBtYXRoZW1hdGljYWwgb3BlcmF0aW9uIG9uIHR3byB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wZXJhdG9yIFRoZSBmdW5jdGlvbiB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSB1c2VkIGZvciBgdW5kZWZpbmVkYCBhcmd1bWVudHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVNYXRoT3BlcmF0aW9uKG9wZXJhdG9yLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgb3RoZXIgPSBiYXNlVG9TdHJpbmcob3RoZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VUb051bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBvdGhlciA9IGJhc2VUb051bWJlcihvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IG9wZXJhdG9yKHZhbHVlLCBvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ub3ZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFycmF5RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGl0ZXJhdGVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBvdmVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU92ZXIoYXJyYXlGdW5jKSB7XG4gICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oaXRlcmF0ZWVzKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcbiAgICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICB2YXIgdGhpc0FyZyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGFycmF5RnVuYyhpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkoaXRlcmF0ZWUsIHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHBhZGRpbmcgZm9yIGBzdHJpbmdgIGJhc2VkIG9uIGBsZW5ndGhgLiBUaGUgYGNoYXJzYCBzdHJpbmdcbiAgICAgKiBpcyB0cnVuY2F0ZWQgaWYgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGV4Y2VlZHMgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkaW5nIGZvciBgc3RyaW5nYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYWRkaW5nKGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIGNoYXJzID0gY2hhcnMgPT09IHVuZGVmaW5lZCA/ICcgJyA6IGJhc2VUb1N0cmluZyhjaGFycyk7XG5cbiAgICAgIHZhciBjaGFyc0xlbmd0aCA9IGNoYXJzLmxlbmd0aDtcbiAgICAgIGlmIChjaGFyc0xlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJzTGVuZ3RoID8gYmFzZVJlcGVhdChjaGFycywgbGVuZ3RoKSA6IGNoYXJzO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VSZXBlYXQoY2hhcnMsIG5hdGl2ZUNlaWwobGVuZ3RoIC8gc3RyaW5nU2l6ZShjaGFycykpKTtcbiAgICAgIHJldHVybiBoYXNVbmljb2RlKGNoYXJzKVxuICAgICAgICA/IGNhc3RTbGljZShzdHJpbmdUb0FycmF5KHJlc3VsdCksIDAsIGxlbmd0aCkuam9pbignJylcbiAgICAgICAgOiByZXN1bHQuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nXG4gICAgICogb2YgYHRoaXNBcmdgIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZWZ0TGVuZ3RoICsgYXJnc0xlbmd0aCksXG4gICAgICAgICAgICBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG5cbiAgICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4KytdID0gYXJndW1lbnRzWysrYXJnc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZm4sIGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5yYW5nZWAgb3IgYF8ucmFuZ2VSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJhbmdlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAgICAgaWYgKHN0ZXAgJiYgdHlwZW9mIHN0ZXAgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RhcnQsIGVuZCwgc3RlcCkpIHtcbiAgICAgICAgICBlbmQgPSBzdGVwID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAgPSBzdGVwID09PSB1bmRlZmluZWQgPyAoc3RhcnQgPCBlbmQgPyAxIDogLTEpIDogdG9GaW5pdGUoc3RlcCk7XG4gICAgICAgIHJldHVybiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSByZWxhdGlvbmFsIG9wZXJhdGlvbiBvbiB0d28gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcGVyYXRvciBUaGUgZnVuY3Rpb24gdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlbGF0aW9uYWwgb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24ob3BlcmF0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnICYmIHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICBvdGhlciA9IHRvTnVtYmVyKG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BlcmF0b3IodmFsdWUsIG90aGVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGNvbnRpbnVlIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgYGZ1bmNgIHdyYXBwZXIuXG4gICAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlY3VycnkoZnVuYywgYml0bWFzaywgd3JhcEZ1bmMsIHBsYWNlaG9sZGVyLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNDdXJyeSA9IGJpdG1hc2sgJiBXUkFQX0NVUlJZX0ZMQUcsXG4gICAgICAgICAgbmV3SG9sZGVycyA9IGlzQ3VycnkgPyBob2xkZXJzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5ld0hvbGRlcnNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBob2xkZXJzLFxuICAgICAgICAgIG5ld1BhcnRpYWxzID0gaXNDdXJyeSA/IHBhcnRpYWxzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5ld1BhcnRpYWxzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogcGFydGlhbHM7XG5cbiAgICAgIGJpdG1hc2sgfD0gKGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfRkxBRyA6IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgIGJpdG1hc2sgJj0gfihpc0N1cnJ5ID8gV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgOiBXUkFQX1BBUlRJQUxfRkxBRyk7XG5cbiAgICAgIGlmICghKGJpdG1hc2sgJiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcpKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyk7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RGF0YSA9IFtcbiAgICAgICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgbmV3UGFydGlhbHMsIG5ld0hvbGRlcnMsIG5ld1BhcnRpYWxzUmlnaHQsXG4gICAgICAgIG5ld0hvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5XG4gICAgICBdO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gd3JhcEZ1bmMuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgICAgIGlmIChpc0xhemlhYmxlKGZ1bmMpKSB7XG4gICAgICAgIHNldERhdGEocmVzdWx0LCBuZXdEYXRhKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhyZXN1bHQsIGZ1bmMsIGJpdG1hc2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLnJvdW5kYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBNYXRoYCBtZXRob2QgdG8gdXNlIHdoZW4gcm91bmRpbmcuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUm91bmQobWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBNYXRoW21ldGhvZE5hbWVdO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG51bWJlciwgcHJlY2lzaW9uKSB7XG4gICAgICAgIG51bWJlciA9IHRvTnVtYmVyKG51bWJlcik7XG4gICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PSBudWxsID8gMCA6IG5hdGl2ZU1pbih0b0ludGVnZXIocHJlY2lzaW9uKSwgMjkyKTtcbiAgICAgICAgaWYgKHByZWNpc2lvbiAmJiBuYXRpdmVJc0Zpbml0ZShudW1iZXIpKSB7XG4gICAgICAgICAgLy8gU2hpZnQgd2l0aCBleHBvbmVudGlhbCBub3RhdGlvbiB0byBhdm9pZCBmbG9hdGluZy1wb2ludCBpc3N1ZXMuXG4gICAgICAgICAgLy8gU2VlIFtNRE5dKGh0dHBzOi8vbWRuLmlvL3JvdW5kI0V4YW1wbGVzKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgIHZhciBwYWlyID0gKHRvU3RyaW5nKG51bWJlcikgKyAnZScpLnNwbGl0KCdlJyksXG4gICAgICAgICAgICAgIHZhbHVlID0gZnVuYyhwYWlyWzBdICsgJ2UnICsgKCtwYWlyWzFdICsgcHJlY2lzaW9uKSk7XG5cbiAgICAgICAgICBwYWlyID0gKHRvU3RyaW5nKHZhbHVlKSArICdlJykuc3BsaXQoJ2UnKTtcbiAgICAgICAgICByZXR1cm4gKyhwYWlyWzBdICsgJ2UnICsgKCtwYWlyWzFdIC0gcHJlY2lzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMobnVtYmVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNldCBvYmplY3Qgb2YgYHZhbHVlc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFkZCB0byB0aGUgc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBzZXQuXG4gICAgICovXG4gICAgdmFyIGNyZWF0ZVNldCA9ICEoU2V0ICYmICgxIC8gc2V0VG9BcnJheShuZXcgU2V0KFssLTBdKSlbMV0pID09IElORklOSVRZKSA/IG5vb3AgOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBuZXcgU2V0KHZhbHVlcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy50b1BhaXJzYCBvciBgXy50b1BhaXJzSW5gIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhaXJzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVRvUGFpcnMoa2V5c0Z1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIHRhZyA9IGdldFRhZyhvYmplY3QpO1xuICAgICAgICBpZiAodGFnID09IG1hcFRhZykge1xuICAgICAgICAgIHJldHVybiBtYXBUb0FycmF5KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VG9QYWlycyhvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlVG9QYWlycyhvYmplY3QsIGtleXNGdW5jKG9iamVjdCkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBlaXRoZXIgY3VycmllcyBvciBpbnZva2VzIGBmdW5jYCB3aXRoIG9wdGlvbmFsXG4gICAgICogYHRoaXNgIGJpbmRpbmcgYW5kIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gICAgICogICAgMSAtIGBfLmJpbmRgXG4gICAgICogICAgMiAtIGBfLmJpbmRLZXlgXG4gICAgICogICAgNCAtIGBfLmN1cnJ5YCBvciBgXy5jdXJyeVJpZ2h0YCBvZiBhIGJvdW5kIGZ1bmN0aW9uXG4gICAgICogICAgOCAtIGBfLmN1cnJ5YFxuICAgICAqICAgMTYgLSBgXy5jdXJyeVJpZ2h0YFxuICAgICAqICAgMzIgLSBgXy5wYXJ0aWFsYFxuICAgICAqICAgNjQgLSBgXy5wYXJ0aWFsUmlnaHRgXG4gICAgICogIDEyOCAtIGBfLnJlYXJnYFxuICAgICAqICAyNTYgLSBgXy5hcnlgXG4gICAgICogIDUxMiAtIGBfLmZsaXBgXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlV3JhcChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRztcbiAgICAgIGlmICghaXNCaW5kS2V5ICYmIHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IHBhcnRpYWxzID8gcGFydGlhbHMubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYXJ5ID0gYXJ5ID09PSB1bmRlZmluZWQgPyBhcnkgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKGFyeSksIDApO1xuICAgICAgYXJpdHkgPSBhcml0eSA9PT0gdW5kZWZpbmVkID8gYXJpdHkgOiB0b0ludGVnZXIoYXJpdHkpO1xuICAgICAgbGVuZ3RoIC09IGhvbGRlcnMgPyBob2xkZXJzLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmIChiaXRtYXNrICYgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxzUmlnaHQgPSBwYXJ0aWFscyxcbiAgICAgICAgICAgIGhvbGRlcnNSaWdodCA9IGhvbGRlcnM7XG5cbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBnZXREYXRhKGZ1bmMpO1xuXG4gICAgICB2YXIgbmV3RGF0YSA9IFtcbiAgICAgICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCxcbiAgICAgICAgYXJnUG9zLCBhcnksIGFyaXR5XG4gICAgICBdO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBtZXJnZURhdGEobmV3RGF0YSwgZGF0YSk7XG4gICAgICB9XG4gICAgICBmdW5jID0gbmV3RGF0YVswXTtcbiAgICAgIGJpdG1hc2sgPSBuZXdEYXRhWzFdO1xuICAgICAgdGhpc0FyZyA9IG5ld0RhdGFbMl07XG4gICAgICBwYXJ0aWFscyA9IG5ld0RhdGFbM107XG4gICAgICBob2xkZXJzID0gbmV3RGF0YVs0XTtcbiAgICAgIGFyaXR5ID0gbmV3RGF0YVs5XSA9IG5ld0RhdGFbOV0gPT09IHVuZGVmaW5lZFxuICAgICAgICA/IChpc0JpbmRLZXkgPyAwIDogZnVuYy5sZW5ndGgpXG4gICAgICAgIDogbmF0aXZlTWF4KG5ld0RhdGFbOV0gLSBsZW5ndGgsIDApO1xuXG4gICAgICBpZiAoIWFyaXR5ICYmIGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKTtcbiAgICAgIH1cbiAgICAgIGlmICghYml0bWFzayB8fCBiaXRtYXNrID09IFdSQVBfQklORF9GTEFHKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVCaW5kKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcpO1xuICAgICAgfSBlbHNlIGlmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRyB8fCBiaXRtYXNrID09IFdSQVBfQ1VSUllfUklHSFRfRkxBRykge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVDdXJyeShmdW5jLCBiaXRtYXNrLCBhcml0eSk7XG4gICAgICB9IGVsc2UgaWYgKChiaXRtYXNrID09IFdSQVBfUEFSVElBTF9GTEFHIHx8IGJpdG1hc2sgPT0gKFdSQVBfQklORF9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcpKSAmJiAhaG9sZGVycy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVIeWJyaWQuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgICAgIH1cbiAgICAgIHZhciBzZXR0ZXIgPSBkYXRhID8gYmFzZVNldERhdGEgOiBzZXREYXRhO1xuICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhzZXR0ZXIocmVzdWx0LCBuZXdEYXRhKSwgZnVuYywgYml0bWFzayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5kZWZhdWx0c2AgdG8gY3VzdG9taXplIGl0cyBgXy5hc3NpZ25JbmAgdXNlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzXG4gICAgICogb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXNcbiAgICAgKiB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgKGVxKG9ialZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgIHJldHVybiBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLmRlZmF1bHRzRGVlcGAgdG8gY3VzdG9taXplIGl0cyBgXy5tZXJnZWAgdXNlIHRvIG1lcmdlIHNvdXJjZVxuICAgICAqIG9iamVjdHMgaW50byBkZXN0aW5hdGlvbiBvYmplY3RzIHRoYXQgYXJlIHBhc3NlZCB0aHJ1LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBtZXJnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgcGFyZW50IG9iamVjdCBvZiBgc3JjVmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gICAgICogIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykge1xuICAgICAgaWYgKGlzT2JqZWN0KG9ialZhbHVlKSAmJiBpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgb2JqVmFsdWUpO1xuICAgICAgICBiYXNlTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCB1bmRlZmluZWQsIGN1c3RvbURlZmF1bHRzTWVyZ2UsIHN0YWNrKTtcbiAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLm9taXRgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uY2xvbmVEZWVwYCB1c2UgdG8gb25seSBjbG9uZSBwbGFpblxuICAgICAqIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bmNsb25lZCB2YWx1ZSBvciBgdW5kZWZpbmVkYCB0byBkZWZlciBjbG9uaW5nIHRvIGBfLmNsb25lRGVlcGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tT21pdENsb25lKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gICAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gICAgICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgYXJyU3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gICAgICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gICAgICBpZiAoYXJyU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBhcnJTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gYXJyYXk7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gICAgICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgICAgIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gICAgICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICAgICAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgICAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gICAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgICAgIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgb2JqU3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICAgICAgaWYgKG9ialN0YWNrZWQgJiYgb3RoU3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gb2JqU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IG9iamVjdDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gICAgICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgICAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgICAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIGZsYXR0ZW5zIHRoZSByZXN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRSZXN0KGZ1bmMpIHtcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCB1bmRlZmluZWQsIGZsYXR0ZW4pLCBmdW5jICsgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGdldERhdGEgPSAhbWV0YU1hcCA/IG5vb3AgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICByZXR1cm4gbWV0YU1hcC5nZXQoZnVuYyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hbWUgb2YgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEZ1bmNOYW1lKGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSAoZnVuYy5uYW1lICsgJycpLFxuICAgICAgICAgIGFycmF5ID0gcmVhbE5hbWVzW3Jlc3VsdF0sXG4gICAgICAgICAgbGVuZ3RoID0gaGFzT3duUHJvcGVydHkuY2FsbChyZWFsTmFtZXMsIHJlc3VsdCkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBhcnJheVtsZW5ndGhdLFxuICAgICAgICAgICAgb3RoZXJGdW5jID0gZGF0YS5mdW5jO1xuICAgICAgICBpZiAob3RoZXJGdW5jID09IG51bGwgfHwgb3RoZXJGdW5jID09IGZ1bmMpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YS5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFyZ3VtZW50IHBsYWNlaG9sZGVyIHZhbHVlIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEhvbGRlcihmdW5jKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gsICdwbGFjZWhvbGRlcicpID8gbG9kYXNoIDogZnVuYztcbiAgICAgIHJldHVybiBvYmplY3QucGxhY2Vob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpdGVyYXRlZVwiIGZ1bmN0aW9uLiBJZiBgXy5pdGVyYXRlZWAgaXMgY3VzdG9taXplZCxcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGN1c3RvbSBtZXRob2QsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBiYXNlSXRlcmF0ZWVgLlxuICAgICAqIElmIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIHRoZSBjaG9zZW4gZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIHRoZW0gYW5kXG4gICAgICogaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWVdIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiB0aGUgY3JlYXRlZCBpdGVyYXRlZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNob3NlbiBmdW5jdGlvbiBvciBpdHMgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEl0ZXJhdGVlKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaC5pdGVyYXRlZSB8fCBpdGVyYXRlZTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gaXRlcmF0ZWUgPyBiYXNlSXRlcmF0ZWUgOiByZXN1bHQ7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHJlc3VsdChhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgICAgIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgICAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgICAgICA6IGRhdGEubWFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gICAgICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICAgICAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgaWYgKHVubWFza2VkKSB7XG4gICAgICAgIGlmIChpc093bikge1xuICAgICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB3aGlsZSAob2JqZWN0KSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIHZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4gICAgLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuICAgIGlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAgICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgICAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAgICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICAgICAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgICAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZpZXcsIGFwcGx5aW5nIGFueSBgdHJhbnNmb3Jtc2AgdG8gdGhlIGBzdGFydGAgYW5kIGBlbmRgIHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtcyBUaGUgdHJhbnNmb3JtYXRpb25zIHRvIGFwcGx5IHRvIHRoZSB2aWV3LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBzdGFydGAgYW5kIGBlbmRgXG4gICAgICogIHBvc2l0aW9ucyBvZiB0aGUgdmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRWaWV3KHN0YXJ0LCBlbmQsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRyYW5zZm9ybXNbaW5kZXhdLFxuICAgICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2Ryb3AnOiAgICAgIHN0YXJ0ICs9IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Ryb3BSaWdodCc6IGVuZCAtPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlJzogICAgICBlbmQgPSBuYXRpdmVNaW4oZW5kLCBzdGFydCArIHNpemUpOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlUmlnaHQnOiBzdGFydCA9IG5hdGl2ZU1heChzdGFydCwgZW5kIC0gc2l6ZSk7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyAnc3RhcnQnOiBzdGFydCwgJ2VuZCc6IGVuZCB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHdyYXBwZXIgZGV0YWlscyBmcm9tIHRoZSBgc291cmNlYCBib2R5IGNvbW1lbnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgVGhlIHNvdXJjZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd3JhcHBlciBkZXRhaWxzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFdyYXBEZXRhaWxzKHNvdXJjZSkge1xuICAgICAgdmFyIG1hdGNoID0gc291cmNlLm1hdGNoKHJlV3JhcERldGFpbHMpO1xuICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQocmVTcGxpdERldGFpbHMpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICAgICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICAgICAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAgICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gICAgICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgICAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICAgICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgICAgIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgICAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgICAgIDoge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE1hcGAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgYFNldGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgICAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB3cmFwcGVyIGBkZXRhaWxzYCBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgYHNvdXJjZWAgYm9keS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIG1vZGlmeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gaW5zZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHNvdXJjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnRXcmFwRGV0YWlscyhzb3VyY2UsIGRldGFpbHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBkZXRhaWxzLmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgIGRldGFpbHNbbGFzdEluZGV4XSA9IChsZW5ndGggPiAxID8gJyYgJyA6ICcnKSArIGRldGFpbHNbbGFzdEluZGV4XTtcbiAgICAgIGRldGFpbHMgPSBkZXRhaWxzLmpvaW4obGVuZ3RoID4gMiA/ICcsICcgOiAnICcpO1xuICAgICAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKHJlV3JhcENvbW1lbnQsICd7XFxuLyogW3dyYXBwZWQgd2l0aCAnICsgZGV0YWlscyArICddICovXFxuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICAgICAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICAgICApIHtcbiAgICAgICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgICAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICAgICAgOiAodmFsdWUgPT09IG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMYXppYWJsZShmdW5jKSB7XG4gICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICBvdGhlciA9IGxvZGFzaFtmdW5jTmFtZV07XG5cbiAgICAgIGlmICh0eXBlb2Ygb3RoZXIgIT0gJ2Z1bmN0aW9uJyB8fCAhKGZ1bmNOYW1lIGluIExhenlXcmFwcGVyLnByb3RvdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGZ1bmMgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBnZXREYXRhKG90aGVyKTtcbiAgICAgIHJldHVybiAhIWRhdGEgJiYgZnVuYyA9PT0gZGF0YVswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gICAgICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaXMgY2FwYWJsZSBvZiBiZWluZyBtYXNrZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2FibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICB2YXIgaXNNYXNrYWJsZSA9IGNvcmVKc0RhdGEgPyBpc0Z1bmN0aW9uIDogc3R1YkZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICAgICAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICAgICAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gICAgICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gICAgICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gICAgICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICAgICAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHRoZSBmdW5jdGlvbiBtZXRhZGF0YSBvZiBgc291cmNlYCBpbnRvIGBkYXRhYC5cbiAgICAgKlxuICAgICAqIE1lcmdpbmcgbWV0YWRhdGEgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHdyYXBwZXJzIHVzZWQgdG8gaW52b2tlIGEgZnVuY3Rpb24uXG4gICAgICogVGhpcyBpcyBwb3NzaWJsZSBiZWNhdXNlIG1ldGhvZHMgbGlrZSBgXy5iaW5kYCwgYF8uY3VycnlgLCBhbmQgYF8ucGFydGlhbGBcbiAgICAgKiBtYXkgYmUgYXBwbGllZCByZWdhcmRsZXNzIG9mIGV4ZWN1dGlvbiBvcmRlci4gTWV0aG9kcyBsaWtlIGBfLmFyeWAgYW5kXG4gICAgICogYF8ucmVhcmdgIG1vZGlmeSBmdW5jdGlvbiBhcmd1bWVudHMsIG1ha2luZyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcmVcbiAgICAgKiBleGVjdXRlZCBpbXBvcnRhbnQsIHByZXZlbnRpbmcgdGhlIG1lcmdpbmcgb2YgbWV0YWRhdGEuIEhvd2V2ZXIsIHdlIG1ha2VcbiAgICAgKiBhbiBleGNlcHRpb24gZm9yIGEgc2FmZSBjb21iaW5lZCBjYXNlIHdoZXJlIGN1cnJpZWQgZnVuY3Rpb25zIGhhdmUgYF8uYXJ5YFxuICAgICAqIGFuZCBvciBgXy5yZWFyZ2AgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSBUaGUgZGVzdGluYXRpb24gbWV0YWRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBzb3VyY2UgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkYXRhYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZURhdGEoZGF0YSwgc291cmNlKSB7XG4gICAgICB2YXIgYml0bWFzayA9IGRhdGFbMV0sXG4gICAgICAgICAgc3JjQml0bWFzayA9IHNvdXJjZVsxXSxcbiAgICAgICAgICBuZXdCaXRtYXNrID0gYml0bWFzayB8IHNyY0JpdG1hc2ssXG4gICAgICAgICAgaXNDb21tb24gPSBuZXdCaXRtYXNrIDwgKFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHIHwgV1JBUF9BUllfRkxBRyk7XG5cbiAgICAgIHZhciBpc0NvbWJvID1cbiAgICAgICAgKChzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpIHx8XG4gICAgICAgICgoc3JjQml0bWFzayA9PSBXUkFQX0FSWV9GTEFHKSAmJiAoYml0bWFzayA9PSBXUkFQX1JFQVJHX0ZMQUcpICYmIChkYXRhWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pKSB8fFxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpKSAmJiAoc291cmNlWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpO1xuXG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIG1ldGFkYXRhIGNhbid0IGJlIG1lcmdlZC5cbiAgICAgIGlmICghKGlzQ29tbW9uIHx8IGlzQ29tYm8pKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgdGhpc0FyZ2AgaWYgYXZhaWxhYmxlLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRykge1xuICAgICAgICBkYXRhWzJdID0gc291cmNlWzJdO1xuICAgICAgICAvLyBTZXQgd2hlbiBjdXJyeWluZyBhIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAgICBuZXdCaXRtYXNrIHw9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyA/IDAgOiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUc7XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgYXJndW1lbnRzLlxuICAgICAgdmFyIHZhbHVlID0gc291cmNlWzNdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0aWFscyA9IGRhdGFbM107XG4gICAgICAgIGRhdGFbM10gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzKHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzRdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzRdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzNdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNF07XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgcmlnaHQgYXJndW1lbnRzLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbNV07XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcGFydGlhbHMgPSBkYXRhWzVdO1xuICAgICAgICBkYXRhWzVdID0gcGFydGlhbHMgPyBjb21wb3NlQXJnc1JpZ2h0KHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzZdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzZdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzVdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNl07XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcmdQb3NgIGlmIGF2YWlsYWJsZS5cbiAgICAgIHZhbHVlID0gc291cmNlWzddO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRhdGFbN10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyeWAgaWYgaXQncyBzbWFsbGVyLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0FSWV9GTEFHKSB7XG4gICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdID09IG51bGwgPyBzb3VyY2VbOF0gOiBuYXRpdmVNaW4oZGF0YVs4XSwgc291cmNlWzhdKTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyaXR5YCBpZiBvbmUgaXMgbm90IHByb3ZpZGVkLlxuICAgICAgaWYgKGRhdGFbOV0gPT0gbnVsbCkge1xuICAgICAgICBkYXRhWzldID0gc291cmNlWzldO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgZnVuY2AgYW5kIG1lcmdlIGJpdG1hc2tzLlxuICAgICAgZGF0YVswXSA9IHNvdXJjZVswXTtcbiAgICAgIGRhdGFbMV0gPSBuZXdCaXRtYXNrO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAgICAgKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICAgICAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFyZW50IHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gZ2V0IHRoZSBwYXJlbnQgdmFsdWUgb2YuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBhcmVudCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJlbnQob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5sZW5ndGggPCAyID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlb3JkZXIgYGFycmF5YCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBpbmRleGVzIHdoZXJlIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIGZpcnN0IGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBmaXJzdCBlbGVtZW50LCB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBzZWNvbmQgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIHNlY29uZCBlbGVtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byByZW9yZGVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFycmF5IGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVvcmRlcihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oaW5kZXhlcy5sZW5ndGgsIGFyckxlbmd0aCksXG4gICAgICAgICAgb2xkQXJyYXkgPSBjb3B5QXJyYXkoYXJyYXkpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBhcnJheVtsZW5ndGhdID0gaXNJbmRleChpbmRleCwgYXJyTGVuZ3RoKSA/IG9sZEFycmF5W2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIgb3IgXCJjb25zdHJ1Y3RvclwiLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgICAgIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgdGhpcyBmdW5jdGlvbiBiZWNvbWVzIGhvdCwgaS5lLiBpcyBpbnZva2VkIGEgbG90IGluIGEgc2hvcnRcbiAgICAgKiBwZXJpb2Qgb2YgdGltZSwgaXQgd2lsbCB0cmlwIGl0cyBicmVha2VyIGFuZCB0cmFuc2l0aW9uIHRvIGFuIGlkZW50aXR5XG4gICAgICogZnVuY3Rpb24gdG8gYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uIHBhdXNlcyBpbiBWOC4gU2VlXG4gICAgICogW1Y4IGlzc3VlIDIwNzBdKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIwNzApXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBzZXREYXRhID0gc2hvcnRPdXQoYmFzZVNldERhdGEpO1xuXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBhcm91bmQgdGhlIGdsb2JhbCBbYHNldFRpbWVvdXRgXShodHRwczovL21kbi5pby9zZXRUaW1lb3V0KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfE9iamVjdH0gUmV0dXJucyB0aGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIHNldFRpbWVvdXQgPSBjdHhTZXRUaW1lb3V0IHx8IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICAgIHJldHVybiByb290LnNldFRpbWVvdXQoZnVuYywgd2FpdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGB3cmFwcGVyYCB0byBtaW1pYyB0aGUgc291cmNlIG9mIGByZWZlcmVuY2VgXG4gICAgICogd2l0aCB3cmFwcGVyIGRldGFpbHMgaW4gYSBjb21tZW50IGF0IHRoZSB0b3Agb2YgdGhlIHNvdXJjZSBib2R5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVmZXJlbmNlIFRoZSByZWZlcmVuY2UgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYHdyYXBwZXJgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFdyYXBUb1N0cmluZyh3cmFwcGVyLCByZWZlcmVuY2UsIGJpdG1hc2spIHtcbiAgICAgIHZhciBzb3VyY2UgPSAocmVmZXJlbmNlICsgJycpO1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKHdyYXBwZXIsIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgdXBkYXRlV3JhcERldGFpbHMoZ2V0V3JhcERldGFpbHMoc291cmNlKSwgYml0bWFzaykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAgICAgKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAgICAgKiBtaWxsaXNlY29uZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gICAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgd2hpY2ggbXV0YXRlcyBhbmQgc2V0cyB0aGUgc2l6ZSBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NpemU9YXJyYXkubGVuZ3RoXSBUaGUgc2l6ZSBvZiBgYXJyYXlgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGVTZWxmKGFycmF5LCBzaXplKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgc2l6ZSA9IHNpemUgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHNpemU7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IHNpemUpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLFxuICAgICAgICAgICAgdmFsdWUgPSBhcnJheVtyYW5kXTtcblxuICAgICAgICBhcnJheVtyYW5kXSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBhcnJheS5sZW5ndGggPSBzaXplO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL1xuICAgIHZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgICAgIH1cbiAgICAgIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gICAgICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gICAgICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHdyYXBwZXIgYGRldGFpbHNgIGJhc2VkIG9uIGBiaXRtYXNrYCBmbGFncy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0FycmF5fSBkZXRhaWxzIFRoZSBkZXRhaWxzIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGV0YWlsc2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlV3JhcERldGFpbHMoZGV0YWlscywgYml0bWFzaykge1xuICAgICAgYXJyYXlFYWNoKHdyYXBGbGFncywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICB2YXIgdmFsdWUgPSAnXy4nICsgcGFpclswXTtcbiAgICAgICAgaWYgKChiaXRtYXNrICYgcGFpclsxXSkgJiYgIWFycmF5SW5jbHVkZXMoZGV0YWlscywgdmFsdWUpKSB7XG4gICAgICAgICAgZGV0YWlscy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGV0YWlscy5zb3J0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB3cmFwcGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHdyYXBwZXIgVGhlIHdyYXBwZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHdyYXBwZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNsb25lKHdyYXBwZXIpIHtcbiAgICAgIGlmICh3cmFwcGVyIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXIuY2xvbmUoKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVyLl9fd3JhcHBlZF9fLCB3cmFwcGVyLl9fY2hhaW5fXyk7XG4gICAgICByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkod3JhcHBlci5fX2FjdGlvbnNfXyk7XG4gICAgICByZXN1bHQuX19pbmRleF9fICA9IHdyYXBwZXIuX19pbmRleF9fO1xuICAgICAgcmVzdWx0Ll9fdmFsdWVzX18gPSB3cmFwcGVyLl9fdmFsdWVzX187XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byBncm91cHMgdGhlIGxlbmd0aCBvZiBgc2l6ZWAuXG4gICAgICogSWYgYGFycmF5YCBjYW4ndCBiZSBzcGxpdCBldmVubHksIHRoZSBmaW5hbCBjaHVuayB3aWxsIGJlIHRoZSByZW1haW5pbmdcbiAgICAgKiBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT0xXSBUaGUgbGVuZ3RoIG9mIGVhY2ggY2h1bmtcbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNodW5rcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMik7XG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsnYycsICdkJ11dXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAzKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InLCAnYyddLCBbJ2QnXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaHVuayhhcnJheSwgc2l6ZSwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc2l6ZSwgZ3VhcmQpIDogc2l6ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBzaXplID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpemUgPSBuYXRpdmVNYXgodG9JbnRlZ2VyKHNpemUpLCAwKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoIHx8IHNpemUgPCAxKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG5hdGl2ZUNlaWwobGVuZ3RoIC8gc2l6ZSkpO1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gYmFzZVNsaWNlKGFycmF5LCBpbmRleCwgKGluZGV4ICs9IHNpemUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBmYWxzZXkgdmFsdWVzIHJlbW92ZWQuIFRoZSB2YWx1ZXMgYGZhbHNlYCwgYG51bGxgLFxuICAgICAqIGAwYCwgYFwiXCJgLCBgdW5kZWZpbmVkYCwgYW5kIGBOYU5gIGFyZSBmYWxzZXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY29tcGFjdChbMCwgMSwgZmFsc2UsIDIsICcnLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgY29uY2F0ZW5hdGluZyBgYXJyYXlgIHdpdGggYW55IGFkZGl0aW9uYWwgYXJyYXlzXG4gICAgICogYW5kL29yIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb25jYXRlbmF0ZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29uY2F0ZW5hdGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMV07XG4gICAgICogdmFyIG90aGVyID0gXy5jb25jYXQoYXJyYXksIDIsIFszXSwgW1s0XV0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob3RoZXIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF1dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uY2F0KCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCAtIDEpLFxuICAgICAgICAgIGFycmF5ID0gYXJndW1lbnRzWzBdLFxuICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICBhcmdzW2luZGV4IC0gMV0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5UHVzaChpc0FycmF5KGFycmF5KSA/IGNvcHlBcnJheShhcnJheSkgOiBbYXJyYXldLCBiYXNlRmxhdHRlbihhcmdzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBgYXJyYXlgIHZhbHVlcyBub3QgaW5jbHVkZWQgaW4gdGhlIG90aGVyIGdpdmVuIGFycmF5c1xuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy53aXRob3V0LCBfLnhvclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2UoWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGlmZmVyZW5jZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgYW5kIGB2YWx1ZXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbEJ5YCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2VCeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kaWZmZXJlbmNlQnkoW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCBbeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2VCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QodmFsdWVzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRpZmZlcmVuY2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAgdG8gYHZhbHVlc2AuIFRoZSBvcmRlciBhbmRcbiAgICAgKiByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgY29tcGFyYXRvclxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsV2l0aGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2VXaXRoKG9iamVjdHMsIFt7ICd4JzogMSwgJ3knOiAyIH1dLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2VXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KHZhbHVlcyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoY29tcGFyYXRvcikpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgbiA9IGxlbmd0aCAtIG47XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCB0cnVlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbGxzIGVsZW1lbnRzIG9mIGBhcnJheWAgd2l0aCBgdmFsdWVgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdFxuICAgICAqIGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLmZpbGwoYXJyYXksICdhJyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdhJywgJ2EnXVxuICAgICAqXG4gICAgICogXy5maWxsKEFycmF5KDMpLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgMiwgMl1cbiAgICAgKlxuICAgICAqIF8uZmlsbChbNCwgNiwgOCwgMTBdLCAnKicsIDEsIDMpO1xuICAgICAqIC8vID0+IFs0LCAnKicsICcqJywgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAmJiB0eXBlb2Ygc3RhcnQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHZhbHVlLCBzdGFydCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ3BlYmJsZXMnOyB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBsZW5ndGggLSAxO1xuICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4IDwgMFxuICAgICAgICAgID8gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKVxuICAgICAgICAgIDogbmF0aXZlTWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlZXAoWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNCwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuRGVlcChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCBJTkZJTklUWSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmbGF0dGVuIGBhcnJheWAgdXAgdG8gYGRlcHRoYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9MV0gVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIFsyLCBbMywgWzRdXSwgNV1dO1xuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVwdGgoYXJyYXksIDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlcHRoKGFycmF5LCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZXB0aChhcnJheSwgZGVwdGgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGRlcHRoID0gZGVwdGggPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGgpO1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8udG9QYWlyc2A7IHRoaXMgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkXG4gICAgICogZnJvbSBrZXktdmFsdWUgYHBhaXJzYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIFRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mcm9tUGFpcnMoW1snYScsIDFdLCBbJ2InLCAyXV0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21QYWlycyhwYWlycykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGFpcnMgPT0gbnVsbCA/IDAgOiBwYWlycy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbcGFpclswXV0gPSBwYWlyWzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgZmlyc3RcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5oZWFkKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5oZWFkKFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoZWFkKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIGluIGBhcnJheWBcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhcyB0aGVcbiAgICAgKiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBTZWFyY2ggZnJvbSB0aGUgYGZyb21JbmRleGAuXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWwoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlU2xpY2UoYXJyYXksIDAsIC0xKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGFyZSBpbmNsdWRlZCBpbiBhbGwgZ2l2ZW4gYXJyYXlzXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMl1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZClcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uaW50ZXJzZWN0aW9uQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH1dXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbkJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyksXG4gICAgICAgICAgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcblxuICAgICAgaWYgKGl0ZXJhdGVlID09PSBsYXN0KG1hcHBlZCkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzXG4gICAgICogb2YgcmVzdWx0IHZhbHVlcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBjb21wYXJhdG9yIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb25XaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9XVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKSxcbiAgICAgICAgICBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuXG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFsbCBlbGVtZW50cyBpbiBgYXJyYXlgIGludG8gYSBzdHJpbmcgc2VwYXJhdGVkIGJ5IGBzZXBhcmF0b3JgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzZXBhcmF0b3I9JywnXSBUaGUgZWxlbWVudCBzZXBhcmF0b3IuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgam9pbmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5qb2luKFsnYScsICdiJywgJ2MnXSwgJ34nKTtcbiAgICAgKiAvLyA9PiAnYX5ifmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gam9pbihhcnJheSwgc2VwYXJhdG9yKSB7XG4gICAgICByZXR1cm4gYXJyYXkgPT0gbnVsbCA/ICcnIDogbmF0aXZlSm9pbi5jYWxsKGFycmF5LCBzZXBhcmF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgYXJyYXlgIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogLy8gU2VhcmNoIGZyb20gdGhlIGBmcm9tSW5kZXhgLlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgIGlmIChmcm9tSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmRleCA9IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgICBpbmRleCA9IGluZGV4IDwgMCA/IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCkgOiBuYXRpdmVNaW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgICAgICA/IHN0cmljdExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgaW5kZXgpXG4gICAgICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZWxlbWVudCBhdCBpbmRleCBgbmAgb2YgYGFycmF5YC4gSWYgYG5gIGlzIG5lZ2F0aXZlLCB0aGUgbnRoXG4gICAgICogZWxlbWVudCBmcm9tIHRoZSBlbmQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnXTtcbiAgICAgKlxuICAgICAqIF8ubnRoKGFycmF5LCAxKTtcbiAgICAgKiAvLyA9PiAnYidcbiAgICAgKlxuICAgICAqIF8ubnRoKGFycmF5LCAtMik7XG4gICAgICogLy8gPT4gJ2MnO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG50aChhcnJheSwgbikge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZU50aChhcnJheSwgdG9JbnRlZ2VyKG4pKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBnaXZlbiB2YWx1ZXMgZnJvbSBgYXJyYXlgIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLndpdGhvdXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuIFVzZSBgXy5yZW1vdmVgXG4gICAgICogdG8gcmVtb3ZlIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2EnLCAnYicsICdjJ107XG4gICAgICpcbiAgICAgKiBfLnB1bGwoYXJyYXksICdhJywgJ2MnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydiJywgJ2InXVxuICAgICAqL1xuICAgIHZhciBwdWxsID0gYmFzZVJlc3QocHVsbEFsbCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZWAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2EnLCAnYicsICdjJ107XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGwoYXJyYXksIFsnYScsICdjJ10pO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbChhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbEFsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgYW5kIGB2YWx1ZXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZUJ5YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDMgfSwgeyAneCc6IDEgfV07XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGxCeShhcnJheSwgW3sgJ3gnOiAxIH0sIHsgJ3gnOiAzIH1dLCAneCcpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsQnkoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxBbGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAgdG8gYHZhbHVlc2AuIFRoZSBjb21wYXJhdG9yIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VXaXRoYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAzLCAneSc6IDQgfSwgeyAneCc6IDUsICd5JzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbFdpdGgoYXJyYXksIFt7ICd4JzogMywgJ3knOiA0IH1dLCBfLmlzRXF1YWwpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogNSwgJ3knOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbFdpdGgoYXJyYXksIHZhbHVlcywgY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSBgYXJyYXlgIGNvcnJlc3BvbmRpbmcgdG8gYGluZGV4ZXNgIGFuZCByZXR1cm5zIGFuXG4gICAgICogYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uYXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IFtpbmRleGVzXSBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJ107XG4gICAgICogdmFyIHB1bGxlZCA9IF8ucHVsbEF0KGFycmF5LCBbMSwgM10pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdjJ11cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKHB1bGxlZCk7XG4gICAgICogLy8gPT4gWydiJywgJ2QnXVxuICAgICAqL1xuICAgIHZhciBwdWxsQXQgPSBmbGF0UmVzdChmdW5jdGlvbihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGJhc2VBdChhcnJheSwgaW5kZXhlcyk7XG5cbiAgICAgIGJhc2VQdWxsQXQoYXJyYXksIGFycmF5TWFwKGluZGV4ZXMsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpc0luZGV4KGluZGV4LCBsZW5ndGgpID8gK2luZGV4IDogaW5kZXg7XG4gICAgICB9KS5zb3J0KGNvbXBhcmVBc2NlbmRpbmcpKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYGFycmF5YCB0aGF0IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvclxuICAgICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSByZW1vdmVkIGVsZW1lbnRzLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5maWx0ZXJgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuIFVzZSBgXy5wdWxsYFxuICAgICAqIHRvIHB1bGwgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBieSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCA0XTtcbiAgICAgKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzIsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIGBhcnJheWAgc28gdGhhdCB0aGUgZmlyc3QgZWxlbWVudCBiZWNvbWVzIHRoZSBsYXN0LCB0aGUgc2Vjb25kXG4gICAgICogZWxlbWVudCBiZWNvbWVzIHRoZSBzZWNvbmQgdG8gbGFzdCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YCBhbmQgaXMgYmFzZWQgb25cbiAgICAgKiBbYEFycmF5I3JldmVyc2VgXShodHRwczovL21kbi5pby9BcnJheS9yZXZlcnNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8ucmV2ZXJzZShhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV2ZXJzZShhcnJheSkge1xuICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyBhcnJheSA6IG5hdGl2ZVJldmVyc2UuY2FsbChhcnJheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgdXNlZCBpbnN0ZWFkIG9mXG4gICAgICogW2BBcnJheSNzbGljZWBdKGh0dHBzOi8vbWRuLmlvL0FycmF5L3NsaWNlKSB0byBlbnN1cmUgZGVuc2UgYXJyYXlzIGFyZVxuICAgICAqIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgJiYgdHlwZW9mIGVuZCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc3RhcnQsIGVuZCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbnRlZ2VyKGVuZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIGEgYmluYXJ5IHNlYXJjaCB0byBkZXRlcm1pbmUgdGhlIGxvd2VzdCBpbmRleCBhdCB3aGljaCBgdmFsdWVgXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0byBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWzMwLCA1MF0sIDQwKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRJbmRleGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpclxuICAgICAqIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDQgfSwgeyAneCc6IDUgfV07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgZnVuY3Rpb24obykgeyByZXR1cm4gby54OyB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgcGVyZm9ybXMgYSBiaW5hcnlcbiAgICAgKiBzZWFyY2ggb24gYSBzb3J0ZWQgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleE9mKFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgZXEoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBoaWdoZXN0XG4gICAgICogaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvXG4gICAgICogbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleChbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRMYXN0SW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXJcbiAgICAgKiBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiA0IH0sIHsgJ3gnOiA1IH1dO1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCBmdW5jdGlvbihvKSB7IHJldHVybiBvLng7IH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmxhc3RJbmRleE9mYCBleGNlcHQgdGhhdCBpdCBwZXJmb3JtcyBhIGJpbmFyeVxuICAgICAqIHNlYXJjaCBvbiBhIHNvcnRlZCBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleE9mKFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICB2YXIgaW5kZXggPSBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKSAtIDE7XG4gICAgICAgIGlmIChlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQncyBkZXNpZ25lZCBhbmQgb3B0aW1pemVkXG4gICAgICogZm9yIHNvcnRlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRVbmlxKFsxLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkVW5pcShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVNvcnRlZFVuaXEoYXJyYXkpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxQnlgIGV4Y2VwdCB0aGF0IGl0J3MgZGVzaWduZWQgYW5kIG9wdGltaXplZFxuICAgICAqIGZvciBzb3J0ZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRVbmlxQnkoWzEuMSwgMS4yLCAyLjMsIDIuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjEsIDIuM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU29ydGVkVW5pcShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWlsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFpbChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTbGljZShhcnJheSwgMSwgbGVuZ3RoKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2UoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICBuID0gbGVuZ3RoIC0gbjtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4sIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuIEVsZW1lbnRzIGFyZVxuICAgICAqIHRha2VuIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy4gRWxlbWVudHNcbiAgICAgKiBhcmUgdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIGZyb20gYWxsIGdpdmVuIGFycmF5cyB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbihbMl0sIFsxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgdmFyIHVuaW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieVxuICAgICAqIHdoaWNoIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFJlc3VsdCB2YWx1ZXMgYXJlIGNob3NlbiBmcm9tIHRoZSBmaXJzdFxuICAgICAqIGFycmF5IGluIHdoaWNoIHRoZSB2YWx1ZSBvY2N1cnMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbkJ5KFsyLjFdLCBbMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xLCAxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnVuaW9uQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIHVuaW9uQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gUmVzdWx0IHZhbHVlcyBhcmUgY2hvc2VuIGZyb21cbiAgICAgKiB0aGUgZmlyc3QgYXJyYXkgaW4gd2hpY2ggdGhlIHZhbHVlIG9jY3Vycy4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8udW5pb25XaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5LCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpbiB3aGljaCBvbmx5IHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGVhY2ggZWxlbWVudFxuICAgICAqIGlzIGtlcHQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXJcbiAgICAgKiBpbiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxKFsyLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXkpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdW5pcXVlbmVzcyBpcyBjb21wdXRlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGVcbiAgICAgKiBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxQnkoWzIuMSwgMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xLCAxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnVuaXFCeShbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXkuVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8udW5pcVdpdGgob2JqZWN0cywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcVdpdGgoYXJyYXksIGNvbXBhcmF0b3IpIHtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5LCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgZ3JvdXBlZFxuICAgICAqIGVsZW1lbnRzIGFuZCBjcmVhdGVzIGFuIGFycmF5IHJlZ3JvdXBpbmcgdGhlIGVsZW1lbnRzIHRvIHRoZWlyIHByZS16aXBcbiAgICAgKiBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZWdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB6aXBwZWQgPSBfLnppcChbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxLCB0cnVlXSwgWydiJywgMiwgZmFsc2VdXVxuICAgICAqXG4gICAgICogXy51bnppcCh6aXBwZWQpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW56aXAoYXJyYXkpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICBhcnJheSA9IGFycmF5RmlsdGVyKGFycmF5LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoZ3JvdXApKSB7XG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGdyb3VwLmxlbmd0aCwgbGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYmFzZVRpbWVzKGxlbmd0aCwgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKGFycmF5LCBiYXNlUHJvcGVydHkoaW5kZXgpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB0byBzcGVjaWZ5XG4gICAgICogaG93IHJlZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxuICAgICAqIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXA6ICguLi5ncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZVxuICAgICAqICByZWdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0pO1xuICAgICAqIC8vID0+IFtbMSwgMTAsIDEwMF0sIFsyLCAyMCwgMjAwXV1cbiAgICAgKlxuICAgICAqIF8udW56aXBXaXRoKHppcHBlZCwgXy5hZGQpO1xuICAgICAqIC8vID0+IFszLCAzMCwgMzAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuemlwV2l0aChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHVuemlwKGFycmF5KTtcbiAgICAgIGlmIChpdGVyYXRlZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlNYXAocmVzdWx0LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICByZXR1cm4gYXBwbHkoaXRlcmF0ZWUsIHVuZGVmaW5lZCwgZ3JvdXApO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIGdpdmVuIHZhbHVlcyB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8uZGlmZmVyZW5jZSwgXy54b3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53aXRob3V0KFsyLCAxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICovXG4gICAgdmFyIHdpdGhvdXQgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcylcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGlzIHRoZVxuICAgICAqIFtzeW1tZXRyaWMgZGlmZmVyZW5jZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3ltbWV0cmljX2RpZmZlcmVuY2UpXG4gICAgICogb2YgdGhlIGdpdmVuIGFycmF5cy4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXJcbiAgICAgKiB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy5kaWZmZXJlbmNlLCBfLndpdGhvdXRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3IoWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqL1xuICAgIHZhciB4b3IgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ueG9yYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5XG4gICAgICogd2hpY2ggYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZFxuICAgICAqIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lXG4gICAgICogYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3JCeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4yLCAzLjRdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnhvckJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciB4b3JCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy54b3JgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpc1xuICAgICAqIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ueG9yV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciB4b3JXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLCB0aGUgZmlyc3Qgb2Ygd2hpY2ggY29udGFpbnMgdGhlXG4gICAgICogZmlyc3QgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgdGhlIHNlY29uZCBvZiB3aGljaCBjb250YWlucyB0aGVcbiAgICAgKiBzZWNvbmQgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwKFsnYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snYScsIDEsIHRydWVdLCBbJ2InLCAyLCBmYWxzZV1dXG4gICAgICovXG4gICAgdmFyIHppcCA9IGJhc2VSZXN0KHVuemlwKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZnJvbVBhaXJzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIHR3byBhcnJheXMsXG4gICAgICogb25lIG9mIHByb3BlcnR5IGlkZW50aWZpZXJzIGFuZCBvbmUgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0KFsnYScsICdiJ10sIFsxLCAyXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0KHByb3BzLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMgfHwgW10sIGFzc2lnblZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcE9iamVjdGAgZXhjZXB0IHRoYXQgaXQgc3VwcG9ydHMgcHJvcGVydHkgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0RGVlcChbJ2EuYlswXS5jJywgJ2EuYlsxXS5kJ10sIFsxLCAyXSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2InOiBbeyAnYyc6IDEgfSwgeyAnZCc6IDIgfV0gfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0RGVlcChwcm9wcywgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gYmFzZVppcE9iamVjdChwcm9wcyB8fCBbXSwgdmFsdWVzIHx8IFtdLCBiYXNlU2V0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHRvIHNwZWNpZnlcbiAgICAgKiBob3cgZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxuICAgICAqIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXA6ICguLi5ncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lXG4gICAgICogIGdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwV2l0aChbMSwgMl0sIFsxMCwgMjBdLCBbMTAwLCAyMDBdLCBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gYSArIGIgKyBjO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxMTEsIDIyMl1cbiAgICAgKi9cbiAgICB2YXIgemlwV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5cy5sZW5ndGgsXG4gICAgICAgICAgaXRlcmF0ZWUgPSBsZW5ndGggPiAxID8gYXJyYXlzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpdGVyYXRlZSA9IHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nID8gKGFycmF5cy5wb3AoKSwgaXRlcmF0ZWUpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHVuemlwV2l0aChhcnJheXMsIGl0ZXJhdGVlKTtcbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlIHRoYXQgd3JhcHMgYHZhbHVlYCB3aXRoIGV4cGxpY2l0IG1ldGhvZFxuICAgICAqIGNoYWluIHNlcXVlbmNlcyBlbmFibGVkLiBUaGUgcmVzdWx0IG9mIHN1Y2ggc2VxdWVuY2VzIG11c3QgYmUgdW53cmFwcGVkXG4gICAgICogd2l0aCBgXyN2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHlvdW5nZXN0ID0gX1xuICAgICAqICAgLmNoYWluKHVzZXJzKVxuICAgICAqICAgLnNvcnRCeSgnYWdlJylcbiAgICAgKiAgIC5tYXAoZnVuY3Rpb24obykge1xuICAgICAqICAgICByZXR1cm4gby51c2VyICsgJyBpcyAnICsgby5hZ2U7XG4gICAgICogICB9KVxuICAgICAqICAgLmhlYWQoKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMgaXMgMSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFpbih2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaCh2YWx1ZSk7XG4gICAgICByZXN1bHQuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBgaW50ZXJjZXB0b3JgIGFuZCByZXR1cm5zIGB2YWx1ZWAuIFRoZSBpbnRlcmNlcHRvclxuICAgICAqIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvXG4gICAgICogXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluIHNlcXVlbmNlIGluIG9yZGVyIHRvIG1vZGlmeSBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSlcbiAgICAgKiAgLnRhcChmdW5jdGlvbihhcnJheSkge1xuICAgICAqICAgIC8vIE11dGF0ZSBpbnB1dCBhcnJheS5cbiAgICAgKiAgICBhcnJheS5wb3AoKTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnJldmVyc2UoKVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy50YXBgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwicGFzcyB0aHJ1XCIgdmFsdWVzIHJlcGxhY2luZyBpbnRlcm1lZGlhdGVcbiAgICAgKiByZXN1bHRzIGluIGEgbWV0aG9kIGNoYWluIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXygnICBhYmMgICcpXG4gICAgICogIC5jaGFpbigpXG4gICAgICogIC50cmltKClcbiAgICAgKiAgLnRocnUoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWydhYmMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocnUodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICByZXR1cm4gaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSB3cmFwcGVyIHZlcnNpb24gb2YgYF8uYXRgLlxuICAgICAqXG4gICAgICogQG5hbWUgYXRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9LCA0XSB9O1xuICAgICAqXG4gICAgICogXyhvYmplY3QpLmF0KFsnYVswXS5iLmMnLCAnYVsxXSddKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqL1xuICAgIHZhciB3cmFwcGVyQXQgPSBmbGF0UmVzdChmdW5jdGlvbihwYXRocykge1xuICAgICAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICBzdGFydCA9IGxlbmd0aCA/IHBhdGhzWzBdIDogMCxcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbihvYmplY3QpIHsgcmV0dXJuIGJhc2VBdChvYmplY3QsIHBhdGhzKTsgfTtcblxuICAgICAgaWYgKGxlbmd0aCA+IDEgfHwgdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGggfHxcbiAgICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHx8ICFpc0luZGV4KHN0YXJ0KSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2Uoc3RhcnQsICtzdGFydCArIChsZW5ndGggPyAxIDogMCkpO1xuICAgICAgdmFsdWUuX19hY3Rpb25zX18ucHVzaCh7XG4gICAgICAgICdmdW5jJzogdGhydSxcbiAgICAgICAgJ2FyZ3MnOiBbaW50ZXJjZXB0b3JdLFxuICAgICAgICAndGhpc0FyZyc6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUsIHRoaXMuX19jaGFpbl9fKS50aHJ1KGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgIGlmIChsZW5ndGggJiYgIWFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgIGFycmF5LnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlIHdpdGggZXhwbGljaXQgbWV0aG9kIGNoYWluIHNlcXVlbmNlcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQG5hbWUgY2hhaW5cbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gQSBzZXF1ZW5jZSB3aXRob3V0IGV4cGxpY2l0IGNoYWluaW5nLlxuICAgICAqIF8odXNlcnMpLmhlYWQoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICpcbiAgICAgKiAvLyBBIHNlcXVlbmNlIHdpdGggZXhwbGljaXQgY2hhaW5pbmcuXG4gICAgICogXyh1c2VycylcbiAgICAgKiAgIC5jaGFpbigpXG4gICAgICogICAuaGVhZCgpXG4gICAgICogICAucGljaygndXNlcicpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDaGFpbigpIHtcbiAgICAgIHJldHVybiBjaGFpbih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW4gc2VxdWVuY2UgYW5kIHJldHVybnMgdGhlIHdyYXBwZWQgcmVzdWx0LlxuICAgICAqXG4gICAgICogQG5hbWUgY29tbWl0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyXTtcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oYXJyYXkpLnB1c2goMyk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkID0gd3JhcHBlZC5jb21taXQoKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkLmxhc3QoKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNvbW1pdCgpIHtcbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih0aGlzLnZhbHVlKCksIHRoaXMuX19jaGFpbl9fKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuZXh0IHZhbHVlIG9uIGEgd3JhcHBlZCBvYmplY3QgZm9sbG93aW5nIHRoZVxuICAgICAqIFtpdGVyYXRvciBwcm90b2NvbF0oaHR0cHM6Ly9tZG4uaW8vaXRlcmF0aW9uX3Byb3RvY29scyNpdGVyYXRvcikuXG4gICAgICpcbiAgICAgKiBAbmFtZSBuZXh0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV4dCBpdGVyYXRvciB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSk7XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogZmFsc2UsICd2YWx1ZSc6IDEgfVxuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IGZhbHNlLCAndmFsdWUnOiAyIH1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiB0cnVlLCAndmFsdWUnOiB1bmRlZmluZWQgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJOZXh0KCkge1xuICAgICAgaWYgKHRoaXMuX192YWx1ZXNfXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX192YWx1ZXNfXyA9IHRvQXJyYXkodGhpcy52YWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIHZhciBkb25lID0gdGhpcy5fX2luZGV4X18gPj0gdGhpcy5fX3ZhbHVlc19fLmxlbmd0aCxcbiAgICAgICAgICB2YWx1ZSA9IGRvbmUgPyB1bmRlZmluZWQgOiB0aGlzLl9fdmFsdWVzX19bdGhpcy5fX2luZGV4X18rK107XG5cbiAgICAgIHJldHVybiB7ICdkb25lJzogZG9uZSwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSB3cmFwcGVyIHRvIGJlIGl0ZXJhYmxlLlxuICAgICAqXG4gICAgICogQG5hbWUgU3ltYm9sLml0ZXJhdG9yXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pO1xuICAgICAqXG4gICAgICogd3JhcHBlZFtTeW1ib2wuaXRlcmF0b3JdKCkgPT09IHdyYXBwZWQ7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogQXJyYXkuZnJvbSh3cmFwcGVkKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVG9JdGVyYXRvcigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgY2hhaW4gc2VxdWVuY2UgcGxhbnRpbmcgYHZhbHVlYCBhcyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHBsYW50XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGxhbnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSkubWFwKHNxdWFyZSk7XG4gICAgICogdmFyIG90aGVyID0gd3JhcHBlZC5wbGFudChbMywgNF0pO1xuICAgICAqXG4gICAgICogb3RoZXIudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbOSwgMTZdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclBsYW50KHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIHBhcmVudCA9IHRoaXM7XG5cbiAgICAgIHdoaWxlIChwYXJlbnQgaW5zdGFuY2VvZiBiYXNlTG9kYXNoKSB7XG4gICAgICAgIHZhciBjbG9uZSA9IHdyYXBwZXJDbG9uZShwYXJlbnQpO1xuICAgICAgICBjbG9uZS5fX2luZGV4X18gPSAwO1xuICAgICAgICBjbG9uZS5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSBjbG9uZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBjbG9uZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldmlvdXMgPSBjbG9uZTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9fd3JhcHBlZF9fO1xuICAgICAgfVxuICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdGhlIHdyYXBwZXIgdmVyc2lvbiBvZiBgXy5yZXZlcnNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIHRoZSB3cmFwcGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfKGFycmF5KS5yZXZlcnNlKCkudmFsdWUoKVxuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJSZXZlcnNlKCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXztcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHZhciB3cmFwcGVkID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCkge1xuICAgICAgICAgIHdyYXBwZWQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgd3JhcHBlZCA9IHdyYXBwZWQucmV2ZXJzZSgpO1xuICAgICAgICB3cmFwcGVkLl9fYWN0aW9uc19fLnB1c2goe1xuICAgICAgICAgICdmdW5jJzogdGhydSxcbiAgICAgICAgICAnYXJncyc6IFtyZXZlcnNlXSxcbiAgICAgICAgICAndGhpc0FyZyc6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZWQsIHRoaXMuX19jaGFpbl9fKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRocnUocmV2ZXJzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluIHNlcXVlbmNlIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHZhbHVlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgdG9KU09OLCB2YWx1ZU9mXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKHRoaXMuX193cmFwcGVkX18sIHRoaXMuX19hY3Rpb25zX18pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZlxuICAgICAqIGVhY2gga2V5IGlzIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGtleSB3YXMgcmV0dXJuZWQgYnkgYGl0ZXJhdGVlYC4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs2LjEsIDQuMiwgNi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmNvdW50QnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogMiwgJzUnOiAxIH1cbiAgICAgKi9cbiAgICB2YXIgY291bnRCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgKytyZXN1bHRba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgMSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYWxsKiogZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICogW2VtcHR5IGNvbGxlY3Rpb25zXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbXB0eV9zZXQpIGJlY2F1c2VcbiAgICAgKiBbZXZlcnl0aGluZyBpcyB0cnVlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYWN1b3VzX3RydXRoKSBvZlxuICAgICAqIGVsZW1lbnRzIG9mIGVtcHR5IGNvbGxlY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ldmVyeShbdHJ1ZSwgMSwgbnVsbCwgJ3llcyddLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFdmVyeSA6IGJhc2VFdmVyeTtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucmVtb3ZlYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAc2VlIF8ucmVqZWN0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gQ29tYmluaW5nIHNldmVyYWwgcHJlZGljYXRlcyB1c2luZyBgXy5vdmVyRXZlcnlgIG9yIGBfLm92ZXJTb21lYC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5vdmVyU29tZShbeyAnYWdlJzogMzYgfSwgWydhZ2UnLCA0MF1dKSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ2Jhcm5leSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICAgICAqL1xuICAgIHZhciBmaW5kID0gY3JlYXRlRmluZChmaW5kSW5kZXgpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9Y29sbGVjdGlvbi5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3QoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgdmFyIGZpbmRMYXN0ID0gY3JlYXRlRmluZChmaW5kTGFzdEluZGV4KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmbGF0dGVuZWQgYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYFxuICAgICAqIHRocnUgYGl0ZXJhdGVlYCBhbmQgZmxhdHRlbmluZyB0aGUgbWFwcGVkIHJlc3VsdHMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbbiwgbl07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwKFsxLCAyXSwgZHVwbGljYXRlKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMiwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbGF0TWFwYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBmbGF0dGVucyB0aGVcbiAgICAgKiBtYXBwZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbW1tuLCBuXV1dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcERlZXAoWzEsIDJdLCBkdXBsaWNhdGUpO1xuICAgICAqIC8vID0+IFsxLCAxLCAyLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXBEZWVwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgSU5GSU5JVFkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxhdE1hcGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgZmxhdHRlbnMgdGhlXG4gICAgICogbWFwcGVkIHJlc3VsdHMgdXAgdG8gYGRlcHRoYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9MV0gVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbW1tuLCBuXV1dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcERlcHRoKFsxLCAyXSwgZHVwbGljYXRlLCAyKTtcbiAgICAgKiAvLyA9PiBbWzEsIDFdLCBbMiwgMl1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcERlcHRoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBkZXB0aCkge1xuICAgICAgZGVwdGggPSBkZXB0aCA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgZGVwdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiXG4gICAgICogcHJvcGVydHkgYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIHVzZSBgXy5mb3JJbmBcbiAgICAgKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIGVhY2hcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAc2VlIF8uZm9yRWFjaFJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyBgMWAgdGhlbiBgMmAuXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckVhY2hgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGFsaWFzIGVhY2hSaWdodFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBzZWUgXy5mb3JFYWNoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaFJpZ2h0KFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzIGAyYCB0aGVuIGAxYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaFJpZ2h0IDogYmFzZUVhY2hSaWdodDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBvcmRlciBvZiBncm91cGVkIHZhbHVlc1xuICAgICAqIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gYGNvbGxlY3Rpb25gLiBUaGUgY29ycmVzcG9uZGluZ1xuICAgICAqIHZhbHVlIG9mIGVhY2gga2V5IGlzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZVxuICAgICAqIGtleS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNi4xLCA0LjIsIDYuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjNdIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZ3JvdXBCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxuICAgICAqL1xuICAgIHZhciBncm91cEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgW3ZhbHVlXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiBgY29sbGVjdGlvbmAuIElmIGBjb2xsZWN0aW9uYCBpcyBhIHN0cmluZywgaXQnc1xuICAgICAqIGNoZWNrZWQgZm9yIGEgc3Vic3RyaW5nIG9mIGB2YWx1ZWAsIG90aGVyd2lzZVxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogaXMgdXNlZCBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXNcbiAgICAgKiB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyh7ICdhJzogMSwgJ2InOiAyIH0sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoJ2FiY2QnLCAnYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5jbHVkZXMoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICAgIGNvbGxlY3Rpb24gPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24gOiB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4ICYmICFndWFyZCkgPyB0b0ludGVnZXIoZnJvbUluZGV4KSA6IDA7XG5cbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICAgIGZyb21JbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pXG4gICAgICAgID8gKGZyb21JbmRleCA8PSBsZW5ndGggJiYgY29sbGVjdGlvbi5pbmRleE9mKHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpXG4gICAgICAgIDogKCEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nXG4gICAgICogYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogYXJlIHByb3ZpZGVkIHRvIGVhY2ggaW52b2tlZCBtZXRob2QuIElmIGBwYXRoYCBpcyBhIGZ1bmN0aW9uLCBpdCdzIGludm9rZWRcbiAgICAgKiBmb3IsIGFuZCBgdGhpc2AgYm91bmQgdG8sIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZSBvclxuICAgICAqICB0aGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGVhY2ggbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludm9rZU1hcChbWzUsIDEsIDddLCBbMywgMiwgMV1dLCAnc29ydCcpO1xuICAgICAqIC8vID0+IFtbMSwgNSwgN10sIFsxLCAyLCAzXV1cbiAgICAgKlxuICAgICAqIF8uaW52b2tlTWFwKFsxMjMsIDQ1Nl0sIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsICcnKTtcbiAgICAgKiAvLyA9PiBbWycxJywgJzInLCAnMyddLCBbJzQnLCAnNScsICc2J11dXG4gICAgICovXG4gICAgdmFyIGludm9rZU1hcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHBhdGgsIGFyZ3MpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzRnVuYyA9IHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbicsXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gaXNGdW5jID8gYXBwbHkocGF0aCwgdmFsdWUsIGFyZ3MpIDogYmFzZUludm9rZSh2YWx1ZSwgcGF0aCwgYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgb2ZcbiAgICAgKiBlYWNoIGtleSBpcyB0aGUgbGFzdCBlbGVtZW50IHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFtcbiAgICAgKiAgIHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LFxuICAgICAqICAgeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmtleUJ5KGFycmF5LCBmdW5jdGlvbihvKSB7XG4gICAgICogICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvLmNvZGUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8ua2V5QnkoYXJyYXksICdkaXInKTtcbiAgICAgKiAvLyA9PiB7ICdsZWZ0JzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdyaWdodCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqL1xuICAgIHZhciBrZXlCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1XG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gICAgICogYF8uZXZlcnlgLCBgXy5maWx0ZXJgLCBgXy5tYXBgLCBgXy5tYXBWYWx1ZXNgLCBgXy5yZWplY3RgLCBhbmQgYF8uc29tZWAuXG4gICAgICpcbiAgICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAgICAgKiBgYXJ5YCwgYGNodW5rYCwgYGN1cnJ5YCwgYGN1cnJ5UmlnaHRgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZXZlcnlgLFxuICAgICAqIGBmaWxsYCwgYGludmVydGAsIGBwYXJzZUludGAsIGByYW5kb21gLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZXBlYXRgLFxuICAgICAqIGBzYW1wbGVTaXplYCwgYHNsaWNlYCwgYHNvbWVgLCBgc29ydEJ5YCwgYHNwbGl0YCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdHJpbWAsIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGFuZCBgd29yZHNgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5tYXAoWzQsIDhdLCBzcXVhcmUpO1xuICAgICAqIC8vID0+IFsxNiwgNjRdXG4gICAgICpcbiAgICAgKiBfLm1hcCh7ICdhJzogNCwgJ2InOiA4IH0sIHNxdWFyZSk7XG4gICAgICogLy8gPT4gWzE2LCA2NF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwKHVzZXJzLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRCeWAgZXhjZXB0IHRoYXQgaXQgYWxsb3dzIHNwZWNpZnlpbmcgdGhlIHNvcnRcbiAgICAgKiBvcmRlcnMgb2YgdGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlc1xuICAgICAqIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yXG4gICAgICogZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlciBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXlbXXxGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IFtvcmRlcnNdIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBTb3J0IGJ5IGB1c2VyYCBpbiBhc2NlbmRpbmcgb3JkZXIgYW5kIGJ5IGBhZ2VgIGluIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICogXy5vcmRlckJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10sIFsnYXNjJywgJ2Rlc2MnXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0MF1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycywgZ3VhcmQpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0FycmF5KGl0ZXJhdGVlcykpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gaXRlcmF0ZWVzID09IG51bGwgPyBbXSA6IFtpdGVyYXRlZXNdO1xuICAgICAgfVxuICAgICAgb3JkZXJzID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBvcmRlcnM7XG4gICAgICBpZiAoIWlzQXJyYXkob3JkZXJzKSkge1xuICAgICAgICBvcmRlcnMgPSBvcmRlcnMgPT0gbnVsbCA/IFtdIDogW29yZGVyc107XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byB0d28gZ3JvdXBzLCB0aGUgZmlyc3Qgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IsIHRoZSBzZWNvbmQgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleSBmb3IuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydwZWJibGVzJ10sIFsnYmFybmV5JywgJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsICdwZWJibGVzJ10sIFsnZnJlZCddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cbiAgICAgKi9cbiAgICB2YXIgcGFydGl0aW9uID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXkgPyAwIDogMV0ucHVzaCh2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24oKSB7IHJldHVybiBbW10sIFtdXTsgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZWR1Y2VzIGBjb2xsZWN0aW9uYCB0byBhIHZhbHVlIHdoaWNoIGlzIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLiBJZiBgYWNjdW11bGF0b3JgXG4gICAgICogaXMgbm90IGdpdmVuLCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbFxuICAgICAqIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICAgICAqIChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5yZWR1Y2VgLCBgXy5yZWR1Y2VSaWdodGAsIGFuZCBgXy50cmFuc2Zvcm1gLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFzc2lnbmAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgaW5jbHVkZXNgLCBgbWVyZ2VgLCBgb3JkZXJCeWAsXG4gICAgICogYW5kIGBzb3J0QnlgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5yZWR1Y2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlZHVjZShbMSwgMl0sIGZ1bmN0aW9uKHN1bSwgbikge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG47XG4gICAgICogfSwgMCk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAgICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZSA6IGJhc2VSZWR1Y2UsXG4gICAgICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2gpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmVkdWNlYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLnJlZHVjZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbWzAsIDFdLCBbMiwgM10sIFs0LCA1XV07XG4gICAgICpcbiAgICAgKiBfLnJlZHVjZVJpZ2h0KGFycmF5LCBmdW5jdGlvbihmbGF0dGVuZWQsIG90aGVyKSB7XG4gICAgICogICByZXR1cm4gZmxhdHRlbmVkLmNvbmNhdChvdGhlcik7XG4gICAgICogfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA1LCAyLCAzLCAwLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2VSaWdodCA6IGJhc2VSZWR1Y2UsXG4gICAgICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2hSaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmZpbHRlcmA7IHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYFxuICAgICAqIHRoYXQgYHByZWRpY2F0ZWAgZG9lcyAqKm5vdCoqIHJldHVybiB0cnV0aHkgZm9yLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBzZWUgXy5maWx0ZXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5yZWplY3QodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVqZWN0KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgbmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgcmFuZG9tIGVsZW1lbnQgZnJvbSBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNhbXBsZSA6IGJhc2VTYW1wbGU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGBuYCByYW5kb20gZWxlbWVudHMgYXQgdW5pcXVlIGtleXMgZnJvbSBgY29sbGVjdGlvbmAgdXAgdG8gdGhlXG4gICAgICogc2l6ZSBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGVTaXplKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzMsIDFdXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZVNpemUoWzEsIDIsIDNdLCA0KTtcbiAgICAgKiAvLyA9PiBbMiwgMywgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGVTaXplKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIDogbiA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICB9XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNhbXBsZVNpemUgOiBiYXNlU2FtcGxlU2l6ZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlXG4gICAgICogW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IFs0LCAxLCAzLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTaHVmZmxlIDogYmFzZVNodWZmbGU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgaXRzIGxlbmd0aCBmb3IgYXJyYXktbGlrZVxuICAgICAqIHZhbHVlcyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIGZvciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2xsZWN0aW9uIHNpemUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2l6ZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uc2l6ZSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2l6ZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+IDdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pID8gc3RyaW5nU2l6ZShjb2xsZWN0aW9uKSA6IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyhjb2xsZWN0aW9uKTtcbiAgICAgIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uc2l6ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlS2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFueSoqIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb21lKFtudWxsLCAwLCAneWVzJywgZmFsc2VdLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U29tZSA6IGJhc2VTb21lO1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhydSBlYWNoIGl0ZXJhdGVlLiBUaGlzIG1ldGhvZFxuICAgICAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZlxuICAgICAqIGVxdWFsIGVsZW1lbnRzLiBUaGUgaXRlcmF0ZWVzIGFyZSBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDMwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KHVzZXJzLCBbZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyOyB9XSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCAzMF1dXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCAzMF0sIFsnZnJlZCcsIDQ4XV1cbiAgICAgKi9cbiAgICB2YXIgc29ydEJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWVzKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA+IDEgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0pKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtdO1xuICAgICAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdLCBpdGVyYXRlZXNbMl0pKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtpdGVyYXRlZXNbMF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKGl0ZXJhdGVlcywgMSksIFtdKTtcbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICAgICAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IERhdGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gICAgICogfSwgXy5ub3coKSk7XG4gICAgICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgbm93ID0gY3R4Tm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmJlZm9yZWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXNcbiAgICAgKiBgZnVuY2Agb25jZSBpdCdzIGNhbGxlZCBgbmAgb3IgbW9yZSB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYmVmb3JlIGBmdW5jYCBpcyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXZlcyA9IFsncHJvZmlsZScsICdzZXR0aW5ncyddO1xuICAgICAqXG4gICAgICogdmFyIGRvbmUgPSBfLmFmdGVyKHNhdmVzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnZG9uZSBzYXZpbmchJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goc2F2ZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgKiAgIGFzeW5jU2F2ZSh7ICd0eXBlJzogdHlwZSwgJ2NvbXBsZXRlJzogZG9uZSB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdkb25lIHNhdmluZyEnIGFmdGVyIHRoZSB0d28gYXN5bmMgc2F2ZXMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWZ0ZXIobiwgZnVuYykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA8IDEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHVwIHRvIGBuYCBhcmd1bWVudHMsXG4gICAgICogaWdub3JpbmcgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgY2FwLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnOCcsICcxMCddLCBfLmFyeShwYXJzZUludCwgMSkpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnkoZnVuYywgbiwgZ3VhcmQpIHtcbiAgICAgIG4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IG47XG4gICAgICBuID0gKGZ1bmMgJiYgbiA9PSBudWxsKSA/IGZ1bmMubGVuZ3RoIDogbjtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQVJZX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHNcbiAgICAgKiBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hpbGUgaXQncyBjYWxsZWQgbGVzcyB0aGFuIGBuYCB0aW1lcy4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIHRoZSBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBhdCB3aGljaCBgZnVuY2AgaXMgbm8gbG9uZ2VyIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uYmVmb3JlKDUsIGFkZENvbnRhY3RUb0xpc3QpKTtcbiAgICAgKiAvLyA9PiBBbGxvd3MgYWRkaW5nIHVwIHRvIDQgY29udGFjdHMgdG8gdGhlIGxpc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmVmb3JlKG4sIGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uID4gMCkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgICAgZnVuYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgbmF0aXZlIGBGdW5jdGlvbiNiaW5kYCwgdGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCJcbiAgICAgKiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBCb3VuZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgXywgJyEnKTtcbiAgICAgKiBib3VuZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGJpdG1hc2sgPSBXUkFQX0JJTkRfRkxBRztcbiAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKGJpbmQpKTtcbiAgICAgICAgYml0bWFzayB8PSBXUkFQX1BBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgb2JqZWN0W2tleV1gIHdpdGggYHBhcnRpYWxzYFxuICAgICAqIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBfLmJpbmRgIGJ5IGFsbG93aW5nIGJvdW5kIGZ1bmN0aW9ucyB0byByZWZlcmVuY2VcbiAgICAgKiBtZXRob2RzIHRoYXQgbWF5IGJlIHJlZGVmaW5lZCBvciBkb24ndCB5ZXQgZXhpc3QuIFNlZVxuICAgICAqIFtQZXRlciBNaWNoYXV4J3MgYXJ0aWNsZV0oaHR0cDovL3BldGVyLm1pY2hhdXguY2EvYXJ0aWNsZXMvbGF6eS1mdW5jdGlvbi1kZWZpbml0aW9uLXBhdHRlcm4pXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kS2V5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52b2tlIHRoZSBtZXRob2Qgb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAndXNlcic6ICdmcmVkJyxcbiAgICAgKiAgICdncmVldCc6IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiBvYmplY3QuZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICd5YSAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBCb3VuZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCBfLCAnIScpO1xuICAgICAqIGJvdW5kKCdoaScpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kS2V5ID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBrZXksIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHO1xuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZEtleSkpO1xuICAgICAgICBiaXRtYXNrIHw9IFdSQVBfUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoa2V5LCBiaXRtYXNrLCBvYmplY3QsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYXJndW1lbnRzIG9mIGBmdW5jYCBhbmQgZWl0aGVyIGludm9rZXNcbiAgICAgKiBgZnVuY2AgcmV0dXJuaW5nIGl0cyByZXN1bHQsIGlmIGF0IGxlYXN0IGBhcml0eWAgbnVtYmVyIG9mIGFyZ3VtZW50cyBoYXZlXG4gICAgICogYmVlbiBwcm92aWRlZCwgb3IgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgcmVtYWluaW5nIGBmdW5jYFxuICAgICAqIGFyZ3VtZW50cywgYW5kIHNvIG9uLiBUaGUgYXJpdHkgb2YgYGZ1bmNgIG1heSBiZSBzcGVjaWZpZWQgaWYgYGZ1bmMubGVuZ3RoYFxuICAgICAqIGlzIG5vdCBzdWZmaWNpZW50LlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEpKDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyBDdXJyaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIGN1cnJpZWQoMSkoXywgMykoMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnkoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICBhcml0eSA9IGd1YXJkID8gdW5kZWZpbmVkIDogYXJpdHk7XG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0NVUlJZX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSk7XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeS5wbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jdXJyeWAgZXhjZXB0IHRoYXQgYXJndW1lbnRzIGFyZSBhcHBsaWVkIHRvIGBmdW5jYFxuICAgICAqIGluIHRoZSBtYW5uZXIgb2YgYF8ucGFydGlhbFJpZ2h0YCBpbnN0ZWFkIG9mIGBfLnBhcnRpYWxgLlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5UmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnlSaWdodChhYmMpO1xuICAgICAqXG4gICAgICogY3VycmllZCgzKSgyKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMiwgMykoMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogLy8gQ3VycmllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiBjdXJyaWVkKDMpKDEsIF8pKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5UmlnaHQoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICBhcml0eSA9IGd1YXJkID8gdW5kZWZpbmVkIDogYXJpdHk7XG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSk7XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeVJpZ2h0LnBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAgICAgKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAgICAgKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gICAgICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gICAgICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gICAgICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICAgICAqIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAgICAgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICAgICAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gICAgICpcbiAgICAgKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gICAgICogICAnbGVhZGluZyc6IHRydWUsXG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pKTtcbiAgICAgKlxuICAgICAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gICAgICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gICAgICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICAgICAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAgICAgKlxuICAgICAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxhc3RBcmdzLFxuICAgICAgICAgIGxhc3RUaGlzLFxuICAgICAgICAgIG1heFdhaXQsXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHRpbWVySWQsXG4gICAgICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgICAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgICAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICAgICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgICAgICB0aW1lV2FpdGluZyA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgICAgICByZXR1cm4gbWF4aW5nXG4gICAgICAgICAgPyBuYXRpdmVNaW4odGltZVdhaXRpbmcsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKVxuICAgICAgICAgIDogdGltZVdhaXRpbmc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICAgICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgICAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAgICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICAgICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICAgICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICAgICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgICAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICAgICAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gICAgICByZXR1cm4gZGVib3VuY2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmVycyBpbnZva2luZyB0aGUgYGZ1bmNgIHVudGlsIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzIGNsZWFyZWQuIEFueVxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWZlci5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbih0ZXh0KSB7XG4gICAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgKiB9LCAnZGVmZXJyZWQnKTtcbiAgICAgKiAvLyA9PiBMb2dzICdkZWZlcnJlZCcgYWZ0ZXIgb25lIG1pbGxpc2Vjb25kLlxuICAgICAqL1xuICAgIHZhciBkZWZlciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBiYXNlRGVsYXkoZnVuYywgMSwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGBmdW5jYCBhZnRlciBgd2FpdGAgbWlsbGlzZWNvbmRzLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlXG4gICAgICogcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWxheShmdW5jdGlvbih0ZXh0KSB7XG4gICAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgKiB9LCAxMDAwLCAnbGF0ZXInKTtcbiAgICAgKiAvLyA9PiBMb2dzICdsYXRlcicgYWZ0ZXIgb25lIHNlY29uZC5cbiAgICAgKi9cbiAgICB2YXIgZGVsYXkgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIHRvTnVtYmVyKHdhaXQpIHx8IDAsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgcmV2ZXJzZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBmbGlwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmxpcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZsaXBwZWQgPSBfLmZsaXAoZnVuY3Rpb24oKSB7XG4gICAgICogICByZXR1cm4gXy50b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBmbGlwcGVkKCdhJywgJ2InLCAnYycsICdkJyk7XG4gICAgICogLy8gPT4gWydkJywgJ2MnLCAnYicsICdhJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGlwKGZ1bmMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfRkxJUF9GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICAgICAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAgICAgKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICAgICAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICAgICAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gICAgICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAgICAgKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICAgICAqXG4gICAgICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB2YWx1ZXMob3RoZXIpO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqXG4gICAgICogb2JqZWN0LmEgPSAyO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gICAgICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKlxuICAgICAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gICAgICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9XG5cbiAgICAvLyBFeHBvc2UgYE1hcENhY2hlYC5cbiAgICBtZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBuZWdhdGVzIHRoZSByZXN1bHQgb2YgdGhlIHByZWRpY2F0ZSBgZnVuY2AuIFRoZVxuICAgICAqIGBmdW5jYCBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBuZWdhdGUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbmVnYXRlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNFdmVuKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFsxLCAyLCAzLCA0LCA1LCA2XSwgXy5uZWdhdGUoaXNFdmVuKSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmVnYXRlKHByZWRpY2F0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgIGNhc2UgMTogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyByZXN0cmljdGVkIHRvIGludm9raW5nIGBmdW5jYCBvbmNlLiBSZXBlYXQgY2FsbHNcbiAgICAgKiB0byB0aGUgZnVuY3Rpb24gcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgaW52b2NhdGlvbi4gVGhlIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBpbml0aWFsaXplID0gXy5vbmNlKGNyZWF0ZUFwcGxpY2F0aW9uKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIC8vID0+IGBjcmVhdGVBcHBsaWNhdGlvbmAgaXMgaW52b2tlZCBvbmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25jZShmdW5jKSB7XG4gICAgICByZXR1cm4gYmVmb3JlKDIsIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50cyB0cmFuc2Zvcm1lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFt0cmFuc2Zvcm1zPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGFyZ3VtZW50IHRyYW5zZm9ybXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGRvdWJsZWQobikge1xuICAgICAqICAgcmV0dXJuIG4gKiAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJBcmdzKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHJldHVybiBbeCwgeV07XG4gICAgICogfSwgW3NxdWFyZSwgZG91YmxlZF0pO1xuICAgICAqXG4gICAgICogZnVuYyg5LCAzKTtcbiAgICAgKiAvLyA9PiBbODEsIDZdXG4gICAgICpcbiAgICAgKiBmdW5jKDEwLCA1KTtcbiAgICAgKiAvLyA9PiBbMTAwLCAxMF1cbiAgICAgKi9cbiAgICB2YXIgb3ZlckFyZ3MgPSBjYXN0UmVzdChmdW5jdGlvbihmdW5jLCB0cmFuc2Zvcm1zKSB7XG4gICAgICB0cmFuc2Zvcm1zID0gKHRyYW5zZm9ybXMubGVuZ3RoID09IDEgJiYgaXNBcnJheSh0cmFuc2Zvcm1zWzBdKSlcbiAgICAgICAgPyBhcnJheU1hcCh0cmFuc2Zvcm1zWzBdLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpXG4gICAgICAgIDogYXJyYXlNYXAoYmFzZUZsYXR0ZW4odHJhbnNmb3JtcywgMSksIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG5cbiAgICAgIHZhciBmdW5jc0xlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oYXJncy5sZW5ndGgsIGZ1bmNzTGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gdHJhbnNmb3Jtc1tpbmRleF0uY2FsbCh0aGlzLCBhcmdzW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZVxuICAgICAqIGFyZ3VtZW50cyBpdCByZWNlaXZlcy4gVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5iaW5kYCBleGNlcHQgaXQgZG9lcyAqKm5vdCoqXG4gICAgICogYWx0ZXIgdGhlIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogVGhlIGBfLnBhcnRpYWwucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWwoZ3JlZXQsICdoZWxsbycpO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFBhcnRpYWxseSBhcHBsaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWwoZ3JlZXQsIF8sICdmcmVkJyk7XG4gICAgICogZ3JlZXRGcmVkKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqL1xuICAgIHZhciBwYXJ0aWFsID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsKSk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1BBUlRJQUxfRkxBRywgdW5kZWZpbmVkLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnBhcnRpYWxgIGV4Y2VwdCB0aGF0IHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50c1xuICAgICAqIGFyZSBhcHBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhlIGBfLnBhcnRpYWxSaWdodC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgbmFtZSkge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdmcmVkJyk7XG4gICAgICogZ3JlZXRGcmVkKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gUGFydGlhbGx5IGFwcGxpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2hlbGxvJywgXyk7XG4gICAgICogc2F5SGVsbG9UbygnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqL1xuICAgIHZhciBwYXJ0aWFsUmlnaHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKHBhcnRpYWxSaWdodCkpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcsIHVuZGVmaW5lZCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgYXJyYW5nZWQgYWNjb3JkaW5nXG4gICAgICogdG8gdGhlIHNwZWNpZmllZCBgaW5kZXhlc2Agd2hlcmUgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBmaXJzdCBpbmRleCBpc1xuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBzZWNvbmQgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZWFycmFuZ2UgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW10pfSBpbmRleGVzIFRoZSBhcnJhbmdlZCBhcmd1bWVudCBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcmVhcmdlZCA9IF8ucmVhcmcoZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9LCBbMiwgMCwgMV0pO1xuICAgICAqXG4gICAgICogcmVhcmdlZCgnYicsICdjJywgJ2EnKVxuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIHZhciByZWFyZyA9IGZsYXRSZXN0KGZ1bmN0aW9uKGZ1bmMsIGluZGV4ZXMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUkVBUkdfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaW5kZXhlcyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uIGFuZCBhcmd1bWVudHMgZnJvbSBgc3RhcnRgIGFuZCBiZXlvbmQgcHJvdmlkZWQgYXNcbiAgICAgKiBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGVcbiAgICAgKiBbcmVzdCBwYXJhbWV0ZXJdKGh0dHBzOi8vbWRuLmlvL3Jlc3RfcGFyYW1ldGVycykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNheSA9IF8ucmVzdChmdW5jdGlvbih3aGF0LCBuYW1lcykge1xuICAgICAqICAgcmV0dXJuIHdoYXQgKyAnICcgKyBfLmluaXRpYWwobmFtZXMpLmpvaW4oJywgJykgK1xuICAgICAqICAgICAoXy5zaXplKG5hbWVzKSA+IDEgPyAnLCAmICcgOiAnJykgKyBfLmxhc3QobmFtZXMpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2F5KCdoZWxsbycsICdmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3QoZnVuYywgc3RhcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jLCBzdGFydCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gICAgICogY3JlYXRlIGZ1bmN0aW9uIGFuZCBhbiBhcnJheSBvZiBhcmd1bWVudHMgbXVjaCBsaWtlXG4gICAgICogW2BGdW5jdGlvbiNhcHBseWBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1mdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZVxuICAgICAqIFtzcHJlYWQgb3BlcmF0b3JdKGh0dHBzOi8vbWRuLmlvL3NwcmVhZF9vcGVyYXRvcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBzcHJlYWQgYXJndW1lbnRzIG92ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHNwcmVhZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNheSA9IF8uc3ByZWFkKGZ1bmN0aW9uKHdobywgd2hhdCkge1xuICAgICAqICAgcmV0dXJuIHdobyArICcgc2F5cyAnICsgd2hhdDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheShbJ2ZyZWQnLCAnaGVsbG8nXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQgc2F5cyBoZWxsbydcbiAgICAgKlxuICAgICAqIHZhciBudW1iZXJzID0gUHJvbWlzZS5hbGwoW1xuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDQwKSxcbiAgICAgKiAgIFByb21pc2UucmVzb2x2ZSgzNilcbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIG51bWJlcnMudGhlbihfLnNwcmVhZChmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4geCArIHk7XG4gICAgICogfSkpO1xuICAgICAqIC8vID0+IGEgUHJvbWlzZSBvZiA3NlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNwcmVhZChmdW5jLCBzdGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6IG5hdGl2ZU1heCh0b0ludGVnZXIoc3RhcnQpLCAwKTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFyZ3Nbc3RhcnRdLFxuICAgICAgICAgICAgb3RoZXJBcmdzID0gY2FzdFNsaWNlKGFyZ3MsIDAsIHN0YXJ0KTtcblxuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBhcnJheVB1c2gob3RoZXJBcmdzLCBhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gICAgICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAgICAgKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXG4gICAgICogaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgXG4gICAgICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuICAgICAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcbiAgICAgKiB0aHJvdHRsZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiByZXR1cm4gdGhlXG4gICAgICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gICAgICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gICAgICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICAgICAqXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gICAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmcuXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICAgICAqXG4gICAgICogLy8gSW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXMuXG4gICAgICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICAgICAqXG4gICAgICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcbiAgICAgICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICAgICAnbWF4V2FpdCc6IHdhaXQsXG4gICAgICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIG9uZSBhcmd1bWVudCwgaWdub3JpbmcgYW55XG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8udW5hcnkocGFyc2VJbnQpKTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5hcnkoZnVuYykge1xuICAgICAgcmV0dXJuIGFyeShmdW5jLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBgdmFsdWVgIHRvIGB3cmFwcGVyYCBhcyBpdHMgZmlyc3RcbiAgICAgKiBhcmd1bWVudC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBmdW5jdGlvbiBhcmUgYXBwZW5kZWRcbiAgICAgKiB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgYHdyYXBwZXJgLiBUaGUgd3JhcHBlciBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFt3cmFwcGVyPWlkZW50aXR5XSBUaGUgd3JhcHBlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHAgPSBfLndyYXAoXy5lc2NhcGUsIGZ1bmN0aW9uKGZ1bmMsIHRleHQpIHtcbiAgICAgKiAgIHJldHVybiAnPHA+JyArIGZ1bmModGV4dCkgKyAnPC9wPic7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBwKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICc8cD5mcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXM8L3A+J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXAodmFsdWUsIHdyYXBwZXIpIHtcbiAgICAgIHJldHVybiBwYXJ0aWFsKGNhc3RGdW5jdGlvbih3cmFwcGVyKSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgYXMgYW4gYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoMSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSh7ICdhJzogMSB9KTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEgfV1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBbJ2FiYyddXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheShudWxsKTtcbiAgICAgKiAvLyA9PiBbbnVsbF1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gW3VuZGVmaW5lZF1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKiBjb25zb2xlLmxvZyhfLmNhc3RBcnJheShhcnJheSkgPT09IGFycmF5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdEFycmF5KCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gICAgICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwczovL21kbi5pby9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobSlcbiAgICAgKiBhbmQgc3VwcG9ydHMgY2xvbmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLCBkYXRlIG9iamVjdHMsIG1hcHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkXG4gICAgICogYXJyYXlzLiBUaGUgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFyZSBjbG9uZWRcbiAgICAgKiBhcyBwbGFpbiBvYmplY3RzLiBBbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoXG4gICAgICogYXMgZXJyb3Igb2JqZWN0cywgZnVuY3Rpb25zLCBET00gbm9kZXMsIGFuZCBXZWFrTWFwcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVEZWVwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICAgICAqXG4gICAgICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKG9iamVjdHMpO1xuICAgICAqIGNvbnNvbGUubG9nKHNoYWxsb3dbMF0gPT09IG9iamVjdHNbMF0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCxcbiAgICAgKiBjbG9uaW5nIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHVwIHRvIGZvdXIgYXJndW1lbnRzOyAodmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3QsIHN0YWNrXSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVEZWVwV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKHZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBlbCA9IF8uY2xvbmVXaXRoKGRvY3VtZW50LmJvZHksIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZWwgPT09IGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogY29uc29sZS5sb2coZWwubm9kZU5hbWUpO1xuICAgICAqIC8vID0+ICdCT0RZJ1xuICAgICAqIGNvbnNvbGUubG9nKGVsLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVXaXRoKHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChvYmplY3RzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhkZWVwWzBdID09PSBvYmplY3RzWzBdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lV2l0aGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZVdpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcih2YWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBlbCA9IF8uY2xvbmVEZWVwV2l0aChkb2N1bWVudC5ib2R5LCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGVsID09PSBkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqIGNvbnNvbGUubG9nKGVsLm5vZGVOYW1lKTtcbiAgICAgKiAvLyA9PiAnQk9EWSdcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5jaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXBXaXRoKHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgb2JqZWN0YCBjb25mb3JtcyB0byBgc291cmNlYCBieSBpbnZva2luZyB0aGUgcHJlZGljYXRlXG4gICAgICogcHJvcGVydGllcyBvZiBgc291cmNlYCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGBfLmNvbmZvcm1zYCB3aGVuIGBzb3VyY2VgIGlzXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xNC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBjb25mb3JtcywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqXG4gICAgICogXy5jb25mb3Jtc1RvKG9iamVjdCwgeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAxOyB9IH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uY29uZm9ybXNUbyhvYmplY3QsIHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMjsgfSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBzb3VyY2UgPT0gbnVsbCB8fCBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwga2V5cyhzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVxKCdhJywgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVxKE5hTiwgTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmx0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3QoMywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5ndCgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBndCA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oYmFzZUd0KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvXG4gICAgICogIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ubHRlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDMsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDMsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDEsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGd0ZSA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gb3RoZXI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheUJ1ZmZlcmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5QnVmZmVyKG5ldyBBcnJheUJ1ZmZlcigyKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5QnVmZmVyKG5ldyBBcnJheSgyKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcnJheUJ1ZmZlciA9IG5vZGVJc0FycmF5QnVmZmVyID8gYmFzZVVuYXJ5KG5vZGVJc0FycmF5QnVmZmVyKSA6IGJhc2VJc0FycmF5QnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICAgICAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAgICAgKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gICAgICogaXMgYW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYm9vbGVhbiBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJvb2xlYW4sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4oZmFsc2UpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGJvb2xUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBEYXRlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZGF0ZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUobmV3IERhdGUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKCdNb24gQXByaWwgMjMgMjAxMicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzRGF0ZSA9IG5vZGVJc0RhdGUgPyBiYXNlVW5hcnkobm9kZUlzRGF0ZSkgOiBiYXNlSXNEYXRlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoJzxib2R5PicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMSAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAgICAgKlxuICAgICAqIE9iamVjdHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIG5vIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZFxuICAgICAqIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBBcnJheS1saWtlIHZhbHVlcyBzdWNoIGFzIGBhcmd1bWVudHNgIG9iamVjdHMsIGFycmF5cywgYnVmZmVycywgc3RyaW5ncywgb3JcbiAgICAgKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gICAgICogU2ltaWxhcmx5LCBtYXBzIGFuZCBzZXRzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBzaXplYCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkodHJ1ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgICAoaXNBcnJheSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZS5zcGxpY2UgPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgaXNCdWZmZXIodmFsdWUpIHx8IGlzVHlwZWRBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpO1xuICAgICAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgICAgICByZXR1cm4gIXZhbHVlLnNpemU7XG4gICAgICB9XG4gICAgICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAhYmFzZUtleXModmFsdWUpLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICAgICAqIGVxdWl2YWxlbnQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsXG4gICAgICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxuICAgICAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXG4gICAgICogYnkgdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZ1bmN0aW9ucyBhbmQgRE9NXG4gICAgICogbm9kZXMgYXJlIGNvbXBhcmVkIGJ5IHN0cmljdCBlcXVhbGl0eSwgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogb2JqZWN0ID09PSBvdGhlcjtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzRXF1YWxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIGNvbXBhcmlzb25zXG4gICAgICogYXJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCB1cCB0b1xuICAgICAqIHNpeCBhcmd1bWVudHM6IChvYmpWYWx1ZSwgb3RoVmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3QsIG90aGVyLCBzdGFja10pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNHcmVldGluZyh2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIC9eaCg/Oml8ZWxsbykkLy50ZXN0KHZhbHVlKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSkge1xuICAgICAqICAgaWYgKGlzR3JlZXRpbmcob2JqVmFsdWUpICYmIGlzR3JlZXRpbmcob3RoVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnaGVsbG8nLCAnZ29vZGJ5ZSddO1xuICAgICAqIHZhciBvdGhlciA9IFsnaGknLCAnZ29vZGJ5ZSddO1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsV2l0aChhcnJheSwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsV2l0aCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgb3RoZXIpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCB1bmRlZmluZWQsIGN1c3RvbWl6ZXIpIDogISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYEVycm9yYCwgYEV2YWxFcnJvcmAsIGBSYW5nZUVycm9yYCwgYFJlZmVyZW5jZUVycm9yYCxcbiAgICAgKiBgU3ludGF4RXJyb3JgLCBgVHlwZUVycm9yYCwgb3IgYFVSSUVycm9yYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IoRXJyb3IpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgICAgIHJldHVybiB0YWcgPT0gZXJyb3JUYWcgfHwgdGFnID09IGRvbUV4Y1RhZyB8fFxuICAgICAgICAodHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlLm5hbWUgPT0gJ3N0cmluZycgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBwcmltaXRpdmUgbnVtYmVyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNGaW5pdGVgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNGaW5pdGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiBuYXRpdmVJc0Zpbml0ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbihfKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gICAgICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgICAgIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzSW50ZWdlcmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc0ludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPT0gdG9JbnRlZ2VyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgICAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gICAgICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICAgICAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3Qoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gICAgICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTWFwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNNYXAobmV3IE1hcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc01hcChuZXcgV2Vha01hcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNNYXAgPSBub2RlSXNNYXAgPyBiYXNlVW5hcnkobm9kZUlzTWFwKSA6IGJhc2VJc01hcDtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBgb2JqZWN0YCBhbmQgYHNvdXJjZWAgdG9cbiAgICAgKiBkZXRlcm1pbmUgaWYgYG9iamVjdGAgY29udGFpbnMgZXF1aXZhbGVudCBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgXy5tYXRjaGVzYCB3aGVuIGBzb3VyY2VgIGlzXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdCBgc291cmNlYFxuICAgICAqIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlIGBfLmlzRXF1YWxgXG4gICAgICogZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2InOiAxIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXRjaChvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBnZXRNYXRjaERhdGEoc291cmNlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc01hdGNoYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBjb21wYXJpc29uc1xuICAgICAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggZml2ZVxuICAgICAqIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwgaW5kZXh8a2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNHcmVldGluZyh2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIC9eaCg/Oml8ZWxsbykkLy50ZXN0KHZhbHVlKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgaWYgKGlzR3JlZXRpbmcob2JqVmFsdWUpICYmIGlzR3JlZXRpbmcoc3JjVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdncmVldGluZyc6ICdoZWxsbycgfTtcbiAgICAgKiB2YXIgc291cmNlID0geyAnZ3JlZXRpbmcnOiAnaGknIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2hXaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXRjaFdpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBOYU5gLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNOYU5gXShodHRwczovL21kbi5pby9OdW1iZXIvaXNOYU4pIGFuZCBpcyBub3QgdGhlIHNhbWUgYXNcbiAgICAgKiBnbG9iYWwgW2Bpc05hTmBdKGh0dHBzOi8vbWRuLmlvL2lzTmFOKSB3aGljaCByZXR1cm5zIGB0cnVlYCBmb3JcbiAgICAgKiBgdW5kZWZpbmVkYCBhbmQgb3RoZXIgbm9uLW51bWJlciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4oTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAgICAgLy8gQW4gYE5hTmAgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZi5cbiAgICAgIC8vIFBlcmZvcm0gdGhlIGB0b1N0cmluZ1RhZ2AgY2hlY2sgZmlyc3QgdG8gYXZvaWQgZXJyb3JzIHdpdGggc29tZVxuICAgICAgLy8gQWN0aXZlWCBvYmplY3RzIGluIElFLlxuICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSAhPSArdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcmlzdGluZSBuYXRpdmUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgY2FuJ3QgcmVsaWFibHkgZGV0ZWN0IG5hdGl2ZSBmdW5jdGlvbnMgaW4gdGhlIHByZXNlbmNlXG4gICAgICogb2YgdGhlIGNvcmUtanMgcGFja2FnZSBiZWNhdXNlIGNvcmUtanMgY2lyY3VtdmVudHMgdGhpcyBraW5kIG9mIGRldGVjdGlvbi5cbiAgICAgKiBEZXNwaXRlIG11bHRpcGxlIHJlcXVlc3RzLCB0aGUgY29yZS1qcyBtYWludGFpbmVyIGhhcyBtYWRlIGl0IGNsZWFyOiBhbnlcbiAgICAgKiBhdHRlbXB0IHRvIGZpeCB0aGUgZGV0ZWN0aW9uIHdpbGwgYmUgb2JzdHJ1Y3RlZC4gQXMgYSByZXN1bHQsIHdlJ3JlIGxlZnRcbiAgICAgKiB3aXRoIGxpdHRsZSBjaG9pY2UgYnV0IHRvIHRocm93IGFuIGVycm9yLiBVbmZvcnR1bmF0ZWx5LCB0aGlzIGFsc28gYWZmZWN0c1xuICAgICAqIHBhY2thZ2VzLCBsaWtlIFtiYWJlbC1wb2x5ZmlsbF0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYmFiZWwtcG9seWZpbGwpLFxuICAgICAqIHdoaWNoIHJlbHkgb24gY29yZS1qcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShfKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICBpZiAoaXNNYXNrYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKENPUkVfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBudWxsYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbCh2b2lkIDApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBudWxsaXNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05pbCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmlsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE51bWJlcmAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUbyBleGNsdWRlIGBJbmZpbml0eWAsIGAtSW5maW5pdHlgLCBhbmQgYE5hTmAsIHdoaWNoIGFyZVxuICAgICAqIGNsYXNzaWZpZWQgYXMgbnVtYmVycywgdXNlIHRoZSBgXy5pc0Zpbml0ZWAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gbnVtYmVyVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gICAgICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuOC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICAgICAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgICAgIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBSZWdFeHBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSByZWdleHAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgvYWJjLyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgnL2FiYy8nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1JlZ0V4cCA9IG5vZGVJc1JlZ0V4cCA/IGJhc2VVbmFyeShub2RlSXNSZWdFeHApIDogYmFzZUlzUmVnRXhwO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBzYWZlIGludGVnZXIuIEFuIGludGVnZXIgaXMgc2FmZSBpZiBpdCdzIGFuIElFRUUtNzU0XG4gICAgICogZG91YmxlIHByZWNpc2lvbiBudW1iZXIgd2hpY2ggaXNuJ3QgdGhlIHJlc3VsdCBvZiBhIHJvdW5kZWQgdW5zYWZlIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc1NhZmVJbnRlZ2VyYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzU2FmZUludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNhZmUgaW50ZWdlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU2FmZUludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0ludGVnZXIodmFsdWUpICYmIHZhbHVlID49IC1NQVhfU0FGRV9JTlRFR0VSICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1NldChuZXcgU2V0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICAgICAoIWlzQXJyYXkodmFsdWUpICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3RyaW5nVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZChudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFdlYWtNYXBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB3ZWFrIG1hcCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha01hcChuZXcgV2Vha01hcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtNYXAobmV3IE1hcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1dlYWtNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gd2Vha01hcFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFdlYWtTZXRgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB3ZWFrIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha1NldChuZXcgV2Vha1NldCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtTZXQobmV3IFNldCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1dlYWtTZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHdlYWtTZXRUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5ndFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmx0KDEsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHQoMywgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8ubHQoMywgMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgbHQgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGJhc2VMdCk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0b1xuICAgICAqICBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmd0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBsdGUgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlIDw9IG90aGVyO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0FycmF5KHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KDEpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkobnVsbCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSA/IHN0cmluZ1RvQXJyYXkodmFsdWUpIDogY29weUFycmF5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzeW1JdGVyYXRvciAmJiB2YWx1ZVtzeW1JdGVyYXRvcl0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVG9BcnJheSh2YWx1ZVtzeW1JdGVyYXRvcl0oKSk7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgICBmdW5jID0gdGFnID09IG1hcFRhZyA/IG1hcFRvQXJyYXkgOiAodGFnID09IHNldFRhZyA/IHNldFRvQXJyYXkgOiB2YWx1ZXMpO1xuXG4gICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMi4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoMy4yKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gNWUtMzI0XG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZSgnMy4yJyk7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gICAgICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICAgICAgdmFyIHNpZ24gPSAodmFsdWUgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYFRvSW50ZWdlcmBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2ludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcigzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICAgICAgcmVtYWluZGVyID0gcmVzdWx0ICUgMTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlciBzdWl0YWJsZSBmb3IgdXNlIGFzIHRoZSBsZW5ndGggb2YgYW5cbiAgICAgKiBhcnJheS1saWtlIG9iamVjdC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDQyOTQ5NjcyOTVcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0xlbmd0aCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID8gYmFzZUNsYW1wKHRvSW50ZWdlcih2YWx1ZSksIDAsIE1BWF9BUlJBWV9MRU5HVEgpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b051bWJlcigzLjIpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqXG4gICAgICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiA1ZS0zMjRcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IEluZmluaXR5XG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBOQU47XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IGJhc2VUcmltKHZhbHVlKTtcbiAgICAgIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gICAgICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICAgICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAgICAgKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHNhZmUgaW50ZWdlci4gQSBzYWZlIGludGVnZXIgY2FuIGJlIGNvbXBhcmVkIGFuZFxuICAgICAqIHJlcHJlc2VudGVkIGNvcnJlY3RseS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gOTAwNzE5OTI1NDc0MDk5MVxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9TYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgID8gYmFzZUNsYW1wKHRvSW50ZWdlcih2YWx1ZSksIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKVxuICAgICAgICA6ICh2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAgICAgKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKG51bGwpO1xuICAgICAqIC8vID0+ICcnXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKC0wKTtcbiAgICAgKiAvLyA9PiAnLTAnXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gJzEsMiwzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZVxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAqIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BPYmplY3QuYXNzaWduYF0oaHR0cHM6Ly9tZG4uaW8vT2JqZWN0L2Fzc2lnbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25JblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEJhcigpIHtcbiAgICAgKiAgIHRoaXMuYyA9IDM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAgICAgKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gICAgICBpZiAoaXNQcm90b3R5cGUoc291cmNlKSB8fCBpc0FycmF5TGlrZShzb3VyY2UpKSB7XG4gICAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgb3duIGFuZFxuICAgICAqIGluaGVyaXRlZCBzb3VyY2UgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGV4dGVuZFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQmFyKCkge1xuICAgICAqICAgdGhpcy5jID0gMztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICAgICAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbkluKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMywgJ2QnOiA0IH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduSW4gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25JbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBleHRlbmRXaXRoXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbldpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25JbldpdGgsIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbkluV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduSW5XaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduV2l0aCwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gYHBhdGhzYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwaWNrZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9LCA0XSB9O1xuICAgICAqXG4gICAgICogXy5hdChvYmplY3QsIFsnYVswXS5iLmMnLCAnYVsxXSddKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKi9cbiAgICB2YXIgYXQgPSBmbGF0UmVzdChiYXNlQXQpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBgcHJvdG90eXBlYCBvYmplY3QuIElmIGFcbiAgICAgKiBgcHJvcGVydGllc2Agb2JqZWN0IGlzIGdpdmVuLCBpdHMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXNcbiAgICAgKiBhcmUgYXNzaWduZWQgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwge1xuICAgICAqICAgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gcHJvcGVydGllcyA9PSBudWxsID8gcmVzdWx0IDogYmFzZUFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2VcbiAgICAgKiBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXRcbiAgICAgKiByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICogT25jZSBhIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCB2YWx1ZXMgb2YgdGhlIHNhbWUgcHJvcGVydHkgYXJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZGVmYXVsdHNEZWVwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICB2YXIgbGVuZ3RoID0gc291cmNlcy5sZW5ndGg7XG4gICAgICB2YXIgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICAgIHZhciBwcm9wcyA9IGtleXNJbihzb3VyY2UpO1xuICAgICAgICB2YXIgcHJvcHNJbmRleCA9IC0xO1xuICAgICAgICB2YXIgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsrcHJvcHNJbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW3Byb3BzSW5kZXhdO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgKGVxKHZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgICBvYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kZWZhdWx0c2AgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgYXNzaWduc1xuICAgICAqIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZGVmYXVsdHNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0c0RlZXAoeyAnYSc6IHsgJ2InOiAyIH0gfSwgeyAnYSc6IHsgJ2InOiAxLCAnYyc6IDMgfSB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnYic6IDIsICdjJzogMyB9IH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHNEZWVwID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgYXJncy5wdXNoKHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSk7XG4gICAgICByZXR1cm4gYXBwbHkobWVyZ2VXaXRoLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCxcbiAgICAgKiAgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGJhc2VGb3JPd24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEtleWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGEgY29sbGVjdGlvbiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCxcbiAgICAgKiAgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiByZXR1cm5zICdwZWJibGVzJyBhc3N1bWluZyBgXy5maW5kS2V5YCByZXR1cm5zICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIGJhc2VGaW5kS2V5KG9iamVjdCwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgYmFzZUZvck93blJpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW5cbiAgICAgKiBvYmplY3QgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdFxuICAgICAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9ySW5SaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJbihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckluKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbFxuICAgICAgICA/IG9iamVjdFxuICAgICAgICA6IGJhc2VGb3Iob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JJbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXG4gICAgICogYG9iamVjdGAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9ySW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW5SaWdodChuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2MnLCAnYicsIHRoZW4gJ2EnIGFzc3VtaW5nIGBfLmZvckluYCBsb2dzICdhJywgJ2InLCB0aGVuICdjJy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJblJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbFxuICAgICAgICA/IG9iamVjdFxuICAgICAgICA6IGJhc2VGb3JSaWdodChvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCBhbmRcbiAgICAgKiBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uXG4gICAgICogZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvck93blJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93bihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JPd24ob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yT3duYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JPd25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9yT3duUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdiJyB0aGVuICdhJyBhc3N1bWluZyBgXy5mb3JPd25gIGxvZ3MgJ2EnIHRoZW4gJ2InLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvck93blJpZ2h0KG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGVudW1lcmFibGUgcHJvcGVydGllc1xuICAgICAqIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICogQHNlZSBfLmZ1bmN0aW9uc0luXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IF8uY29uc3RhbnQoJ2EnKTtcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9ucyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGFuZCBpbmhlcml0ZWRcbiAgICAgKiBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKiBAc2VlIF8uZnVuY3Rpb25zXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IF8uY29uc3RhbnQoJ2EnKTtcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9uc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uc0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5c0luKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gICAgICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IHsgJ2InOiAyIH0gfTtcbiAgICAgKiB2YXIgb3RoZXIgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYS5iJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvdGhlciwgJ2EnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhcyhvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBpbnZlcnRlZCBrZXlzIGFuZCB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICogSWYgYG9iamVjdGAgY29udGFpbnMgZHVwbGljYXRlIHZhbHVlcywgc3Vic2VxdWVudCB2YWx1ZXMgb3ZlcndyaXRlXG4gICAgICogcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pbnZlcnQob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogJ2MnLCAnMic6ICdiJyB9XG4gICAgICovXG4gICAgdmFyIGludmVydCA9IGNyZWF0ZUludmVydGVyKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRbdmFsdWVdID0ga2V5O1xuICAgIH0sIGNvbnN0YW50KGlkZW50aXR5KSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludmVydGAgZXhjZXB0IHRoYXQgdGhlIGludmVydGVkIG9iamVjdCBpcyBnZW5lcmF0ZWRcbiAgICAgKiBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmcgZWFjaCBlbGVtZW50IG9mIGBvYmplY3RgIHRocnUgYGl0ZXJhdGVlYC4gVGhlXG4gICAgICogY29ycmVzcG9uZGluZyBpbnZlcnRlZCB2YWx1ZSBvZiBlYWNoIGludmVydGVkIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzXG4gICAgICogcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGludmVydGVkIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0Qnkob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gICAgICpcbiAgICAgKiBfLmludmVydEJ5KG9iamVjdCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAnZ3JvdXAnICsgdmFsdWU7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnZ3JvdXAxJzogWydhJywgJ2MnXSwgJ2dyb3VwMic6IFsnYiddIH1cbiAgICAgKi9cbiAgICB2YXIgaW52ZXJ0QnkgPSBjcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0W3ZhbHVlXS5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbdmFsdWVdID0gW2tleV07XG4gICAgICB9XG4gICAgfSwgZ2V0SXRlcmF0ZWUpO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IFsxLCAyLCAzLCA0XSB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLmludm9rZShvYmplY3QsICdhWzBdLmIuYy5zbGljZScsIDEsIDMpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqL1xuICAgIHZhciBpbnZva2UgPSBiYXNlUmVzdChiYXNlSW52b2tlKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAgICAgKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5cyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLmtleXMoJ2hpJyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5rZXlzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLm1hcFZhbHVlc2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlXG4gICAgICogc2FtZSB2YWx1ZXMgYXMgYG9iamVjdGAgYW5kIGtleXMgZ2VuZXJhdGVkIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZVxuICAgICAqIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gICAgICogQHNlZSBfLm1hcFZhbHVlc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcEtleXMoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICByZXR1cm4ga2V5ICsgdmFsdWU7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYTEnOiAxLCAnYjInOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBLZXlzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWRcbiAgICAgKiBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnVcbiAgICAgKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBzZWUgXy5tYXBLZXlzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdmcmVkJzogICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tYXBWYWx1ZXModXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlOyB9KTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyk7XG5cbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAgICAgKiBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZVxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICAgICAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICAgICAqIGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkuIE90aGVyIG9iamVjdHMgYW5kIHZhbHVlIHR5cGVzIGFyZSBvdmVycmlkZGVuIGJ5XG4gICAgICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gICAgICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIG90aGVyID0ge1xuICAgICAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiAyLCAnYyc6IDMgfSwgeyAnZCc6IDQsICdlJzogNSB9XSB9XG4gICAgICovXG4gICAgdmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gICAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVyZ2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBtZXJnZWQgdmFsdWVzIG9mIHRoZSBkZXN0aW5hdGlvbiBhbmQgc291cmNlXG4gICAgICogcHJvcGVydGllcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIG1lcmdpbmcgaXMgaGFuZGxlZCBieSB0aGVcbiAgICAgKiBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggc2l4IGFyZ3VtZW50czpcbiAgICAgKiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiBvYmpWYWx1ZS5jb25jYXQoc3JjVmFsdWUpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogWzFdLCAnYic6IFsyXSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiBbM10sICdiJzogWzRdIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlV2l0aChvYmplY3QsIG90aGVyLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogWzEsIDNdLCAnYic6IFsyLCA0XSB9XG4gICAgICovXG4gICAgdmFyIG1lcmdlV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZVxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgcGF0aHMgb2YgYG9iamVjdGAgdGhhdCBhcmUgbm90IG9taXR0ZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgY29uc2lkZXJhYmx5IHNsb3dlciB0aGFuIGBfLnBpY2tgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gb21pdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ub21pdChvYmplY3QsIFsnYScsICdjJ10pO1xuICAgICAqIC8vID0+IHsgJ2InOiAnMicgfVxuICAgICAqL1xuICAgIHZhciBvbWl0ID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgaXNEZWVwID0gZmFsc2U7XG4gICAgICBwYXRocyA9IGFycmF5TWFwKHBhdGhzLCBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgICBpc0RlZXAgfHwgKGlzRGVlcCA9IHBhdGgubGVuZ3RoID4gMSk7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfSk7XG4gICAgICBjb3B5T2JqZWN0KG9iamVjdCwgZ2V0QWxsS2V5c0luKG9iamVjdCksIHJlc3VsdCk7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIHJlc3VsdCA9IGJhc2VDbG9uZShyZXN1bHQsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX0ZMQVRfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9tT21pdENsb25lKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgYmFzZVVuc2V0KHJlc3VsdCwgcGF0aHNbbGVuZ3RoXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tCeWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mXG4gICAgICogdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYG9iamVjdGAgdGhhdFxuICAgICAqIGBwcmVkaWNhdGVgIGRvZXNuJ3QgcmV0dXJuIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3b1xuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLm9taXRCeShvYmplY3QsIF8uaXNOdW1iZXIpO1xuICAgICAqIC8vID0+IHsgJ2InOiAnMicgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9taXRCeShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHBpY2tCeShvYmplY3QsIG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ucGljayhvYmplY3QsIFsnYScsICdjJ10pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIHZhciBwaWNrID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGljayhvYmplY3QsIHBhdGhzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBgb2JqZWN0YCBwcm9wZXJ0aWVzIGBwcmVkaWNhdGVgIHJldHVybnNcbiAgICAgKiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAodmFsdWUsIGtleSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ucGlja0J5KG9iamVjdCwgXy5pc051bWJlcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGlja0J5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgdmFyIHByb3BzID0gYXJyYXlNYXAoZ2V0QWxsS2V5c0luKG9iamVjdCksIGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIFtwcm9wXTtcbiAgICAgIH0pO1xuICAgICAgcHJlZGljYXRlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlKTtcbiAgICAgIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGUodmFsdWUsIHBhdGhbMF0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5nZXRgIGV4Y2VwdCB0aGF0IGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhXG4gICAgICogZnVuY3Rpb24gaXQncyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGl0cyBwYXJlbnQgb2JqZWN0IGFuZFxuICAgICAqIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byByZXNvbHZlLlxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYzEnOiAzLCAnYzInOiBfLmNvbnN0YW50KDQpIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMScpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMicpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMycsICdkZWZhdWx0Jyk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzMnLCBfLmNvbnN0YW50KCdkZWZhdWx0JykpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3VsdChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICAvLyBFbnN1cmUgdGhlIGxvb3AgaXMgZW50ZXJlZCB3aGVuIHBhdGggaXMgZW1wdHkuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICBvYmplY3QgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFt0b0tleShwYXRoW2luZGV4XSldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IGlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgYSBwb3J0aW9uIG9mIGBwYXRoYCBkb2Vzbid0IGV4aXN0LFxuICAgICAqIGl0J3MgY3JlYXRlZC4gQXJyYXlzIGFyZSBjcmVhdGVkIGZvciBtaXNzaW5nIGluZGV4IHByb3BlcnRpZXMgd2hpbGUgb2JqZWN0c1xuICAgICAqIGFyZSBjcmVhdGVkIGZvciBhbGwgb3RoZXIgbWlzc2luZyBwcm9wZXJ0aWVzLiBVc2UgYF8uc2V0V2l0aGAgdG8gY3VzdG9taXplXG4gICAgICogYHBhdGhgIGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5zZXQob2JqZWN0LCAnYVswXS5iLmMnLCA0KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uc2V0KG9iamVjdCwgWyd4JywgJzAnLCAneScsICd6J10sIDUpO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC54WzBdLnkueik7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc2V0YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgb2JqZWN0cyBvZiBgcGF0aGAuICBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIHBhdGggY3JlYXRpb24gaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAobnNWYWx1ZSwga2V5LCBuc09iamVjdCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge307XG4gICAgICpcbiAgICAgKiBfLnNldFdpdGgob2JqZWN0LCAnWzBdWzFdJywgJ2EnLCBPYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzAnOiB7ICcxJzogJ2EnIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFdpdGgob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZC12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGBcbiAgICAgKiB3aGljaCBjYW4gYmUgY29uc3VtZWQgYnkgYF8uZnJvbVBhaXJzYC4gSWYgYG9iamVjdGAgaXMgYSBtYXAgb3Igc2V0LCBpdHNcbiAgICAgKiBlbnRyaWVzIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBlbnRyaWVzXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udG9QYWlycyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMV0sIFsnYicsIDJdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciB0b1BhaXJzID0gY3JlYXRlVG9QYWlycyhrZXlzKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQtdmFsdWUgcGFpcnNcbiAgICAgKiBmb3IgYG9iamVjdGAgd2hpY2ggY2FuIGJlIGNvbnN1bWVkIGJ5IGBfLmZyb21QYWlyc2AuIElmIGBvYmplY3RgIGlzIGEgbWFwXG4gICAgICogb3Igc2V0LCBpdHMgZW50cmllcyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZW50cmllc0luXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udG9QYWlyc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxXSwgWydiJywgMl0sIFsnYycsIDNdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciB0b1BhaXJzSW4gPSBjcmVhdGVUb1BhaXJzKGtleXNJbik7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBgXy5yZWR1Y2VgOyB0aGlzIG1ldGhvZCB0cmFuc2Zvcm1zIGBvYmplY3RgIHRvIGEgbmV3XG4gICAgICogYGFjY3VtdWxhdG9yYCBvYmplY3Qgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIGVhY2ggb2YgaXRzIG93blxuICAgICAqIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgdGhydSBgaXRlcmF0ZWVgLCB3aXRoIGVhY2ggaW52b2NhdGlvblxuICAgICAqIHBvdGVudGlhbGx5IG11dGF0aW5nIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gSWYgYGFjY3VtdWxhdG9yYCBpcyBub3RcbiAgICAgKiBwcm92aWRlZCwgYSBuZXcgb2JqZWN0IHdpdGggdGhlIHNhbWUgYFtbUHJvdG90eXBlXV1gIHdpbGwgYmUgdXNlZC4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOiAoYWNjdW11bGF0b3IsIHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBjdXN0b20gYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyYW5zZm9ybShbMiwgMywgNF0sIGZ1bmN0aW9uKHJlc3VsdCwgbikge1xuICAgICAqICAgcmVzdWx0LnB1c2gobiAqPSBuKTtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgOV1cbiAgICAgKlxuICAgICAqIF8udHJhbnNmb3JtKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgICAgICBpc0Fyckxpa2UgPSBpc0FyciB8fCBpc0J1ZmZlcihvYmplY3QpIHx8IGlzVHlwZWRBcnJheShvYmplY3QpO1xuXG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KTtcbiAgICAgIGlmIChhY2N1bXVsYXRvciA9PSBudWxsKSB7XG4gICAgICAgIHZhciBDdG9yID0gb2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgaWYgKGlzQXJyTGlrZSkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNBcnIgPyBuZXcgQ3RvciA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGlzRnVuY3Rpb24oQ3RvcikgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKSA6IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIChpc0Fyckxpa2UgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgcHJvcGVydHkgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gdW5zZXQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogNyB9IH1dIH07XG4gICAgICogXy51bnNldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzoge30gfV0gfTtcbiAgICAgKlxuICAgICAqIF8udW5zZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiB7fSB9XSB9O1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdHJ1ZSA6IGJhc2VVbnNldChvYmplY3QsIHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc2V0YCBleGNlcHQgdGhhdCBhY2NlcHRzIGB1cGRhdGVyYCB0byBwcm9kdWNlIHRoZVxuICAgICAqIHZhbHVlIHRvIHNldC4gVXNlIGBfLnVwZGF0ZVdpdGhgIHRvIGN1c3RvbWl6ZSBgcGF0aGAgY3JlYXRpb24uIFRoZSBgdXBkYXRlcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8udXBkYXRlKG9iamVjdCwgJ2FbMF0uYi5jJywgZnVuY3Rpb24obikgeyByZXR1cm4gbiAqIG47IH0pO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gICAgICogLy8gPT4gOVxuICAgICAqXG4gICAgICogXy51cGRhdGUob2JqZWN0LCAneFswXS55LnonLCBmdW5jdGlvbihuKSB7IHJldHVybiBuID8gbiArIDEgOiAwOyB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGUob2JqZWN0LCBwYXRoLCB1cGRhdGVyKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgY2FzdEZ1bmN0aW9uKHVwZGF0ZXIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVwZGF0ZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG9iamVjdHMgb2YgYHBhdGhgLiAgSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBwYXRoIGNyZWF0aW9uIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKG5zVmFsdWUsIGtleSwgbnNPYmplY3QpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7fTtcbiAgICAgKlxuICAgICAqIF8udXBkYXRlV2l0aChvYmplY3QsICdbMF1bMV0nLCBfLmNvbnN0YW50KCdhJyksIE9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMCc6IHsgJzEnOiAnYScgfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlV2l0aChvYmplY3QsIHBhdGgsIHVwZGF0ZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCBjYXN0RnVuY3Rpb24odXBkYXRlciksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKCdoaScpO1xuICAgICAqIC8vID0+IFsnaCcsICdpJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5XG4gICAgICogdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy52YWx1ZXNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDbGFtcHMgYG51bWJlcmAgd2l0aGluIHRoZSBpbmNsdXNpdmUgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNsYW1wKC0xMCwgLTUsIDUpO1xuICAgICAqIC8vID0+IC01XG4gICAgICpcbiAgICAgKiBfLmNsYW1wKDEwLCAtNSwgNSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gICAgICBpZiAodXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cHBlciA9IGxvd2VyO1xuICAgICAgICBsb3dlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVwcGVyID0gdG9OdW1iZXIodXBwZXIpO1xuICAgICAgICB1cHBlciA9IHVwcGVyID09PSB1cHBlciA/IHVwcGVyIDogMDtcbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvd2VyID0gdG9OdW1iZXIobG93ZXIpO1xuICAgICAgICBsb3dlciA9IGxvd2VyID09PSBsb3dlciA/IGxvd2VyIDogMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlQ2xhbXAodG9OdW1iZXIobnVtYmVyKSwgbG93ZXIsIHVwcGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYG5gIGlzIGJldHdlZW4gYHN0YXJ0YCBhbmQgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gSWZcbiAgICAgKiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLCBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gICAgICogSWYgYHN0YXJ0YCBpcyBncmVhdGVyIHRoYW4gYGVuZGAgdGhlIHBhcmFtcyBhcmUgc3dhcHBlZCB0byBzdXBwb3J0XG4gICAgICogbmVnYXRpdmUgcmFuZ2VzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMy4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG51bWJlcmAgaXMgaW4gdGhlIHJhbmdlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLnJhbmdlLCBfLnJhbmdlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDMsIDIsIDQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg0LCA4KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNCwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgyLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDEuMiwgMik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDUuMiwgNCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgtMywgLTIsIC02KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHN0YXJ0ID0gdG9GaW5pdGUoc3RhcnQpO1xuICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgfVxuICAgICAgbnVtYmVyID0gdG9OdW1iZXIobnVtYmVyKTtcbiAgICAgIHJldHVybiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIHRoZSBpbmNsdXNpdmUgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMuXG4gICAgICogSWYgb25seSBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQgYSBudW1iZXIgYmV0d2VlbiBgMGAgYW5kIHRoZSBnaXZlbiBudW1iZXJcbiAgICAgKiBpcyByZXR1cm5lZC4gSWYgYGZsb2F0aW5nYCBpcyBgdHJ1ZWAsIG9yIGVpdGhlciBgbG93ZXJgIG9yIGB1cHBlcmAgYXJlXG4gICAgICogZmxvYXRzLCBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBpcyByZXR1cm5lZCBpbnN0ZWFkIG9mIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSmF2YVNjcmlwdCBmb2xsb3dzIHRoZSBJRUVFLTc1NCBzdGFuZGFyZCBmb3IgcmVzb2x2aW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgdmFsdWVzIHdoaWNoIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjcuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyPTBdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3VwcGVyPTFdIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmbG9hdGluZ10gU3BlY2lmeSByZXR1cm5pbmcgYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMCwgNSk7XG4gICAgICogLy8gPT4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUpO1xuICAgICAqIC8vID0+IGFsc28gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUsIHRydWUpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMS4yLCA1LjIpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMS4yIGFuZCA1LjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kb20obG93ZXIsIHVwcGVyLCBmbG9hdGluZykge1xuICAgICAgaWYgKGZsb2F0aW5nICYmIHR5cGVvZiBmbG9hdGluZyAhPSAnYm9vbGVhbicgJiYgaXNJdGVyYXRlZUNhbGwobG93ZXIsIHVwcGVyLCBmbG9hdGluZykpIHtcbiAgICAgICAgdXBwZXIgPSBmbG9hdGluZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdXBwZXIgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSB1cHBlcjtcbiAgICAgICAgICB1cHBlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbG93ZXIgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSBsb3dlcjtcbiAgICAgICAgICBsb3dlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvd2VyID09PSB1bmRlZmluZWQgJiYgdXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb3dlciA9IDA7XG4gICAgICAgIHVwcGVyID0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsb3dlciA9IHRvRmluaXRlKGxvd2VyKTtcbiAgICAgICAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB1cHBlciA9IGxvd2VyO1xuICAgICAgICAgIGxvd2VyID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cHBlciA9IHRvRmluaXRlKHVwcGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvd2VyID4gdXBwZXIpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBsb3dlcjtcbiAgICAgICAgbG93ZXIgPSB1cHBlcjtcbiAgICAgICAgdXBwZXIgPSB0ZW1wO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nIHx8IGxvd2VyICUgMSB8fCB1cHBlciAlIDEpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBuYXRpdmVSYW5kb20oKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1pbihsb3dlciArIChyYW5kICogKHVwcGVyIC0gbG93ZXIgKyBmcmVlUGFyc2VGbG9hdCgnMWUtJyArICgocmFuZCArICcnKS5sZW5ndGggLSAxKSkpKSwgdXBwZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbY2FtZWwgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FtZWxDYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhbWVsIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICovXG4gICAgdmFyIGNhbWVsQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyBjYXBpdGFsaXplKHdvcmQpIDogd29yZCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UgYW5kIHRoZSByZW1haW5pbmdcbiAgICAgKiB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNhcGl0YWxpemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FwaXRhbGl6ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhcGl0YWxpemUoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICAgICAgcmV0dXJuIHVwcGVyRmlyc3QodG9TdHJpbmcoc3RyaW5nKS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWJ1cnJzIGBzdHJpbmdgIGJ5IGNvbnZlcnRpbmdcbiAgICAgKiBbTGF0aW4tMSBTdXBwbGVtZW50XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbi0xX1N1cHBsZW1lbnRfKFVuaWNvZGVfYmxvY2spI0NoYXJhY3Rlcl90YWJsZSlcbiAgICAgKiBhbmQgW0xhdGluIEV4dGVuZGVkLUFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluX0V4dGVuZGVkLUEpXG4gICAgICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzIGFuZCByZW1vdmluZ1xuICAgICAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWJ1cnIoJ2TDqWrDoCB2dScpO1xuICAgICAqIC8vID0+ICdkZWphIHZ1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYnVycihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4sIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBlbmRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249c3RyaW5nLmxlbmd0aF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCB1cCB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIGB0YXJnZXRgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InLCAyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgdGFyZ2V0ID0gYmFzZVRvU3RyaW5nKHRhcmdldCk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gbGVuZ3RoXG4gICAgICAgIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIGxlbmd0aCk7XG5cbiAgICAgIHZhciBlbmQgPSBwb3NpdGlvbjtcbiAgICAgIHBvc2l0aW9uIC09IHRhcmdldC5sZW5ndGg7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPj0gMCAmJiBzdHJpbmcuc2xpY2UocG9zaXRpb24sIGVuZCkgPT0gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIGFuZCBcIidcIiBpbiBgc3RyaW5nYCB0byB0aGVpclxuICAgICAqIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbFxuICAgICAqIGNoYXJhY3RlcnMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICAgICAqIFwiPlwiIGFuZCBcIi9cIiBkb24ndCBuZWVkIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nXG4gICAgICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuIFNlZVxuICAgICAqIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAgICAgKiAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIikgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXNcbiAgICAgKiBbcXVvdGUgYXR0cmlidXRlIHZhbHVlc10oaHR0cDovL3dvbmtvLmNvbS9wb3N0L2h0bWwtZXNjYXBpbmcpIHRvIHJlZHVjZVxuICAgICAqIFhTUyB2ZWN0b3JzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGVzIHRoZSBgUmVnRXhwYCBzcGVjaWFsIGNoYXJhY3RlcnMgXCJeXCIsIFwiJFwiLCBcIlxcXCIsIFwiLlwiLCBcIipcIiwgXCIrXCIsXG4gICAgICogXCI/XCIsIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXVwiLCBcIntcIiwgXCJ9XCIsIGFuZCBcInxcIiBpbiBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlUmVnRXhwKCdbbG9kYXNoXShodHRwczovL2xvZGFzaC5jb20vKScpO1xuICAgICAqIC8vID0+ICdcXFtsb2Rhc2hcXF1cXChodHRwczovL2xvZGFzaFxcLmNvbS9cXCknXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzUmVnRXhwQ2hhci50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBba2ViYWIgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3BlY2lhbF9jYXNlX3N0eWxlcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBrZWJhYiBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKi9cbiAgICB2YXIga2ViYWJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJy0nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIHNwYWNlIHNlcGFyYXRlZCB3b3JkcywgdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGxvd2VyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJy0tRm9vLUJhci0tJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKi9cbiAgICB2YXIgbG93ZXJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sb3dlckZpcnN0KCdGcmVkJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiBfLmxvd2VyRmlyc3QoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnZlJFRCdcbiAgICAgKi9cbiAgICB2YXIgbG93ZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9Mb3dlckNhc2UnKTtcblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGVzIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLlxuICAgICAqIFBhZGRpbmcgY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgY2FuJ3QgYmUgZXZlbmx5IGRpdmlkZWQgYnkgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDgpO1xuICAgICAqIC8vID0+ICcgIGFiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1hYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgaWYgKCFsZW5ndGggfHwgc3RyTGVuZ3RoID49IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG1pZCA9IChsZW5ndGggLSBzdHJMZW5ndGgpIC8gMjtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGNyZWF0ZVBhZGRpbmcobmF0aXZlRmxvb3IobWlkKSwgY2hhcnMpICtcbiAgICAgICAgc3RyaW5nICtcbiAgICAgICAgY3JlYXRlUGFkZGluZyhuYXRpdmVDZWlsKG1pZCksIGNoYXJzKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSByaWdodCBzaWRlIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXG4gICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnYWJjICAgJ1xuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWRFbmQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgcmV0dXJuIChsZW5ndGggJiYgc3RyTGVuZ3RoIDwgbGVuZ3RoKVxuICAgICAgICA/IChzdHJpbmcgKyBjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IHNpZGUgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJyAgIGFiYydcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdfLV9hYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZFN0YXJ0KHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIHJldHVybiAobGVuZ3RoICYmIHN0ckxlbmd0aCA8IGxlbmd0aClcbiAgICAgICAgPyAoY3JlYXRlUGFkZGluZyhsZW5ndGggLSBzdHJMZW5ndGgsIGNoYXJzKSArIHN0cmluZylcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gaW50ZWdlciBvZiB0aGUgc3BlY2lmaWVkIHJhZGl4LiBJZiBgcmFkaXhgIGlzXG4gICAgICogYHVuZGVmaW5lZGAgb3IgYDBgLCBhIGByYWRpeGAgb2YgYDEwYCBpcyB1c2VkIHVubGVzcyBgdmFsdWVgIGlzIGFcbiAgICAgKiBoZXhhZGVjaW1hbCwgaW4gd2hpY2ggY2FzZSBhIGByYWRpeGAgb2YgYDE2YCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGFsaWducyB3aXRoIHRoZVxuICAgICAqIFtFUzUgaW1wbGVtZW50YXRpb25dKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi4yKSBvZiBgcGFyc2VJbnRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXg9MTBdIFRoZSByYWRpeCB0byBpbnRlcnByZXQgYHZhbHVlYCBieS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnNlSW50KCcwOCcpO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICcwOCcsICcxMCddLCBfLnBhcnNlSW50KTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQoc3RyaW5nLCByYWRpeCwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCB8fCByYWRpeCA9PSBudWxsKSB7XG4gICAgICAgIHJhZGl4ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocmFkaXgpIHtcbiAgICAgICAgcmFkaXggPSArcmFkaXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlUGFyc2VJbnQodG9TdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJyksIHJhZGl4IHx8IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGVhdHMgdGhlIGdpdmVuIHN0cmluZyBgbmAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnKicsIDMpO1xuICAgICAqIC8vID0+ICcqKionXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMik7XG4gICAgICogLy8gPT4gJ2FiY2FiYydcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCdhYmMnLCAwKTtcbiAgICAgKiAvLyA9PiAnJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBuLCBndWFyZCkgOiBuID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmVwZWF0KHRvU3RyaW5nKHN0cmluZyksIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIG1hdGNoZXMgZm9yIGBwYXR0ZXJuYCBpbiBgc3RyaW5nYCB3aXRoIGByZXBsYWNlbWVudGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFN0cmluZyNyZXBsYWNlYF0oaHR0cHM6Ly9tZG4uaW8vU3RyaW5nL3JlcGxhY2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IHBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gcmVwbGFjZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gcmVwbGFjZW1lbnQgVGhlIG1hdGNoIHJlcGxhY2VtZW50LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXBsYWNlKCdIaSBGcmVkJywgJ0ZyZWQnLCAnQmFybmV5Jyk7XG4gICAgICogLy8gPT4gJ0hpIEJhcm5leSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYWNlKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoYXJnc1swXSk7XG5cbiAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA8IDMgPyBzdHJpbmcgOiBzdHJpbmcucmVwbGFjZShhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtzbmFrZSBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbmFrZV9jYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNuYWtlIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCctLUZPTy1CQVItLScpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqL1xuICAgIHZhciBzbmFrZUNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnXycgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgYnkgYHNlcGFyYXRvcmAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFN0cmluZyNzcGxpdGBdKGh0dHBzOi8vbWRuLmlvL1N0cmluZy9zcGxpdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gc3BsaXQuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBzZXBhcmF0b3IgVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHNwbGl0IGJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIFRoZSBsZW5ndGggdG8gdHJ1bmNhdGUgcmVzdWx0cyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHN0cmluZyBzZWdtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zcGxpdCgnYS1iLWMnLCAnLScsIDIpO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcGxpdChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIGlmIChsaW1pdCAmJiB0eXBlb2YgbGltaXQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KSkge1xuICAgICAgICBzZXBhcmF0b3IgPSBsaW1pdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGxpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9BUlJBWV9MRU5HVEggOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmICghbGltaXQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKFxuICAgICAgICAgICAgdHlwZW9mIHNlcGFyYXRvciA9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgKHNlcGFyYXRvciAhPSBudWxsICYmICFpc1JlZ0V4cChzZXBhcmF0b3IpKVxuICAgICAgICAgICkpIHtcbiAgICAgICAgc2VwYXJhdG9yID0gYmFzZVRvU3RyaW5nKHNlcGFyYXRvcik7XG4gICAgICAgIGlmICghc2VwYXJhdG9yICYmIGhhc1VuaWNvZGUoc3RyaW5nKSkge1xuICAgICAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShzdHJpbmcpLCAwLCBsaW1pdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBbc3RhcnQgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3R5bGlzdGljX29yX3NwZWNpYWxpc2VkX3VzYWdlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0YXJ0IGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKi9cbiAgICB2YXIgc3RhcnRDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgdXBwZXJGaXJzdCh3b3JkKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj0wXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIGB0YXJnZXRgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09IG51bGxcbiAgICAgICAgPyAwXG4gICAgICAgIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIHN0cmluZy5sZW5ndGgpO1xuXG4gICAgICB0YXJnZXQgPSBiYXNlVG9TdHJpbmcodGFyZ2V0KTtcbiAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgdGFyZ2V0Lmxlbmd0aCkgPT0gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbiB0aGF0IGNhbiBpbnRlcnBvbGF0ZSBkYXRhIHByb3BlcnRpZXNcbiAgICAgKiBpbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVycywgSFRNTC1lc2NhcGUgaW50ZXJwb2xhdGVkIGRhdGEgcHJvcGVydGllcyBpblxuICAgICAqIFwiZXNjYXBlXCIgZGVsaW1pdGVycywgYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdCBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy4gRGF0YVxuICAgICAqIHByb3BlcnRpZXMgbWF5IGJlIGFjY2Vzc2VkIGFzIGZyZWUgdmFyaWFibGVzIGluIHRoZSB0ZW1wbGF0ZS4gSWYgYSBzZXR0aW5nXG4gICAgICogb2JqZWN0IGlzIGdpdmVuLCBpdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYF8udGVtcGxhdGVTZXR0aW5nc2AgdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEluIHRoZSBkZXZlbG9wbWVudCBidWlsZCBgXy50ZW1wbGF0ZWAgdXRpbGl6ZXNcbiAgICAgKiBbc291cmNlVVJMc10oaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybClcbiAgICAgKiBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHByZWNvbXBpbGluZyB0ZW1wbGF0ZXMgc2VlXG4gICAgICogW2xvZGFzaCdzIGN1c3RvbSBidWlsZHMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9sb2Rhc2guY29tL2N1c3RvbS1idWlsZHMpLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ2hyb21lIGV4dGVuc2lvbiBzYW5kYm94ZXMgc2VlXG4gICAgICogW0Nocm9tZSdzIGV4dGVuc2lvbnMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHRlbXBsYXRlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlPV8udGVtcGxhdGVTZXR0aW5ncy5lc2NhcGVdXG4gICAgICogIFRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5ldmFsdWF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXZhbHVhdGVdXG4gICAgICogIFRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbXBvcnRzPV8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXVxuICAgICAqICBBbiBvYmplY3QgdG8gaW1wb3J0IGludG8gdGhlIHRlbXBsYXRlIGFzIGZyZWUgdmFyaWFibGVzLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5pbnRlcnBvbGF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGVdXG4gICAgICogIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVUkw9J2xvZGFzaC50ZW1wbGF0ZVNvdXJjZXNbbl0nXVxuICAgICAqICBUaGUgc291cmNlVVJMIG9mIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudmFyaWFibGU9J29iaiddXG4gICAgICogIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyIHRvIGNyZWF0ZSBhIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICAgICAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZXhlY3V0ZSBKYXZhU2NyaXB0IGFuZCBnZW5lcmF0ZSBIVE1MLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIHVzZXIpOyAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIEVTIHRlbXBsYXRlIGxpdGVyYWwgZGVsaW1pdGVyIGFzIGFuIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogLy8gRGlzYWJsZSBzdXBwb3J0IGJ5IHJlcGxhY2luZyB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyAkeyB1c2VyIH0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gcGViYmxlcyEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0LlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlPSBcIlxcXFw8JS0gdmFsdWUgJVxcXFw+XCIgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICdpZ25vcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBgalF1ZXJ5YCBhcyBganFgLlxuICAgICAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSh0ZXh0LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJywgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICAgICAqIGNvbXBpbGVkKGRhdGEpO1xuICAgICAqIC8vID0+IEZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3IuXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGB2YXJpYWJsZWAgb3B0aW9uIHRvIGVuc3VyZSBhIHdpdGgtc3RhdGVtZW50IGlzbid0IHVzZWQgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLnVzZXIgJT4hJywgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XG4gICAgICogY29tcGlsZWQuc291cmNlO1xuICAgICAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgKiAvLyAgIHZhciBfX3QsIF9fcCA9ICcnO1xuICAgICAqIC8vICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEudXNlciApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuICAgICAqIC8vICAgcmV0dXJuIF9fcDtcbiAgICAgKiAvLyB9XG4gICAgICpcbiAgICAgKiAvLyBVc2UgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnMuXG4gICAgICogXy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlID0gL3t7KFtcXHNcXFNdKz8pfX0vZztcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyB7eyB1c2VyIH19IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnbXVzdGFjaGUnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBtdXN0YWNoZSEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAgICAgKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIHN0YWNrIHRyYWNlcy5cbiAgICAgKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnanN0LmpzJyksICdcXFxuICAgICAqICAgdmFyIEpTVCA9IHtcXFxuICAgICAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICAgICAqICAgfTtcXFxuICAgICAqICcpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpIHtcbiAgICAgIC8vIEJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIChodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nLylcbiAgICAgIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxuICAgICAgdmFyIHNldHRpbmdzID0gbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3M7XG5cbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSkge1xuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIG9wdGlvbnMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMsIHNldHRpbmdzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKTtcblxuICAgICAgdmFyIGltcG9ydHMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMuaW1wb3J0cywgc2V0dGluZ3MuaW1wb3J0cywgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiksXG4gICAgICAgICAgaW1wb3J0c0tleXMgPSBrZXlzKGltcG9ydHMpLFxuICAgICAgICAgIGltcG9ydHNWYWx1ZXMgPSBiYXNlVmFsdWVzKGltcG9ydHMsIGltcG9ydHNLZXlzKTtcblxuICAgICAgdmFyIGlzRXNjYXBpbmcsXG4gICAgICAgICAgaXNFdmFsdWF0aW5nLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAgICAgLy8gQ29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyLlxuICAgICAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAgICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcbiAgICAgICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgICAgICwgJ2cnKTtcblxuICAgICAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAgLy8gVGhlIHNvdXJjZVVSTCBnZXRzIGluamVjdGVkIGludG8gdGhlIHNvdXJjZSB0aGF0J3MgZXZhbC1lZCwgc28gYmUgY2FyZWZ1bFxuICAgICAgLy8gdG8gbm9ybWFsaXplIGFsbCBraW5kcyBvZiB3aGl0ZXNwYWNlLCBzbyBlLmcuIG5ld2xpbmVzIChhbmQgdW5pY29kZSB2ZXJzaW9ucyBvZiBpdCkgY2FuJ3Qgc25lYWsgaW5cbiAgICAgIC8vIGFuZCBlc2NhcGUgdGhlIGNvbW1lbnQsIHRodXMgaW5qZWN0aW5nIGNvZGUgdGhhdCBnZXRzIGV2YWxlZC5cbiAgICAgIHZhciBzb3VyY2VVUkwgPSAnLy8jIHNvdXJjZVVSTD0nICtcbiAgICAgICAgKGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3NvdXJjZVVSTCcpXG4gICAgICAgICAgPyAob3B0aW9ucy5zb3VyY2VVUkwgKyAnJykucmVwbGFjZSgvXFxzL2csICcgJylcbiAgICAgICAgICA6ICgnbG9kYXNoLnRlbXBsYXRlU291cmNlc1snICsgKCsrdGVtcGxhdGVDb3VudGVyKSArICddJylcbiAgICAgICAgKSArICdcXG4nO1xuXG4gICAgICBzdHJpbmcucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAgICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4ndCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgICAgIHNvdXJjZSArPSBzdHJpbmcuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShyZVVuZXNjYXBlZFN0cmluZywgZXNjYXBlU3RyaW5nQ2hhcik7XG5cbiAgICAgICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXG4gICAgICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2YWx1YXRlVmFsdWUpIHtcbiAgICAgICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICAgIC8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgbmVlZHMgYG1hdGNoYCByZXR1cm5lZCBpblxuICAgICAgICAvLyBvcmRlciB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGBvZmZzZXRgIHZhbHVlLlxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTtcblxuICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgICAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAgICAgLy8gY29kZSB0byBhZGQgdGhlIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluLlxuICAgICAgdmFyIHZhcmlhYmxlID0gaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAndmFyaWFibGUnKSAmJiBvcHRpb25zLnZhcmlhYmxlO1xuICAgICAgaWYgKCF2YXJpYWJsZSkge1xuICAgICAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgICAgIH1cbiAgICAgIC8vIFRocm93IGFuIGVycm9yIGlmIGEgZm9yYmlkZGVuIGNoYXJhY3RlciB3YXMgZm91bmQgaW4gYHZhcmlhYmxlYCwgdG8gcHJldmVudFxuICAgICAgLy8gcG90ZW50aWFsIGNvbW1hbmQgaW5qZWN0aW9uIGF0dGFja3MuXG4gICAgICBlbHNlIGlmIChyZUZvcmJpZGRlbklkZW50aWZpZXJDaGFycy50ZXN0KHZhcmlhYmxlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9URU1QTF9WQVJfRVJST1JfVEVYVCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5ncy5cbiAgICAgIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsICckMTsnKTtcblxuICAgICAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cbiAgICAgIHNvdXJjZSA9ICdmdW5jdGlvbignICsgKHZhcmlhYmxlIHx8ICdvYmonKSArICcpIHtcXG4nICtcbiAgICAgICAgKHZhcmlhYmxlXG4gICAgICAgICAgPyAnJ1xuICAgICAgICAgIDogJ29iaiB8fCAob2JqID0ge30pO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIFwidmFyIF9fdCwgX19wID0gJydcIiArXG4gICAgICAgIChpc0VzY2FwaW5nXG4gICAgICAgICAgID8gJywgX19lID0gXy5lc2NhcGUnXG4gICAgICAgICAgIDogJydcbiAgICAgICAgKSArXG4gICAgICAgIChpc0V2YWx1YXRpbmdcbiAgICAgICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgICAgIDogJztcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBzb3VyY2UgK1xuICAgICAgICAncmV0dXJuIF9fcFxcbn0nO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKGltcG9ydHNLZXlzLCBzb3VyY2VVUkwgKyAncmV0dXJuICcgKyBzb3VyY2UpXG4gICAgICAgICAgLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXG4gICAgICAvLyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgYXMgYSBjb252ZW5pZW5jZSBmb3IgaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzLlxuICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIGlmIChpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gbG93ZXIgY2FzZSBqdXN0IGxpa2VcbiAgICAgKiBbU3RyaW5nI3RvTG93ZXJDYXNlXShodHRwczovL21kbi5pby90b0xvd2VyQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBsb3dlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9Mb3dlcignLS1Gb28tQmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnLS1mb28tYmFyLS0nXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb29iYXInXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ19fZm9vX2Jhcl9fJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTG93ZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gdXBwZXIgY2FzZSBqdXN0IGxpa2VcbiAgICAgKiBbU3RyaW5nI3RvVXBwZXJDYXNlXShodHRwczovL21kbi5pby90b1VwcGVyQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1cHBlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9VcHBlcignLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnLS1GT08tQkFSLS0nXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGT09CQVInXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ19fRk9PX0JBUl9fJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvVXBwZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSkudG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW0oJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy50cmltKCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy5tYXAoWycgIGZvbyAgJywgJyAgYmFyICAnXSwgXy50cmltKTtcbiAgICAgKiAvLyA9PiBbJ2ZvbycsICdiYXInXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW0oc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gYmFzZVRyaW0oc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgY2hyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoY2hhcnMpLFxuICAgICAgICAgIHN0YXJ0ID0gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpLFxuICAgICAgICAgIGVuZCA9IGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykgKyAxO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIHN0YXJ0LCBlbmQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbUVuZCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICcgIGFiYydcbiAgICAgKlxuICAgICAqIF8udHJpbUVuZCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJy1fLWFiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltRW5kKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5zbGljZSgwLCB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSArIDEpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBlbmQgPSBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIHN0cmluZ1RvQXJyYXkoY2hhcnMpKSArIDE7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMCwgZW5kKS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbVN0YXJ0KCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYyAgJ1xuICAgICAqXG4gICAgICogXy50cmltU3RhcnQoJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmMtXy0nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbVN0YXJ0KHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIHN0YXJ0ID0gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIHN0cmluZ1RvQXJyYXkoY2hhcnMpKTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCBzdGFydCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGVzIGBzdHJpbmdgIGlmIGl0J3MgbG9uZ2VyIHRoYW4gdGhlIGdpdmVuIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKiBUaGUgbGFzdCBjaGFyYWN0ZXJzIG9mIHRoZSB0cnVuY2F0ZWQgc3RyaW5nIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBvbWlzc2lvblxuICAgICAqIHN0cmluZyB3aGljaCBkZWZhdWx0cyB0byBcIi4uLlwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRydW5jYXRlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sZW5ndGg9MzBdIFRoZSBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm9taXNzaW9uPScuLi4nXSBUaGUgc3RyaW5nIHRvIGluZGljYXRlIHRleHQgaXMgb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtvcHRpb25zLnNlcGFyYXRvcl0gVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHRydW5jYXRlIHRvLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRydW5jYXRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nKTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAnICdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLC4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogLyw/ICsvXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZS4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnb21pc3Npb24nOiAnIFsuLi5dJ1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWcgWy4uLl0nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGUoc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gREVGQVVMVF9UUlVOQ19MRU5HVEgsXG4gICAgICAgICAgb21pc3Npb24gPSBERUZBVUxUX1RSVU5DX09NSVNTSU9OO1xuXG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9ICdzZXBhcmF0b3InIGluIG9wdGlvbnMgPyBvcHRpb25zLnNlcGFyYXRvciA6IHNlcGFyYXRvcjtcbiAgICAgICAgbGVuZ3RoID0gJ2xlbmd0aCcgaW4gb3B0aW9ucyA/IHRvSW50ZWdlcihvcHRpb25zLmxlbmd0aCkgOiBsZW5ndGg7XG4gICAgICAgIG9taXNzaW9uID0gJ29taXNzaW9uJyBpbiBvcHRpb25zID8gYmFzZVRvU3RyaW5nKG9wdGlvbnMub21pc3Npb24pIDogb21pc3Npb247XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIGlmIChoYXNVbmljb2RlKHN0cmluZykpIHtcbiAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyk7XG4gICAgICAgIHN0ckxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCA+PSBzdHJMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBlbmQgPSBsZW5ndGggLSBzdHJpbmdTaXplKG9taXNzaW9uKTtcbiAgICAgIGlmIChlbmQgPCAxKSB7XG4gICAgICAgIHJldHVybiBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzdHJTeW1ib2xzXG4gICAgICAgID8gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDAsIGVuZCkuam9pbignJylcbiAgICAgICAgOiBzdHJpbmcuc2xpY2UoMCwgZW5kKTtcblxuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJTeW1ib2xzKSB7XG4gICAgICAgIGVuZCArPSAocmVzdWx0Lmxlbmd0aCAtIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNSZWdFeHAoc2VwYXJhdG9yKSkge1xuICAgICAgICBpZiAoc3RyaW5nLnNsaWNlKGVuZCkuc2VhcmNoKHNlcGFyYXRvcikpIHtcbiAgICAgICAgICB2YXIgbWF0Y2gsXG4gICAgICAgICAgICAgIHN1YnN0cmluZyA9IHJlc3VsdDtcblxuICAgICAgICAgIGlmICghc2VwYXJhdG9yLmdsb2JhbCkge1xuICAgICAgICAgICAgc2VwYXJhdG9yID0gUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIHRvU3RyaW5nKHJlRmxhZ3MuZXhlYyhzZXBhcmF0b3IpKSArICdnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdWJzdHJpbmcpKSkge1xuICAgICAgICAgICAgdmFyIG5ld0VuZCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgbmV3RW5kID09PSB1bmRlZmluZWQgPyBlbmQgOiBuZXdFbmQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0cmluZy5pbmRleE9mKGJhc2VUb1N0cmluZyhzZXBhcmF0b3IpLCBlbmQpICE9IGVuZCkge1xuICAgICAgICB2YXIgaW5kZXggPSByZXN1bHQubGFzdEluZGV4T2Yoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8uZXNjYXBlYDsgdGhpcyBtZXRob2QgY29udmVydHMgdGhlIEhUTUwgZW50aXRpZXNcbiAgICAgKiBgJmFtcDtgLCBgJmx0O2AsIGAmZ3Q7YCwgYCZxdW90O2AsIGFuZCBgJiMzOTtgIGluIGBzdHJpbmdgIHRvXG4gICAgICogdGhlaXIgY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIEhUTUwgZW50aXRpZXMgYXJlIHVuZXNjYXBlZC4gVG8gdW5lc2NhcGUgYWRkaXRpb25hbFxuICAgICAqIEhUTUwgZW50aXRpZXMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNi4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc0VzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZWRIdG1sLCB1bmVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgc3BhY2Ugc2VwYXJhdGVkIHdvcmRzLCB0byB1cHBlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdXBwZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnLS1mb28tYmFyJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnX19mb29fYmFyX18nKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKi9cbiAgICB2YXIgdXBwZXJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgd29yZC50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51cHBlckZpcnN0KCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICpcbiAgICAgKiBfLnVwcGVyRmlyc3QoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnRlJFRCdcbiAgICAgKi9cbiAgICB2YXIgdXBwZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9VcHBlckNhc2UnKTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW3BhdHRlcm5dIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdvcmRzLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnLCAvW14sIF0rL2cpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAnJicsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3b3JkcyhzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcGF0dGVybiA9IGd1YXJkID8gdW5kZWZpbmVkIDogcGF0dGVybjtcblxuICAgICAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSA/IHVuaWNvZGVXb3JkcyhzdHJpbmcpIDogYXNjaWlXb3JkcyhzdHJpbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuKSB8fCBbXTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxuICAgICAqIG9iamVjdC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGF0dGVtcHQuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBmdW5jYCByZXN1bHQgb3IgZXJyb3Igb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCB0aHJvd2luZyBlcnJvcnMgZm9yIGludmFsaWQgc2VsZWN0b3JzLlxuICAgICAqIHZhciBlbGVtZW50cyA9IF8uYXR0ZW1wdChmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAqICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAqIH0sICc+Xz4nKTtcbiAgICAgKlxuICAgICAqIGlmIChfLmlzRXJyb3IoZWxlbWVudHMpKSB7XG4gICAgICogICBlbGVtZW50cyA9IFtdO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICB2YXIgYXR0ZW1wdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gaXNFcnJvcihlKSA/IGUgOiBuZXcgRXJyb3IoZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBtZXRob2RzIG9mIGFuIG9iamVjdCB0byB0aGUgb2JqZWN0IGl0c2VsZiwgb3ZlcndyaXRpbmcgdGhlIGV4aXN0aW5nXG4gICAgICogbWV0aG9kLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJpbmQgYW5kIGFzc2lnbiB0aGUgYm91bmQgbWV0aG9kcyB0by5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBtZXRob2ROYW1lcyBUaGUgb2JqZWN0IG1ldGhvZCBuYW1lcyB0byBiaW5kLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ2NsaWNrJzogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdjbGlja2VkICcgKyB0aGlzLmxhYmVsKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5iaW5kQWxsKHZpZXcsIFsnY2xpY2snXSk7XG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHZpZXcuY2xpY2spO1xuICAgICAqIC8vID0+IExvZ3MgJ2NsaWNrZWQgZG9jcycgd2hlbiBjbGlja2VkLlxuICAgICAqL1xuICAgIHZhciBiaW5kQWxsID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBtZXRob2ROYW1lcykge1xuICAgICAgYXJyYXlFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAga2V5ID0gdG9LZXkoa2V5KTtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBiaW5kKG9iamVjdFtrZXldLCBvYmplY3QpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGl0ZXJhdGVzIG92ZXIgYHBhaXJzYCBhbmQgaW52b2tlcyB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAqIGZ1bmN0aW9uIG9mIHRoZSBmaXJzdCBwcmVkaWNhdGUgdG8gcmV0dXJuIHRydXRoeS4gVGhlIHByZWRpY2F0ZS1mdW5jdGlvblxuICAgICAqIHBhaXJzIGFyZSBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWRcbiAgICAgKiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMgVGhlIHByZWRpY2F0ZS1mdW5jdGlvbiBwYWlycy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5jb25kKFtcbiAgICAgKiAgIFtfLm1hdGNoZXMoeyAnYSc6IDEgfSksICAgICAgICAgICBfLmNvbnN0YW50KCdtYXRjaGVzIEEnKV0sXG4gICAgICogICBbXy5jb25mb3Jtcyh7ICdiJzogXy5pc051bWJlciB9KSwgXy5jb25zdGFudCgnbWF0Y2hlcyBCJyldLFxuICAgICAqICAgW18uc3R1YlRydWUsICAgICAgICAgICAgICAgICAgICAgIF8uY29uc3RhbnQoJ25vIG1hdGNoJyldXG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gJ21hdGNoZXMgQSdcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6IDAsICdiJzogMSB9KTtcbiAgICAgKiAvLyA9PiAnbWF0Y2hlcyBCJ1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogJzEnLCAnYic6ICcyJyB9KTtcbiAgICAgKiAvLyA9PiAnbm8gbWF0Y2gnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZChwYWlycykge1xuICAgICAgdmFyIGxlbmd0aCA9IHBhaXJzID09IG51bGwgPyAwIDogcGFpcnMubGVuZ3RoLFxuICAgICAgICAgIHRvSXRlcmF0ZWUgPSBnZXRJdGVyYXRlZSgpO1xuXG4gICAgICBwYWlycyA9ICFsZW5ndGggPyBbXSA6IGFycmF5TWFwKHBhaXJzLCBmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFpclsxXSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdG9JdGVyYXRlZShwYWlyWzBdKSwgcGFpclsxXV07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpbmRleF07XG4gICAgICAgICAgaWYgKGFwcGx5KHBhaXJbMF0sIHRoaXMsIGFyZ3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkocGFpclsxXSwgdGhpcywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBwcmVkaWNhdGUgcHJvcGVydGllcyBvZiBgc291cmNlYCB3aXRoXG4gICAgICogdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdmFsdWVzIG9mIGEgZ2l2ZW4gb2JqZWN0LCByZXR1cm5pbmcgYHRydWVgIGlmXG4gICAgICogYWxsIHByZWRpY2F0ZXMgcmV0dXJuIHRydXRoeSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjcmVhdGVkIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG8gYF8uY29uZm9ybXNUb2Agd2l0aFxuICAgICAqIGBzb3VyY2VgIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IDIsICdiJzogMSB9LFxuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8uY29uZm9ybXMoeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAxOyB9IH0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEsICdiJzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmZvcm1zKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGJhc2VDb25mb3JtcyhiYXNlQ2xvbmUoc291cmNlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGB2YWx1ZWAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBkZWZhdWx0IHZhbHVlIHNob3VsZCBiZSByZXR1cm5lZCBpblxuICAgICAqIGl0cyBwbGFjZS4gVGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGBudWxsYCxcbiAgICAgKiBvciBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIFRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0VG8oMSwgMTApO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdFRvKHVuZGVmaW5lZCwgMTApO1xuICAgICAqIC8vID0+IDEwXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmYXVsdFRvKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUpID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBnaXZlbiBmdW5jdGlvbnNcbiAgICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtmdW5jc10gVGhlIGZ1bmN0aW9ucyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBzZWUgXy5mbG93UmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93KFtfLmFkZCwgc3F1YXJlXSk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi9cbiAgICB2YXIgZmxvdyA9IGNyZWF0ZUZsb3coKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxvd2AgZXhjZXB0IHRoYXQgaXQgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXRcbiAgICAgKiBpbnZva2VzIHRoZSBnaXZlbiBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2Z1bmNzXSBUaGUgZnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQHNlZSBfLmZsb3dcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93UmlnaHQoW3NxdWFyZSwgXy5hZGRdKTtcbiAgICAgKiBhZGRTcXVhcmUoMSwgMik7XG4gICAgICogLy8gPT4gOVxuICAgICAqL1xuICAgIHZhciBmbG93UmlnaHQgPSBjcmVhdGVGbG93KHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZFxuICAgICAqIGZ1bmN0aW9uLiBJZiBgZnVuY2AgaXMgYSBwcm9wZXJ0eSBuYW1lLCB0aGUgY3JlYXRlZCBmdW5jdGlvbiByZXR1cm5zIHRoZVxuICAgICAqIHByb3BlcnR5IHZhbHVlIGZvciBhIGdpdmVuIGVsZW1lbnQuIElmIGBmdW5jYCBpcyBhbiBhcnJheSBvciBvYmplY3QsIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgY29udGFpbiB0aGUgZXF1aXZhbGVudFxuICAgICAqIHNvdXJjZSBwcm9wZXJ0aWVzLCBvdGhlcndpc2UgaXQgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5pdGVyYXRlZSh7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0pKTtcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH1dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8uaXRlcmF0ZWUoWyd1c2VyJywgJ2ZyZWQnXSkpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwKHVzZXJzLCBfLml0ZXJhdGVlKCd1c2VyJykpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gQ3JlYXRlIGN1c3RvbSBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqIF8uaXRlcmF0ZWUgPSBfLndyYXAoXy5pdGVyYXRlZSwgZnVuY3Rpb24oaXRlcmF0ZWUsIGZ1bmMpIHtcbiAgICAgKiAgIHJldHVybiAhXy5pc1JlZ0V4cChmdW5jKSA/IGl0ZXJhdGVlKGZ1bmMpIDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICogICAgIHJldHVybiBmdW5jLnRlc3Qoc3RyaW5nKTtcbiAgICAgKiAgIH07XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihbJ2FiYycsICdkZWYnXSwgL2VmLyk7XG4gICAgICogLy8gPT4gWydkZWYnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGl0ZXJhdGVlKGZ1bmMpIHtcbiAgICAgIHJldHVybiBiYXNlSXRlcmF0ZWUodHlwZW9mIGZ1bmMgPT0gJ2Z1bmN0aW9uJyA/IGZ1bmMgOiBiYXNlQ2xvbmUoZnVuYywgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGEgZ2l2ZW5cbiAgICAgKiBvYmplY3QgYW5kIGBzb3VyY2VgLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZSBnaXZlbiBvYmplY3QgaGFzIGVxdWl2YWxlbnRcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvIGBfLmlzTWF0Y2hgIHdpdGggYHNvdXJjZWBcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0IGBzb3VyY2VgXG4gICAgICogdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWUgYF8uaXNFcXVhbGBcbiAgICAgKiBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBNdWx0aXBsZSB2YWx1ZXMgY2FuIGJlIGNoZWNrZWQgYnkgY29tYmluaW5nIHNldmVyYWwgbWF0Y2hlcnNcbiAgICAgKiB1c2luZyBgXy5vdmVyU29tZWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LFxuICAgICAqICAgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5tYXRjaGVzKHsgJ2EnOiA0LCAnYyc6IDYgfSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfV1cbiAgICAgKlxuICAgICAqIC8vIENoZWNraW5nIGZvciBzZXZlcmFsIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ub3ZlclNvbWUoW18ubWF0Y2hlcyh7ICdhJzogMSB9KSwgXy5tYXRjaGVzKHsgJ2EnOiA0IH0pXSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlcyhzb3VyY2UpIHtcbiAgICAgIHJldHVybiBiYXNlTWF0Y2hlcyhiYXNlQ2xvbmUoc291cmNlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdGhlXG4gICAgICogdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0IHRvIGBzcmNWYWx1ZWAsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlXG4gICAgICogb2JqZWN0IHZhbHVlIGlzIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdFxuICAgICAqIGBzcmNWYWx1ZWAgdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWVcbiAgICAgKiBgXy5pc0VxdWFsYCBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBNdWx0aXBsZSB2YWx1ZXMgY2FuIGJlIGNoZWNrZWQgYnkgY29tYmluaW5nIHNldmVyYWwgbWF0Y2hlcnNcbiAgICAgKiB1c2luZyBgXy5vdmVyU29tZWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LFxuICAgICAqICAgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKG9iamVjdHMsIF8ubWF0Y2hlc1Byb3BlcnR5KCdhJywgNCkpO1xuICAgICAqIC8vID0+IHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICpcbiAgICAgKiAvLyBDaGVja2luZyBmb3Igc2V2ZXJhbCBwb3NzaWJsZSB2YWx1ZXNcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLm92ZXJTb21lKFtfLm1hdGNoZXNQcm9wZXJ0eSgnYScsIDEpLCBfLm1hdGNoZXNQcm9wZXJ0eSgnYScsIDQpXSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBiYXNlQ2xvbmUoc3JjVmFsdWUsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICogQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZva2VyIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogXy5jb25zdGFudCgyKSB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IF8uY29uc3RhbnQoMSkgfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ubWV0aG9kKCdhLmInKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLm1ldGhvZChbJ2EnLCAnYiddKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgdmFyIG1ldGhvZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWV0aG9kYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIHRoZSBtZXRob2QgYXQgYSBnaXZlbiBwYXRoIG9mIGBvYmplY3RgLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlXG4gICAgICogcHJvdmlkZWQgdG8gdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludm9rZXIgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IF8udGltZXMoMywgXy5jb25zdGFudCksXG4gICAgICogICAgIG9iamVjdCA9IHsgJ2EnOiBhcnJheSwgJ2InOiBhcnJheSwgJ2MnOiBhcnJheSB9O1xuICAgICAqXG4gICAgICogXy5tYXAoWydhWzJdJywgJ2NbMF0nXSwgXy5tZXRob2RPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKlxuICAgICAqIF8ubWFwKFtbJ2EnLCAnMiddLCBbJ2MnLCAnMCddXSwgXy5tZXRob2RPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKi9cbiAgICB2YXIgbWV0aG9kT2YgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIGZ1bmN0aW9uIHByb3BlcnRpZXMgb2YgYSBzb3VyY2VcbiAgICAgKiBvYmplY3QgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC4gSWYgYG9iamVjdGAgaXMgYSBmdW5jdGlvbiwgdGhlbiBtZXRob2RzXG4gICAgICogYXJlIGFkZGVkIHRvIGl0cyBwcm90b3R5cGUgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVc2UgYF8ucnVuSW5Db250ZXh0YCB0byBjcmVhdGUgYSBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB0b1xuICAgICAqIGF2b2lkIGNvbmZsaWN0cyBjYXVzZWQgYnkgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IFtvYmplY3Q9bG9kYXNoXSBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBmdW5jdGlvbnMgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hhaW49dHJ1ZV0gU3BlY2lmeSB3aGV0aGVyIG1peGlucyBhcmUgY2hhaW5hYmxlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHZvd2VscyhzdHJpbmcpIHtcbiAgICAgKiAgIHJldHVybiBfLmZpbHRlcihzdHJpbmcsIGZ1bmN0aW9uKHYpIHtcbiAgICAgKiAgICAgcmV0dXJuIC9bYWVpb3VdL2kudGVzdCh2KTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0pO1xuICAgICAqIF8udm93ZWxzKCdmcmVkJyk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKlxuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9LCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1peGluKG9iamVjdCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKHNvdXJjZSksXG4gICAgICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlRnVuY3Rpb25zKHNvdXJjZSwgcHJvcHMpO1xuXG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsICYmXG4gICAgICAgICAgIShpc09iamVjdChzb3VyY2UpICYmIChtZXRob2ROYW1lcy5sZW5ndGggfHwgIXByb3BzLmxlbmd0aCkpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBzb3VyY2U7XG4gICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0ID0gdGhpcztcbiAgICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlRnVuY3Rpb25zKHNvdXJjZSwga2V5cyhzb3VyY2UpKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGFpbiA9ICEoaXNPYmplY3Qob3B0aW9ucykgJiYgJ2NoYWluJyBpbiBvcHRpb25zKSB8fCAhIW9wdGlvbnMuY2hhaW4sXG4gICAgICAgICAgaXNGdW5jID0gaXNGdW5jdGlvbihvYmplY3QpO1xuXG4gICAgICBhcnJheUVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBzb3VyY2VbbWV0aG9kTmFtZV07XG4gICAgICAgIG9iamVjdFttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgICAgICBvYmplY3QucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXztcbiAgICAgICAgICAgIGlmIChjaGFpbiB8fCBjaGFpbkFsbCkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0KHRoaXMuX193cmFwcGVkX18pLFxuICAgICAgICAgICAgICAgICAgYWN0aW9ucyA9IHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh0aGlzLl9fYWN0aW9uc19fKTtcblxuICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goeyAnZnVuYyc6IGZ1bmMsICdhcmdzJzogYXJndW1lbnRzLCAndGhpc0FyZyc6IG9iamVjdCB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IGNoYWluQWxsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkob2JqZWN0LCBhcnJheVB1c2goW3RoaXMudmFsdWUoKV0sIGFyZ3VtZW50cykpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVydHMgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHMgcHJldmlvdXMgdmFsdWUgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG9cbiAgICAgKiB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBsb2Rhc2ggPSBfLm5vQ29uZmxpY3QoKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgICAgaWYgKHJvb3QuXyA9PT0gdGhpcykge1xuICAgICAgICByb290Ll8gPSBvbGREYXNoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAgICAgKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyB0aGUgYXJndW1lbnQgYXQgaW5kZXggYG5gLiBJZiBgbmAgaXMgbmVnYXRpdmUsXG4gICAgICogdGhlIG50aCBhcmd1bWVudCBmcm9tIHRoZSBlbmQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgaW5kZXggb2YgdGhlIGFyZ3VtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXNzLXRocnUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5udGhBcmcoMSk7XG4gICAgICogZnVuYygnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+ICdiJ1xuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm50aEFyZygtMik7XG4gICAgICogZnVuYygnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+ICdjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG50aEFyZyhuKSB7XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VOdGgoYXJncywgbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBpdGVyYXRlZXNgIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlc1xuICAgICAqIGFuZCByZXR1cm5zIHRoZWlyIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyKFtNYXRoLm1heCwgTWF0aC5taW5dKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoMSwgMiwgMywgNCk7XG4gICAgICogLy8gPT4gWzQsIDFdXG4gICAgICovXG4gICAgdmFyIG92ZXIgPSBjcmVhdGVPdmVyKGFycmF5TWFwKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiAqKmFsbCoqIG9mIHRoZSBgcHJlZGljYXRlc2AgcmV0dXJuXG4gICAgICogdHJ1dGh5IHdoZW4gaW52b2tlZCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBGb2xsb3dpbmcgc2hvcnRoYW5kcyBhcmUgcG9zc2libGUgZm9yIHByb3ZpZGluZyBwcmVkaWNhdGVzLlxuICAgICAqIFBhc3MgYW4gYE9iamVjdGAgYW5kIGl0IHdpbGwgYmUgdXNlZCBhcyBhbiBwYXJhbWV0ZXIgZm9yIGBfLm1hdGNoZXNgIHRvIGNyZWF0ZSB0aGUgcHJlZGljYXRlLlxuICAgICAqIFBhc3MgYW4gYEFycmF5YCBvZiBwYXJhbWV0ZXJzIGZvciBgXy5tYXRjaGVzUHJvcGVydHlgIGFuZCB0aGUgcHJlZGljYXRlIHdpbGwgYmUgY3JlYXRlZCB1c2luZyB0aGVtLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3ByZWRpY2F0ZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgcHJlZGljYXRlcyB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJFdmVyeShbQm9vbGVhbiwgaXNGaW5pdGVdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoJzEnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBmdW5jKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgb3ZlckV2ZXJ5ID0gY3JlYXRlT3ZlcihhcnJheUV2ZXJ5KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiAqKmFueSoqIG9mIHRoZSBgcHJlZGljYXRlc2AgcmV0dXJuXG4gICAgICogdHJ1dGh5IHdoZW4gaW52b2tlZCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBGb2xsb3dpbmcgc2hvcnRoYW5kcyBhcmUgcG9zc2libGUgZm9yIHByb3ZpZGluZyBwcmVkaWNhdGVzLlxuICAgICAqIFBhc3MgYW4gYE9iamVjdGAgYW5kIGl0IHdpbGwgYmUgdXNlZCBhcyBhbiBwYXJhbWV0ZXIgZm9yIGBfLm1hdGNoZXNgIHRvIGNyZWF0ZSB0aGUgcHJlZGljYXRlLlxuICAgICAqIFBhc3MgYW4gYEFycmF5YCBvZiBwYXJhbWV0ZXJzIGZvciBgXy5tYXRjaGVzUHJvcGVydHlgIGFuZCB0aGUgcHJlZGljYXRlIHdpbGwgYmUgY3JlYXRlZCB1c2luZyB0aGVtLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3ByZWRpY2F0ZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgcHJlZGljYXRlcyB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJTb21lKFtCb29sZWFuLCBpc0Zpbml0ZV0pO1xuICAgICAqXG4gICAgICogZnVuYygnMScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgbWF0Y2hlc0Z1bmMgPSBfLm92ZXJTb21lKFt7ICdhJzogMSB9LCB7ICdhJzogMiB9XSlcbiAgICAgKiB2YXIgbWF0Y2hlc1Byb3BlcnR5RnVuYyA9IF8ub3ZlclNvbWUoW1snYScsIDFdLCBbJ2EnLCAyXV0pXG4gICAgICovXG4gICAgdmFyIG92ZXJTb21lID0gY3JlYXRlT3ZlcihhcnJheVNvbWUpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKlxuICAgICAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICAgICAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnByb3BlcnR5YDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJuc1xuICAgICAqIHRoZSB2YWx1ZSBhdCBhIGdpdmVuIHBhdGggb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzAsIDEsIDJdLFxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKlxuICAgICAqIF8ubWFwKFtbJ2EnLCAnMiddLCBbJ2MnLCAnMCddXSwgXy5wcm9wZXJ0eU9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5T2Yob2JqZWN0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gICAgICogYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBBIHN0ZXAgb2YgYC0xYCBpcyB1c2VkIGlmIGEgbmVnYXRpdmVcbiAgICAgKiBgc3RhcnRgIGlzIHNwZWNpZmllZCB3aXRob3V0IGFuIGBlbmRgIG9yIGBzdGVwYC4gSWYgYGVuZGAgaXMgbm90IHNwZWNpZmllZCxcbiAgICAgKiBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSmF2YVNjcmlwdCBmb2xsb3dzIHRoZSBJRUVFLTc1NCBzdGFuZGFyZCBmb3IgcmVzb2x2aW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgdmFsdWVzIHdoaWNoIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKiBAc2VlIF8uaW5SYW5nZSwgXy5yYW5nZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoNCk7XG4gICAgICogLy8gPT4gWzAsIDEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKC00KTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMCwgNSwgMTAsIDE1XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICB2YXIgcmFuZ2UgPSBjcmVhdGVSYW5nZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5yYW5nZWAgZXhjZXB0IHRoYXQgaXQgcG9wdWxhdGVzIHZhbHVlcyBpblxuICAgICAqIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICogQHNlZSBfLmluUmFuZ2UsIF8ucmFuZ2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDQpO1xuICAgICAqIC8vID0+IFszLCAyLCAxLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KC00KTtcbiAgICAgKiAvLyA9PiBbLTMsIC0yLCAtMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgxLCA1KTtcbiAgICAgKiAvLyA9PiBbNCwgMywgMiwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzE1LCAxMCwgNSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFstMywgLTIsIC0xLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDEsIDQsIDApO1xuICAgICAqIC8vID0+IFsxLCAxLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgdmFyIHJhbmdlUmlnaHQgPSBjcmVhdGVSYW5nZSh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAgICAgKiAvLyA9PiBbW10sIFtdXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICAgICAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uc3R1Yk9iamVjdCk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAgICAgKiAvLyA9PiBbe30sIHt9XVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViT2JqZWN0KCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YlN0cmluZyk7XG4gICAgICogLy8gPT4gWycnLCAnJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YlRydWUpO1xuICAgICAqIC8vID0+IFt0cnVlLCB0cnVlXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJUcnVlKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgaXRlcmF0ZWUgYG5gIHRpbWVzLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBlYWNoIGludm9jYXRpb24uIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAoaW5kZXgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygzLCBTdHJpbmcpO1xuICAgICAqIC8vID0+IFsnMCcsICcxJywgJzInXVxuICAgICAqXG4gICAgICogIF8udGltZXMoNCwgXy5jb25zdGFudCgwKSk7XG4gICAgICogLy8gPT4gWzAsIDAsIDAsIDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICBpZiAobiA8IDEgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gTUFYX0FSUkFZX0xFTkdUSCxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCk7XG5cbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUpO1xuICAgICAgbiAtPSBNQVhfQVJSQVlfTEVOR1RIO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZVRpbWVzKGxlbmd0aCwgaXRlcmF0ZWUpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICAgIGl0ZXJhdGVlKGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1BhdGgoJ2EuYi5jJyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICpcbiAgICAgKiBfLnRvUGF0aCgnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnMCcsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvUGF0aCh2YWx1ZSkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgdG9LZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU3ltYm9sKHZhbHVlKSA/IFt2YWx1ZV0gOiBjb3B5QXJyYXkoc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRC4gSWYgYHByZWZpeGAgaXMgZ2l2ZW4sIHRoZSBJRCBpcyBhcHBlbmRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXg9JyddIFRoZSB2YWx1ZSB0byBwcmVmaXggdGhlIElEIHdpdGguXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElELlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCdjb250YWN0XycpO1xuICAgICAqIC8vID0+ICdjb250YWN0XzEwNCdcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoKTtcbiAgICAgKiAvLyA9PiAnMTA1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICAgICAgdmFyIGlkID0gKytpZENvdW50ZXI7XG4gICAgICByZXR1cm4gdG9TdHJpbmcocHJlZml4KSArIGlkO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhdWdlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhbiBhZGRpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYWRkZW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGFuIGFkZGl0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRvdGFsLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmFkZCg2LCA0KTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqL1xuICAgIHZhciBhZGQgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKGF1Z2VuZCwgYWRkZW5kKSB7XG4gICAgICByZXR1cm4gYXVnZW5kICsgYWRkZW5kO1xuICAgIH0sIDApO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCB1cCB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZCB1cC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHVwIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgdXAgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNlaWwoNC4wMDYpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKlxuICAgICAqIF8uY2VpbCg2LjAwNCwgMik7XG4gICAgICogLy8gPT4gNi4wMVxuICAgICAqXG4gICAgICogXy5jZWlsKDYwNDAsIC0yKTtcbiAgICAgKiAvLyA9PiA2MTAwXG4gICAgICovXG4gICAgdmFyIGNlaWwgPSBjcmVhdGVSb3VuZCgnY2VpbCcpO1xuXG4gICAgLyoqXG4gICAgICogRGl2aWRlIHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGl2aWRlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhIGRpdmlzaW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXZpc29yIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgZGl2aXNpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcXVvdGllbnQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGl2aWRlKDYsIDQpO1xuICAgICAqIC8vID0+IDEuNVxuICAgICAqL1xuICAgIHZhciBkaXZpZGUgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICByZXR1cm4gZGl2aWRlbmQgLyBkaXZpc29yO1xuICAgIH0sIDEpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCBkb3duIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kIGRvd24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCBkb3duIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgZG93biBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoNC4wMDYpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoMC4wNDYsIDIpO1xuICAgICAqIC8vID0+IDAuMDRcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoNDA2MCwgLTIpO1xuICAgICAqIC8vID0+IDQwMDBcbiAgICAgKi9cbiAgICB2YXIgZmxvb3IgPSBjcmVhdGVSb3VuZCgnZmxvb3InKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxuICAgICAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1heChbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWF4KFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXgoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VHdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tYXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAgICAgKiB0aGUgdmFsdWUgaXMgcmFua2VkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiAxIH0sIHsgJ24nOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5tYXhCeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IHsgJ24nOiAyIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWF4Qnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiB7ICduJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4QnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYmFzZUd0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWVhbiBvZiB0aGUgdmFsdWVzIGluIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tZWFuKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lYW4oYXJyYXkpIHtcbiAgICAgIHJldHVybiBiYXNlTWVhbihhcnJheSwgaWRlbnRpdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVhbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIHZhbHVlIHRvIGJlIGF2ZXJhZ2VkLlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogNCB9LCB7ICduJzogMiB9LCB7ICduJzogOCB9LCB7ICduJzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWVhbkJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tZWFuQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVhbkJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VNZWFuKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxuICAgICAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1pbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8ubWluKFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW4oYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VMdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5taW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAgICAgKiB0aGUgdmFsdWUgaXMgcmFua2VkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiAxIH0sIHsgJ24nOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5taW5CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IHsgJ24nOiAxIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWluQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiB7ICduJzogMSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYmFzZUx0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBseSB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG11bHRpcGxpZXIgVGhlIGZpcnN0IG51bWJlciBpbiBhIG11bHRpcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aXBsaWNhbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwcm9kdWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm11bHRpcGx5KDYsIDQpO1xuICAgICAqIC8vID0+IDI0XG4gICAgICovXG4gICAgdmFyIG11bHRpcGx5ID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihtdWx0aXBsaWVyLCBtdWx0aXBsaWNhbmQpIHtcbiAgICAgIHJldHVybiBtdWx0aXBsaWVyICogbXVsdGlwbGljYW5kO1xuICAgIH0sIDEpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQuMDA2LCAyKTtcbiAgICAgKiAvLyA9PiA0LjAxXG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQwNjAsIC0yKTtcbiAgICAgKiAvLyA9PiA0MTAwXG4gICAgICovXG4gICAgdmFyIHJvdW5kID0gY3JlYXRlUm91bmQoJ3JvdW5kJyk7XG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdCB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbnVlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhIHN1YnRyYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdWJ0cmFoZW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgc3VidHJhY3Rpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgZGlmZmVyZW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdWJ0cmFjdCg2LCA0KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgdmFyIHN1YnRyYWN0ID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihtaW51ZW5kLCBzdWJ0cmFoZW5kKSB7XG4gICAgICByZXR1cm4gbWludWVuZCAtIHN1YnRyYWhlbmQ7XG4gICAgfSwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgc3VtIG9mIHRoZSB2YWx1ZXMgaW4gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjQuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3VtKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdW0oYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTdW0oYXJyYXksIGlkZW50aXR5KVxuICAgICAgICA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zdW1gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSB2YWx1ZSB0byBiZSBzdW1tZWQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDQgfSwgeyAnbic6IDIgfSwgeyAnbic6IDggfSwgeyAnbic6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLnN1bUJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc3VtQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1bUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVN1bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IDA7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdGhhdCByZXR1cm4gd3JhcHBlZCB2YWx1ZXMgaW4gY2hhaW4gc2VxdWVuY2VzLlxuICAgIGxvZGFzaC5hZnRlciA9IGFmdGVyO1xuICAgIGxvZGFzaC5hcnkgPSBhcnk7XG4gICAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcbiAgICBsb2Rhc2guYXNzaWduSW4gPSBhc3NpZ25JbjtcbiAgICBsb2Rhc2guYXNzaWduSW5XaXRoID0gYXNzaWduSW5XaXRoO1xuICAgIGxvZGFzaC5hc3NpZ25XaXRoID0gYXNzaWduV2l0aDtcbiAgICBsb2Rhc2guYXQgPSBhdDtcbiAgICBsb2Rhc2guYmVmb3JlID0gYmVmb3JlO1xuICAgIGxvZGFzaC5iaW5kID0gYmluZDtcbiAgICBsb2Rhc2guYmluZEFsbCA9IGJpbmRBbGw7XG4gICAgbG9kYXNoLmJpbmRLZXkgPSBiaW5kS2V5O1xuICAgIGxvZGFzaC5jYXN0QXJyYXkgPSBjYXN0QXJyYXk7XG4gICAgbG9kYXNoLmNoYWluID0gY2hhaW47XG4gICAgbG9kYXNoLmNodW5rID0gY2h1bms7XG4gICAgbG9kYXNoLmNvbXBhY3QgPSBjb21wYWN0O1xuICAgIGxvZGFzaC5jb25jYXQgPSBjb25jYXQ7XG4gICAgbG9kYXNoLmNvbmQgPSBjb25kO1xuICAgIGxvZGFzaC5jb25mb3JtcyA9IGNvbmZvcm1zO1xuICAgIGxvZGFzaC5jb25zdGFudCA9IGNvbnN0YW50O1xuICAgIGxvZGFzaC5jb3VudEJ5ID0gY291bnRCeTtcbiAgICBsb2Rhc2guY3JlYXRlID0gY3JlYXRlO1xuICAgIGxvZGFzaC5jdXJyeSA9IGN1cnJ5O1xuICAgIGxvZGFzaC5jdXJyeVJpZ2h0ID0gY3VycnlSaWdodDtcbiAgICBsb2Rhc2guZGVib3VuY2UgPSBkZWJvdW5jZTtcbiAgICBsb2Rhc2guZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICBsb2Rhc2guZGVmYXVsdHNEZWVwID0gZGVmYXVsdHNEZWVwO1xuICAgIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICAgIGxvZGFzaC5kZWxheSA9IGRlbGF5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZUJ5ID0gZGlmZmVyZW5jZUJ5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlV2l0aCA9IGRpZmZlcmVuY2VXaXRoO1xuICAgIGxvZGFzaC5kcm9wID0gZHJvcDtcbiAgICBsb2Rhc2guZHJvcFJpZ2h0ID0gZHJvcFJpZ2h0O1xuICAgIGxvZGFzaC5kcm9wUmlnaHRXaGlsZSA9IGRyb3BSaWdodFdoaWxlO1xuICAgIGxvZGFzaC5kcm9wV2hpbGUgPSBkcm9wV2hpbGU7XG4gICAgbG9kYXNoLmZpbGwgPSBmaWxsO1xuICAgIGxvZGFzaC5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgbG9kYXNoLmZsYXRNYXAgPSBmbGF0TWFwO1xuICAgIGxvZGFzaC5mbGF0TWFwRGVlcCA9IGZsYXRNYXBEZWVwO1xuICAgIGxvZGFzaC5mbGF0TWFwRGVwdGggPSBmbGF0TWFwRGVwdGg7XG4gICAgbG9kYXNoLmZsYXR0ZW4gPSBmbGF0dGVuO1xuICAgIGxvZGFzaC5mbGF0dGVuRGVlcCA9IGZsYXR0ZW5EZWVwO1xuICAgIGxvZGFzaC5mbGF0dGVuRGVwdGggPSBmbGF0dGVuRGVwdGg7XG4gICAgbG9kYXNoLmZsaXAgPSBmbGlwO1xuICAgIGxvZGFzaC5mbG93ID0gZmxvdztcbiAgICBsb2Rhc2guZmxvd1JpZ2h0ID0gZmxvd1JpZ2h0O1xuICAgIGxvZGFzaC5mcm9tUGFpcnMgPSBmcm9tUGFpcnM7XG4gICAgbG9kYXNoLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICBsb2Rhc2guZnVuY3Rpb25zSW4gPSBmdW5jdGlvbnNJbjtcbiAgICBsb2Rhc2guZ3JvdXBCeSA9IGdyb3VwQnk7XG4gICAgbG9kYXNoLmluaXRpYWwgPSBpbml0aWFsO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbkJ5ID0gaW50ZXJzZWN0aW9uQnk7XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbldpdGggPSBpbnRlcnNlY3Rpb25XaXRoO1xuICAgIGxvZGFzaC5pbnZlcnQgPSBpbnZlcnQ7XG4gICAgbG9kYXNoLmludmVydEJ5ID0gaW52ZXJ0Qnk7XG4gICAgbG9kYXNoLmludm9rZU1hcCA9IGludm9rZU1hcDtcbiAgICBsb2Rhc2guaXRlcmF0ZWUgPSBpdGVyYXRlZTtcbiAgICBsb2Rhc2gua2V5QnkgPSBrZXlCeTtcbiAgICBsb2Rhc2gua2V5cyA9IGtleXM7XG4gICAgbG9kYXNoLmtleXNJbiA9IGtleXNJbjtcbiAgICBsb2Rhc2gubWFwID0gbWFwO1xuICAgIGxvZGFzaC5tYXBLZXlzID0gbWFwS2V5cztcbiAgICBsb2Rhc2gubWFwVmFsdWVzID0gbWFwVmFsdWVzO1xuICAgIGxvZGFzaC5tYXRjaGVzID0gbWF0Y2hlcztcbiAgICBsb2Rhc2gubWF0Y2hlc1Byb3BlcnR5ID0gbWF0Y2hlc1Byb3BlcnR5O1xuICAgIGxvZGFzaC5tZW1vaXplID0gbWVtb2l6ZTtcbiAgICBsb2Rhc2gubWVyZ2UgPSBtZXJnZTtcbiAgICBsb2Rhc2gubWVyZ2VXaXRoID0gbWVyZ2VXaXRoO1xuICAgIGxvZGFzaC5tZXRob2QgPSBtZXRob2Q7XG4gICAgbG9kYXNoLm1ldGhvZE9mID0gbWV0aG9kT2Y7XG4gICAgbG9kYXNoLm1peGluID0gbWl4aW47XG4gICAgbG9kYXNoLm5lZ2F0ZSA9IG5lZ2F0ZTtcbiAgICBsb2Rhc2gubnRoQXJnID0gbnRoQXJnO1xuICAgIGxvZGFzaC5vbWl0ID0gb21pdDtcbiAgICBsb2Rhc2gub21pdEJ5ID0gb21pdEJ5O1xuICAgIGxvZGFzaC5vbmNlID0gb25jZTtcbiAgICBsb2Rhc2gub3JkZXJCeSA9IG9yZGVyQnk7XG4gICAgbG9kYXNoLm92ZXIgPSBvdmVyO1xuICAgIGxvZGFzaC5vdmVyQXJncyA9IG92ZXJBcmdzO1xuICAgIGxvZGFzaC5vdmVyRXZlcnkgPSBvdmVyRXZlcnk7XG4gICAgbG9kYXNoLm92ZXJTb21lID0gb3ZlclNvbWU7XG4gICAgbG9kYXNoLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICAgIGxvZGFzaC5wYXJ0aWFsUmlnaHQgPSBwYXJ0aWFsUmlnaHQ7XG4gICAgbG9kYXNoLnBhcnRpdGlvbiA9IHBhcnRpdGlvbjtcbiAgICBsb2Rhc2gucGljayA9IHBpY2s7XG4gICAgbG9kYXNoLnBpY2tCeSA9IHBpY2tCeTtcbiAgICBsb2Rhc2gucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICBsb2Rhc2gucHJvcGVydHlPZiA9IHByb3BlcnR5T2Y7XG4gICAgbG9kYXNoLnB1bGwgPSBwdWxsO1xuICAgIGxvZGFzaC5wdWxsQWxsID0gcHVsbEFsbDtcbiAgICBsb2Rhc2gucHVsbEFsbEJ5ID0gcHVsbEFsbEJ5O1xuICAgIGxvZGFzaC5wdWxsQWxsV2l0aCA9IHB1bGxBbGxXaXRoO1xuICAgIGxvZGFzaC5wdWxsQXQgPSBwdWxsQXQ7XG4gICAgbG9kYXNoLnJhbmdlID0gcmFuZ2U7XG4gICAgbG9kYXNoLnJhbmdlUmlnaHQgPSByYW5nZVJpZ2h0O1xuICAgIGxvZGFzaC5yZWFyZyA9IHJlYXJnO1xuICAgIGxvZGFzaC5yZWplY3QgPSByZWplY3Q7XG4gICAgbG9kYXNoLnJlbW92ZSA9IHJlbW92ZTtcbiAgICBsb2Rhc2gucmVzdCA9IHJlc3Q7XG4gICAgbG9kYXNoLnJldmVyc2UgPSByZXZlcnNlO1xuICAgIGxvZGFzaC5zYW1wbGVTaXplID0gc2FtcGxlU2l6ZTtcbiAgICBsb2Rhc2guc2V0ID0gc2V0O1xuICAgIGxvZGFzaC5zZXRXaXRoID0gc2V0V2l0aDtcbiAgICBsb2Rhc2guc2h1ZmZsZSA9IHNodWZmbGU7XG4gICAgbG9kYXNoLnNsaWNlID0gc2xpY2U7XG4gICAgbG9kYXNoLnNvcnRCeSA9IHNvcnRCeTtcbiAgICBsb2Rhc2guc29ydGVkVW5pcSA9IHNvcnRlZFVuaXE7XG4gICAgbG9kYXNoLnNvcnRlZFVuaXFCeSA9IHNvcnRlZFVuaXFCeTtcbiAgICBsb2Rhc2guc3BsaXQgPSBzcGxpdDtcbiAgICBsb2Rhc2guc3ByZWFkID0gc3ByZWFkO1xuICAgIGxvZGFzaC50YWlsID0gdGFpbDtcbiAgICBsb2Rhc2gudGFrZSA9IHRha2U7XG4gICAgbG9kYXNoLnRha2VSaWdodCA9IHRha2VSaWdodDtcbiAgICBsb2Rhc2gudGFrZVJpZ2h0V2hpbGUgPSB0YWtlUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2gudGFrZVdoaWxlID0gdGFrZVdoaWxlO1xuICAgIGxvZGFzaC50YXAgPSB0YXA7XG4gICAgbG9kYXNoLnRocm90dGxlID0gdGhyb3R0bGU7XG4gICAgbG9kYXNoLnRocnUgPSB0aHJ1O1xuICAgIGxvZGFzaC50b0FycmF5ID0gdG9BcnJheTtcbiAgICBsb2Rhc2gudG9QYWlycyA9IHRvUGFpcnM7XG4gICAgbG9kYXNoLnRvUGFpcnNJbiA9IHRvUGFpcnNJbjtcbiAgICBsb2Rhc2gudG9QYXRoID0gdG9QYXRoO1xuICAgIGxvZGFzaC50b1BsYWluT2JqZWN0ID0gdG9QbGFpbk9iamVjdDtcbiAgICBsb2Rhc2gudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGxvZGFzaC51bmFyeSA9IHVuYXJ5O1xuICAgIGxvZGFzaC51bmlvbiA9IHVuaW9uO1xuICAgIGxvZGFzaC51bmlvbkJ5ID0gdW5pb25CeTtcbiAgICBsb2Rhc2gudW5pb25XaXRoID0gdW5pb25XaXRoO1xuICAgIGxvZGFzaC51bmlxID0gdW5pcTtcbiAgICBsb2Rhc2gudW5pcUJ5ID0gdW5pcUJ5O1xuICAgIGxvZGFzaC51bmlxV2l0aCA9IHVuaXFXaXRoO1xuICAgIGxvZGFzaC51bnNldCA9IHVuc2V0O1xuICAgIGxvZGFzaC51bnppcCA9IHVuemlwO1xuICAgIGxvZGFzaC51bnppcFdpdGggPSB1bnppcFdpdGg7XG4gICAgbG9kYXNoLnVwZGF0ZSA9IHVwZGF0ZTtcbiAgICBsb2Rhc2gudXBkYXRlV2l0aCA9IHVwZGF0ZVdpdGg7XG4gICAgbG9kYXNoLnZhbHVlcyA9IHZhbHVlcztcbiAgICBsb2Rhc2gudmFsdWVzSW4gPSB2YWx1ZXNJbjtcbiAgICBsb2Rhc2gud2l0aG91dCA9IHdpdGhvdXQ7XG4gICAgbG9kYXNoLndvcmRzID0gd29yZHM7XG4gICAgbG9kYXNoLndyYXAgPSB3cmFwO1xuICAgIGxvZGFzaC54b3IgPSB4b3I7XG4gICAgbG9kYXNoLnhvckJ5ID0geG9yQnk7XG4gICAgbG9kYXNoLnhvcldpdGggPSB4b3JXaXRoO1xuICAgIGxvZGFzaC56aXAgPSB6aXA7XG4gICAgbG9kYXNoLnppcE9iamVjdCA9IHppcE9iamVjdDtcbiAgICBsb2Rhc2guemlwT2JqZWN0RGVlcCA9IHppcE9iamVjdERlZXA7XG4gICAgbG9kYXNoLnppcFdpdGggPSB6aXBXaXRoO1xuXG4gICAgLy8gQWRkIGFsaWFzZXMuXG4gICAgbG9kYXNoLmVudHJpZXMgPSB0b1BhaXJzO1xuICAgIGxvZGFzaC5lbnRyaWVzSW4gPSB0b1BhaXJzSW47XG4gICAgbG9kYXNoLmV4dGVuZCA9IGFzc2lnbkluO1xuICAgIGxvZGFzaC5leHRlbmRXaXRoID0gYXNzaWduSW5XaXRoO1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIG1peGluKGxvZGFzaCwgbG9kYXNoKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEFkZCBtZXRob2RzIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMgaW4gY2hhaW4gc2VxdWVuY2VzLlxuICAgIGxvZGFzaC5hZGQgPSBhZGQ7XG4gICAgbG9kYXNoLmF0dGVtcHQgPSBhdHRlbXB0O1xuICAgIGxvZGFzaC5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG4gICAgbG9kYXNoLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xuICAgIGxvZGFzaC5jZWlsID0gY2VpbDtcbiAgICBsb2Rhc2guY2xhbXAgPSBjbGFtcDtcbiAgICBsb2Rhc2guY2xvbmUgPSBjbG9uZTtcbiAgICBsb2Rhc2guY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuICAgIGxvZGFzaC5jbG9uZURlZXBXaXRoID0gY2xvbmVEZWVwV2l0aDtcbiAgICBsb2Rhc2guY2xvbmVXaXRoID0gY2xvbmVXaXRoO1xuICAgIGxvZGFzaC5jb25mb3Jtc1RvID0gY29uZm9ybXNUbztcbiAgICBsb2Rhc2guZGVidXJyID0gZGVidXJyO1xuICAgIGxvZGFzaC5kZWZhdWx0VG8gPSBkZWZhdWx0VG87XG4gICAgbG9kYXNoLmRpdmlkZSA9IGRpdmlkZTtcbiAgICBsb2Rhc2guZW5kc1dpdGggPSBlbmRzV2l0aDtcbiAgICBsb2Rhc2guZXEgPSBlcTtcbiAgICBsb2Rhc2guZXNjYXBlID0gZXNjYXBlO1xuICAgIGxvZGFzaC5lc2NhcGVSZWdFeHAgPSBlc2NhcGVSZWdFeHA7XG4gICAgbG9kYXNoLmV2ZXJ5ID0gZXZlcnk7XG4gICAgbG9kYXNoLmZpbmQgPSBmaW5kO1xuICAgIGxvZGFzaC5maW5kSW5kZXggPSBmaW5kSW5kZXg7XG4gICAgbG9kYXNoLmZpbmRLZXkgPSBmaW5kS2V5O1xuICAgIGxvZGFzaC5maW5kTGFzdCA9IGZpbmRMYXN0O1xuICAgIGxvZGFzaC5maW5kTGFzdEluZGV4ID0gZmluZExhc3RJbmRleDtcbiAgICBsb2Rhc2guZmluZExhc3RLZXkgPSBmaW5kTGFzdEtleTtcbiAgICBsb2Rhc2guZmxvb3IgPSBmbG9vcjtcbiAgICBsb2Rhc2guZm9yRWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmZvckVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZm9ySW4gPSBmb3JJbjtcbiAgICBsb2Rhc2guZm9ySW5SaWdodCA9IGZvckluUmlnaHQ7XG4gICAgbG9kYXNoLmZvck93biA9IGZvck93bjtcbiAgICBsb2Rhc2guZm9yT3duUmlnaHQgPSBmb3JPd25SaWdodDtcbiAgICBsb2Rhc2guZ2V0ID0gZ2V0O1xuICAgIGxvZGFzaC5ndCA9IGd0O1xuICAgIGxvZGFzaC5ndGUgPSBndGU7XG4gICAgbG9kYXNoLmhhcyA9IGhhcztcbiAgICBsb2Rhc2guaGFzSW4gPSBoYXNJbjtcbiAgICBsb2Rhc2guaGVhZCA9IGhlYWQ7XG4gICAgbG9kYXNoLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgbG9kYXNoLmluY2x1ZGVzID0gaW5jbHVkZXM7XG4gICAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuICAgIGxvZGFzaC5pblJhbmdlID0gaW5SYW5nZTtcbiAgICBsb2Rhc2guaW52b2tlID0gaW52b2tlO1xuICAgIGxvZGFzaC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xuICAgIGxvZGFzaC5pc0FycmF5ID0gaXNBcnJheTtcbiAgICBsb2Rhc2guaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG4gICAgbG9kYXNoLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2U7XG4gICAgbG9kYXNoLmlzQXJyYXlMaWtlT2JqZWN0ID0gaXNBcnJheUxpa2VPYmplY3Q7XG4gICAgbG9kYXNoLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcbiAgICBsb2Rhc2guaXNCdWZmZXIgPSBpc0J1ZmZlcjtcbiAgICBsb2Rhc2guaXNEYXRlID0gaXNEYXRlO1xuICAgIGxvZGFzaC5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG4gICAgbG9kYXNoLmlzRW1wdHkgPSBpc0VtcHR5O1xuICAgIGxvZGFzaC5pc0VxdWFsID0gaXNFcXVhbDtcbiAgICBsb2Rhc2guaXNFcXVhbFdpdGggPSBpc0VxdWFsV2l0aDtcbiAgICBsb2Rhc2guaXNFcnJvciA9IGlzRXJyb3I7XG4gICAgbG9kYXNoLmlzRmluaXRlID0gaXNGaW5pdGU7XG4gICAgbG9kYXNoLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgIGxvZGFzaC5pc0ludGVnZXIgPSBpc0ludGVnZXI7XG4gICAgbG9kYXNoLmlzTGVuZ3RoID0gaXNMZW5ndGg7XG4gICAgbG9kYXNoLmlzTWFwID0gaXNNYXA7XG4gICAgbG9kYXNoLmlzTWF0Y2ggPSBpc01hdGNoO1xuICAgIGxvZGFzaC5pc01hdGNoV2l0aCA9IGlzTWF0Y2hXaXRoO1xuICAgIGxvZGFzaC5pc05hTiA9IGlzTmFOO1xuICAgIGxvZGFzaC5pc05hdGl2ZSA9IGlzTmF0aXZlO1xuICAgIGxvZGFzaC5pc05pbCA9IGlzTmlsO1xuICAgIGxvZGFzaC5pc051bGwgPSBpc051bGw7XG4gICAgbG9kYXNoLmlzTnVtYmVyID0gaXNOdW1iZXI7XG4gICAgbG9kYXNoLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4gICAgbG9kYXNoLmlzT2JqZWN0TGlrZSA9IGlzT2JqZWN0TGlrZTtcbiAgICBsb2Rhc2guaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLmlzUmVnRXhwID0gaXNSZWdFeHA7XG4gICAgbG9kYXNoLmlzU2FmZUludGVnZXIgPSBpc1NhZmVJbnRlZ2VyO1xuICAgIGxvZGFzaC5pc1NldCA9IGlzU2V0O1xuICAgIGxvZGFzaC5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICAgIGxvZGFzaC5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuICAgIGxvZGFzaC5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXk7XG4gICAgbG9kYXNoLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG4gICAgbG9kYXNoLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcbiAgICBsb2Rhc2guaXNXZWFrU2V0ID0gaXNXZWFrU2V0O1xuICAgIGxvZGFzaC5qb2luID0gam9pbjtcbiAgICBsb2Rhc2gua2ViYWJDYXNlID0ga2ViYWJDYXNlO1xuICAgIGxvZGFzaC5sYXN0ID0gbGFzdDtcbiAgICBsb2Rhc2gubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2gubG93ZXJDYXNlID0gbG93ZXJDYXNlO1xuICAgIGxvZGFzaC5sb3dlckZpcnN0ID0gbG93ZXJGaXJzdDtcbiAgICBsb2Rhc2gubHQgPSBsdDtcbiAgICBsb2Rhc2gubHRlID0gbHRlO1xuICAgIGxvZGFzaC5tYXggPSBtYXg7XG4gICAgbG9kYXNoLm1heEJ5ID0gbWF4Qnk7XG4gICAgbG9kYXNoLm1lYW4gPSBtZWFuO1xuICAgIGxvZGFzaC5tZWFuQnkgPSBtZWFuQnk7XG4gICAgbG9kYXNoLm1pbiA9IG1pbjtcbiAgICBsb2Rhc2gubWluQnkgPSBtaW5CeTtcbiAgICBsb2Rhc2guc3R1YkFycmF5ID0gc3R1YkFycmF5O1xuICAgIGxvZGFzaC5zdHViRmFsc2UgPSBzdHViRmFsc2U7XG4gICAgbG9kYXNoLnN0dWJPYmplY3QgPSBzdHViT2JqZWN0O1xuICAgIGxvZGFzaC5zdHViU3RyaW5nID0gc3R1YlN0cmluZztcbiAgICBsb2Rhc2guc3R1YlRydWUgPSBzdHViVHJ1ZTtcbiAgICBsb2Rhc2gubXVsdGlwbHkgPSBtdWx0aXBseTtcbiAgICBsb2Rhc2gubnRoID0gbnRoO1xuICAgIGxvZGFzaC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbiAgICBsb2Rhc2gubm9vcCA9IG5vb3A7XG4gICAgbG9kYXNoLm5vdyA9IG5vdztcbiAgICBsb2Rhc2gucGFkID0gcGFkO1xuICAgIGxvZGFzaC5wYWRFbmQgPSBwYWRFbmQ7XG4gICAgbG9kYXNoLnBhZFN0YXJ0ID0gcGFkU3RhcnQ7XG4gICAgbG9kYXNoLnBhcnNlSW50ID0gcGFyc2VJbnQ7XG4gICAgbG9kYXNoLnJhbmRvbSA9IHJhbmRvbTtcbiAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuICAgIGxvZGFzaC5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5yZXBlYXQgPSByZXBlYXQ7XG4gICAgbG9kYXNoLnJlcGxhY2UgPSByZXBsYWNlO1xuICAgIGxvZGFzaC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgbG9kYXNoLnJvdW5kID0gcm91bmQ7XG4gICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDtcbiAgICBsb2Rhc2guc2FtcGxlID0gc2FtcGxlO1xuICAgIGxvZGFzaC5zaXplID0gc2l6ZTtcbiAgICBsb2Rhc2guc25ha2VDYXNlID0gc25ha2VDYXNlO1xuICAgIGxvZGFzaC5zb21lID0gc29tZTtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXggPSBzb3J0ZWRJbmRleDtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXhCeSA9IHNvcnRlZEluZGV4Qnk7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4T2YgPSBzb3J0ZWRJbmRleE9mO1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXggPSBzb3J0ZWRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleEJ5ID0gc29ydGVkTGFzdEluZGV4Qnk7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleE9mID0gc29ydGVkTGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLnN0YXJ0Q2FzZSA9IHN0YXJ0Q2FzZTtcbiAgICBsb2Rhc2guc3RhcnRzV2l0aCA9IHN0YXJ0c1dpdGg7XG4gICAgbG9kYXNoLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG4gICAgbG9kYXNoLnN1bSA9IHN1bTtcbiAgICBsb2Rhc2guc3VtQnkgPSBzdW1CeTtcbiAgICBsb2Rhc2gudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICBsb2Rhc2gudGltZXMgPSB0aW1lcztcbiAgICBsb2Rhc2gudG9GaW5pdGUgPSB0b0Zpbml0ZTtcbiAgICBsb2Rhc2gudG9JbnRlZ2VyID0gdG9JbnRlZ2VyO1xuICAgIGxvZGFzaC50b0xlbmd0aCA9IHRvTGVuZ3RoO1xuICAgIGxvZGFzaC50b0xvd2VyID0gdG9Mb3dlcjtcbiAgICBsb2Rhc2gudG9OdW1iZXIgPSB0b051bWJlcjtcbiAgICBsb2Rhc2gudG9TYWZlSW50ZWdlciA9IHRvU2FmZUludGVnZXI7XG4gICAgbG9kYXNoLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgbG9kYXNoLnRvVXBwZXIgPSB0b1VwcGVyO1xuICAgIGxvZGFzaC50cmltID0gdHJpbTtcbiAgICBsb2Rhc2gudHJpbUVuZCA9IHRyaW1FbmQ7XG4gICAgbG9kYXNoLnRyaW1TdGFydCA9IHRyaW1TdGFydDtcbiAgICBsb2Rhc2gudHJ1bmNhdGUgPSB0cnVuY2F0ZTtcbiAgICBsb2Rhc2gudW5lc2NhcGUgPSB1bmVzY2FwZTtcbiAgICBsb2Rhc2gudW5pcXVlSWQgPSB1bmlxdWVJZDtcbiAgICBsb2Rhc2gudXBwZXJDYXNlID0gdXBwZXJDYXNlO1xuICAgIGxvZGFzaC51cHBlckZpcnN0ID0gdXBwZXJGaXJzdDtcblxuICAgIC8vIEFkZCBhbGlhc2VzLlxuICAgIGxvZGFzaC5lYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5maXJzdCA9IGhlYWQ7XG5cbiAgICBtaXhpbihsb2Rhc2gsIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB7fTtcbiAgICAgIGJhc2VGb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gucHJvdG90eXBlLCBtZXRob2ROYW1lKSkge1xuICAgICAgICAgIHNvdXJjZVttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9KCkpLCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBsb2Rhc2guVkVSU0lPTiA9IFZFUlNJT047XG5cbiAgICAvLyBBc3NpZ24gZGVmYXVsdCBwbGFjZWhvbGRlcnMuXG4gICAgYXJyYXlFYWNoKFsnYmluZCcsICdiaW5kS2V5JywgJ2N1cnJ5JywgJ2N1cnJ5UmlnaHQnLCAncGFydGlhbCcsICdwYXJ0aWFsUmlnaHQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgbG9kYXNoW21ldGhvZE5hbWVdLnBsYWNlaG9sZGVyID0gbG9kYXNoO1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uZHJvcGAgYW5kIGBfLnRha2VgIHZhcmlhbnRzLlxuICAgIGFycmF5RWFjaChbJ2Ryb3AnLCAndGFrZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24obikge1xuICAgICAgICBuID0gbiA9PT0gdW5kZWZpbmVkID8gMSA6IG5hdGl2ZU1heCh0b0ludGVnZXIobiksIDApO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSAodGhpcy5fX2ZpbHRlcmVkX18gJiYgIWluZGV4KVxuICAgICAgICAgID8gbmV3IExhenlXcmFwcGVyKHRoaXMpXG4gICAgICAgICAgOiB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5fX2ZpbHRlcmVkX18pIHtcbiAgICAgICAgICByZXN1bHQuX190YWtlQ291bnRfXyA9IG5hdGl2ZU1pbihuLCByZXN1bHQuX190YWtlQ291bnRfXyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0Ll9fdmlld3NfXy5wdXNoKHtcbiAgICAgICAgICAgICdzaXplJzogbmF0aXZlTWluKG4sIE1BWF9BUlJBWV9MRU5HVEgpLFxuICAgICAgICAgICAgJ3R5cGUnOiBtZXRob2ROYW1lICsgKHJlc3VsdC5fX2Rpcl9fIDwgMCA/ICdSaWdodCcgOiAnJylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWUgKyAnUmlnaHQnXSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpW21ldGhvZE5hbWVdKG4pLnJldmVyc2UoKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIHRoYXQgYWNjZXB0IGFuIGBpdGVyYXRlZWAgdmFsdWUuXG4gICAgYXJyYXlFYWNoKFsnZmlsdGVyJywgJ21hcCcsICd0YWtlV2hpbGUnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB0eXBlID0gaW5kZXggKyAxLFxuICAgICAgICAgIGlzRmlsdGVyID0gdHlwZSA9PSBMQVpZX0ZJTFRFUl9GTEFHIHx8IHR5cGUgPT0gTEFaWV9XSElMRV9GTEFHO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXN1bHQuX19pdGVyYXRlZXNfXy5wdXNoKHtcbiAgICAgICAgICAnaXRlcmF0ZWUnOiBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksXG4gICAgICAgICAgJ3R5cGUnOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gcmVzdWx0Ll9fZmlsdGVyZWRfXyB8fCBpc0ZpbHRlcjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5oZWFkYCBhbmQgYF8ubGFzdGAuXG4gICAgYXJyYXlFYWNoKFsnaGVhZCcsICdsYXN0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgdGFrZU5hbWUgPSAndGFrZScgKyAoaW5kZXggPyAnUmlnaHQnIDogJycpO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbdGFrZU5hbWVdKDEpLnZhbHVlKClbMF07XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uaW5pdGlhbGAgYW5kIGBfLnRhaWxgLlxuICAgIGFycmF5RWFjaChbJ2luaXRpYWwnLCAndGFpbCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIGRyb3BOYW1lID0gJ2Ryb3AnICsgKGluZGV4ID8gJycgOiAnUmlnaHQnKTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZmlsdGVyZWRfXyA/IG5ldyBMYXp5V3JhcHBlcih0aGlzKSA6IHRoaXNbZHJvcE5hbWVdKDEpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb21wYWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoaWRlbnRpdHkpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKHByZWRpY2F0ZSkuaGVhZCgpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuZmluZExhc3QgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5maW5kKHByZWRpY2F0ZSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5pbnZva2VNYXAgPSBiYXNlUmVzdChmdW5jdGlvbihwYXRoLCBhcmdzKSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUpKSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXM7XG4gICAgICBpZiAocmVzdWx0Ll9fZmlsdGVyZWRfXyAmJiAoc3RhcnQgPiAwIHx8IGVuZCA8IDApKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRha2VSaWdodCgtc3RhcnQpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuZHJvcChzdGFydCk7XG4gICAgICB9XG4gICAgICBpZiAoZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gdG9JbnRlZ2VyKGVuZCk7XG4gICAgICAgIHJlc3VsdCA9IGVuZCA8IDAgPyByZXN1bHQuZHJvcFJpZ2h0KC1lbmQpIDogcmVzdWx0LnRha2UoZW5kIC0gc3RhcnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRha2VSaWdodFdoaWxlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkudGFrZVdoaWxlKHByZWRpY2F0ZSkucmV2ZXJzZSgpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGFrZShNQVhfQVJSQVlfTEVOR1RIKTtcbiAgICB9O1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgYmFzZUZvck93bihMYXp5V3JhcHBlci5wcm90b3R5cGUsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBjaGVja0l0ZXJhdGVlID0gL14oPzpmaWx0ZXJ8ZmluZHxtYXB8cmVqZWN0KXxXaGlsZSQvLnRlc3QobWV0aG9kTmFtZSksXG4gICAgICAgICAgaXNUYWtlciA9IC9eKD86aGVhZHxsYXN0KSQvLnRlc3QobWV0aG9kTmFtZSksXG4gICAgICAgICAgbG9kYXNoRnVuYyA9IGxvZGFzaFtpc1Rha2VyID8gKCd0YWtlJyArIChtZXRob2ROYW1lID09ICdsYXN0JyA/ICdSaWdodCcgOiAnJykpIDogbWV0aG9kTmFtZV0sXG4gICAgICAgICAgcmV0VW53cmFwcGVkID0gaXNUYWtlciB8fCAvXmZpbmQvLnRlc3QobWV0aG9kTmFtZSk7XG5cbiAgICAgIGlmICghbG9kYXNoRnVuYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgICBhcmdzID0gaXNUYWtlciA/IFsxXSA6IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGlzTGF6eSA9IHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIsXG4gICAgICAgICAgICBpdGVyYXRlZSA9IGFyZ3NbMF0sXG4gICAgICAgICAgICB1c2VMYXp5ID0gaXNMYXp5IHx8IGlzQXJyYXkodmFsdWUpO1xuXG4gICAgICAgIHZhciBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaEZ1bmMuYXBwbHkobG9kYXNoLCBhcnJheVB1c2goW3ZhbHVlXSwgYXJncykpO1xuICAgICAgICAgIHJldHVybiAoaXNUYWtlciAmJiBjaGFpbkFsbCkgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHVzZUxhenkgJiYgY2hlY2tJdGVyYXRlZSAmJiB0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyAmJiBpdGVyYXRlZS5sZW5ndGggIT0gMSkge1xuICAgICAgICAgIC8vIEF2b2lkIGxhenkgdXNlIGlmIHRoZSBpdGVyYXRlZSBoYXMgYSBcImxlbmd0aFwiIHZhbHVlIG90aGVyIHRoYW4gYDFgLlxuICAgICAgICAgIGlzTGF6eSA9IHVzZUxhenkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXyxcbiAgICAgICAgICAgIGlzSHlicmlkID0gISF0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCxcbiAgICAgICAgICAgIGlzVW53cmFwcGVkID0gcmV0VW53cmFwcGVkICYmICFjaGFpbkFsbCxcbiAgICAgICAgICAgIG9ubHlMYXp5ID0gaXNMYXp5ICYmICFpc0h5YnJpZDtcblxuICAgICAgICBpZiAoIXJldFVud3JhcHBlZCAmJiB1c2VMYXp5KSB7XG4gICAgICAgICAgdmFsdWUgPSBvbmx5TGF6eSA/IHZhbHVlIDogbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgICAgICByZXN1bHQuX19hY3Rpb25zX18ucHVzaCh7ICdmdW5jJzogdGhydSwgJ2FyZ3MnOiBbaW50ZXJjZXB0b3JdLCAndGhpc0FyZyc6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIocmVzdWx0LCBjaGFpbkFsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW53cmFwcGVkICYmIG9ubHlMYXp5KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgICAgcmV0dXJuIGlzVW53cmFwcGVkID8gKGlzVGFrZXIgPyByZXN1bHQudmFsdWUoKVswXSA6IHJlc3VsdC52YWx1ZSgpKSA6IHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYEFycmF5YCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBhcnJheUVhY2goWydwb3AnLCAncHVzaCcsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlQcm90b1ttZXRob2ROYW1lXSxcbiAgICAgICAgICBjaGFpbk5hbWUgPSAvXig/OnB1c2h8c29ydHx1bnNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSkgPyAndGFwJyA6ICd0aHJ1JyxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSAvXig/OnBvcHxzaGlmdCkkLy50ZXN0KG1ldGhvZE5hbWUpO1xuXG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBpZiAocmV0VW53cmFwcGVkICYmICF0aGlzLl9fY2hhaW5fXykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10sIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2NoYWluTmFtZV0oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10sIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBNYXAgbWluaWZpZWQgbWV0aG9kIG5hbWVzIHRvIHRoZWlyIHJlYWwgbmFtZXMuXG4gICAgYmFzZUZvck93bihMYXp5V3JhcHBlci5wcm90b3R5cGUsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBsb2Rhc2hGdW5jID0gbG9kYXNoW21ldGhvZE5hbWVdO1xuICAgICAgaWYgKGxvZGFzaEZ1bmMpIHtcbiAgICAgICAgdmFyIGtleSA9IGxvZGFzaEZ1bmMubmFtZSArICcnO1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwocmVhbE5hbWVzLCBrZXkpKSB7XG4gICAgICAgICAgcmVhbE5hbWVzW2tleV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZWFsTmFtZXNba2V5XS5wdXNoKHsgJ25hbWUnOiBtZXRob2ROYW1lLCAnZnVuYyc6IGxvZGFzaEZ1bmMgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWFsTmFtZXNbY3JlYXRlSHlicmlkKHVuZGVmaW5lZCwgV1JBUF9CSU5EX0tFWV9GTEFHKS5uYW1lXSA9IFt7XG4gICAgICAnbmFtZSc6ICd3cmFwcGVyJyxcbiAgICAgICdmdW5jJzogdW5kZWZpbmVkXG4gICAgfV07XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTGF6eVdyYXBwZXJgLlxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jbG9uZSA9IGxhenlDbG9uZTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmV2ZXJzZSA9IGxhenlSZXZlcnNlO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS52YWx1ZSA9IGxhenlWYWx1ZTtcblxuICAgIC8vIEFkZCBjaGFpbiBzZXF1ZW5jZSBtZXRob2RzIHRvIHRoZSBgbG9kYXNoYCB3cmFwcGVyLlxuICAgIGxvZGFzaC5wcm90b3R5cGUuYXQgPSB3cmFwcGVyQXQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jaGFpbiA9IHdyYXBwZXJDaGFpbjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbW1pdCA9IHdyYXBwZXJDb21taXQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5uZXh0ID0gd3JhcHBlck5leHQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5wbGFudCA9IHdyYXBwZXJQbGFudDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnJldmVyc2UgPSB3cmFwcGVyUmV2ZXJzZTtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnRvSlNPTiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWVPZiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWUgPSB3cmFwcGVyVmFsdWU7XG5cbiAgICAvLyBBZGQgbGF6eSBhbGlhc2VzLlxuICAgIGxvZGFzaC5wcm90b3R5cGUuZmlyc3QgPSBsb2Rhc2gucHJvdG90eXBlLmhlYWQ7XG5cbiAgICBpZiAoc3ltSXRlcmF0b3IpIHtcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbc3ltSXRlcmF0b3JdID0gd3JhcHBlclRvSXRlcmF0b3I7XG4gICAgfVxuICAgIHJldHVybiBsb2Rhc2g7XG4gIH0pO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIEV4cG9ydCBsb2Rhc2guXG4gIHZhciBfID0gcnVuSW5Db250ZXh0KCk7XG5cbiAgLy8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2U6XG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEV4cG9zZSBMb2Rhc2ggb24gdGhlIGdsb2JhbCBvYmplY3QgdG8gcHJldmVudCBlcnJvcnMgd2hlbiBMb2Rhc2ggaXNcbiAgICAvLyBsb2FkZWQgYnkgYSBzY3JpcHQgdGFnIGluIHRoZSBwcmVzZW5jZSBvZiBhbiBBTUQgbG9hZGVyLlxuICAgIC8vIFNlZSBodHRwOi8vcmVxdWlyZWpzLm9yZy9kb2NzL2Vycm9ycy5odG1sI21pc21hdGNoIGZvciBtb3JlIGRldGFpbHMuXG4gICAgLy8gVXNlIGBfLm5vQ29uZmxpY3RgIHRvIHJlbW92ZSBMb2Rhc2ggZnJvbSB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICByb290Ll8gPSBfO1xuXG4gICAgLy8gRGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28sIHRocm91Z2ggcGF0aCBtYXBwaW5nLCBpdCBjYW4gYmVcbiAgICAvLyByZWZlcmVuY2VkIGFzIHRoZSBcInVuZGVyc2NvcmVcIiBtb2R1bGUuXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGBleHBvcnRzYCBhZnRlciBgZGVmaW5lYCBpbiBjYXNlIGEgYnVpbGQgb3B0aW1pemVyIGFkZHMgaXQuXG4gIGVsc2UgaWYgKGZyZWVNb2R1bGUpIHtcbiAgICAvLyBFeHBvcnQgZm9yIE5vZGUuanMuXG4gICAgKGZyZWVNb2R1bGUuZXhwb3J0cyA9IF8pLl8gPSBfO1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgc3VwcG9ydC5cbiAgICBmcmVlRXhwb3J0cy5fID0gXztcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBFeHBvcnQgdG8gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAgcm9vdC5fID0gXztcbiAgfVxufS5jYWxsKHRoaXMpKTtcbiIsIi8vIFRvRG8gLSB2YXJpYWJsZSBzZXBlcmF0aW9uXG5leHBvcnQgY29uc3QgQ09OU1RBTlRTID0ge1xuICAgIC8vIGhhc0NvcmRvdmE6IHdpbmRvd1snY29yZG92YSddICE9PSB1bmRlZmluZWQsXG4gICAgLy8gaXNXYXZlTGVuczogd2luZG93WydXYXZlTGVucyddICE9PSB1bmRlZmluZWQsXG4gICAgaXNTdHVkaW9Nb2RlOiBmYWxzZSxcbiAgICBpc1J1bk1vZGU6IHRydWUsXG4gICAgWFNSRl9DT09LSUVfTkFNRTogJ3dtX3hzcmZfdG9rZW4nLFxuICAgIERFRkFVTFRfVElNRVJfREVMQVk6IDUwMCxcbiAgICBXSURHRVRfRE9FU05UX0VYSVNUIDogJ1RoZSB3aWRnZXQgeW91XFwncmUgdHJ5aW5nIHRvIG5hdmlnYXRlIHRvIGRvZXNuXFwndCBleGlzdCBvbiB0aGlzIHBhZ2UnXG59O1xuZXhwb3J0IGNvbnN0IFZBUklBQkxFX0NPTlNUQU5UUyA9IHtcbiAgICBDQVRFR09SWToge1xuICAgICAgICBNT0RFTDogJ3dtLlZhcmlhYmxlJyxcbiAgICAgICAgTElWRTogJ3dtLkxpdmVWYXJpYWJsZScsXG4gICAgICAgIENSVUQ6ICd3bS5DcnVkVmFyaWFibGUnLFxuICAgICAgICBTRVJWSUNFOiAnd20uU2VydmljZVZhcmlhYmxlJyxcbiAgICAgICAgV0VCU09DS0VUOiAnd20uV2ViU29ja2V0VmFyaWFibGUnLFxuICAgICAgICBOQVZJR0FUSU9OOiAnd20uTmF2aWdhdGlvblZhcmlhYmxlJyxcbiAgICAgICAgTk9USUZJQ0FUSU9OOiAnd20uTm90aWZpY2F0aW9uVmFyaWFibGUnLFxuICAgICAgICBUSU1FUjogJ3dtLlRpbWVyVmFyaWFibGUnLFxuICAgICAgICBMT0dJTjogJ3dtLkxvZ2luVmFyaWFibGUnLFxuICAgICAgICBMT0dPVVQ6ICd3bS5Mb2dvdXRWYXJpYWJsZScsXG4gICAgICAgIERFVklDRTogJ3dtLkRldmljZVZhcmlhYmxlJ1xuICAgIH0sXG4gICAgRVZFTlRTOiBbJ29uQmVmb3JlJyxcbiAgICAgICAgJ29uQmVmb3JlVXBkYXRlJyxcbiAgICAgICAgJ29uUmVzdWx0JyxcbiAgICAgICAgJ29uQmVmb3JlT3BlbicsXG4gICAgICAgICdvbk9wZW4nLFxuICAgICAgICAnb25CZWZvcmVNZXNzYWdlU2VuZCcsXG4gICAgICAgICdvbk1lc3NhZ2VSZWNlaXZlJyxcbiAgICAgICAgJ29uUHJvZ3Jlc3MnLFxuICAgICAgICAnb25FcnJvcicsXG4gICAgICAgICdvbkJlZm9yZURhdGFzZXRSZWFkeScsXG4gICAgICAgICdvbkNhblVwZGF0ZScsXG4gICAgICAgICdvbkNsaWNrJyxcbiAgICAgICAgJ29uSGlkZScsXG4gICAgICAgICdvbk9rJyxcbiAgICAgICAgJ29uQ2FuY2VsJyxcbiAgICAgICAgJ29uQmVmb3JlQ2xvc2UnLFxuICAgICAgICAnb25DbG9zZScsXG4gICAgICAgICdvblRpbWVyRmlyZScsXG4gICAgICAgICdvblN1Y2Nlc3MnLFxuICAgICAgICAnb25PbmxpbmUnLFxuICAgICAgICAnb25PZmZsaW5lJ10sXG4gICAgRVZFTlQ6IHtcbiAgICAgICAgJ0NBTl9VUERBVEUnOiAnb25DYW5VcGRhdGUnLFxuICAgICAgICAnQkVGT1JFJzogJ29uQmVmb3JlJyxcbiAgICAgICAgJ0JFRk9SRV9VUERBVEUnOiAnb25CZWZvcmVVcGRhdGUnLFxuICAgICAgICAnUFJFUEFSRV9TRVREQVRBJzogJ29uQmVmb3JlRGF0YXNldFJlYWR5JyxcbiAgICAgICAgJ1JFU1VMVCc6ICdvblJlc3VsdCcsXG4gICAgICAgICdFUlJPUic6ICdvbkVycm9yJyxcbiAgICAgICAgJ0FCT1JUJzogJ29uQWJvcnQnLFxuICAgICAgICAnUFJPR1JFU1MnOiAnb25Qcm9ncmVzcycsXG4gICAgICAgICdDTElDSyc6ICdvbkNsaWNrJyxcbiAgICAgICAgJ0hJREUnOiAnb25IaWRlJyxcbiAgICAgICAgJ09LJzogJ29uT2snLFxuICAgICAgICAnQ0FOQ0VMJzogJ29uQ2FuY2VsJyxcbiAgICAgICAgJ0NMT1NFJzogJ29uQ2xvc2UnLFxuICAgICAgICAnVElNRVJfRklSRSc6ICdvblRpbWVyRmlyZScsXG4gICAgICAgICdTVUNDRVNTJzogJ29uU3VjY2VzcycsXG4gICAgICAgICdCRUZPUkVfT1BFTic6ICdvbkJlZm9yZU9wZW4nLFxuICAgICAgICAnT1BFTic6ICdvbk9wZW4nLFxuICAgICAgICAnQkVGT1JFX1NFTkQnOiAnb25CZWZvcmVNZXNzYWdlU2VuZCcsXG4gICAgICAgICdNRVNTQUdFX1JFQ0VJVkUnOiAnb25NZXNzYWdlUmVjZWl2ZScsXG4gICAgICAgICdCRUZPUkVfQ0xPU0UnOiAnb25CZWZvcmVDbG9zZSdcbiAgICB9LFxuICAgIE9XTkVSOiB7XG4gICAgICAgICdBUFAnOiAnQXBwJyxcbiAgICAgICAgJ1BBR0UnOiAnUGFnZSdcbiAgICB9LFxuICAgIFJFU1RfU1VQUE9SVEVEX1NFUlZJQ0VTOiBbJ0phdmFTZXJ2aWNlJywgJ1NvYXBTZXJ2aWNlJywgJ0ZlZWRTZXJ2aWNlJywgJ1Jlc3RTZXJ2aWNlJywgJ1NlY3VyaXR5U2VydmljZVR5cGUnLCAnRGF0YVNlcnZpY2UnLCAnV2ViU29ja2V0U2VydmljZScsICdPcGVuQVBJU2VydmljZSddLFxuICAgIFBBR0lOQVRJT05fUEFSQU1TOiBbJ3BhZ2UnLCAnc2l6ZScsICdzb3J0J10sXG4gICAgUkVTVF9TRVJWSUNFOiB7XG4gICAgICAgICdCQVNFX1BBVEhfS0VZJzogJ3gtV00tQkFTRV9QQVRIJyxcbiAgICAgICAgJ1JFTEFUSVZFX1BBVEhfS0VZJzogJ3gtV00tUkVMQVRJVkVfUEFUSCcsXG4gICAgICAgICdPQVVUSF9QUk9WSURFUl9LRVknOiAneC1XTS1QUk9WSURFUl9JRCcsXG4gICAgICAgICdBVVRIX0hEUl9LRVknOiAnQXV0aG9yaXphdGlvbicsXG4gICAgICAgICdTRUNVUklUWV9ERUZOJzoge1xuICAgICAgICAgICAgJ0JBU0lDJzogJ2Jhc2ljJyxcbiAgICAgICAgICAgICdPQVVUSDInOiAnb2F1dGgyJyxcbiAgICAgICAgfSxcbiAgICAgICAgJ0FVVEhfVFlQRSc6IHtcbiAgICAgICAgICAgICdCQVNJQyc6ICdCQVNJQycsXG4gICAgICAgICAgICAnT0FVVEgnOiAnT0FVVEgyJyxcbiAgICAgICAgICAgICdOT05FJzogJ05PTkUnLFxuICAgICAgICB9LFxuICAgICAgICAnQ09OVEVOVF9UWVBFX0tFWSc6ICd4LVdNLUNPTlRFTlRfVFlQRScsXG4gICAgICAgICdBQ0NFU1NUT0tFTl9QTEFDRUhPTERFUic6IHtcbiAgICAgICAgICAgICdMRUZUJzogJycsXG4gICAgICAgICAgICAnUklHSFQnOiAnLmFjY2Vzc190b2tlbidcbiAgICAgICAgfSxcbiAgICAgICAgRVJSX1RZUEU6IHtcbiAgICAgICAgICAgIE5PX0FDQ0VTU1RPS0VOOiAnbWlzc2luZ19hY2Nlc3N0b2tlbicsXG4gICAgICAgICAgICBOT19DUkVERU5USUFMUzogJ25vX2NyZWRlbnRpYWxzJyxcbiAgICAgICAgICAgIE1FVEFEQVRBX01JU1NJTkc6ICdtZXRhZGF0YV9taXNzaW5nJyxcbiAgICAgICAgICAgIENSVURfT1BFUkFUSU9OX01JU1NJTkc6ICdjcnVkX29wZXJhdGlvbl9taXNzaW5nJyxcbiAgICAgICAgICAgIFVTRVJfVU5BVVRIT1JJU0VEOiAndXNlcl91bmF1dGhvcmlzZWQnLFxuICAgICAgICAgICAgUkVRVUlSRURfRklFTERfTUlTU0lORzogJ3JlcXVpcmVkX2ZpZWxkX21pc3NpbmcnLFxuICAgICAgICB9LFxuICAgICAgICBFUlJfTVNHOiB7XG4gICAgICAgICAgICBOT19BQ0NFU1NUT0tFTjogJ0FjY2VzcyB0b2tlbiBtaXNzaW5nJyxcbiAgICAgICAgICAgIE5PX0NSRURFTlRJQUxTOiAnTm8gY3JlZGVudGlhbHMgcHJlc2VudCcsXG4gICAgICAgICAgICBNRVRBREFUQV9NSVNTSU5HOiAnTWV0YWRhdGEgbWlzc2luZyBmb3IgXCIkdmFyaWFibGVcIicsXG4gICAgICAgICAgICBVU0VSX1VOQVVUSE9SSVNFRDogJ1VuYXV0aG9yaXplZCBVc2VyJyxcbiAgICAgICAgICAgIENSVURfT1BFUkFUSU9OX01JU1NJTkc6ICdPcGVyYXRpb24gXCIkb3BlcmF0aW9uXCIgbm90IGFsbG93ZWQgZm9yIFwiJHZhcmlhYmxlXCInLFxuICAgICAgICAgICAgUkVRVUlSRURfRklFTERfTUlTU0lORzogJ1JlcXVpcmVkIGZpZWxkKHMpIG1pc3Npbmc6IFwiJHswfVwiJ1xuICAgICAgICB9LFxuICAgICAgICBVTkNMT0FLRURfSEVBREVSUzogWydDT05URU5ULVRZUEUnLCAnQUNDRVBUJywgJ0NPTlRFTlQtTEVOR1RIJywgJ0FDQ0VQVC1FTkNPRElORycsICdBQ0NFUFQtTEFOR1VBR0UnXSxcbiAgICAgICAgUFJFRklYOiB7XG4gICAgICAgICAgICBBVVRIX0hEUl9WQUw6IHtcbiAgICAgICAgICAgICAgICBCQVNJQzogJ0Jhc2ljJyxcbiAgICAgICAgICAgICAgICBPQVVUSDogJ0JlYXJlcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDTE9BS19IRUFERVJfS0VZOiAnWC1XTS0nXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFNFUlZJQ0VfVFlQRToge1xuICAgICAgICBKQVZBOiAnSmF2YVNlcnZpY2UnLFxuICAgICAgICBSRVNUOiAnUmVzdFNlcnZpY2UnLFxuICAgICAgICBTT0FQOiAnU29hcFNlcnZpY2UnLFxuICAgICAgICBGRUVEOiAnRmVlZFNlcnZpY2UnLFxuICAgICAgICBEQVRBOiAnRGF0YVNlcnZpY2UnLFxuICAgICAgICBTRUNVUklUWTogJ1NlY3VyaXR5U2VydmljZVR5cGUnLFxuICAgICAgICBXRUJTT0NLRVQ6ICdXZWJTb2NrZXRTZXJ2aWNlJyxcbiAgICAgICAgT1BFTkFQSTogJ09wZW5BUElTZXJ2aWNlJ1xuICAgIH0sXG4gICAgQ09OVFJPTExFUl9UWVBFOiB7XG4gICAgICAgIFFVRVJZOiAnUXVlcnlFeGVjdXRpb24nLFxuICAgICAgICBQUk9DRURVUkU6ICdQcm9jZWR1cmVFeGVjdXRpb24nXG4gICAgfSxcbiAgICBIVFRQX1NUQVRVU19DT0RFOiB7XG4gICAgICAgIENPUlNfRkFJTFVSRTogLTEsXG4gICAgICAgIFVOQVVUSE9SSVpFRDogNDAxLFxuICAgICAgICBGT1JCSURERU46IDQwM1xuICAgIH0sXG4gICAgRVhQT1JUX1RZUEVTX01BUDoge1xuICAgICAgICAnRVhDRUwnIDogJy54bHN4JyxcbiAgICAgICAgJ0NTVicgOiAnLmNzdid9LFxuICAgIERFRkFVTFRfVkFSIDoge1xuICAgICAgICAnTk9USUZJQ0FUSU9OJyA6ICdhcHBOb3RpZmljYXRpb24nXG4gICAgfVxufTtcblxuZXhwb3J0IGNvbnN0IFdTX0NPTlNUQU5UUyA9IHtcbiAgICBOT05fQk9EWV9IVFRQX01FVEhPRFM6IFsnR0VUJywgJ0hFQUQnXSxcbiAgICBDT05URU5UX1RZUEVTOiB7XG4gICAgICAgIEZPUk1fVVJMX0VOQ09ERUQ6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICBNVUxUSVBBUlRfRk9STURBVEE6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJyxcbiAgICAgICAgT0NURVRfU1RSRUFNOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJ1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBEQl9DT05TVEFOVFMgPSB7XG4gICAgJ0RBVEFCQVNFX01BVENIX01PREVTJzoge1xuICAgICAgICAnbGlrZScgICAgICAgICAgICAgOiAnTElLRScsXG4gICAgICAgICdzdGFydCcgICAgICAgICAgICA6ICdTVEFSVElOR19XSVRIJyxcbiAgICAgICAgJ3N0YXJ0aWdub3JlY2FzZScgIDogJ1NUQVJUSU5HX1dJVEhfSUdOT1JFQ0FTRScsXG4gICAgICAgICdlbmQnICAgICAgICAgICAgICA6ICdFTkRJTkdfV0lUSCcsXG4gICAgICAgICdlbmRpZ25vcmVjYXNlJyAgICA6ICdFTkRJTkdfV0lUSF9JR05PUkVDQVNFJyxcbiAgICAgICAgJ2FueXdoZXJlJyAgICAgICAgIDogJ0NPTlRBSU5JTkcnLFxuICAgICAgICAnYW55d2hlcmVpZ25vcmVjYXNlJzogJ0NPTlRBSU5JTkdfSUdOT1JFQ0FTRScsXG4gICAgICAgICdub3doZXJlJyAgICAgICAgICA6ICdET0VTX05PVF9DT05UQUlOJyxcbiAgICAgICAgJ25vd2hlcmVpZ25vcmVjYXNlJzogJ0RPRVNfTk9UX0NPTlRBSU5fSUdOT1JFQ0FTRScsXG4gICAgICAgICdleGFjdCcgICAgICAgICAgICA6ICdFUVVBTFMnLFxuICAgICAgICAnZXhhY3RpZ25vcmVjYXNlJyAgOiAnRVFVQUxTX0lHTk9SRUNBU0UnLFxuICAgICAgICAnbm90ZXF1YWxzJyAgICAgICAgOiAnTk9UX0VRVUFMUycsXG4gICAgICAgIFwibm90ZXF1YWxzaWdub3JlY2FzZVwiOiBcIk5PVF9FUVVBTFNfSUdOT1JFQ0FTRVwiLFxuICAgICAgICAnYmV0d2VlbicgICAgICAgICAgOiAnQkVUV0VFTicsXG4gICAgICAgICdpbicgICAgICAgICAgICAgICA6ICdJTicsXG4gICAgICAgIFwibm90aW5cIiAgICAgICAgICAgIDogXCJOT1RJTlwiLFxuICAgICAgICAnbGVzc3RoYW4nICAgICAgICAgOiAnTEVTU19USEFOJyxcbiAgICAgICAgJ2xlc3N0aGFuZXF1YWwnICAgIDogJ0xFU1NfVEhBTl9PUl9FUVVBTFMnLFxuICAgICAgICAnZ3JlYXRlcnRoYW4nICAgICAgOiAnR1JFQVRFUl9USEFOJyxcbiAgICAgICAgJ2dyZWF0ZXJ0aGFuZXF1YWwnIDogJ0dSRUFURVJfVEhBTl9PUl9FUVVBTFMnLFxuICAgICAgICAnbnVsbCcgICAgICAgICAgICAgOiAnTlVMTCcsXG4gICAgICAgICdpc25vdG51bGwnICAgICAgICA6ICdJU19OT1RfTlVMTCcsXG4gICAgICAgICdlbXB0eScgICAgICAgICAgICA6ICdFTVBUWScsXG4gICAgICAgICdpc25vdGVtcHR5JyAgICAgICA6ICdJU19OT1RfRU1QVFknLFxuICAgICAgICAnbnVsbG9yZW1wdHknICAgICAgOiAnTlVMTF9PUl9FTVBUWSdcbiAgICB9LFxuICAgICdEQVRBQkFTRV9FTVBUWV9NQVRDSF9NT0RFUyc6IFsnTlVMTCcsICdJU19OT1RfTlVMTCcsICdFTVBUWScsICdJU19OT1RfRU1QVFknLCAnTlVMTF9PUl9FTVBUWSddLFxuICAgICdEQVRBQkFTRV9SQU5HRV9NQVRDSF9NT0RFUyc6IFsnSU4nLCAnTk9USU4nLCAnQkVUV0VFTicsICdMRVNTX1RIQU4nLCAnTEVTU19USEFOX09SX0VRVUFMUycsICdHUkVBVEVSX1RIQU4nLCAnR1JFQVRFUl9USEFOX09SX0VRVUFMUycsICdOT1RfRVFVQUxTJ10sXG4gICAgJ0RBVEFCQVNFX05VTExfRU1QVFlfTUFUQ0gnOiB7XG4gICAgICAgICdOVUxMJyAgICAgICAgICA6ICdOVUxMJyxcbiAgICAgICAgJ0lTX05PVF9OVUxMJyAgIDogJ0lTX05PVF9OVUxMJyxcbiAgICAgICAgJ0VNUFRZJyAgICAgICAgIDogJ05VTEwnLFxuICAgICAgICAnSVNfTk9UX0VNUFRZJyAgOiAnSVNfTk9UX05VTEwnLFxuICAgICAgICAnTlVMTF9PUl9FTVBUWScgOiAnTlVMTCdcbiAgICB9LFxuICAgICdEQVRBQkFTRV9NQVRDSF9NT0RFU19XSVRIX1FVRVJZJzoge1xuICAgICAgICAnTElLRScgICAgICAgICAgICAgICAgICAgOiAnJHswfSBsaWtlICR7MX0nLFxuICAgICAgICAnU1RBUlRJTkdfV0lUSCcgICAgICAgICAgOiAnJHswfSBsaWtlICR7MX0nLFxuICAgICAgICAnU1RBUlRJTkdfV0lUSF9JR05PUkVDQVNFJzogJyR7MH0gbGlrZSAkezF9JyxcbiAgICAgICAgJ0VORElOR19XSVRIJyAgICAgICAgICAgIDogJyR7MH0gbGlrZSAkezF9JyxcbiAgICAgICAgJ0VORElOR19XSVRIX0lHTk9SRUNBU0UnIDogJyR7MH0gbGlrZSAkezF9JyxcbiAgICAgICAgJ0NPTlRBSU5JTkcnICAgICAgICAgICAgIDogJyR7MH0gbGlrZSAkezF9JyxcbiAgICAgICAgJ0NPTlRBSU5JTkdfSUdOT1JFQ0FTRScgIDogJyR7MH0gbGlrZSAkezF9JyxcbiAgICAgICAgJ0RPRVNfTk9UX0NPTlRBSU4nICAgICAgIDogJyR7MH0gbm90IGxpa2UgJHsxfScsXG4gICAgICAgICdET0VTX05PVF9DT05UQUlOX0lHTk9SRUNBU0UnOiAnJHswfSBub3QgbGlrZSAkezF9JyxcbiAgICAgICAgJ0VRVUFMUycgICAgICAgICAgICAgICAgIDogJyR7MH09JHsxfScsXG4gICAgICAgICdFUVVBTFNfSUdOT1JFQ0FTRScgICAgICA6ICckezB9PSR7MX0nLFxuICAgICAgICAnTk9UX0VRVUFMUycgICAgICAgICAgICAgOiAnJHswfSE9JHsxfScsXG4gICAgICAgIFwiTk9UX0VRVUFMU19JR05PUkVDQVNFXCIgIDogXCIkezB9IT0kezF9XCIsXG4gICAgICAgICdCRVRXRUVOJyAgICAgICAgICAgICAgICA6ICckezB9IGJldHdlZW4gJHsxfScsXG4gICAgICAgICdJTicgICAgICAgICAgICAgICAgICAgICA6ICckezB9IGluICR7MX0nLFxuICAgICAgICAnTk9USU4nICAgICAgICAgICAgICAgICAgOiBcIiR7MH0gbm90IGluICR7MX1cIixcbiAgICAgICAgJ0xFU1NfVEhBTicgICAgICAgICAgICAgIDogJyR7MH08JHsxfScsXG4gICAgICAgICdMRVNTX1RIQU5fT1JfRVFVQUxTJyAgICA6ICckezB9PD0kezF9JyxcbiAgICAgICAgJ0dSRUFURVJfVEhBTicgICAgICAgICAgIDogJyR7MH0+JHsxfScsXG4gICAgICAgICdHUkVBVEVSX1RIQU5fT1JfRVFVQUxTJyA6ICckezB9Pj0kezF9JyxcbiAgICAgICAgJ05VTEwnICAgICAgICAgICAgICAgICAgIDogJyR7MH0gaXMgbnVsbCcsXG4gICAgICAgICdJU19OT1RfTlVMTCcgICAgICAgICAgICA6ICckezB9IGlzIG5vdCBudWxsJyxcbiAgICAgICAgJ0VNUFRZJyAgICAgICAgICAgICAgICAgIDogJyR7MH09XFwnXFwnJyxcbiAgICAgICAgJ0lTX05PVF9FTVBUWScgICAgICAgICAgIDogJyR7MH08PlxcJ1xcJycsXG4gICAgICAgICdOVUxMX09SX0VNUFRZJyAgICAgICAgICA6ICckezB9IGlzIG51bGwgb3IgJHswfT1cXCdcXCcnXG4gICAgfSxcbiAgICAnREFUQUJBU0VfU1RSSU5HX01PREVTJzogWydMSUtFJywgJ1NUQVJUSU5HX1dJVEgnLCAnU1RBUlRJTkdfV0lUSF9JR05PUkVDQVNFJywgJ0VORElOR19XSVRIJywgJ0VORElOR19XSVRIX0lHTk9SRUNBU0UnLCAnQ09OVEFJTklORycsICdDT05UQUlOSU5HX0lHTk9SRUNBU0UnLCAnRE9FU19OT1RfQ09OVEFJTicsICdET0VTX05PVF9DT05UQUlOX0lHTk9SRUNBU0UnLCAnRVFVQUxTJywgJ0VRVUFMU19JR05PUkVDQVNFJywgJ05PVF9FUVVBTFMnLCBcIk5PVF9FUVVBTFNfSUdOT1JFQ0FTRVwiXVxufTtcblxuZXhwb3J0IGNvbnN0IFNXQUdHRVJfQ09OU1RBTlRTID0ge1xuICAgIFdNX0RBVEFfSlNPTjogJ3dtX2RhdGFfanNvbicsXG4gICAgV01fSFRUUF9KU09OOiAnd21faHR0cFJlcXVlc3REZXRhaWxzJ1xufTtcblxuZXhwb3J0IGNvbnN0IFZBUklBQkxFX1VSTFMgPSB7XG4gICAgREFUQUJBU0U6IHtcbiAgICBzZWFyY2hUYWJsZURhdGE6IHtcbiAgICAgICAgdXJsOiAnLzpzZXJ2aWNlLzpkYXRhTW9kZWxOYW1lLzplbnRpdHlOYW1lL3NlYXJjaD9wYWdlPTpwYWdlJnNpemU9OnNpemUmOnNvcnQnLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcbiAgICB9LFxuICAgIHNlYXJjaFRhYmxlRGF0YVdpdGhRdWVyeToge1xuICAgICAgICB1cmw6ICcvOnNlcnZpY2UvOmRhdGFNb2RlbE5hbWUvOmVudGl0eU5hbWUvZmlsdGVyP3BhZ2U9OnBhZ2Umc2l6ZT06c2l6ZSY6c29ydCcsXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZWFkVGFibGVEYXRhOiB7XG4gICAgICAgIHVybDogJy86c2VydmljZS86ZGF0YU1vZGVsTmFtZS86ZW50aXR5TmFtZT9wYWdlPTpwYWdlJnNpemU9OnNpemUmOnNvcnQnLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJ1xuICAgIH0sXG4gICAgaW5zZXJ0VGFibGVEYXRhOiB7XG4gICAgICAgIHVybDogJy86c2VydmljZS86ZGF0YU1vZGVsTmFtZS86ZW50aXR5TmFtZScsXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJ1xuICAgIH0sXG4gICAgaW5zZXJ0TXVsdGlQYXJ0VGFibGVEYXRhOiB7XG4gICAgICAgIHVybDogJy86c2VydmljZS86ZGF0YU1vZGVsTmFtZS86ZW50aXR5TmFtZScsXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHt9XG4gICAgICAgICAgICAvLyAsdHJhbnNmb3JtUmVxdWVzdDogV00uaWRlbnRpdHlcbiAgICB9LFxuICAgIHVwZGF0ZVRhYmxlRGF0YToge1xuICAgICAgICB1cmw6ICcvOnNlcnZpY2UvOmRhdGFNb2RlbE5hbWUvOmVudGl0eU5hbWUvOmlkJyxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCdcbiAgICB9LFxuICAgIHVwZGF0ZU11bHRpUGFydFRhYmxlRGF0YToge1xuICAgICAgICB1cmw6ICcvOnNlcnZpY2UvOmRhdGFNb2RlbE5hbWUvOmVudGl0eU5hbWUvOmlkJyxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczoge31cbiAgICAgICAgICAgIC8vICx0cmFuc2Zvcm1SZXF1ZXN0OiBXTS5pZGVudGl0eVxuICAgIH0sXG4gICAgZGVsZXRlVGFibGVEYXRhOiB7XG4gICAgICAgIHVybDogJy86c2VydmljZS86ZGF0YU1vZGVsTmFtZS86ZW50aXR5TmFtZS86aWQnLFxuICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJ1xuICAgIH0sXG4gICAgdXBkYXRlQ29tcG9zaXRlVGFibGVEYXRhOiB7XG4gICAgICAgIHVybDogJy86c2VydmljZS86ZGF0YU1vZGVsTmFtZS86ZW50aXR5TmFtZS9jb21wb3NpdGUtaWQ/OmlkJyxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCdcbiAgICB9LFxuICAgIHBlcmlvZFVwZGF0ZUNvbXBvc2l0ZVRhYmxlRGF0YToge1xuICAgICAgICB1cmw6ICcvOnNlcnZpY2UvOmRhdGFNb2RlbE5hbWUvOmVudGl0eU5hbWUvY29tcG9zaXRlLWlkL3BlcmlvZHM/OmlkJyxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCdcbiAgICB9LFxuICAgIHVwZGF0ZU11bHRpUGFydENvbXBvc2l0ZVRhYmxlRGF0YToge1xuICAgICAgICB1cmw6ICcvOnNlcnZpY2UvOmRhdGFNb2RlbE5hbWUvOmVudGl0eU5hbWUvY29tcG9zaXRlLWlkPzppZCcsXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHt9XG4gICAgICAgICAgICAvLyAsIHRyYW5zZm9ybVJlcXVlc3Q6IFdNLmlkZW50aXR5XG4gICAgfSxcbiAgICBkZWxldGVDb21wb3NpdGVUYWJsZURhdGE6IHtcbiAgICAgICAgdXJsOiAnLzpzZXJ2aWNlLzpkYXRhTW9kZWxOYW1lLzplbnRpdHlOYW1lL2NvbXBvc2l0ZS1pZD86aWQnLFxuICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJ1xuICAgIH0sXG4gICAgcGVyaW9kRGVsZXRlQ29tcG9zaXRlVGFibGVEYXRhOiB7XG4gICAgICAgIHVybDogJy86c2VydmljZS86ZGF0YU1vZGVsTmFtZS86ZW50aXR5TmFtZS9jb21wb3NpdGUtaWQvcGVyaW9kcz86aWQnLFxuICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJ1xuICAgIH0sXG4gICAgZ2V0RGlzdGluY3REYXRhQnlGaWVsZHM6IHtcbiAgICAgICAgdXJsOiAnLzpzZXJ2aWNlLzpkYXRhTW9kZWxOYW1lLzplbnRpdHlOYW1lL2FnZ3JlZ2F0aW9ucz9wYWdlPTpwYWdlJnNpemU9OnNpemUmOnNvcnQnLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcbiAgICB9LFxuICAgIGV4cG9ydFRhYmxlRGF0YToge1xuICAgICAgICB1cmw6ICcvc2VydmljZXMvOmRhdGFNb2RlbE5hbWUvOmVudGl0eU5hbWUvZXhwb3J0Pzpzb3J0JyxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnXG4gICAgfSxcbiAgICByZWFkVGFibGVSZWxhdGVkRGF0YToge1xuICAgICAgICB1cmw6ICcvOnNlcnZpY2UvOmRhdGFNb2RlbE5hbWUvOmVudGl0eU5hbWUvOmlkLzpyZWxhdGVkRmllbGROYW1lP3BhZ2U9OnBhZ2Umc2l6ZT06c2l6ZSY6c29ydCcsXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnXG4gICAgfSxcbiAgICBleGVjdXRlTmFtZWRRdWVyeToge1xuICAgICAgICB1cmw6ICcvOnNlcnZpY2UvOmRhdGFNb2RlbE5hbWUvcXVlcnlFeGVjdXRvci9xdWVyaWVzLzpxdWVyeU5hbWU/cGFnZT06cGFnZSZzaXplPTpzaXplJjpxdWVyeVBhcmFtcycsXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnXG4gICAgfSxcbiAgICBleGVjdXRlQ3VzdG9tUXVlcnk6IHtcbiAgICAgICAgdXJsOiAnLzpzZXJ2aWNlLzpkYXRhTW9kZWxOYW1lL3F1ZXJpZXMvZXhlY3V0ZT9wYWdlPTpwYWdlJnNpemU9OnNpemUnLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcbiAgICB9LFxuICAgIGV4ZWN1dGVBZ2dyZWdhdGVRdWVyeToge1xuICAgICAgICB1cmw6ICcvc2VydmljZXMvOmRhdGFNb2RlbE5hbWUvOmVudGl0eU5hbWUvYWdncmVnYXRpb25zP3BhZ2U9OnBhZ2Umc2l6ZT06c2l6ZSZzb3J0PTpzb3J0JyxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnXG4gICAgfSxcbiAgICBleGVjdXRlTmFtZWRQcm9jZWR1cmU6IHtcbiAgICAgICAgdXJsOiAnLzpzZXJ2aWNlLzpkYXRhTW9kZWxOYW1lL3Byb2NlZHVyZUV4ZWN1dG9yL3Byb2NlZHVyZS9leGVjdXRlLzpwcm9jZWR1cmVOYW1lP3BhZ2U9OnBhZ2Umc2l6ZT06c2l6ZSY6cHJvY2VkdXJlUGFyYW1zJyxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCdcbiAgICB9LFxuICAgIGNvdW50VGFibGVEYXRhV2l0aFF1ZXJ5OiB7XG4gICAgICAgIHVybDogJy86c2VydmljZS86ZGF0YU1vZGVsTmFtZS86ZW50aXR5TmFtZS9jb3VudD86cXVlcnlQYXJhbXMnLFxuICAgICAgICBtZXRob2Q6ICdHRVQnXG4gICAgfVxufSxcbiAgICBvYXV0aENvbmZpZ3VyYXRpb24gOiB7XG4gICAgICAgIGdldEF1dGhvcml6YXRpb25Vcmw6IHtcbiAgICAgICAgICAgIHVybDogJ3NlcnZpY2VzL29hdXRoMi86cHJvdmlkZXJJZC9hdXRob3JpemF0aW9uVXJsJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnXG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgY29uc3QgJHJvb3RTY29wZSA9IHtcbiAgICBwcm9qZWN0OiB7XG4gICAgICAgIGRlcGxveWVkVXJsOiAnLi8nLFxuICAgICAgICBpZDogJ3RlbXBfaWQnXG4gICAgfSxcbiAgICBwcm9qZWN0TmFtZTogJ3Rlc3RfcHJvamVjdF9uYW1lJyxcbiAgICBpc0FwcGxpY2F0aW9uVHlwZTogdHJ1ZVxufTtcbiIsImltcG9ydCB7IFNlcnZpY2VWYXJpYWJsZU1hbmFnZXIgfSBmcm9tICcuLi9tYW5hZ2VyL3ZhcmlhYmxlL3NlcnZpY2UtdmFyaWFibGUubWFuYWdlcic7XG5pbXBvcnQgeyBNb2RlbFZhcmlhYmxlTWFuYWdlciB9IGZyb20gJy4uL21hbmFnZXIvdmFyaWFibGUvbW9kZWwtdmFyaWFibGUubWFuYWdlcic7XG5pbXBvcnQgeyBMaXZlVmFyaWFibGVNYW5hZ2VyIH0gZnJvbSAnLi4vbWFuYWdlci92YXJpYWJsZS9saXZlLXZhcmlhYmxlLm1hbmFnZXInO1xuaW1wb3J0IHsgQ3J1ZFZhcmlhYmxlTWFuYWdlciB9IGZyb20gJy4uL21hbmFnZXIvdmFyaWFibGUvY3J1ZC12YXJpYWJsZS5tYW5hZ2VyJztcbmltcG9ydCB7IEJhc2VWYXJpYWJsZU1hbmFnZXIgfSBmcm9tICcuLi9tYW5hZ2VyL3ZhcmlhYmxlL2Jhc2UtdmFyaWFibGUubWFuYWdlcic7XG5pbXBvcnQgeyBUaW1lckFjdGlvbk1hbmFnZXIgfSBmcm9tICcuLi9tYW5hZ2VyL2FjdGlvbi90aW1lci1hY3Rpb24ubWFuYWdlcic7XG5cbmNvbnN0IG1hbmFnZXJNYXAgPSBuZXcgTWFwKCksXG4gICAgdHlwZVRvTWFuYWdlck1hcCA9IHtcbiAgICAgICAgJ1ZhcmlhYmxlJzogQmFzZVZhcmlhYmxlTWFuYWdlcixcbiAgICAgICAgJ3dtLlZhcmlhYmxlJzogTW9kZWxWYXJpYWJsZU1hbmFnZXIsXG4gICAgICAgICd3bS5TZXJ2aWNlVmFyaWFibGUnOiBTZXJ2aWNlVmFyaWFibGVNYW5hZ2VyLFxuICAgICAgICAnd20uTGl2ZVZhcmlhYmxlJzogTGl2ZVZhcmlhYmxlTWFuYWdlcixcbiAgICAgICAgJ3dtLkNydWRWYXJpYWJsZSc6IENydWRWYXJpYWJsZU1hbmFnZXIsXG4gICAgICAgICd3bS5UaW1lclZhcmlhYmxlJzogVGltZXJBY3Rpb25NYW5hZ2VyLFxuICAgIH07XG5cbmV4cG9ydCBjbGFzcyBWYXJpYWJsZU1hbmFnZXJGYWN0b3J5IHtcblxuICAgIHN0YXRpYyBnZXQodHlwZTogYW55KSB7XG4gICAgICAgIHJldHVybiBtYW5hZ2VyTWFwLmhhcyh0eXBlKSA/XG4gICAgICAgICAgICBtYW5hZ2VyTWFwLmdldCh0eXBlKSA6XG4gICAgICAgICAgICBtYW5hZ2VyTWFwLnNldCh0eXBlLCBuZXcgdHlwZVRvTWFuYWdlck1hcFt0eXBlXSgpKS5nZXQodHlwZSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaXNEZWZpbmVkIH0gZnJvbSAnLi4vLi4vdXRpbC91dGlscyc7XG5cbmltcG9ydCB7IGluaXRpYXRlQ2FsbGJhY2sgfSBmcm9tICcuLi8uLi91dGlsL3ZhcmlhYmxlL3ZhcmlhYmxlcy51dGlscyc7XG5pbXBvcnQgeyBDT05TVEFOVFMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvdmFyaWFibGVzLmNvbnN0YW50cyc7XG5cbmV4cG9ydCBjbGFzcyBUaW1lckFjdGlvbk1hbmFnZXIge1xuICAgIHRyaWdnZXIodmFyaWFibGUsIG9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIGlmIChpc0RlZmluZWQodmFyaWFibGUuX3Byb21pc2UpIHx8IENPTlNUQU5UUy5pc1N0dWRpb01vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXBlYXRUaW1lciA9IHZhcmlhYmxlLnJlcGVhdGluZyxcbiAgICAgICAgICAgIGRlbGF5ID0gdmFyaWFibGUuZGVsYXkgfHwgQ09OU1RBTlRTLkRFRkFVTFRfVElNRVJfREVMQVksXG4gICAgICAgICAgICBldmVudCA9ICdvblRpbWVyRmlyZScsXG4gICAgICAgICAgICBleGVjID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGluaXRpYXRlQ2FsbGJhY2soZXZlbnQsIHZhcmlhYmxlLCB7fSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHZhcmlhYmxlLl9wcm9taXNlID0gcmVwZWF0VGltZXIgPyBzZXRJbnRlcnZhbChleGVjLCBkZWxheSkgOiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGV4ZWMoKTtcbiAgICAgICAgICAgIHZhcmlhYmxlLl9wcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB9LCBkZWxheSk7XG5cbiAgICAgICAgLyovLyBkZXN0cm95IHRoZSB0aW1lciBvbiBzY29wZSBkZXN0cnVjdGlvblxuICAgICAgICBjYWxsQmFja1Njb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXJpYWJsZS5jYW5jZWwodmFyaWFibGUuX3Byb21pc2UpO1xuICAgICAgICB9KTsqL1xuXG4gICAgICAgIHJldHVybiB2YXJpYWJsZS5fcHJvbWlzZTtcbiAgICB9XG5cbiAgICBjYW5jZWwodmFyaWFibGUpIHtcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh2YXJpYWJsZS5fcHJvbWlzZSkpIHtcbiAgICAgICAgICAgIGlmICh2YXJpYWJsZS5yZXBlYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHZhcmlhYmxlLl9wcm9taXNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHZhcmlhYmxlLl9wcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhcmlhYmxlLl9wcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaHR0cFNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlsL3ZhcmlhYmxlL3ZhcmlhYmxlcy51dGlscyc7XG5pbXBvcnQgeyBhcHBNYW5hZ2VyfSBmcm9tICcuLy4uLy4uL3V0aWwvdmFyaWFibGUvdmFyaWFibGVzLnV0aWxzJztcbmltcG9ydCB7IEFkdmFuY2VkT3B0aW9ucyB9IGZyb20gJy4uLy4uL2FkdmFuY2VkLW9wdGlvbnMnO1xuXG4vLyBkZWNsYXJlIGNvbnN0IF86IGFueTtcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlVmFyaWFibGVNYW5hZ2VyIHtcblxuICAgIGluaXRCaW5kaW5nKHZhcmlhYmxlOiBhbnksIGJpbmRTb3VyY2U/OiBhbnksIGJpbmRUYXJnZXQ/OiBhbnkpIHtcbiAgICAgICAvLyBwcm9jZXNzQmluZGluZyh2YXJpYWJsZSwgdmFyaWFibGUuX2NvbnRleHQsIGJpbmRTb3VyY2UsIGJpbmRUYXJnZXQpO1xuICAgICAgICAvLyBUb0RvIC0gdmFyaWFibGUgc2VwZXJhdGlvblxuICAgIH1cblxuICAgIG5vdGlmeUluZmxpZ2h0KHZhcmlhYmxlOiBhbnksIHN0YXR1czogYm9vbGVhbiwgZGF0YT86IGFueSwgb3B0aW9ucz86IGFueSkge1xuICAgICAgICAvLyBUb0RvIC0gdmFyaWFibGUgc2VwZXJhdGlvblxuICAgICAgICBhcHBNYW5hZ2VyICYmIGFwcE1hbmFnZXIubm90aWZ5KCd0b2dnbGUtdmFyaWFibGUtc3RhdGUnLCB7XG4gICAgICAgICAgICB2YXJpYWJsZTogdmFyaWFibGUsXG4gICAgICAgICAgICBhY3RpdmU6IHN0YXR1cyxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHNldHMgdGhlIHZhcmlhYmxlIHBhcmFtZXRlciByZXF1ZXN0VHJhY2tJZCB0byBYLVdNLVJlcXVlc3QtVHJhY2stSWQgd2hpY2ggaXMgcmVjZWl2ZWQgaW4gdGhlIHJlc3BvbnNlIGhlYWRlcnMuXG4gICAgICogQHBhcmFtIHJlc3BvbnNlXG4gICAgICovXG4gICAgc2V0UmVxdWVzdFRyYWNrSWQocmVzcG9uc2U6IGFueSwgdmFyaWFibGU6IGFueSkge1xuICAgICAgICBjb25zdCByZXF1ZXN0VHJhY2tJZCA9IHJlc3BvbnNlPy5oZWFkZXJzPy5nZXQoJ3gtd20tcmVxdWVzdC10cmFjay1pZCcpO1xuICAgICAgICBpZiAocmVxdWVzdFRyYWNrSWQpIHtcbiAgICAgICAgICAgIHZhcmlhYmxlLl9yZXF1ZXN0VHJhY2tJZCA9IHJlcXVlc3RUcmFja0lkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgbWFrZXMgdGhlIGZpbmFsIGFuZ3VsYXIgaHR0cCBjYWxsIHRoYXQgcmV0dXJucyBhbiBvYnNlcnZhYmxlLlxuICAgICAqIFdlIGF0dGFjaCB0aGlzIG9ic2VydmFibGUgdG8gdmFyaWFibGUgdG8gY2FuY2VsIGEgbmV0d29yayBjYWxsXG4gICAgICogQHBhcmFtIHJlcXVlc3RQYXJhbXNcbiAgICAgKiBAcGFyYW0gdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gZGJPcGVyYXRpb25cbiAgICAgKi9cbiAgICAvLyBUb0RvIC0gdmFyaWFibGUgc2VwZXJhdGlvblxuICAgIGh0dHBDYWxsKHJlcXVlc3RQYXJhbXMsIHZhcmlhYmxlLCBwYXJhbXM/OiBhbnkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHZhcmlhYmxlLl9vYnNlcnZhYmxlID0gdmFyaWFibGUuaHR0cFNlcnZpY2Uuc2VuZENhbGxBc09ic2VydmFibGUocmVxdWVzdFBhcmFtcywgcGFyYW1zKS5zdWJzY3JpYmUoKHJlc3BvbnNlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFJlcXVlc3RUcmFja0lkKHJlc3BvbnNlLCB2YXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIChlcnI6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVxdWVzdFRyYWNrSWQoZXJyLCB2YXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlLmh0dHBTZXJ2aWNlLmlzUGxhdGZvcm1TZXNzaW9uVGltZW91dChlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlbmQgdGhlIG5vdGlmaWNhdGlvbiBtYW51YWxseSB0byBoaWRlIGFueSBjb250ZXh0IHNwaW5uZXJzIG9uIHBhZ2UuXG4gICAgICAgICAgICAgICAgICAgIC8vIFtUT0RPXTogYW55IHNwaW5uZXJzIG9uIHdpZGdldCBsaXN0ZW5pbmcgb24gdGhpcyB2YXJpYWJsZSB3aWxsIGFsc28gZ28gb2ZmLiBOZWVkIHRvIHNlZSBhbiBhcHByb2FjaCB0byBzb3ZsZSB0aGF0LlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUluZmxpZ2h0KHZhcmlhYmxlLCBmYWxzZSwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyLl80MDFTdWJzY3JpYmVyLmFzT2JzZXJ2YWJsZSgpLnN1YnNjcmliZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0+IHJlc29sdmUocmVzcG9uc2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9PiByZWplY3QoZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBwcmVwYXJlcyB0aGUgb3B0aW9ucyBwYXJhbWV0ZXIgZm9yIHZhcmlhYmxlIGNhbGxiYWNrcy5cbiAgICAgKiBAcGFyYW0geGhyT2JqLCBUaGUgeGhyT2JqIHRvIGJlIHBhc3NlZFxuICAgICAqIEBwYXJhbSBtb3JlT3B0aW9ucywgYW55IG90aGVyIGluZm8gdG8gYmUgcGFzc2VkIGluIHRoZSBvcHRpb25zIHBhcmFtXG4gICAgICovXG4gICAgcHJlcGFyZUNhbGxiYWNrT3B0aW9ucyh4aHJPYmo6IGFueSwgbW9yZU9wdGlvbnM/IDogYW55KTogQWR2YW5jZWRPcHRpb25zIHtcbiAgICAgICAgbGV0IG9wdGlvbnM6IEFkdmFuY2VkT3B0aW9ucyA9IHt9O1xuICAgICAgICBvcHRpb25zWyd4aHJPYmonXSA9IHhock9iajtcbiAgICAgICAgaWYgKG1vcmVPcHRpb25zKSB7XG4gICAgICAgICAgICBfLmV4dGVuZChvcHRpb25zLCBtb3JlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxufVxuIiwiLy8gaW1wb3J0IHsgJGludm9rZVdhdGNoZXJzLCBnZXRDbG9uZWRPYmplY3QsIGdldFZhbGlkSlNPTiwgaXNEZWZpbmVkLCBpc1BhZ2VhYmxlLCBpc1ZhbGlkV2ViVVJMLCBub29wLCB0cmlnZ2VyRm4sIHhtbFRvSnNvbiB9IGZyb20gJ0B3bS9jb3JlJztcbmltcG9ydCB7IGdldENsb25lZE9iamVjdCwgdHJpZ2dlckZuIH0gZnJvbSBcIi4uLy4uL3V0aWwvdXRpbHNcIjtcbmltcG9ydCB7IENydWRWYXJpYWJsZSB9IGZyb20gJy4uLy4uL21vZGVsL3ZhcmlhYmxlL2NydWQtdmFyaWFibGUnO1xuaW1wb3J0IHsgU2VydmljZVZhcmlhYmxlVXRpbHMgfSBmcm9tICcuLi8uLi91dGlsL3ZhcmlhYmxlL3NlcnZpY2UtdmFyaWFibGUudXRpbHMnO1xuaW1wb3J0IHsgJHF1ZXVlIH0gZnJvbSAnLi4vLi4vdXRpbC9pbmZsaWdodC1xdWV1ZSc7XG5pbXBvcnQgeyBWQVJJQUJMRV9DT05TVEFOVFMsIFdTX0NPTlNUQU5UUyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy92YXJpYWJsZXMuY29uc3RhbnRzJztcbmltcG9ydCB7YXBwTWFuYWdlciwgc2V0SW5wdXR9IGZyb20gJy4vLi4vLi4vdXRpbC92YXJpYWJsZS92YXJpYWJsZXMudXRpbHMnO1xuaW1wb3J0IHsgZ2V0RXZhbHVhdGVkT3JkZXJCeSwgaHR0cFNlcnZpY2UsIGluaXRpYXRlQ2FsbGJhY2ssIG1ldGFkYXRhU2VydmljZSwgZ2V0RXJyTWVzc2FnZSB9IGZyb20gJy4uLy4uL3V0aWwvdmFyaWFibGUvdmFyaWFibGVzLnV0aWxzJztcbmltcG9ydCB7IGdldEFjY2Vzc1Rva2VuIH0gZnJvbSAnLi4vLi4vdXRpbC9vQXV0aC51dGlscyc7XG5pbXBvcnQge1NlcnZpY2VWYXJpYWJsZU1hbmFnZXJ9IGZyb20gJy4vc2VydmljZS12YXJpYWJsZS5tYW5hZ2VyJztcblxuZGVjbGFyZSBjb25zdCBfO1xuXG5leHBvcnQgY2xhc3MgQ3J1ZFZhcmlhYmxlTWFuYWdlciBleHRlbmRzIFNlcnZpY2VWYXJpYWJsZU1hbmFnZXIge1xuXG4gICAgZmlsZVVwbG9hZFJlc3BvbnNlOiBhbnkgPSBbXTtcbiAgICBmaWxlVXBsb2FkQ291bnQgPSAwO1xuICAgIHRvdGFsRmlsZXNDb3VudCA9IDA7XG4gICAgc3VjY2Vzc0ZpbGVVcGxvYWRDb3VudCA9IDA7XG4gICAgZmFpbGVkRmlsZVVwbG9hZENvdW50ID0gMDtcblxuICAgIHByaXZhdGUgZ2V0UGFnaW5hdGlvbkluZm8odmFyaWFibGUsIGlucHV0RmllbGRzLCBvcHRpb25zPykge1xuICAgICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMub3BlcmF0aW9uKSB7XG4gICAgICAgICAgICBvcHRpb25zLm9wZXJhdGlvbiA9ICdsaXN0JztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJ2aWNlRGVmID0gZ2V0Q2xvbmVkT2JqZWN0KG1ldGFkYXRhU2VydmljZS5nZXRCeUNydWRJZCh2YXJpYWJsZS5jcnVkT3BlcmF0aW9uSWQsIHZhcmlhYmxlLmdldFByZWZhYk5hbWUoKSkpO1xuICAgICAgICBsZXQgbWV0aG9kSW5mbyA9IHNlcnZpY2VEZWYgPT09IG51bGwgPyBudWxsIDogXy5nZXQoc2VydmljZURlZiwgJ3dtU2VydmljZU9wZXJhdGlvbkluZm8nKTtcbiAgICAgICAgbWV0aG9kSW5mbyA9IHNlcnZpY2VEZWYuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLm9wZXJhdGlvbiA9PT0gaXRlbS5vcGVyYXRpb25UeXBlO1xuICAgICAgICB9KVswXTtcbiAgICAgICAgaWYgKCFtZXRob2RJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kSW5mbztcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXRob2RJbmZvLnBhZ2luYXRpb25JbmZvID0ge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29udGVudE1hcHBpbmdcIjogXCJjb250ZW50XCIsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhc2NTb3J0RXhwcmVzc2lvblwiOiBcInt7ZmllbGROYW1lfX0gYVwiLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGVzY1NvcnRFeHByZXNzaW9uXCI6IFwie3tmaWVsZE5hbWV9fSBkXCIsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cImRlZmF1bHRTb3J0RXhwcmVzc2lvblwiOiBcImlkXCIsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0b3RhbE1hcHBpbmdcIjogXCJ0b3RhbEVsZW1lbnRzXCIsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYWdlTWFwcGluZ1wiOiB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwYWdlTnVtXCIsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJ0aGUgZXhpc3RpbmcgaWRcIixcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IHRydWVcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic2l6ZU1hcHBpbmdcIjoge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImluXCI6IFwicXVlcnlcIixcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibGltaXRcIixcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcInRoZSBleGlzdGluZyBpZFwiLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzb3J0TWFwcGluZ1wiOiB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInNvcnRJbmZvXCIsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW5cIjogXCJxdWVyeVwiLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwidGhlIHNvcnRpbmcgY3JpdGVyaWFcIixcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICBtZXRob2RJbmZvLnBhZ2luYXRpb25JbmZvID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG1ldGhvZEluZm8ucGFnaW5hdGlvbkluZm87XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRPcGVyYXRpb25JbmZvKHZhcmlhYmxlLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBzZXJ2aWNlRGVmID0gZ2V0Q2xvbmVkT2JqZWN0KG1ldGFkYXRhU2VydmljZS5nZXRCeUNydWRJZCh2YXJpYWJsZS5jcnVkT3BlcmF0aW9uSWQsIHZhcmlhYmxlLmdldFByZWZhYk5hbWUoKSkpO1xuICAgICAgICBsZXQgbWV0aG9kSW5mbztcbiAgICAgICAgLy8gZmFsbGJhY2sgaWYgdGhlcmUgaXMgbm8gb3BlcmF0aW9uXG4gICAgICAgIGlmIChvcHRpb25zICYmICFvcHRpb25zLm9wZXJhdGlvbikge1xuICAgICAgICAgICAgb3B0aW9ucy5vcGVyYXRpb24gPSAnbGlzdCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZXJ2aWNlRGVmLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1ldGhvZEluZm8gPSBzZXJ2aWNlRGVmLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5vcGVyYXRpb24gPT09IGl0ZW0ub3BlcmF0aW9uVHlwZTtcbiAgICAgICAgfSlbMF07XG4gICAgICAgIHJldHVybiBtZXRob2RJbmZvID8gbWV0aG9kSW5mby53bVNlcnZpY2VPcGVyYXRpb25JbmZvIDoge2ludmFsaWQ6IHRydWV9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRzIHRoZSBzZXJ2aWNlIG9wZXJhdGlvbiBpbmZvIGFnYWluc3QgYSBzZXJ2aWNlIHZhcmlhYmxlXG4gICAgICogdGhpcyBpcyBleHRyYWN0ZWQgZnJvbSB0aGUgbWV0YWRhdGFzZXJ2aWNlXG4gICAgICogQHBhcmFtIHZhcmlhYmxlXG4gICAgICogQHBhcmFtIGlucHV0RmllbGRzOiBzYW1wbGUgdmFsdWVzLCBpZiBwcm92aWRlZCwgd2lsbCBiZSBzZXQgYWdhaW5zdCBwYXJhbXMgaW4gdGhlIGRlZmluaXRpb25cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHthbnl9XG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRNZXRob2RJbmZvRm9yQ3J1ZCh2YXJpYWJsZSwgaW5wdXRGaWVsZHMsIG9wdGlvbnM/KSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZEluZm8gPSB0aGlzLmdldE9wZXJhdGlvbkluZm8odmFyaWFibGUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIW1ldGhvZEluZm8gfHwgbWV0aG9kSW5mby5pbnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kSW5mbztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWN1cml0eURlZm5PYmogPSBfLmdldChtZXRob2RJbmZvLnNlY3VyaXR5RGVmaW5pdGlvbnMsICcwJyksXG4gICAgICAgICAgICBpc09BdXRoVHlwZVNlcnZpY2UgPSBzZWN1cml0eURlZm5PYmogJiYgKHNlY3VyaXR5RGVmbk9iai50eXBlID09PSBWQVJJQUJMRV9DT05TVEFOVFMuUkVTVF9TRVJWSUNFLlNFQ1VSSVRZX0RFRk4uT0FVVEgyKTtcbiAgICAgICAgaWYgKG1ldGhvZEluZm8ucGFyYW1ldGVycykge1xuICAgICAgICAgICAgbWV0aG9kSW5mby5wYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIHJlYWRPbmx5IHBhcmFtcyBpbiBjYXNlIG9mIGZvcm1EYXRhIGZpbGUgcGFyYW1zIHdpbGwgYmUgZHVwbGljYXRlZFxuICAgICAgICAgICAgICAgIGlmIChwYXJhbS5yZWFkT25seSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFtLnNhbXBsZVZhbHVlID0gaW5wdXRGaWVsZHNbcGFyYW0ubmFtZV07XG4gICAgICAgICAgICAgICAgLyogc3VwcG9ydGluZyBwYWdpbmF0aW9uIGZvciBxdWVyeSBzZXJ2aWNlIHZhcmlhYmxlICovXG4gICAgICAgICAgICAgICAgaWYgKFZBUklBQkxFX0NPTlNUQU5UUy5QQUdJTkFUSU9OX1BBUkFNUy5pbmRleE9mKHBhcmFtLm5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW0ubmFtZSA9PT0gJ3NpemUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbS5zYW1wbGVWYWx1ZSA9IG9wdGlvbnMuc2l6ZSB8fCBwYXJhbS5zYW1wbGVWYWx1ZSB8fCBwYXJzZUludCh2YXJpYWJsZS5tYXhSZXN1bHRzLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW0ubmFtZSA9PT0gJ3BhZ2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbS5zYW1wbGVWYWx1ZSA9IG9wdGlvbnMucGFnZSB8fCBwYXJhbS5zYW1wbGVWYWx1ZSB8fCAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtLm5hbWUgPT09ICdzb3J0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0uc2FtcGxlVmFsdWUgPSBnZXRFdmFsdWF0ZWRPcmRlckJ5KHZhcmlhYmxlLm9yZGVyQnksIG9wdGlvbnMub3JkZXJCeSkgfHwgcGFyYW0uc2FtcGxlVmFsdWUgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtLm5hbWUgPT09ICdhY2Nlc3NfdG9rZW4nICYmIGlzT0F1dGhUeXBlU2VydmljZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbS5zYW1wbGVWYWx1ZSA9IGdldEFjY2Vzc1Rva2VuKHNlY3VyaXR5RGVmbk9ialtWQVJJQUJMRV9DT05TVEFOVFMuUkVTVF9TRVJWSUNFLk9BVVRIX1BST1ZJREVSX0tFWV0sIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRob2RJbmZvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByb3h5IGZvciB0aGUgaW52b2tlIGNhbGxcbiAgICAgKiBSZXF1ZXN0IEluZm8gaXMgY29uc3RydWN0ZWRcbiAgICAgKiBpZiBlcnJvciBmb3VuZCwgZXJyb3IgaXMgdGhyb3duXG4gICAgICogZWxzZSwgY2FsbCBpcyBtYWRlXG4gICAgICogQHBhcmFtIHtDcnVkVmFyaWFibGV9IHZhcmlhYmxlXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWNjZXNzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3JcbiAgICAgKiBAcmV0dXJucyB7YW55fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9pbnZva2UgKHZhcmlhYmxlOiBDcnVkVmFyaWFibGUsIG9wdGlvbnM6IGFueSwgc3VjY2VzczogRnVuY3Rpb24sIGVycm9yOiBGdW5jdGlvbikge1xuICAgICAgICBsZXQgaW5wdXRGaWVsZHMgPSBnZXRDbG9uZWRPYmplY3Qob3B0aW9ucy5pbnB1dEZpZWxkcyB8fCB7fSk7XG4gICAgICAgIGlmIChvcHRpb25zLm9wZXJhdGlvbiA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAgIGlucHV0RmllbGRzID0gZ2V0Q2xvbmVkT2JqZWN0KG9wdGlvbnMucm93IHx8IGlucHV0RmllbGRzLnJvdyB8fCBvcHRpb25zLmlucHV0RmllbGRzIHx8IHZhcmlhYmxlLmRhdGFCaW5kaW5nKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm9wZXJhdGlvbiA9PT0gJ2NyZWF0ZScgJiYgb3B0aW9ucy5yb3cpIHtcbiAgICAgICAgICAgIGlucHV0RmllbGRzID0gZ2V0Q2xvbmVkT2JqZWN0KG9wdGlvbnMucm93KTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm9wZXJhdGlvbiA9PT0gJ3VwZGF0ZScgJiYgb3B0aW9ucy5yb3cpIHtcbiAgICAgICAgICAgIGlucHV0RmllbGRzID0gZ2V0Q2xvbmVkT2JqZWN0KG9wdGlvbnMucm93KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFVkVOVDogT05fQkVGT1JFX1VQREFURVxuICAgICAgICBjb25zdCBvdXRwdXQ6IGFueSA9IGluaXRpYXRlQ2FsbGJhY2soVkFSSUFCTEVfQ09OU1RBTlRTLkVWRU5ULkJFRk9SRV9VUERBVEUsIHZhcmlhYmxlLCBpbnB1dEZpZWxkcywgb3B0aW9ucyk7XG4gICAgICAgIGxldCBzdWNjZXNzSGFuZGxlcjtcbiAgICAgICAgbGV0IGVycm9ySGFuZGxlcjtcblxuICAgICAgICBpZiAob3V0cHV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgJHF1ZXVlLnByb2Nlc3ModmFyaWFibGUpO1xuICAgICAgICAgICAgdHJpZ2dlckZuKGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXy5pc09iamVjdChvdXRwdXQpKSB7XG4gICAgICAgICAgICBpbnB1dEZpZWxkcyA9IG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcEluZm8gPSB0aGlzLmdldE9wZXJhdGlvbkluZm8odmFyaWFibGUsIG9wdGlvbnMpO1xuICAgICAgICBsZXQgYm9keVBhcmFtO1xuICAgICAgICBpZiAob3BJbmZvICYmIG9wSW5mby5wYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBib2R5UGFyYW0gPSBvcEluZm8ucGFyYW1ldGVycy5maWx0ZXIoZnVuY3Rpb24ob3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3AucGFyYW1ldGVyVHlwZSA9PT0gJ2JvZHknIHx8IG9wLnBhcmFtZXRlclR5cGUgPT09ICdmb3JtRGF0YSc7XG4gICAgICAgICAgICB9KVswXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBmaWVsZHMgd2l0aCBiaW5kaW5nc1xuICAgICAgICBjb25zdCBiaW5kaW5nRmllbGRzID0gXy5nZXQodmFyaWFibGUuZGF0YUJpbmRpbmcsIG9wdGlvbnMub3BlcmF0aW9uKSB8fCB7fTtcbiAgICAgICAgLy8gYmluZGluZ3MgZnJvbSBzZXRJbnB1dCBjYW4gY29tZSBhbG9uZyB3aXRoIHRoZSBib2R5IHBhcmFtLCBzbyBlbXBsb3llZS5hZ2Ugd2lsbCBoYXZlIHRvIGJlIGNvbnZlcnRlZCB0byBhZ2VcbiAgICAgICAgaWYgKGJvZHlQYXJhbSAmJiBiaW5kaW5nRmllbGRzW2JvZHlQYXJhbS5uYW1lXSkge1xuICAgICAgICAgICAgXy5mb3JFYWNoKGJpbmRpbmdGaWVsZHMsIGZ1bmN0aW9uKGJpbmRpbmdGaWVsZFZhbCwgYmluZGluZ0ZpZWxkS2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRpbmdGaWVsZEtleSA9PT0gYm9keVBhcmFtLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5tZXJnZShpbnB1dEZpZWxkcywgYmluZGluZ0ZpZWxkVmFsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dEZpZWxkc1tiaW5kaW5nRmllbGRLZXldID0gYmluZGluZ0ZpZWxkVmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXy5tZXJnZShpbnB1dEZpZWxkcywgYmluZGluZ0ZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChvcHRpb25zLm9wZXJhdGlvbiA9PT0gJ2NyZWF0ZScgfHwgb3B0aW9ucy5vcGVyYXRpb24gPT09ICd1cGRhdGUnKSAmJiAoIWJvZHlQYXJhbSB8fCAhaW5wdXRGaWVsZHNbYm9keVBhcmFtLm5hbWVdKSkge1xuICAgICAgICAgICAgbGV0IGJvZHlUeXBlS2V5cyA9IFtdLCBub25Cb2R5UGFyYW07XG4gICAgICAgICAgICAvLyBvbmx5IG1lcmdlIGJvZHkvZm9ybURhdGEgdHlwZSBwYXJhbXMgdG8gdGhlIHJlcXVlc3RCb2R5LlxuICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgaW4gaW5wdXRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBub25Cb2R5UGFyYW0gPSBvcEluZm8ucGFyYW1ldGVycy5maWx0ZXIoZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtLm5hbWUgPT09IGZpZWxkTmFtZSAmJiBwYXJhbS5wYXJhbWV0ZXJUeXBlICE9PSAnYm9keScgJiYgcGFyYW0ucGFyYW1ldGVyVHlwZSAhPT0gJ2Zvcm1EYXRhJztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobm9uQm9keVBhcmFtLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBib2R5VHlwZUtleXMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcUJvZHlGaWVsZHMgPSBfLm9taXQoaW5wdXRGaWVsZHMsIGJvZHlUeXBlS2V5cyk7XG4gICAgICAgICAgICBpZiAoYm9keVBhcmFtKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRGaWVsZHNbYm9keVBhcmFtLm5hbWVdID0gZ2V0Q2xvbmVkT2JqZWN0KHJlcUJvZHlGaWVsZHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dEZpZWxkcy5SZXF1ZXN0Qm9keSA9IGdldENsb25lZE9iamVjdChyZXFCb2R5RmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFnaW5hdGlvbkluZm87XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbkluZm8gPSB0aGlzLmdldE1ldGhvZEluZm9Gb3JDcnVkKHZhcmlhYmxlLCBpbnB1dEZpZWxkcywgb3B0aW9ucyk7XG4gICAgICAgIGxldCBwYXRoUGFyYW0sIGJvZHlUeXBlUGFyYW07XG4gICAgICAgIGlmICghdmFyaWFibGUucGFnaW5hdGlvblRyYW5zZm9ybWF0aW9uUmVxdWlyZWQgJiYgb3BlcmF0aW9uSW5mbyAmJiAhb3BlcmF0aW9uSW5mby5pbnZhbGlkKSB7XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uSW5mby5wYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uSW5mby5wYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtZXRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1ldGVyLnBhcmFtZXRlclR5cGUgPT09ICdwYXRoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFBhcmFtID0gcGFyYW1ldGVyLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1ldGVyLnBhcmFtZXRlclR5cGUgPT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keVR5cGVQYXJhbSA9IHBhcmFtZXRlci5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRGaWVsZHNbYm9keVR5cGVQYXJhbV0gPSBnZXRDbG9uZWRPYmplY3QoaW5wdXRGaWVsZHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dEZpZWxkcykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09IGJvZHlUeXBlUGFyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGlucHV0RmllbGRzW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdGhQYXJhbSAmJiBpbnB1dEZpZWxkc1tib2R5VHlwZVBhcmFtXSkge1xuICAgICAgICAgICAgICAgIGlucHV0RmllbGRzW3BhdGhQYXJhbV0gPSBnZXRDbG9uZWRPYmplY3QoaW5wdXRGaWVsZHNbYm9keVR5cGVQYXJhbV1bcGF0aFBhcmFtXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxzZSB7XG4gICAgICAgIC8vICAgICBpbnB1dEZpZWxkcy50b3RhbE1hcHBpbmcgPSBwYWdpbmF0aW9uSW5mbyAmJiBwYWdpbmF0aW9uSW5mby50b3RhbE1hcHBpbmc7XG4gICAgICAgIC8vIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdFBhcmFtcyA9IFNlcnZpY2VWYXJpYWJsZVV0aWxzLmNvbnN0cnVjdFJlcXVlc3RQYXJhbXModmFyaWFibGUsIG9wZXJhdGlvbkluZm8sIGlucHV0RmllbGRzKTtcbiAgICAgICAgaW5wdXRGaWVsZHMuc29ydEluZm8gPSBvcHRpb25zLm9yZGVyQnk7XG4gICAgICAgIC8vIGNoZWNrIGVycm9yc1xuICAgICAgICBpZiAocmVxdWVzdFBhcmFtcy5lcnJvcikge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbXMuZXJyb3IudHlwZSA9PT0gVkFSSUFCTEVfQ09OU1RBTlRTLlJFU1RfU0VSVklDRS5FUlJfVFlQRS5DUlVEX09QRVJBVElPTl9NSVNTSU5HKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFBhcmFtcy5lcnJvci5tZXNzYWdlID0gcmVxdWVzdFBhcmFtcy5lcnJvci5tZXNzYWdlLnJlcGxhY2UoJyRvcGVyYXRpb24nLCBvcHRpb25zLm9wZXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wcmV2ZW50TWlzc2luZ09wTXNnKSB7XG4gICAgICAgICAgICAgICAgJHF1ZXVlLnByb2Nlc3ModmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5mbyA9IHRoaXMuaGFuZGxlUmVxdWVzdE1ldGFFcnJvcihyZXF1ZXN0UGFyYW1zLCB2YXJpYWJsZSwgc3VjY2VzcywgZXJyb3IsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgcmVhc29uID0gKF8uZ2V0KGluZm8sICdlcnJvci5tZXNzYWdlJykgfHwgJ0FuIGVycm9yIG9jY3VycmVkIHdoaWxlIHRyaWdnZXJpbmcgdGhlIHZhcmlhYmxlJyk7XG4gICAgICAgICAgICB0cmlnZ2VyRm4oZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaWxlIHVwbG9hZFxuICAgICAgICBpZiAoU2VydmljZVZhcmlhYmxlVXRpbHMuaXNGaWxlVXBsb2FkUmVxdWVzdCh2YXJpYWJsZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwbG9hZFByb21pc2UgPSB0aGlzLnVwbG9hZEZpbGUodmFyaWFibGUsIG9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yLCBpbnB1dEZpZWxkcywgcmVxdWVzdFBhcmFtcyk7XG4gICAgICAgICAgICBpZiAodXBsb2FkUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGxvYWRQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlsZSBkb3dubG9hZFxuICAgICAgICBpZiAob3BlcmF0aW9uSW5mbyAmJiBfLmlzQXJyYXkob3BlcmF0aW9uSW5mby5wcm9kdWNlcykgJiYgXy5pbmNsdWRlcyhvcGVyYXRpb25JbmZvLnByb2R1Y2VzLCBXU19DT05TVEFOVFMuQ09OVEVOVF9UWVBFUy5PQ1RFVF9TVFJFQU0pKSB7XG4gICAgICAgICAgICAvLyBUb0RvIC0gdmFyaWFibGUgc2VwZXJhdGlvblxuICAgICAgICAgICAgcmV0dXJuIHZhcmlhYmxlLnNpbXVsYXRlRmlsZURvd25sb2FkKHJlcXVlc3RQYXJhbXMsIHZhcmlhYmxlLmRhdGFCaW5kaW5nLmZpbGUgfHwgdmFyaWFibGUubmFtZSwgdmFyaWFibGUuZGF0YUJpbmRpbmcuZXhwb3J0VHlwZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGluaXRpYXRlQ2FsbGJhY2soVkFSSUFCTEVfQ09OU1RBTlRTLkVWRU5ULlNVQ0NFU1MsIHZhcmlhYmxlLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICAkcXVldWUucHJvY2Vzcyh2YXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckZuKHN1Y2Nlc3MpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGluaXRpYXRlQ2FsbGJhY2soVkFSSUFCTEVfQ09OU1RBTlRTLkVWRU5ULkVSUk9SLCB2YXJpYWJsZSwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgJHF1ZXVlLnByb2Nlc3ModmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJGbihlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdGlmeSB2YXJpYWJsZSBwcm9ncmVzc1xuICAgICAgICB0aGlzLm5vdGlmeUluZmxpZ2h0KHZhcmlhYmxlLCAhb3B0aW9ucy5za2lwVG9nZ2xlU3RhdGUpO1xuXG4gICAgICAgIHN1Y2Nlc3NIYW5kbGVyID0gKHJlc3BvbnNlLCByZXNvbHZlLCBpbnB1dE9iaj8pID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlLnBhZ2luYXRpb25UcmFuc2Zvcm1hdGlvblJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBqc29uID0gSlNPTi5wYXJzZShyZXNwb25zZS5ib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFnZWFibGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY29udGVudCcgICAgICAgICA6IGpzb25bcGFnaW5hdGlvbkluZm8uY29udGVudE1hcHBpbmddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpcnN0JyAgICAgICAgICAgOiBpbnB1dE9ialtwYWdpbmF0aW9uSW5mby5wYWdlTWFwcGluZy5uYW1lXSA9PT0gMSA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsYXN0JyAgICAgICAgICAgIDogaW5wdXRPYmpbcGFnaW5hdGlvbkluZm8ucGFnZU1hcHBpbmcubmFtZV0gPT09IGpzb25baW5wdXRGaWVsZHMudG90YWxNYXBwaW5nXSA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdudW1iZXInICAgICAgICAgIDogaW5wdXRPYmpbcGFnaW5hdGlvbkluZm8ucGFnZU1hcHBpbmcubmFtZV0gLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ251bWJlck9mRWxlbWVudHMnOiBpbnB1dE9ialtwYWdpbmF0aW9uSW5mby5zaXplTWFwcGluZy5uYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzaXplJyAgICAgICAgICAgIDogaW5wdXRPYmpbcGFnaW5hdGlvbkluZm8uc2l6ZU1hcHBpbmcubmFtZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAnc29ydCcgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAndG90YWxFbGVtZW50cycgICA6IGpzb25baW5wdXRGaWVsZHMudG90YWxNYXBwaW5nXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0b3RhbFBhZ2VzJyAgICAgIDogTWF0aC5jZWlsKGpzb25baW5wdXRGaWVsZHMudG90YWxNYXBwaW5nXSAvIGlucHV0T2JqW3BhZ2luYXRpb25JbmZvLnNpemVNYXBwaW5nLm5hbWVdKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRPYmouc29ydEluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VhYmxlLnNvcnQgPSBbe2RpcmVjdGlvbjogaW5wdXRPYmouc29ydEluZm8uc3BsaXQoJyAnKVsxXS50b1VwcGVyQ2FzZSgpLCBwcm9wZXJ0eTogaW5wdXRPYmouc29ydEluZm8uc3BsaXQoJyAnKVswXSwgaWdub3JlQ2FzZTogZmFsc2UsIG51bGxIYW5kbGluZzogXCJOQVRJVkVcIiwgYXNjZW5kaW5nOiBpbnB1dE9iai5zb3J0SW5mby5zcGxpdCgnICcpWzFdID09PSAnYXNjJyA/IHRydWUgOiBmYWxzZX1dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGpzb24gPSBnZXRDbG9uZWRPYmplY3QocGFnZWFibGUpO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoanNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnByb2Nlc3NTdWNjZXNzUmVzcG9uc2UocmVzcG9uc2UuYm9keSwgdmFyaWFibGUsIF8uZXh0ZW5kKG9wdGlvbnMsIHsneGhyT2JqJzogcmVzcG9uc2V9KSwgc3VjY2VzcywgcmVzcG9uc2UuaGVhZGVycywgb3BlcmF0aW9uSW5mbyk7XG4gICAgICAgICAgICAgICAgLy8gbm90aWZ5IHZhcmlhYmxlIHN1Y2Nlc3NcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUluZmxpZ2h0KHZhcmlhYmxlLCBmYWxzZSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZXJyb3JIYW5kbGVyID0gKGVyciwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlcnJNc2cgPSBnZXRFcnJNZXNzYWdlKGVyciwgdmFyaWFibGUuaHR0cFNlcnZpY2UuZ2V0TG9jYWxlKCkpO1xuICAgICAgICAgICAgLy8gbm90aWZ5IHZhcmlhYmxlIGVycm9yXG4gICAgICAgICAgICB0aGlzLm5vdGlmeUluZmxpZ2h0KHZhcmlhYmxlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NFcnJvclJlc3BvbnNlKHZhcmlhYmxlLCBlcnJNc2csIGVycm9yLCBlcnIsIG9wdGlvbnMuc2tpcE5vdGlmaWNhdGlvbik7XG4gICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJNc2csXG4gICAgICAgICAgICAgICAgZGV0YWlsczogZXJyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBtYWtlIHRoZSBjYWxsIGFuZCByZXR1cm4gYSBwcm9taXNlIHRvIHRoZSB1c2VyIHRvIHN1cHBvcnQgc2NyaXB0IGNhbGxzIG1hZGUgYnkgdXNlcnNcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMucmVzcG9uc2VUeXBlID0gJ3RleHQnOyAvLyB0aGlzIGlzIHRvIHJldHVybiB0ZXh0IHJlc3BvbnNlLiBKU09OICYgWE1MLXRvLUpTT04gcGFyc2luZyBpcyBoYW5kbGVkIGluIHN1Y2Nlc3MgaGFuZGxlci5cbiAgICAgICAgICAgIHRoaXMuaHR0cENhbGwocmVxdWVzdFBhcmFtcywgdmFyaWFibGUpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgc3VjY2Vzc0hhbmRsZXIocmVzcG9uc2UsIHJlc29sdmUsIGlucHV0RmllbGRzKTtcbiAgICAgICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGVyciwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gdGhlIF9vYnNlcnZhYmxlIHByb3BlcnR5IG9uIHZhcmlhYmxlIGlzIHVzZWQgc3RvcmUgdGhlIG9ic2VydmFibGUgdXNpbmcgd2hpY2ggdGhlIG5ldHdvcmsgY2FsbCBpcyBtYWRlXG4gICAgICAgICAgICAvLyB0aGlzIGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgdmFyaWFibGUgY2FsbHMuXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIFBVQkxJQyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8vXG5cbiAgICBwdWJsaWMgaW52b2tlKHZhcmlhYmxlLCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgYXBwTWFuYWdlci5ub3RpZnkoJ2NoZWNrLXN0YXRlLXBlcnNpc3RlbmNlLW9wdGlvbnMnLCB7XG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgdmFyaWFibGU6IHZhcmlhYmxlXG4gICAgICAgIH0pO1xuICAgICAgICBvcHRpb25zLm9wZXJhdGlvbiA9IG9wdGlvbnMub3BlcmF0aW9uIHx8ICdsaXN0JztcbiAgICAgICAgb3B0aW9ucy5pbnB1dEZpZWxkcyA9IG9wdGlvbnMuaW5wdXRGaWVsZHMgfHwgZ2V0Q2xvbmVkT2JqZWN0KHZhcmlhYmxlLmRhdGFCaW5kaW5nW29wdGlvbnMub3BlcmF0aW9uXSk7XG4gICAgICAgIHJldHVybiAkcXVldWUuc3VibWl0KHZhcmlhYmxlKS50aGVuKHRoaXMuX2ludm9rZS5iaW5kKHRoaXMsIHZhcmlhYmxlLCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvciksIGVycm9yKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0SW5wdXRQYXJtcyh2YXJpYWJsZSkge1xuICAgICAgICBjb25zdCB3bVNlcnZpY2VPcGVyYXRpb25JbmZvID0gXy5nZXQobWV0YWRhdGFTZXJ2aWNlLmdldEJ5T3BlcmF0aW9uSWQodmFyaWFibGUub3BlcmF0aW9uSWQsIHZhcmlhYmxlLmdldFByZWZhYk5hbWUoKSksICd3bVNlcnZpY2VPcGVyYXRpb25JbmZvJyk7XG4gICAgICAgIHJldHVybiBfLmdldCh3bVNlcnZpY2VPcGVyYXRpb25JbmZvLCAncGFyYW1ldGVycycpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXRJbnB1dCh2YXJpYWJsZSwga2V5LCB2YWwsIG9wdGlvbnMsIHR5cGU/KSB7XG4gICAgICAgIHR5cGUgPSB0eXBlIHx8ICdsaXN0JztcbiAgICAgICAgaWYgKF8uaXNFbXB0eSh2YXJpYWJsZS5kYXRhQmluZGluZ1t0eXBlXSkpIHtcbiAgICAgICAgICAgIHZhcmlhYmxlLmRhdGFCaW5kaW5nW3R5cGVdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldElucHV0KHZhcmlhYmxlLmRhdGFCaW5kaW5nW3R5cGVdLCBrZXksIHZhbCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGJpbmRpbmdzIGZvciB0aGUgQ1JVRCB2YXJpYWJsZVxuICAgICAqIGZsYXR0ZW4gdGhlIGJpbmRpbmdzIChjYXRlZ29yaXNlZCBieSBvcGVyYXRpb24gbmFtZSkgdG8gYSBsaXN0IG9mIGJpbmRpbmdzXG4gICAgICogZWFjaCBiaW5kaW5nIG9iamVjdCdzIHRhcmdldCBpcyBjaGFuZ2VkIGFwcGVuZGVkIHdpdGggdGhlIG9wZXJhdGlvbiB0eXBlXG4gICAgICogRS5nLiBJbnB1dCBiaW5kaW5nIHdpbGwgYmUgbGlrZTpcbiAgICAge1xuICAgICAgIFwibGlzdFwiOiBbXG4gICAgICAgICB7XG4gICAgICAgICAgIFwidGFyZ2V0XCI6IFwicVwiLFxuICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgXCJ2YWx1ZVwiOiBcIlhcIlxuICAgICAgICAgfVxuICAgICAgIF0sXG4gICAgICAgXCJ1cGRhdGVcIjogW1xuICAgICAgICAge1xuICAgICAgICAgICBcInRhcmdldFwiOiBcImlkXCIsXG4gICAgICAgICAgIFwidmFsdWVcIjogXCJiaW5kOldpZGdldHMuVXNlckNvbnRyb2xsZXJUYWJsZTIuc2VsZWN0ZWRpdGVtLnVzZXJJZFwiLFxuICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgIH1cbiAgICAgICBdXG4gICAgIH1cblxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGl0IHRvXG4gICAgIFtcbiAgICAgICAgIHtcbiAgICAgICAgICAgXCJ0YXJnZXRcIjogXCJsaXN0LnFcIixcbiAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgIFwidmFsdWVcIjogXCJYXCJcbiAgICAgICAgIH0sXG4gICAgICAgICB7XG4gICAgICAgICAgIFwidGFyZ2V0XCI6IFwidXBkYXRlLmlkXCIsXG4gICAgICAgICAgIFwidmFsdWVcIjogXCJiaW5kOldpZGdldHMuVXNlckNvbnRyb2xsZXJUYWJsZTIuc2VsZWN0ZWRpdGVtLnVzZXJJZFwiLFxuICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgIH1cbiAgICAgXVxuXG4gICAgICogVGhlIGJpbmRpbmdzIHdpbGwgYmUgZXZhbHVhdGVkIHRocm91Z2ggdGhlIGJhc2UtbWFuYWdlciBpbml0QmluZGluZyBtZXRob2QgYW5kIHdpbGxcbiAgICAgKiBiZSBzdG9yZWQgaW4gdmFyaWFibGUuZGF0YUJpbmRpbmcgYXMgZm9sbG93czpcbiAgICAge1xuICAgICAgICBsaXN0OiB7XG4gICAgICAgICAgICBxOiBcIlhcIlxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgIGlkOiBcImV2YWx1YXRlZCB2YWx1ZVwiXG4gICAgICAgIH1cbiAgICAgfVxuICAgICAqIEBwYXJhbSB2YXJpYWJsZVxuICAgICAqL1xuICAgIHB1YmxpYyBpbml0QmluZGluZyh2YXJpYWJsZSkge1xuICAgICAgICBsZXQgY3J1ZEJpbmRJbmZvID0gdmFyaWFibGUuZGF0YUJpbmRpbmcgfHwge30sXG4gICAgICAgICAgICBmbGF0dGVuZWRCaW5kSW5mbyA9IFtdO1xuXG4gICAgICAgIF8uZm9yRWFjaChjcnVkQmluZEluZm8sIChiaW5kTm9kZXMsIG9wZXJhdGlvblR5cGUpID0+IHtcbiAgICAgICAgICAgIGJpbmROb2RlcyA9IGJpbmROb2RlcyB8fCBbXTtcbiAgICAgICAgICAgIGJpbmROb2Rlcy5mb3JFYWNoKChiaW5kTm9kZSk9PntcbiAgICAgICAgICAgICAgICBiaW5kTm9kZS50YXJnZXQgPSBvcGVyYXRpb25UeXBlICsgJy4nICsgYmluZE5vZGUudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGZsYXR0ZW5lZEJpbmRJbmZvLnB1c2goYmluZE5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXJpYWJsZS5kYXRhQmluZGluZyA9IGZsYXR0ZW5lZEJpbmRJbmZvO1xuXG4gICAgICAgIHN1cGVyLmluaXRCaW5kaW5nKHZhcmlhYmxlKTtcbiAgICB9XG59XG4iLCIvLyBpbXBvcnQgeyAkaW52b2tlV2F0Y2hlcnMsIHByb2Nlc3NGaWx0ZXJFeHBCaW5kTm9kZSB9IGZyb20gJ0B3bS9jb3JlJztcbmltcG9ydCB7IGdldENsb25lZE9iamVjdCwgaXNEYXRlVGltZVR5cGUsIGlzRGVmaW5lZCwgdHJpZ2dlckZuIH0gZnJvbSBcIi4uLy4uL3V0aWwvdXRpbHNcIjtcblxuaW1wb3J0IHsgQmFzZVZhcmlhYmxlTWFuYWdlciB9IGZyb20gJy4vYmFzZS12YXJpYWJsZS5tYW5hZ2VyJztcbmltcG9ydCB7IGRlYm91bmNlVmFyaWFibGVDYWxsLCBmb3JtYXRFeHBvcnRFeHByZXNzaW9uLCBpbml0aWF0ZUNhbGxiYWNrLCBzZXRJbnB1dCwgYXBwTWFuYWdlciwgaHR0cFNlcnZpY2UsIGZvcm1hdERhdGUsIGdldEVyck1lc3NhZ2UgfSBmcm9tICcuLi8uLi91dGlsL3ZhcmlhYmxlL3ZhcmlhYmxlcy51dGlscyc7XG5pbXBvcnQgeyBMaXZlVmFyaWFibGVVdGlscyB9IGZyb20gJy4uLy4uL3V0aWwvdmFyaWFibGUvbGl2ZS12YXJpYWJsZS51dGlscyc7XG5pbXBvcnQgeyBkZWNvZGVEYXRhIH0gZnJvbSAnLi8uLi8uLi91dGlsL3ZhcmlhYmxlL3ZhcmlhYmxlcy51dGlscyc7XG5pbXBvcnQgeyAkcXVldWUgfSBmcm9tICcuLi8uLi91dGlsL2luZmxpZ2h0LXF1ZXVlJztcbmltcG9ydCB7ICRyb290U2NvcGUsIENPTlNUQU5UUywgVkFSSUFCTEVfQ09OU1RBTlRTLCBEQl9DT05TVEFOVFMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvdmFyaWFibGVzLmNvbnN0YW50cyc7XG5pbXBvcnQgeyBBZHZhbmNlZE9wdGlvbnMgfSBmcm9tICcuLi8uLi9hZHZhbmNlZC1vcHRpb25zJztcbmltcG9ydCB7IGdlbmVyYXRlQ29ubmVjdGlvblBhcmFtcyB9IGZyb20gJy4uLy4uL3V0aWwvdmFyaWFibGUvbGl2ZS12YXJpYWJsZS5odHRwLnV0aWxzJztcbmltcG9ydCB7IFZhcmlhYmxlRXZlbnRzIH0gZnJvbSBcIi4uLy4uL21vZGVsL2Jhc2UtdmFyaWFibGVcIjtcblxuZGVjbGFyZSBjb25zdCBfLCB3aW5kb3c7XG5jb25zdCBlbXB0eUFyciA9IFtdO1xuXG5leHBvcnQgY2xhc3MgTGl2ZVZhcmlhYmxlTWFuYWdlciBleHRlbmRzIEJhc2VWYXJpYWJsZU1hbmFnZXIge1xuXG4gICAgcHVibGljIGluaXRGaWx0ZXJFeHByZXNzaW9uQmluZGluZyh2YXJpYWJsZSkge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdmFyaWFibGUuX2NvbnRleHQ7XG4gICAgICAgIGNvbnN0IGRlc3Ryb3lGbiA9IGNvbnRleHQucmVnaXN0ZXJEZXN0cm95TGlzdGVuZXIgPyBjb250ZXh0LnJlZ2lzdGVyRGVzdHJveUxpc3RlbmVyLmJpbmQoY29udGV4dCkgOiBfLm5vb3A7XG4gICAgICAgIC8vIFRvRG8gLSB2YXJpYWJsZSBzZXBlcmF0aW9uXG4gICAgICAgIC8vIGNvbnN0IGZpbHRlclN1YnNjcmlwdGlvbiA9IHByb2Nlc3NGaWx0ZXJFeHBCaW5kTm9kZShjb250ZXh0LCB2YXJpYWJsZS5maWx0ZXJFeHByZXNzaW9ucykuc3Vic2NyaWJlKChyZXNwb25zZTogYW55KSA9PiB7XG4gICAgICAgIC8vICAgICBpZiAodmFyaWFibGUub3BlcmF0aW9uID09PSAncmVhZCcpIHtcbiAgICAgICAgLy8gICAgICAgICAvKiBpZiBhdXRvLXVwZGF0ZSBzZXQgZm9yIHRoZSB2YXJpYWJsZSB3aXRoIHJlYWQgb3BlcmF0aW9uIG9ubHksIGdldCBpdHMgZGF0YSAqL1xuICAgICAgICAvLyAgICAgICAgIGlmICh2YXJpYWJsZS5hdXRvVXBkYXRlICYmICFfLmlzVW5kZWZpbmVkKHJlc3BvbnNlLm5ld1ZhbCkgJiYgXy5pc0Z1bmN0aW9uKHZhcmlhYmxlLnVwZGF0ZSkpIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgZGVib3VuY2VWYXJpYWJsZUNhbGwodmFyaWFibGUsICd1cGRhdGUnKTtcbiAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgIC8vICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAgICAgICAgIC8qIGlmIGF1dG8tdXBkYXRlIHNldCBmb3IgdGhlIHZhcmlhYmxlIHdpdGggcmVhZCBvcGVyYXRpb24gb25seSwgZ2V0IGl0cyBkYXRhICovXG4gICAgICAgIC8vICAgICAgICAgaWYgKHZhcmlhYmxlLmF1dG9VcGRhdGUgJiYgIV8uaXNVbmRlZmluZWQocmVzcG9uc2UubmV3VmFsKSAmJiBfLmlzRnVuY3Rpb24odmFyaWFibGVbdmFyaWFibGUub3BlcmF0aW9uICsgJ1JlY29yZCddKSkge1xuICAgICAgICAvLyAgICAgICAgICAgICBkZWJvdW5jZVZhcmlhYmxlQ2FsbCh2YXJpYWJsZSwgdmFyaWFibGUub3BlcmF0aW9uICsgJ1JlY29yZCcpO1xuICAgICAgICAvLyAgICAgICAgIH1cbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfSk7XG5cbiAgICAgIC8vICBkZXN0cm95Rm4oKCkgPT4gZmlsdGVyU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlRGF0YXNldCh2YXJpYWJsZSwgZGF0YSwgcHJvcGVydGllc01hcCwgcGFnaW5hdGlvbikge1xuICAgICAgICB2YXJpYWJsZS5wYWdpbmF0aW9uID0gcGFnaW5hdGlvbjtcbiAgICAgICAgdmFyaWFibGUuZGF0YVNldCA9IGRhdGE7XG5cbiAgICAgICAgLy8gbGVnYWN5IHByb3BlcnRpZXMgaW4gZGF0YVNldCwgW2RhdGEsIHBhZ2luYXRpb25dXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YXJpYWJsZS5kYXRhU2V0LCAnZGF0YScsIHtcbiAgICAgICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YXJpYWJsZS5kYXRhU2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhcmlhYmxlLmRhdGFTZXQsICdwYWdpbmF0aW9uJywge1xuICAgICAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhcmlhYmxlLnBhZ2luYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgX29wdGlvbnMgb24gdmFyaWFibGUgd2hpY2ggY2FuIGJlIHVzZWQgYnkgdGhlIHdpZGdldHNcbiAgICBwcml2YXRlIHNldFZhcmlhYmxlT3B0aW9ucyh2YXJpYWJsZSwgb3B0aW9ucykge1xuICAgICAgICB2YXJpYWJsZS5fb3B0aW9ucyA9IHZhcmlhYmxlLl9vcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXJpYWJsZS5fb3B0aW9ucy5vcmRlckJ5ID0gb3B0aW9ucyAmJiBvcHRpb25zLm9yZGVyQnk7XG4gICAgICAgIHZhcmlhYmxlLl9vcHRpb25zLmZpbHRlckZpZWxkcyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXJGaWVsZHM7XG4gICAgICAgIHZhcmlhYmxlLl9vcHRpb25zLmxvZ2ljYWxPcCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5sb2dpY2FsT3A7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVFcnJvcih2YXJpYWJsZSwgZXJyb3JDQiwgcmVzcG9uc2UsIG9wdGlvbnMsIGFkdmFuY2VkT3B0aW9ucz8pIHtcbiAgICAgICAgbGV0IG9wdDogQWR2YW5jZWRPcHRpb25zO1xuICAgICAgICAvKiBJZiBjYWxsYmFjayBmdW5jdGlvbiBpcyBwcm92aWRlZCwgc2VuZCB0aGUgZGF0YSB0byB0aGUgY2FsbGJhY2suXG4gICAgICAgICAqIFRoZSBzYW1lIGNhbGxiYWNrIGlmIHRyaWdnZXJlZCBpbiBjYXNlIG9mIGVycm9yIGFsc28uIFRoZSBlcnJvci1oYW5kbGluZyBpcyBkb25lIGluIGdyaWQuanMqL1xuICAgICAgICB0cmlnZ2VyRm4oZXJyb3JDQiwgcmVzcG9uc2UpO1xuXG4gICAgICAgIC8vICBFVkVOVDogT05fUkVTVUxUXG4gICAgICAgIGluaXRpYXRlQ2FsbGJhY2soVkFSSUFCTEVfQ09OU1RBTlRTLkVWRU5ULlJFU1VMVCwgdmFyaWFibGUsIHJlc3BvbnNlLCBhZHZhbmNlZE9wdGlvbnMpO1xuXG4gICAgICAgIC8qIHVwZGF0ZSB0aGUgZGF0YVNldCBhZ2FpbnN0IHRoZSB2YXJpYWJsZSAqL1xuICAgICAgICBpZiAoIW9wdGlvbnMuc2tpcERhdGFTZXRVcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRGF0YXNldCh2YXJpYWJsZSwgZW1wdHlBcnIsIHZhcmlhYmxlLnByb3BlcnRpZXNNYXAsIG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gIEVWRU5UOiBPTl9FUlJPUlxuICAgICAgICBvcHQgPSB0aGlzLnByZXBhcmVDYWxsYmFja09wdGlvbnMob3B0aW9ucy5lcnJvckRldGFpbHMpO1xuICAgICAgICBpbml0aWF0ZUNhbGxiYWNrKFZBUklBQkxFX0NPTlNUQU5UUy5FVkVOVC5FUlJPUiwgdmFyaWFibGUsIHJlc3BvbnNlLCBvcHQpO1xuICAgICAgICAvLyAgRVZFTlQ6IE9OX0NBTl9VUERBVEVcbiAgICAgICAgdmFyaWFibGUuY2FuVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgaW5pdGlhdGVDYWxsYmFjayhWQVJJQUJMRV9DT05TVEFOVFMuRVZFTlQuQ0FOX1VQREFURSwgdmFyaWFibGUsIHJlc3BvbnNlLCBhZHZhbmNlZE9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlcyByZWN1cnNpdmVseSB0aGUgZmlsdGVyRXhwcmVzc2lvbnMgb2JqZWN0IGFuZCBpZiB0aGVyZSBpcyBhbnkgcmVxdWlyZWQgZmllbGQgcHJlc2VudCB3aXRoIG5vIHZhbHVlLFxuICAgICAqIHRoZW4gd2Ugd2lsbCByZXR1cm4gd2l0aG91dCBwcm9jZWVkaW5nIGZ1cnRoZXIuIEl0cyB1cHRvIHRoZSBkZXZlbG9wZXIgdG8gcHJvdmlkZSB0aGUgbWFuZGF0b3J5IHZhbHVlLFxuICAgICAqIGlmIGhlIHdhbnRzIHRvIGFzc2lnbiBpdCBpbiB0ZWggb25iZWZvcmU8ZGVsZXRlL2luc2VydC91cGRhdGU+ZnVuY3Rpb24gdGhlbiBtYWtlIHRoYXQgZmllbGQgaW5cbiAgICAgKiB0aGUgZmlsdGVyIHF1ZXJ5IHNlY3Rpb24gYXMgb3B0aW9uYWxcbiAgICAgKiBAcGFyYW0gZmlsdGVyRXhwcmVzc2lvbnMgLSByZWN1cnNpdmUgcnVsZSBPYmplY3RcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3Qgb3IgYm9vbGVhbi4gT2JqZWN0IGlmIGV2ZXJ5dGhpbmcgZ2V0cyB2YWxpZGF0ZWQgb3IgZWxzZSBqdXN0IGJvb2xlYW4gaW5kaWNhdGluZyBmYWlsdXJlIGluIHRoZSB2YWxpZGF0aW9uc1xuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0RmlsdGVyRXhwckZpZWxkcyA9IGZ1bmN0aW9uIChmaWx0ZXJFeHByZXNzaW9ucykge1xuICAgICAgICBsZXQgaXNSZXF1aXJlZEZpZWxkQWJzZW50ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHRyYXZlcnNlQ2FsbGJhY2tGbiA9IGZ1bmN0aW9uIChwYXJlbnRGaWxFeHBPYmosIGZpbEV4cE9iaikge1xuICAgICAgICAgICAgaWYgKGZpbEV4cE9ialxuICAgICAgICAgICAgICAgICYmIGZpbEV4cE9iai5yZXF1aXJlZFxuICAgICAgICAgICAgICAgICYmICgoXy5pbmRleE9mKFsnbnVsbCcsICdpc25vdG51bGwnLCAnZW1wdHknLCAnaXNub3RlbXB0eScsICdudWxsb3JlbXB0eSddLCBmaWxFeHBPYmoubWF0Y2hNb2RlKSA9PT0gLTEpICYmIGZpbEV4cE9iai52YWx1ZSA9PT0gJycpKSB7XG4gICAgICAgICAgICAgICAgaXNSZXF1aXJlZEZpZWxkQWJzZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIExpdmVWYXJpYWJsZVV0aWxzLnRyYXZlcnNlRmlsdGVyRXhwcmVzc2lvbnMoZmlsdGVyRXhwcmVzc2lvbnMsIHRyYXZlcnNlQ2FsbGJhY2tGbik7XG4gICAgICAgIHJldHVybiBpc1JlcXVpcmVkRmllbGRBYnNlbnQgPyAhaXNSZXF1aXJlZEZpZWxkQWJzZW50IDogZmlsdGVyRXhwcmVzc2lvbnM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0aGUgdXNlciB0byBnZXQgdGhlIGNyaXRlcmlhIG9mIGZpbHRlcmluZyBhbmQgdGhlIGZpbHRlciBmaWVsZHMsIGJhc2VkIG9uIHRoZSBtZXRob2QgY2FsbGVkXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXREYXRhRmlsdGVyT2JqID0gZnVuY3Rpb24gKGNsb25lZEZpbHRlckZpZWxkcykge1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIChjbG9uZWRGaWVsZHMpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldENyaXRlcmlhKGZpbHRlckZpZWxkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3JpdGVyaWFuID0gW107XG4gICAgICAgICAgICAgICAgTGl2ZVZhcmlhYmxlVXRpbHMudHJhdmVyc2VGaWx0ZXJFeHByZXNzaW9ucyhjbG9uZWRGaWVsZHMsIGZ1bmN0aW9uIChmaWx0ZXJFeHByZXNzaW9ucywgY3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlckZpZWxkID09PSBjcml0ZXJpYS50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyaXRlcmlhbi5wdXNoKGNyaXRlcmlhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjcml0ZXJpYW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEZpbHRlckZpZWxkcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVkRmllbGRzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdldEZpbHRlckZpZWxkczogZ2V0RmlsdGVyRmllbGRzLFxuICAgICAgICAgICAgICAgIGdldENyaXRlcmlhOiBnZXRDcml0ZXJpYVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfShjbG9uZWRGaWx0ZXJGaWVsZHMpKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBtYWtlQ2FsbCh2YXJpYWJsZSwgZGJPcGVyYXRpb24sIHBhcmFtcykge1xuICAgICAgICBjb25zdCBzdWNjZXNzSGFuZGxlciA9IChyZXNwb25zZSwgcmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gKGVycm9yLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9IGdldEVyck1lc3NhZ2UoZXJyb3IsIHZhcmlhYmxlLmh0dHBTZXJ2aWNlLmdldExvY2FsZSgpKTtcbiAgICAgICAgICAgIC8vIG5vdGlmeSB2YXJpYWJsZSBlcnJvclxuICAgICAgICAgICAgdGhpcy5ub3RpZnlJbmZsaWdodCh2YXJpYWJsZSwgZmFsc2UpO1xuICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyTXNnLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCByZXFQYXJhbXMgPSBnZW5lcmF0ZUNvbm5lY3Rpb25QYXJhbXMocGFyYW1zLCBkYk9wZXJhdGlvbik7XG4gICAgICAgICAgICByZXFQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiByZXFQYXJhbXMudXJsLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogcmVxUGFyYW1zLm1ldGhvZCxcbiAgICAgICAgICAgICAgICBkYXRhOiByZXFQYXJhbXMuZGF0YSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXFQYXJhbXMuaGVhZGVyc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBhcmFtcy5vcGVyYXRpb24gPSBkYk9wZXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuaHR0cENhbGwocmVxUGFyYW1zLCB2YXJpYWJsZSwgcGFyYW1zKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NIYW5kbGVyKHJlc3BvbnNlLCByZXNvbHZlKTtcbiAgICAgICAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGUsIHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRFbnRpdHlEYXRhKHZhcmlhYmxlLCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICBjb25zdCBkYXRhT2JqOiBhbnkgPSB7fTtcbiAgICAgICAgbGV0IHRhYmxlT3B0aW9ucyxcbiAgICAgICAgICAgIGRiT3BlcmF0aW9uLFxuICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgbmV3RGF0YVNldCxcbiAgICAgICAgICAgIGNsb25lZEZpZWxkcyxcbiAgICAgICAgICAgIHJlcXVlc3REYXRhLFxuICAgICAgICAgICAgZGJPcGVyYXRpb25PcHRpb25zLFxuICAgICAgICAgICAgZ2V0RW50aXR5U3VjY2VzcyxcbiAgICAgICAgICAgIGdldEVudGl0eUVycm9yO1xuXG4gICAgICAgIC8vIGVtcHR5IGFycmF5IGtlcHQgKGlmIHZhcmlhYmxlIGlzIG5vdCBvZiByZWFkIHR5cGUgZmlsdGVyRXhwcmVzc2lvbnMgd2lsbCBiZSB1bmRlZmluZWQpXG4gICAgICAgIGNsb25lZEZpZWxkcyA9IHRoaXMuZ2V0RmlsdGVyRXhwckZpZWxkcyhnZXRDbG9uZWRPYmplY3QodmFyaWFibGUuZmlsdGVyRXhwcmVzc2lvbnMgfHwge30pKTtcbiAgICAgICAgLy8gY2xvbmVkRmllbGRzID0gZ2V0Q2xvbmVkT2JqZWN0KHZhcmlhYmxlLmZpbHRlckZpZWxkcyk7XG4gICAgICAgIC8vICBFVkVOVDogT05fQkVGT1JFX1VQREFURVxuICAgICAgICBvdXRwdXQgPSBpbml0aWF0ZUNhbGxiYWNrKFZBUklBQkxFX0NPTlNUQU5UUy5FVkVOVC5CRUZPUkVfVVBEQVRFLCB2YXJpYWJsZSwgdGhpcy5nZXREYXRhRmlsdGVyT2JqKGNsb25lZEZpZWxkcyksIG9wdGlvbnMpO1xuICAgICAgICAvLyBpZiBmaWx0ZXJGaWVsZHMgYXJlIHVwZGF0ZWQgb3IgbW9kaWZpZWQgaW5zaWRlIHRoZSBvbkJlZm9yZVVwZGF0ZSBldmVudCB0aGVuIGluIGRldmljZSB1c2UgdGhlc2UgZmllbGRzIHRvIGZpbHRlci5cbiAgICAgICAgY29uc3QgdXBkYXRlRmlsdGVyRmllbGRzID0gXy5pc09iamVjdChvdXRwdXQpID8gZ2V0Q2xvbmVkT2JqZWN0KG91dHB1dCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChvdXRwdXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAkcXVldWUucHJvY2Vzcyh2YXJpYWJsZSk7XG4gICAgICAgICAgICAvLyAkcm9vdFNjb3BlLiRlbWl0KCd0b2dnbGUtdmFyaWFibGUtc3RhdGUnLCB2YXJpYWJsZSwgZmFsc2UpO1xuICAgICAgICAgICAgdHJpZ2dlckZuKGVycm9yLCAnQ2FsbCBzdG9wcGVkIGZyb20gdGhlIGV2ZW50OiAnICsgVkFSSUFCTEVfQ09OU1RBTlRTLkVWRU5ULkJFRk9SRV9VUERBVEUpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYWxsIHN0b3BwZWQgZnJvbSB0aGUgZXZlbnQ6ICcgKyBWQVJJQUJMRV9DT05TVEFOVFMuRVZFTlQuQkVGT1JFX1VQREFURSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXJpYWJsZS5jYW5VcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICB0YWJsZU9wdGlvbnMgPSBMaXZlVmFyaWFibGVVdGlscy5wcmVwYXJlVGFibGVPcHRpb25zKHZhcmlhYmxlLCBvcHRpb25zLCBfLmlzT2JqZWN0KG91dHB1dCkgPyBvdXRwdXQgOiBjbG9uZWRGaWVsZHMpO1xuXG4gICAgICAgIC8vICBpZiB0YWJsZU9wdGlvbnMgb2JqZWN0IGhhcyBxdWVyeSB0aGVuIHNldCB0aGUgZGJPcGVyYXRpb24gdG8gJ3NlYXJjaFRhYmxlRGF0YVdpdGhRdWVyeSdcbiAgICAgICAgaWYgKG9wdGlvbnMuc2VhcmNoV2l0aFF1ZXJ5KSB7XG4gICAgICAgICAgICBkYk9wZXJhdGlvbiA9ICdzZWFyY2hUYWJsZURhdGFXaXRoUXVlcnknO1xuICAgICAgICAgICAgcmVxdWVzdERhdGEgPSB0YWJsZU9wdGlvbnMucXVlcnkgPyAoJ3E9JyArIHRhYmxlT3B0aW9ucy5xdWVyeSkgOiAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRiT3BlcmF0aW9uID0gKHRhYmxlT3B0aW9ucy5maWx0ZXIgJiYgdGFibGVPcHRpb25zLmZpbHRlci5sZW5ndGgpID8gJ3NlYXJjaFRhYmxlRGF0YScgOiAncmVhZFRhYmxlRGF0YSc7XG4gICAgICAgICAgICByZXF1ZXN0RGF0YSA9IHRhYmxlT3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZGJPcGVyYXRpb25PcHRpb25zID0ge1xuICAgICAgICAgICAgJ3Byb2plY3RJRCc6ICRyb290U2NvcGUucHJvamVjdC5pZCxcbiAgICAgICAgICAgICdzZXJ2aWNlJzogdmFyaWFibGUuZ2V0UHJlZmFiTmFtZSgpID8gJycgOiAnc2VydmljZXMnLFxuICAgICAgICAgICAgJ2RhdGFNb2RlbE5hbWUnOiB2YXJpYWJsZS5saXZlU291cmNlLFxuICAgICAgICAgICAgJ2VudGl0eU5hbWUnOiB2YXJpYWJsZS50eXBlLFxuICAgICAgICAgICAgJ3BhZ2UnOiBvcHRpb25zLnBhZ2UgfHwgMSxcbiAgICAgICAgICAgICdzaXplJzogb3B0aW9ucy5wYWdlc2l6ZSB8fCAoQ09OU1RBTlRTLmlzUnVuTW9kZSA/ICh2YXJpYWJsZS5tYXhSZXN1bHRzIHx8IDIwKSA6ICh2YXJpYWJsZS5kZXNpZ25NYXhSZXN1bHRzIHx8IDIwKSksXG4gICAgICAgICAgICAnc29ydCc6IHRhYmxlT3B0aW9ucy5zb3J0LFxuICAgICAgICAgICAgJ2RhdGEnOiByZXF1ZXN0RGF0YSxcbiAgICAgICAgICAgICdmaWx0ZXInOiBMaXZlVmFyaWFibGVVdGlscy5nZXRXaGVyZUNsYXVzZUdlbmVyYXRvcih2YXJpYWJsZSwgb3B0aW9ucywgdXBkYXRlRmlsdGVyRmllbGRzKSxcbiAgICAgICAgICAgIC8vICdmaWx0ZXJNZXRhJzogdGFibGVPcHRpb25zLmZpbHRlcixcbiAgICAgICAgICAgICd1cmwnOiB2YXJpYWJsZS5nZXRQcmVmYWJOYW1lKCkgPyAoJHJvb3RTY29wZS5wcm9qZWN0LmRlcGxveWVkVXJsICsgJy9wcmVmYWJzLycgKyB2YXJpYWJsZS5nZXRQcmVmYWJOYW1lKCkpIDogJHJvb3RTY29wZS5wcm9qZWN0LmRlcGxveWVkVXJsXG4gICAgICAgIH07XG4gICAgICAgIGdldEVudGl0eVN1Y2Nlc3MgPSAocmVzcG9uc2U6IGFueSwgcmVzb2x2ZTogYW55KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UudHlwZSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2UuYm9keTtcbiAgICAgICAgICAgICAgICBkYXRhT2JqLmRhdGEgPSByZXNwb25zZS5jb250ZW50O1xuICAgICAgICAgICAgICAgIGRhdGFPYmoucGFnaW5hdGlvbiA9IF8ub21pdChyZXNwb25zZSwgJ2NvbnRlbnQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhZHZhbmNlZE9wdGlvbnM6IEFkdmFuY2VkT3B0aW9ucyA9IHRoaXMucHJlcGFyZUNhbGxiYWNrT3B0aW9ucyhyZXNwb25zZSwge3BhZ2luYXRpb246IGRhdGFPYmoucGFnaW5hdGlvbn0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKChyZXNwb25zZSAmJiByZXNwb25zZS5lcnJvcikgfHwgIXJlc3BvbnNlIHx8ICFfLmlzQXJyYXkocmVzcG9uc2UuY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcih2YXJpYWJsZSwgZXJyb3IsIHJlc3BvbnNlLmVycm9yLCBvcHRpb25zLCBhZHZhbmNlZE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWNvZGVEYXRhKHJlc3BvbnNlLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIExpdmVWYXJpYWJsZVV0aWxzLnByb2Nlc3NCbG9iQ29sdW1ucyhyZXNwb25zZS5jb250ZW50LCB2YXJpYWJsZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuc2tpcERhdGFTZXRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gIEVWRU5UOiBPTl9SRVNVTFRcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhdGVDYWxsYmFjayhWQVJJQUJMRV9DT05TVEFOVFMuRVZFTlQuUkVTVUxULCB2YXJpYWJsZSwgZGF0YU9iai5kYXRhLCBhZHZhbmNlZE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgRVZFTlQ6IE9OX1BSRVBBUkVTRVREQVRBXG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFTZXQgPSBpbml0aWF0ZUNhbGxiYWNrKFZBUklBQkxFX0NPTlNUQU5UUy5FVkVOVC5QUkVQQVJFX1NFVERBVEEsIHZhcmlhYmxlLCBkYXRhT2JqLmRhdGEsIGFkdmFuY2VkT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdEYXRhU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXR0aW5nIG5ld0RhdGFTZXQgYXMgdGhlIHJlc3BvbnNlIHRvIHNlcnZpY2UgdmFyaWFibGUgb25QcmVwYXJlU2V0RGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YU9iai5kYXRhID0gbmV3RGF0YVNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvKiB1cGRhdGUgdGhlIGRhdGFTZXQgYWdhaW5zdCB0aGUgdmFyaWFibGUgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVEYXRhc2V0KHZhcmlhYmxlLCBkYXRhT2JqLmRhdGEsIHZhcmlhYmxlLnByb3BlcnRpZXNNYXAsIGRhdGFPYmoucGFnaW5hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFyaWFibGVPcHRpb25zKHZhcmlhYmxlLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB3YXRjaGVycyBzaG91bGQgZ2V0IHRyaWdnZXJlZCBiZWZvcmUgY2FsbGluZyBvblN1Y2Nlc3MgZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHRoYXQgYW55IHZhcmlhYmxlL3dpZGdldCBkZXBlbmRpbmcgb24gdGhpcyB2YXJpYWJsZSdzIGRhdGEgaXMgdXBkYXRlZFxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZS5ub3RpZnkoVmFyaWFibGVFdmVudHMuQUZURVJfSU5WT0tFLCBbdGhpcywgZGF0YU9iai5kYXRhXSk7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgY2FsbGJhY2sgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIHNlbmQgdGhlIGRhdGEgdG8gdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyRm4oc3VjY2VzcywgZGF0YU9iai5kYXRhLCB2YXJpYWJsZS5wcm9wZXJ0aWVzTWFwLCBkYXRhT2JqLnBhZ2luYXRpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgRVZFTlQ6IE9OX1NVQ0NFU1NcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYXRlQ2FsbGJhY2soVkFSSUFCTEVfQ09OU1RBTlRTLkVWRU5ULlNVQ0NFU1MsIHZhcmlhYmxlLCBkYXRhT2JqLmRhdGEsIGFkdmFuY2VkT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgRVZFTlQ6IE9OX0NBTl9VUERBVEVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlLmNhblVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWF0ZUNhbGxiYWNrKFZBUklBQkxFX0NPTlNUQU5UUy5FVkVOVC5DQU5fVVBEQVRFLCB2YXJpYWJsZSwgZGF0YU9iai5kYXRhLCBhZHZhbmNlZE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoe2RhdGE6IGRhdGFPYmouZGF0YSwgcGFnaW5hdGlvbjogZGF0YU9iai5wYWdpbmF0aW9ufSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGdldEVudGl0eUVycm9yID0gKGU6IGFueSwgcmVqZWN0OiBhbnkpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFyaWFibGVPcHRpb25zKHZhcmlhYmxlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IodmFyaWFibGUsIGVycm9yLCBlLmVycm9yLCBfLmV4dGVuZChvcHRpb25zLCB7ZXJyb3JEZXRhaWxzOiBlLmRldGFpbHN9KSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZS5lcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qIGlmIGl0IGlzIGEgcHJlZmFiIHZhcmlhYmxlICh1c2VkIGluIGEgbm9ybWFsIHByb2plY3QpLCBtb2RpZnkgdGhlIHVybCAqL1xuICAgICAgICAvKkZldGNoIHRoZSB0YWJsZSBkYXRhKi9cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFrZUNhbGwodmFyaWFibGUsIGRiT3BlcmF0aW9uLCBkYk9wZXJhdGlvbk9wdGlvbnMpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgZ2V0RW50aXR5U3VjY2VzcyhyZXNwb25zZSwgcmVzb2x2ZSk7XG4gICAgICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGdldEVudGl0eUVycm9yKGVyciwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHBlcmZvcm1DVUQob3BlcmF0aW9uLCB2YXJpYWJsZSwgb3B0aW9ucywgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIG9wdGlvbnMuaW5wdXRGaWVsZHMgPSBvcHRpb25zLmlucHV0RmllbGRzIHx8IGdldENsb25lZE9iamVjdCh2YXJpYWJsZS5pbnB1dEZpZWxkcyk7XG4gICAgICAgIHJldHVybiAkcXVldWUuc3VibWl0KHZhcmlhYmxlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5SW5mbGlnaHQodmFyaWFibGUsICFvcHRpb25zLnNraXBUb2dnbGVTdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb0NVRChvcGVyYXRpb24sIHZhcmlhYmxlLCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcilcbiAgICAgICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgJHF1ZXVlLnByb2Nlc3ModmFyaWFibGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUluZmxpZ2h0KHZhcmlhYmxlLCBmYWxzZSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICRxdWV1ZS5wcm9jZXNzKHZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlJbmZsaWdodCh2YXJpYWJsZSwgZmFsc2UsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBlcnJvcik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkb0NVRChhY3Rpb24sIHZhcmlhYmxlLCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICBjb25zdCBwcm9qZWN0SUQgPSAkcm9vdFNjb3BlLnByb2plY3QuaWQgfHwgJHJvb3RTY29wZS5wcm9qZWN0TmFtZSxcbiAgICAgICAgICAgIHByaW1hcnlLZXkgPSBMaXZlVmFyaWFibGVVdGlscy5nZXRQcmltYXJ5S2V5KHZhcmlhYmxlKSxcbiAgICAgICAgICAgIGlzRm9ybURhdGFTdXBwb3J0ZWQgPSAod2luZG93LkZpbGUgJiYgd2luZG93LkZpbGVSZWFkZXIgJiYgd2luZG93LkZpbGVMaXN0ICYmIHdpbmRvdy5CbG9iKTtcblxuICAgICAgICBsZXQgZGJOYW1lLFxuICAgICAgICAgICAgY29tcG9zaXRlSWQgPSAnJyxcbiAgICAgICAgICAgIHJvd09iamVjdCA9IHt9LFxuICAgICAgICAgICAgcHJldkRhdGEsXG4gICAgICAgICAgICBjb21wb3NpdGVLZXlzRGF0YSA9IHt9LFxuICAgICAgICAgICAgcHJldkNvbXBvc2l0ZUtleXNEYXRhID0ge30sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGNvbHVtbk5hbWUsXG4gICAgICAgICAgICBjbG9uZWRGaWVsZHMsXG4gICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICBvbkNVRGVycm9yLFxuICAgICAgICAgICAgb25DVURzdWNjZXNzLFxuICAgICAgICAgICAgaW5wdXRGaWVsZHMgPSBvcHRpb25zLmlucHV0RmllbGRzIHx8IHZhcmlhYmxlLmlucHV0RmllbGRzO1xuXG4gICAgICAgIC8vIEVWRU5UOiBPTl9CRUZPUkVfVVBEQVRFXG4gICAgICAgIGNsb25lZEZpZWxkcyA9IGdldENsb25lZE9iamVjdChpbnB1dEZpZWxkcyk7XG4gICAgICAgIG91dHB1dCA9IGluaXRpYXRlQ2FsbGJhY2soVkFSSUFCTEVfQ09OU1RBTlRTLkVWRU5ULkJFRk9SRV9VUERBVEUsIHZhcmlhYmxlLCBjbG9uZWRGaWVsZHMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAob3V0cHV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gJHJvb3RTY29wZS4kZW1pdCgndG9nZ2xlLXZhcmlhYmxlLXN0YXRlJywgdmFyaWFibGUsIGZhbHNlKTtcbiAgICAgICAgICAgIHRyaWdnZXJGbihlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbGwgc3RvcHBlZCBmcm9tIHRoZSBldmVudDogJyArIFZBUklBQkxFX0NPTlNUQU5UUy5FVkVOVC5CRUZPUkVfVVBEQVRFKTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dEZpZWxkcyA9IF8uaXNPYmplY3Qob3V0cHV0KSA/IG91dHB1dCA6IGNsb25lZEZpZWxkcztcbiAgICAgICAgdmFyaWFibGUuY2FuVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucm93KSB7XG4gICAgICAgICAgICByb3dPYmplY3QgPSBvcHRpb25zLnJvdztcbiAgICAgICAgICAgIC8vIEZvciBkYXRldGltZSB0eXBlcywgY29udmVydCB0aGUgdmFsdWUgdG8gdGhlIGZvcm1hdCBhY2NlcHRlZCBieSBiYWNrZW5kXG4gICAgICAgICAgICBfLmZvckVhY2gocm93T2JqZWN0LCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkVHlwZSA9IExpdmVWYXJpYWJsZVV0aWxzLmdldEZpZWxkVHlwZShrZXksIHZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICBsZXQgZmllbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEYXRlVGltZVR5cGUoZmllbGRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUb0RvIC0gdmFyaWFibGUgc2VwZXJhdGlvblxuICAgICAgICAgICAgICAgICAgICBmaWVsZFZhbHVlID0gZm9ybWF0RGF0ZSh2YWx1ZSwgZmllbGRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgcm93T2JqZWN0W2tleV0gPSBmaWVsZFZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc0FycmF5KHZhbHVlKSAmJiBMaXZlVmFyaWFibGVVdGlscy5pc1N0cmluZ1R5cGUoZmllbGRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgJywnIHNlcGFyYXRlZCBzdHJpbmcgaWYgcGFyYW0gaXMgbm90IGFycmF5IHR5cGUgYnV0IHZhbHVlIGlzIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgPSBfLmpvaW4odmFsdWUsICcsJyk7XG4gICAgICAgICAgICAgICAgICAgIHJvd09iamVjdFtrZXldID0gZmllbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE1lcmdlIGlucHV0RmllbGRzIGFsb25nIHdpdGggZGF0YU9iaiB3aGlsZSBtYWtpbmcgSW5zZXJ0L1VwZGF0ZS9EZWxldGVcbiAgICAgICAgICAgIF8uZm9yRWFjaChpbnB1dEZpZWxkcywgKGF0dHJWYWx1ZSwgYXR0ck5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoKGlzRGVmaW5lZChhdHRyVmFsdWUpICYmIGF0dHJWYWx1ZSAhPT0gJycpICYmICghaXNEZWZpbmVkKHJvd09iamVjdFthdHRyTmFtZV0pIHx8IHJvd09iamVjdFthdHRyTmFtZV0gPT09ICcnKSkge1xuICAgICAgICAgICAgICAgICAgICByb3dPYmplY3RbYXR0ck5hbWVdID0gYXR0clZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXy5mb3JFYWNoKGlucHV0RmllbGRzLCAoZmllbGRWYWx1ZSwgZmllbGROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZpZWxkVHlwZTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmltYXJ5S2V5cyA9IHZhcmlhYmxlLnByb3BlcnRpZXNNYXAucHJpbWFyeUZpZWxkcyB8fCB2YXJpYWJsZS5wcm9wZXJ0aWVzTWFwLnByaW1hcnlLZXlzO1xuICAgICAgICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChmaWVsZFZhbHVlKSAmJiBmaWVsZFZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAvKkZvciBkZWxldGUgYWN0aW9uLCB0aGUgaW5wdXRGaWVsZHMgbmVlZCB0byBiZSBzZXQgaW4gdGhlIHJlcXVlc3QgVVJMLiBIZW5jZSBjb21wb3NpdGVJZCBpcyBzZXQuXG4gICAgICAgICAgICAgICAgICAgICAqIEZvciBpbnNlcnQgYWN0aW9uIGlucHV0RmllbGRzIG5lZWQgdG8gYmUgc2V0IGluIHRoZSByZXF1ZXN0IGRhdGEuIEhlbmNlIHJvd09iamVjdCBpcyBzZXQuXG4gICAgICAgICAgICAgICAgICAgICAqIEZvciB1cGRhdGUgYWN0aW9uLCBib3RoIG5lZWQgdG8gYmUgc2V0LiovXG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09ICdkZWxldGVUYWJsZURhdGEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGVJZCA9IGZpZWxkVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3VwZGF0ZVRhYmxlRGF0YScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlLZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGROYW1lID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlSWQgPSBmaWVsZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdkZWxldGVUYWJsZURhdGEnIHx8IExpdmVWYXJpYWJsZVV0aWxzLmlzQ29tcG9zaXRlS2V5KHByaW1hcnlLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFR5cGUgPSBMaXZlVmFyaWFibGVVdGlscy5nZXRGaWVsZFR5cGUoZmllbGROYW1lLCB2YXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNEYXRlVGltZVR5cGUoZmllbGRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvRG8gLSB2YXJpYWJsZSBzZXBlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9IGZvcm1hdERhdGUoZmllbGRWYWx1ZSwgZmllbGRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc0FycmF5KGZpZWxkVmFsdWUpICYmIExpdmVWYXJpYWJsZVV0aWxzLmlzU3RyaW5nVHlwZShmaWVsZFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0ICcsJyBzZXBhcmF0ZWQgc3RyaW5nIGlmIHBhcmFtIGlzIG5vdCBhcnJheSB0eXBlIGJ1dCB2YWx1ZSBpcyBhbiBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgPSBfLmpvaW4oZmllbGRWYWx1ZSwgJywnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd09iamVjdFtmaWVsZE5hbWVdID0gZmllbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgcmVsYXRlZCBlbnRpdGllcywgY2xlYXIgdGhlIGJsb2IgdHlwZSBmaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKF8uaXNPYmplY3QoZmllbGRWYWx1ZSkgJiYgIV8uaXNBcnJheShmaWVsZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKGZpZWxkVmFsdWUsICh2YWwsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChMaXZlVmFyaWFibGVVdGlscy5nZXRGaWVsZFR5cGUoZmllbGROYW1lLCB2YXJpYWJsZSwga2V5KSA9PT0gJ2Jsb2InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkVmFsdWVba2V5XSA9IHZhbCA9PT0gbnVsbCA/IHZhbCA6ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAndXBkYXRlVGFibGVEYXRhJzpcbiAgICAgICAgICAgICAgICBwcmV2RGF0YSA9IG9wdGlvbnMucHJldkRhdGEgfHwge307XG4gICAgICAgICAgICAgICAgLypDb25zdHJ1Y3QgdGhlIFwicmVxdWVzdERhdGFcIiBiYXNlZCBvbiB3aGV0aGVyIHRoZSB0YWJsZSBhc3NvY2lhdGVkIHdpdGggdGhlIGxpdmUtdmFyaWFibGUgaGFzIGEgY29tcG9zaXRlIGtleSBvciBub3QuKi9cbiAgICAgICAgICAgICAgICBpZiAoTGl2ZVZhcmlhYmxlVXRpbHMuaXNDb21wb3NpdGVLZXkocHJpbWFyeUtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKExpdmVWYXJpYWJsZVV0aWxzLmlzTm9QcmltYXJ5S2V5KHByaW1hcnlLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Q29tcG9zaXRlS2V5c0RhdGEgPSBwcmV2RGF0YSB8fCBvcHRpb25zLnJvd0RhdGEgfHwgcm93T2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlS2V5c0RhdGEgPSByb3dPYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5S2V5LmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGVLZXlzRGF0YVtrZXldID0gcm93T2JqZWN0W2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gY2FzZSBvZiBwZXJpb2RpYyB1cGRhdGUgZm9yIEJ1c2luZXNzIHRlbXBvcmFsIGZpZWxkcywgcGFzc2luZyB1cGRhdGVkIGZpZWxkIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucGVyaW9kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZDb21wb3NpdGVLZXlzRGF0YVtrZXldID0gcm93T2JqZWN0W2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldkNvbXBvc2l0ZUtleXNEYXRhW2tleV0gPSBwcmV2RGF0YVtrZXldIHx8IChvcHRpb25zLnJvd0RhdGEgJiYgb3B0aW9ucy5yb3dEYXRhW2tleV0pIHx8IHJvd09iamVjdFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucm93ID0gY29tcG9zaXRlS2V5c0RhdGE7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY29tcG9zaXRlS2V5c0RhdGEgPSBwcmV2Q29tcG9zaXRlS2V5c0RhdGE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZignLicpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gcHJldkRhdGFba2V5XSB8fCAob3B0aW9ucy5yb3dEYXRhICYmIG9wdGlvbnMucm93RGF0YVtrZXldKSB8fCByb3dPYmplY3Rba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uTmFtZSA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gcHJldkRhdGFbY29sdW1uTmFtZVswXV1bY29sdW1uTmFtZVsxXV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmlkID0gaWQ7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucm93ID0gcm93T2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGVsZXRlVGFibGVEYXRhJzpcbiAgICAgICAgICAgICAgICAvKkNvbnN0cnVjdCB0aGUgXCJyZXF1ZXN0RGF0YVwiIGJhc2VkIG9uIHdoZXRoZXIgdGhlIHRhYmxlIGFzc29jaWF0ZWQgd2l0aCB0aGUgbGl2ZS12YXJpYWJsZSBoYXMgYSBjb21wb3NpdGUga2V5IG9yIG5vdC4qL1xuICAgICAgICAgICAgICAgIGlmIChMaXZlVmFyaWFibGVVdGlscy5pc0NvbXBvc2l0ZUtleShwcmltYXJ5S2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTGl2ZVZhcmlhYmxlVXRpbHMuaXNOb1ByaW1hcnlLZXkocHJpbWFyeUtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0ZUtleXNEYXRhID0gcm93T2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlS2V5c0RhdGFba2V5XSA9IHJvd09iamVjdFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jb21wb3NpdGVLZXlzRGF0YSA9IGNvbXBvc2l0ZUtleXNEYXRhO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIV8uaXNFbXB0eShyb3dPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW1hcnlLZXkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSByb3dPYmplY3Rba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uTmFtZSA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gcm93T2JqZWN0W2NvbHVtbk5hbWVbMF1dW2NvbHVtbk5hbWVbMV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5pZCA9IGlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGFibGUgaGFzIGJsb2IgY29sdW1uIHRoZW4gc2VuZCBtdWx0aXBhcnQgZGF0YVxuICAgICAgICBpZiAoKGFjdGlvbiA9PT0gJ3VwZGF0ZVRhYmxlRGF0YScgfHwgYWN0aW9uID09PSAnaW5zZXJ0VGFibGVEYXRhJykgJiYgTGl2ZVZhcmlhYmxlVXRpbHMuaGFzQmxvYih2YXJpYWJsZSkgJiYgaXNGb3JtRGF0YVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3VwZGF0ZVRhYmxlRGF0YScpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSAndXBkYXRlTXVsdGlQYXJ0VGFibGVEYXRhJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uID0gJ2luc2VydE11bHRpUGFydFRhYmxlRGF0YSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dPYmplY3QgPSBMaXZlVmFyaWFibGVVdGlscy5wcmVwYXJlRm9ybURhdGEodmFyaWFibGUsIHJvd09iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgLypDaGVjayBpZiBcIm9wdGlvbnNcIiBoYXZlIHRoZSBcImNvbXBvc2l0ZUtleXNEYXRhXCIgcHJvcGVydHkuKi9cbiAgICAgICAgaWYgKG9wdGlvbnMuY29tcG9zaXRlS2V5c0RhdGEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndXBkYXRlVGFibGVEYXRhJzpcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gJ3VwZGF0ZUNvbXBvc2l0ZVRhYmxlRGF0YSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZVRhYmxlRGF0YSc6XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdkZWxldGVDb21wb3NpdGVUYWJsZURhdGEnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd1cGRhdGVNdWx0aVBhcnRUYWJsZURhdGEnOlxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSAndXBkYXRlTXVsdGlQYXJ0Q29tcG9zaXRlVGFibGVEYXRhJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb3NpdGVJZCA9IExpdmVWYXJpYWJsZVV0aWxzLmdldENvbXBvc2l0ZUlEVVJMKG9wdGlvbnMuY29tcG9zaXRlS2V5c0RhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGRiTmFtZSA9IHZhcmlhYmxlLmxpdmVTb3VyY2U7XG5cbiAgICAgICAgLypTZXQgdGhlIFwiZGF0YVwiIGluIHRoZSByZXF1ZXN0IHRvIFwidW5kZWZpbmVkXCIgaWYgdGhlcmUgaXMgbm8gZGF0YS5cbiAgICAgICAgKiBUaGlzIGhhbmRsZXMgY2FzZXMgc3VjaCBhcyBcIkRlbGV0ZVwiIHJlcXVlc3RzIHdoZXJlIGRhdGEgc2hvdWxkIG5vdCBiZSBwYXNzZWQuKi9cbiAgICAgICAgaWYgKF8uaXNFbXB0eShyb3dPYmplY3QpICYmIGFjdGlvbiA9PT0gJ2RlbGV0ZVRhYmxlRGF0YScpIHtcbiAgICAgICAgICAgIHJvd09iamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoYWN0aW9uID09PSAndXBkYXRlQ29tcG9zaXRlVGFibGVEYXRhJyB8fCBhY3Rpb24gPT09ICdkZWxldGVDb21wb3NpdGVUYWJsZURhdGEnKSAmJiBvcHRpb25zLnBlcmlvZCkge1xuICAgICAgICAgICAgLy8gY2FwaXRhbGl6ZSBmaXJzdCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIGFjdGlvbiA9ICdwZXJpb2QnICsgYWN0aW9uLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgYWN0aW9uLnN1YnN0cigxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRiT3BlcmF0aW9ucyA9IHtcbiAgICAgICAgICAgICdwcm9qZWN0SUQnOiBwcm9qZWN0SUQsXG4gICAgICAgICAgICAnc2VydmljZSc6IHZhcmlhYmxlLl9wcmVmYWJOYW1lID8gJycgOiAnc2VydmljZXMnLFxuICAgICAgICAgICAgJ2RhdGFNb2RlbE5hbWUnOiBkYk5hbWUsXG4gICAgICAgICAgICAnZW50aXR5TmFtZSc6IHZhcmlhYmxlLnR5cGUsXG4gICAgICAgICAgICAnaWQnOiAhXy5pc1VuZGVmaW5lZChvcHRpb25zLmlkKSA/IGVuY29kZVVSSUNvbXBvbmVudChvcHRpb25zLmlkKSA6IGNvbXBvc2l0ZUlkLFxuICAgICAgICAgICAgJ2RhdGEnOiByb3dPYmplY3QsXG4gICAgICAgICAgICAndXJsJzogdmFyaWFibGUuX3ByZWZhYk5hbWUgPyAoJHJvb3RTY29wZS5wcm9qZWN0LmRlcGxveWVkVXJsICsgJy9wcmVmYWJzLycgKyB2YXJpYWJsZS5fcHJlZmFiTmFtZSkgOiAkcm9vdFNjb3BlLnByb2plY3QuZGVwbG95ZWRVcmxcbiAgICAgICAgfTtcblxuICAgICAgICBvbkNVRGVycm9yID0gKHJlc3BvbnNlOiBhbnksIHJlamVjdDogYW55KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlcnJNc2cgPSByZXNwb25zZS5lcnJvcjtcbiAgICAgICAgICAgIGNvbnN0IGFkdmFuY2VkT3B0aW9uczogQWR2YW5jZWRPcHRpb25zID0gdGhpcy5wcmVwYXJlQ2FsbGJhY2tPcHRpb25zKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIC8vIEVWRU5UOiBPTl9SRVNVTFRcbiAgICAgICAgICAgIGluaXRpYXRlQ2FsbGJhY2soVkFSSUFCTEVfQ09OU1RBTlRTLkVWRU5ULlJFU1VMVCwgdmFyaWFibGUsIGVyck1zZywgYWR2YW5jZWRPcHRpb25zKTtcbiAgICAgICAgICAgIC8vIEVWRU5UOiBPTl9FUlJPUlxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnNraXBOb3RpZmljYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpbml0aWF0ZUNhbGxiYWNrKFZBUklBQkxFX0NPTlNUQU5UUy5FVkVOVC5FUlJPUiwgdmFyaWFibGUsIGVyck1zZywgYWR2YW5jZWRPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVWRU5UOiBPTl9DQU5fVVBEQVRFXG4gICAgICAgICAgICB2YXJpYWJsZS5jYW5VcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgaW5pdGlhdGVDYWxsYmFjayhWQVJJQUJMRV9DT05TVEFOVFMuRVZFTlQuQ0FOX1VQREFURSwgdmFyaWFibGUsIGVyck1zZywgYWR2YW5jZWRPcHRpb25zKTtcbiAgICAgICAgICAgIHRyaWdnZXJGbihlcnJvciwgZXJyTXNnKTtcbiAgICAgICAgICAgIHJlamVjdChlcnJNc2cpO1xuICAgICAgICB9O1xuXG4gICAgICAgIG9uQ1VEc3VjY2VzcyA9IChkYXRhOiBhbnksIHJlc29sdmU6IGFueSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gZGF0YS5ib2R5O1xuICAgICAgICAgICAgY29uc3QgYWR2YW5jZWRPcHRpb25zOiBBZHZhbmNlZE9wdGlvbnMgPSB0aGlzLnByZXBhcmVDYWxsYmFja09wdGlvbnMoZGF0YSk7XG5cbiAgICAgICAgICAgICRxdWV1ZS5wcm9jZXNzKHZhcmlhYmxlKTtcbiAgICAgICAgICAgIC8qIGlmIGVycm9yIHJlY2VpdmVkIG9uIG1ha2luZyBjYWxsLCBjYWxsIGVycm9yIGNhbGxiYWNrICovXG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBFVkVOVDogT05fUkVTVUxUXG4gICAgICAgICAgICAgICAgaW5pdGlhdGVDYWxsYmFjayhWQVJJQUJMRV9DT05TVEFOVFMuRVZFTlQuUkVTVUxULCB2YXJpYWJsZSwgcmVzcG9uc2UsIGFkdmFuY2VkT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgLy8gRVZFTlQ6IE9OX0VSUk9SXG4gICAgICAgICAgICAgICAgaW5pdGlhdGVDYWxsYmFjayhWQVJJQUJMRV9DT05TVEFOVFMuRVZFTlQuRVJST1IsIHZhcmlhYmxlLCByZXNwb25zZS5lcnJvciwgYWR2YW5jZWRPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAvLyBFVkVOVDogT05fQ0FOX1VQREFURVxuICAgICAgICAgICAgICAgIHZhcmlhYmxlLmNhblVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaW5pdGlhdGVDYWxsYmFjayhWQVJJQUJMRV9DT05TVEFOVFMuRVZFTlQuQ0FOX1VQREFURSwgdmFyaWFibGUsIHJlc3BvbnNlLmVycm9yLCBhZHZhbmNlZE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJGbihlcnJvciwgcmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZXNwb25zZS5lcnJvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVWRU5UOiBPTl9SRVNVTFRcbiAgICAgICAgICAgIGluaXRpYXRlQ2FsbGJhY2soVkFSSUFCTEVfQ09OU1RBTlRTLkVWRU5ULlJFU1VMVCwgdmFyaWFibGUsIHJlc3BvbnNlLCBhZHZhbmNlZE9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHZhcmlhYmxlLm9wZXJhdGlvbiAhPT0gJ3JlYWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gRVZFTlQ6IE9OX1BSRVBBUkVTRVREQVRBXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RGF0YVNldCA9IGluaXRpYXRlQ2FsbGJhY2soVkFSSUFCTEVfQ09OU1RBTlRTLkVWRU5ULlBSRVBBUkVfU0VUREFUQSwgdmFyaWFibGUsIHJlc3BvbnNlLCBhZHZhbmNlZE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdEYXRhU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgbmV3RGF0YVNldCBhcyB0aGUgcmVzcG9uc2UgdG8gc2VydmljZSB2YXJpYWJsZSBvblByZXBhcmVTZXREYXRhXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gbmV3RGF0YVNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyaWFibGUuZGF0YVNldCA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB3YXRjaGVycyBzaG91bGQgZ2V0IHRyaWdnZXJlZCBiZWZvcmUgY2FsbGluZyBvblN1Y2Nlc3MgZXZlbnQuXG4gICAgICAgICAgICAvLyBzbyB0aGF0IGFueSB2YXJpYWJsZS93aWRnZXQgZGVwZW5kaW5nIG9uIHRoaXMgdmFyaWFibGUncyBkYXRhIGlzIHVwZGF0ZWRcbiAgICAgICAgICAgIHZhcmlhYmxlLm5vdGlmeShWYXJpYWJsZUV2ZW50cy5BRlRFUl9JTlZPS0UsIFt0aGlzLCByZXNwb25zZV0pXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBFVkVOVDogT05fU1VDQ0VTU1xuICAgICAgICAgICAgICAgIGluaXRpYXRlQ2FsbGJhY2soVkFSSUFCTEVfQ09OU1RBTlRTLkVWRU5ULlNVQ0NFU1MsIHZhcmlhYmxlLCByZXNwb25zZSwgYWR2YW5jZWRPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAvLyBFVkVOVDogT05fQ0FOX1VQREFURVxuICAgICAgICAgICAgICAgIHZhcmlhYmxlLmNhblVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaW5pdGlhdGVDYWxsYmFjayhWQVJJQUJMRV9DT05TVEFOVFMuRVZFTlQuQ0FOX1VQREFURSwgdmFyaWFibGUsIHJlc3BvbnNlLCBhZHZhbmNlZE9wdGlvbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cmlnZ2VyRm4oc3VjY2VzcywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFrZUNhbGwodmFyaWFibGUsIGFjdGlvbiwgZGJPcGVyYXRpb25zKS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIG9uQ1VEc3VjY2VzcyhkYXRhLCByZXNvbHZlKTtcbiAgICAgICAgICAgIH0sIHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICBvbkNVRGVycm9yKHJlc3BvbnNlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG5cbiAgICBwcml2YXRlIGFnZ3JlZ2F0ZURhdGEoZGVwbG95ZWRVcmwsIHZhcmlhYmxlLCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICBsZXQgdGFibGVPcHRpb25zLFxuICAgICAgICAgICAgZGJPcGVyYXRpb25PcHRpb25zLFxuICAgICAgICAgICAgYWdncmVnYXRlRGF0YVN1Y2Nlc3MsXG4gICAgICAgICAgICBhZ2dyZWdhdGVEYXRhRXJyb3I7XG4gICAgICAgIGNvbnN0IGRiT3BlcmF0aW9uID0gJ2V4ZWN1dGVBZ2dyZWdhdGVRdWVyeSc7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBvcHRpb25zLnNraXBFbmNvZGUgPSB0cnVlO1xuICAgICAgICBpZiAodmFyaWFibGUuZmlsdGVyRmllbGRzKSB7XG4gICAgICAgICAgICB0YWJsZU9wdGlvbnMgPSBMaXZlVmFyaWFibGVVdGlscy5wcmVwYXJlVGFibGVPcHRpb25zKHZhcmlhYmxlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIG9wdGlvbnMuYWdncmVnYXRpb25zLmZpbHRlciA9IHRhYmxlT3B0aW9ucy5xdWVyeTtcbiAgICAgICAgfVxuICAgICAgICBkYk9wZXJhdGlvbk9wdGlvbnMgPSB7XG4gICAgICAgICAgICAnZGF0YU1vZGVsTmFtZSc6IHZhcmlhYmxlLmxpdmVTb3VyY2UsXG4gICAgICAgICAgICAnZW50aXR5TmFtZSc6IHZhcmlhYmxlLnR5cGUsXG4gICAgICAgICAgICAncGFnZSc6IG9wdGlvbnMucGFnZSB8fCAxLFxuICAgICAgICAgICAgJ3NpemUnOiBvcHRpb25zLnNpemUgfHwgdmFyaWFibGUubWF4UmVzdWx0cyxcbiAgICAgICAgICAgICdzb3J0Jzogb3B0aW9ucy5zb3J0IHx8ICcnLFxuICAgICAgICAgICAgJ3VybCc6IGRlcGxveWVkVXJsLFxuICAgICAgICAgICAgJ2RhdGEnOiBvcHRpb25zLmFnZ3JlZ2F0aW9uc1xuICAgICAgICB9O1xuICAgICAgICBhZ2dyZWdhdGVEYXRhU3VjY2VzcyA9IChyZXNwb25zZTogYW55LCByZXNvbHZlOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKChyZXNwb25zZSAmJiByZXNwb25zZS5lcnJvcikgfHwgIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJGbihlcnJvciwgcmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyaWdnZXJGbihzdWNjZXNzLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGFnZ3JlZ2F0ZURhdGFFcnJvciA9IChlcnJvck1zZzogYW55LCByZWplY3Q6IGFueSkgPT4ge1xuICAgICAgICAgICAgdHJpZ2dlckZuKGVycm9yLCBlcnJvck1zZyk7XG4gICAgICAgICAgICByZWplY3QoZXJyb3JNc2cpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1ha2VDYWxsKHZhcmlhYmxlLCBkYk9wZXJhdGlvbiwgZGJPcGVyYXRpb25PcHRpb25zKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZURhdGFTdWNjZXNzKHJlc3BvbnNlLCByZXNvbHZlKTtcbiAgICAgICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgYWdncmVnYXRlRGF0YUVycm9yKGVyciwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIFBVQkxJQyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8vXG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBodHRwIGNhbGwgZm9yIGEgTGl2ZSBWYXJpYWJsZSBhZ2FpbnN0IHRoZSBjb25maWd1cmVkIERCIEVudGl0eS5cbiAgICAgKiBHZXRzIHRoZSBwYWdpbmF0ZWQgcmVjb3JkcyBhZ2FpbnN0IHRoZSBlbnRpdHlcbiAgICAgKiBAcGFyYW0gdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSBzdWNjZXNzXG4gICAgICogQHBhcmFtIGVycm9yXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn06IHdpbGwgYmUgcmVzb2x2ZWQgb24gc3VjY2Vzc2Z1bCBkYXRhIGZldGNoXG4gICAgICovXG4gICAgcHVibGljIGxpc3RSZWNvcmRzKHZhcmlhYmxlLCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy5maWx0ZXJGaWVsZHMgPSBvcHRpb25zLmZpbHRlckZpZWxkcyB8fCBnZXRDbG9uZWRPYmplY3QodmFyaWFibGUuZmlsdGVyRmllbGRzKTtcbiAgICAgICAgcmV0dXJuICRxdWV1ZS5zdWJtaXQodmFyaWFibGUpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlJbmZsaWdodCh2YXJpYWJsZSwgIW9wdGlvbnMuc2tpcFRvZ2dsZVN0YXRlLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RW50aXR5RGF0YSh2YXJpYWJsZSwgb3B0aW9ucywgc3VjY2VzcywgZXJyb3IpXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICRxdWV1ZS5wcm9jZXNzKHZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlJbmZsaWdodCh2YXJpYWJsZSwgZmFsc2UsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAkcXVldWUucHJvY2Vzcyh2YXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5SW5mbGlnaHQodmFyaWFibGUsIGZhbHNlLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZXJyb3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2VzIGEgUE9TVCBodHRwIGNhbGwgZm9yIGEgTGl2ZSBWYXJpYWJsZSBhZ2FpbnN0IHRoZSBjb25maWd1cmVkIERCIEVudGl0eS5cbiAgICAgKiBTZW5kcyBhIFRhYmxlIHJlY29yZCBvYmplY3Qgd2l0aCB0aGUgcmVxdWVzdCBib2R5XG4gICAgICogdGhlIHJlY29yZCBpcyBpbnNlcnRlZCBpbnRvIHRoZSBlbnRpdHkgYXQgdGhlIGJhY2tlbmRcbiAgICAgKiBAcGFyYW0gdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSBzdWNjZXNzXG4gICAgICogQHBhcmFtIGVycm9yXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn06IHdpbGwgYmUgcmVzb2x2ZWQgb24gc3VjY2Vzc2Z1bCBkYXRhIGZldGNoXG4gICAgICovXG4gICAgcHVibGljIGluc2VydFJlY29yZCh2YXJpYWJsZSwgb3B0aW9ucywgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybUNVRCgnaW5zZXJ0VGFibGVEYXRhJywgdmFyaWFibGUsIG9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIFBVVCBodHRwIGNhbGwgZm9yIGEgTGl2ZSBWYXJpYWJsZSBhZ2FpbnN0IHRoZSBjb25maWd1cmVkIERCIEVudGl0eS5cbiAgICAgKiBTZW5kcyBhIFRhYmxlIHJlY29yZCBvYmplY3Qgd2l0aCB0aGUgcmVxdWVzdCBib2R5IGFnYWluc3QgdGhlIHByaW1hcnkga2V5IG9mIGFuIGV4aXN0aW5nIHJlY29yZFxuICAgICAqIHRoZSByZWNvcmQgaXMgdXBkYXRlZCBpbnRvIHRoZSBlbnRpdHkgYXQgdGhlIGJhY2tlbmRcbiAgICAgKiBAcGFyYW0gdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSBzdWNjZXNzXG4gICAgICogQHBhcmFtIGVycm9yXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn06IHdpbGwgYmUgcmVzb2x2ZWQgb24gc3VjY2Vzc2Z1bCBkYXRhIGZldGNoXG4gICAgICovXG4gICAgcHVibGljIHVwZGF0ZVJlY29yZCh2YXJpYWJsZSwgb3B0aW9ucywgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybUNVRCgndXBkYXRlVGFibGVEYXRhJywgdmFyaWFibGUsIG9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIERFTEVURSBodHRwIGNhbGwgZm9yIGEgTGl2ZSBWYXJpYWJsZSBhZ2FpbnN0IHRoZSBjb25maWd1cmVkIERCIEVudGl0eS5cbiAgICAgKiBTZW5kcyB0aGUgcHJpbWFyeSBrZXkgb2YgYW4gZXhpc3RpbmcgcmVjb3JkXG4gICAgICogdGhlIHJlY29yZCBpcyBkZWxldGVkIGZyb20gdGhlIGVudGl0eSBhdCB0aGUgYmFja2VuZFxuICAgICAqIEBwYXJhbSB2YXJpYWJsZVxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIHN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0gZXJyb3JcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fTogd2lsbCBiZSByZXNvbHZlZCBvbiBzdWNjZXNzZnVsIGRhdGEgZmV0Y2hcbiAgICAgKi9cbiAgICBwdWJsaWMgZGVsZXRlUmVjb3JkKHZhcmlhYmxlLCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5wZXJmb3JtQ1VEKCdkZWxldGVUYWJsZURhdGEnLCB2YXJpYWJsZSwgb3B0aW9ucywgc3VjY2VzcywgZXJyb3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldHMgdGhlIHZhbHVlIGFnYWluc3QgcGFzc2VkIGtleSBvbiB0aGUgXCJpbnB1dEZpZWxkc1wiIG9iamVjdCBpbiB0aGUgdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gdmFyaWFibGVcbiAgICAgKiBAcGFyYW0ga2V5OiBjYW4gYmU6XG4gICAgICogIC0gYSBzdHJpbmcgZS5nLiBcInVzZXJuYW1lXCJcbiAgICAgKiAgLSBhbiBvYmplY3QsIGUuZy4ge1widXNlcm5hbWVcIjogXCJqb2huXCIsIFwic3NuXCI6IFwiMTExMTFcIn1cbiAgICAgKiBAcGFyYW0gdmFsXG4gICAgICogLSBpZiBrZXkgaXMgc3RyaW5nLCB0aGUgdmFsdWUgYWdhaW5zdCBpdCAoZm9yIHRoYXQgZGF0YSB0eXBlKVxuICAgICAqIC0gaWYga2V5IGlzIG9iamVjdCwgbm90IHJlcXVpcmVkXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7YW55fVxuICAgICAqL1xuICAgIHB1YmxpYyBzZXRJbnB1dCh2YXJpYWJsZSwga2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyaWFibGUuaW5wdXRGaWVsZHMgPSB2YXJpYWJsZS5pbnB1dEZpZWxkcyB8fCB7fTtcbiAgICAgICAgcmV0dXJuIHNldElucHV0KHZhcmlhYmxlLmlucHV0RmllbGRzLCBrZXksIHZhbCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0cyB0aGUgdmFsdWUgYWdhaW5zdCBwYXNzZWQga2V5IG9uIHRoZSBcImZpbHRlckZpZWxkc1wiIG9iamVjdCBpbiB0aGUgdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gdmFyaWFibGVcbiAgICAgKiBAcGFyYW0ga2V5OiBjYW4gYmU6XG4gICAgICogIC0gYSBzdHJpbmcgZS5nLiBcInVzZXJuYW1lXCJcbiAgICAgKiAgLSBhbiBvYmplY3QsIGUuZy4ge1widXNlcm5hbWVcIjogXCJqb2huXCIsIFwic3NuXCI6IFwiMTExMTFcIn1cbiAgICAgKiBAcGFyYW0gdmFsXG4gICAgICogLSBpZiBrZXkgaXMgc3RyaW5nLCB0aGUgdmFsdWUgYWdhaW5zdCBpdCAoZm9yIHRoYXQgZGF0YSB0eXBlKVxuICAgICAqIC0gaWYga2V5IGlzIG9iamVjdCwgbm90IHJlcXVpcmVkXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7YW55fVxuICAgICAqL1xuICAgIHB1YmxpYyBzZXRGaWx0ZXIodmFyaWFibGUsIGtleSwgdmFsKSB7XG4gICAgICAgIGxldCBwYXJhbU9iajogYW55ID0ge30sXG4gICAgICAgICAgICB0YXJnZXRPYmo6IGFueSA9IHt9O1xuICAgICAgICBpZiAoXy5pc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICBwYXJhbU9iaiA9IGtleTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtT2JqW2tleV0gPSB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXZhcmlhYmxlLmZpbHRlckV4cHJlc3Npb25zIHx8IF8uaXNFbXB0eSh2YXJpYWJsZS5maWx0ZXJFeHByZXNzaW9ucykpIHtcbiAgICAgICAgICAgIHZhcmlhYmxlLmZpbHRlckV4cHJlc3Npb25zID0geydjb25kaXRpb24nOiAnQU5EJywgJ3J1bGVzJzogW119O1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldE9iaiA9IHZhcmlhYmxlLmZpbHRlckV4cHJlc3Npb25zO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGV4aXN0aW5nIGNyaXRlcmlhIGlmIHByZXNlbnQgb3IgZWxzZSByZXR1cm4gbnVsbC4gRmluZCB0aGUgZmlyc3Qgb25lIGFuZCByZXR1cm4uXG4gICAgICAgIC8vIElmIHRoZSB1c2VyIHdhbnRzIHRvIHNldCBhIGRpZmZlcmVudCBvYmplY3QsIHRoZW4gaGUgaGFzIHRvIHVzZSB0aGUgZ2V0Q3JpdGVyaWEgQVBJIGRlZmluZWRcbiAgICAgICAgLy8gb24gdGhlIGRhdGFGaWx0ZXIgb2JqZWN0IHBhc3NlZCB0byB0aGUgb25CZWZvcmVMaXN0UmVjb3Jkc1xuICAgICAgICBmdW5jdGlvbiBnZXRFeGlzdGluZ0NyaXRlcmlhKGZpbHRlckZpZWxkKSB7XG4gICAgICAgICAgICBsZXQgZXhpc3RpbmdDcml0ZXJpYSA9IG51bGw7XG4gICAgICAgICAgICBMaXZlVmFyaWFibGVVdGlscy50cmF2ZXJzZUZpbHRlckV4cHJlc3Npb25zKHRhcmdldE9iaiwgZnVuY3Rpb24gKGZpbHRlckV4cHJlc3Npb25zLCBjcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJGaWVsZCA9PT0gY3JpdGVyaWEudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0NyaXRlcmlhID0gY3JpdGVyaWE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdDcml0ZXJpYTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8uZm9yRWFjaChwYXJhbU9iaiwgZnVuY3Rpb24gKHBhcmFtVmFsLCBwYXJhbUtleSkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdDcml0ZXJpYSA9IGdldEV4aXN0aW5nQ3JpdGVyaWEocGFyYW1LZXkpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nQ3JpdGVyaWEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ0NyaXRlcmlhLnZhbHVlID0gcGFyYW1WYWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldE9iai5ydWxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBwYXJhbUtleSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJycsXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoTW9kZTogJycsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJhbVZhbCxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXRPYmo7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgYSBmaWxlIGRvd25sb2FkIGNhbGwgZm9yIGEgdGFibGVcbiAgICAgKiBAcGFyYW0gdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIHB1YmxpYyBkb3dubG9hZCh2YXJpYWJsZSwgb3B0aW9ucywgc3VjY2Vzc0hhbmRsZXIsIGVycm9ySGFuZGxlcikge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgbGV0IHRhYmxlT3B0aW9ucyxcbiAgICAgICAgICAgIGRiT3BlcmF0aW9uT3B0aW9ucyxcbiAgICAgICAgICAgIGRvd25sb2FkU3VjY2VzcyxcbiAgICAgICAgICAgIGRvd25sb2FkRXJyb3I7XG4gICAgICAgIGNvbnN0IGRhdGE6IGFueSA9IHt9O1xuICAgICAgICBjb25zdCBkYk9wZXJhdGlvbiA9ICdleHBvcnRUYWJsZURhdGEnO1xuICAgICAgICBjb25zdCBwcm9qZWN0SUQgPSAkcm9vdFNjb3BlLnByb2plY3QuaWQgfHwgJHJvb3RTY29wZS5wcm9qZWN0TmFtZTtcbiAgICAgICAgb3B0aW9ucy5kYXRhLnNlYXJjaFdpdGhRdWVyeSA9IHRydWU7IC8vIEZvciBleHBvcnQsIHF1ZXJ5IGFwaSBpcyB1c2VkLiBTbyBzZXQgdGhpcyBmbGFnIHRvIHRydWVcbiAgICAgICAgb3B0aW9ucy5kYXRhLnNraXBFbmNvZGUgPSB0cnVlO1xuICAgICAgICB0YWJsZU9wdGlvbnMgPSBMaXZlVmFyaWFibGVVdGlscy5wcmVwYXJlVGFibGVPcHRpb25zKHZhcmlhYmxlLCBvcHRpb25zLmRhdGEsIHVuZGVmaW5lZCk7XG4gICAgICAgIGRhdGEucXVlcnkgPSB0YWJsZU9wdGlvbnMucXVlcnkgPyB0YWJsZU9wdGlvbnMucXVlcnkgOiAnJztcbiAgICAgICAgZGF0YS5leHBvcnRTaXplID0gb3B0aW9ucy5kYXRhLmV4cG9ydFNpemU7XG4gICAgICAgIGRhdGEuZXhwb3J0VHlwZSA9IG9wdGlvbnMuZGF0YS5leHBvcnRUeXBlO1xuICAgICAgICBkYXRhLmZpZWxkcyA9IGZvcm1hdEV4cG9ydEV4cHJlc3Npb24ob3B0aW9ucy5kYXRhLmZpZWxkcyk7XG4gICAgICAgIGlmIChvcHRpb25zLmRhdGEuZmlsZU5hbWUpIHtcbiAgICAgICAgICAgIGRhdGEuZmlsZU5hbWUgPSBvcHRpb25zLmRhdGEuZmlsZU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZGJPcGVyYXRpb25PcHRpb25zID0ge1xuICAgICAgICAgICAgJ3Byb2plY3RJRCc6IHByb2plY3RJRCxcbiAgICAgICAgICAgICdzZXJ2aWNlJzogdmFyaWFibGUuZ2V0UHJlZmFiTmFtZSgpID8gJycgOiAnc2VydmljZXMnLFxuICAgICAgICAgICAgJ2RhdGFNb2RlbE5hbWUnOiB2YXJpYWJsZS5saXZlU291cmNlLFxuICAgICAgICAgICAgJ2VudGl0eU5hbWUnOiB2YXJpYWJsZS50eXBlLFxuICAgICAgICAgICAgJ3NvcnQnOiB0YWJsZU9wdGlvbnMuc29ydCxcbiAgICAgICAgICAgICd1cmwnOiB2YXJpYWJsZS5nZXRQcmVmYWJOYW1lKCkgPyAoJHJvb3RTY29wZS5wcm9qZWN0LmRlcGxveWVkVXJsICsgJy9wcmVmYWJzLycgKyB2YXJpYWJsZS5nZXRQcmVmYWJOYW1lKCkpIDogJHJvb3RTY29wZS5wcm9qZWN0LmRlcGxveWVkVXJsLFxuICAgICAgICAgICAgJ2RhdGEnOiBkYXRhLFxuICAgICAgICAgICAgJ2ZpbHRlcic6IExpdmVWYXJpYWJsZVV0aWxzLmdldFdoZXJlQ2xhdXNlR2VuZXJhdG9yKHZhcmlhYmxlLCBvcHRpb25zKVxuICAgICAgICAgICAgLy8gJ2ZpbHRlck1ldGEnICAgIDogdGFibGVPcHRpb25zLmZpbHRlclxuICAgICAgICB9O1xuICAgICAgICBkb3dubG9hZFN1Y2Nlc3MgPSAocmVzcG9uc2U6IGFueSwgcmVzb2x2ZTogYW55KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UudHlwZSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gcmVzcG9uc2UuYm9keS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckZuKHN1Y2Nlc3NIYW5kbGVyLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGRvd25sb2FkRXJyb3IgPSAoZXJyOiBhbnksIHJlamVjdDogYW55KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcHQ6IEFkdmFuY2VkT3B0aW9ucyA9IHRoaXMucHJlcGFyZUNhbGxiYWNrT3B0aW9ucyhlcnIuZGV0YWlscyk7XG4gICAgICAgICAgICBpbml0aWF0ZUNhbGxiYWNrKFZBUklBQkxFX0NPTlNUQU5UUy5FVkVOVC5FUlJPUiwgdmFyaWFibGUsIGVyci5lcnJvciwgb3B0KTtcbiAgICAgICAgICAgIHRyaWdnZXJGbihlcnJvckhhbmRsZXIsIGVyci5lcnJvcik7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFrZUNhbGwodmFyaWFibGUsIGRiT3BlcmF0aW9uLCBkYk9wZXJhdGlvbk9wdGlvbnMpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgZG93bmxvYWRTdWNjZXNzKHJlc3BvbnNlLCByZXNvbHZlKTtcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGRvd25sb2FkRXJyb3IoZXJyb3IsIHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0cyBwcmltYXJ5IGtleXMgYWdhaW5zdCB0aGUgcGFzc2VkIHJlbGF0ZWQgVGFibGVcbiAgICAgKiBAcGFyYW0gdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gcmVsYXRlZEZpZWxkXG4gICAgICogQHJldHVybnMge2FueX1cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0UmVsYXRlZFRhYmxlUHJpbWFyeUtleXModmFyaWFibGUsIHJlbGF0ZWRGaWVsZCkge1xuICAgICAgICBsZXQgcHJpbWFyeUtleXMsXG4gICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICByZWxhdGVkQ29scztcbiAgICAgICAgaWYgKCF2YXJpYWJsZS5wcm9wZXJ0aWVzTWFwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gXy5maW5kKHZhcmlhYmxlLnByb3BlcnRpZXNNYXAuY29sdW1ucyB8fCBbXSwgeydmaWVsZE5hbWUnOiByZWxhdGVkRmllbGR9KTtcbiAgICAgICAgLy8gaWYgcmVsYXRlZCBmaWVsZCBuYW1lIHBhc3NlZCwgZ2V0IGl0cyB0eXBlIGZyb20gY29sdW1ucyBpbnNpZGUgdGhlIGN1cnJlbnQgZmllbGRcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmVsYXRlZENvbHMgPSByZXN1bHQuY29sdW1ucztcbiAgICAgICAgICAgIHByaW1hcnlLZXlzID0gXy5tYXAoXy5maWx0ZXIocmVsYXRlZENvbHMsICdpc1ByaW1hcnlLZXknKSwgJ2ZpZWxkTmFtZScpO1xuICAgICAgICAgICAgaWYgKHByaW1hcnlLZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmltYXJ5S2V5cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWxhdGVkQ29scyAmJiByZWxhdGVkQ29scy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZWxhdGVkQ29scyA9IF8uZmluZChyZWxhdGVkQ29scywgeydpc1JlbGF0ZWQnOiBmYWxzZX0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWxhdGVkQ29scyAmJiByZWxhdGVkQ29scy5maWVsZE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBIVFRQIGNhbGwgdG8gZ2V0IHRoZSBkYXRhIGZvciByZWxhdGVkIGVudGl0eSBvZiBhIGZpZWxkIGluIGFuIGVudGl0eVxuICAgICAqIEBwYXJhbSB2YXJpYWJsZVxuICAgICAqIEBwYXJhbSBjb2x1bW5OYW1lXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gc3VjY2Vzc1xuICAgICAqIEBwYXJhbSBlcnJvclxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRSZWxhdGVkVGFibGVEYXRhKHZhcmlhYmxlLCBjb2x1bW5OYW1lLCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICBjb25zdCBwcm9qZWN0SUQgPSAkcm9vdFNjb3BlLnByb2plY3QuaWQgfHwgJHJvb3RTY29wZS5wcm9qZWN0TmFtZTtcbiAgICAgICAgY29uc3QgcmVsYXRlZFRhYmxlID0gXy5maW5kKHZhcmlhYmxlLnJlbGF0ZWRUYWJsZXMsIHRhYmxlID0+IHRhYmxlLnJlbGF0aW9uTmFtZSA9PT0gY29sdW1uTmFtZSB8fCB0YWJsZS5jb2x1bW5OYW1lID09PSBjb2x1bW5OYW1lKTsgLy8gQ29tcGFyaW5nIGNvbHVtbiBuYW1lIHRvIHN1cHBvcnQgdGhlIG9sZCBwcm9qZWN0c1xuICAgICAgICBjb25zdCBzZWxmUmVsYXRlZENvbHMgPSBfLm1hcChfLmZpbHRlcih2YXJpYWJsZS5yZWxhdGVkVGFibGVzLCBvID0+IG8udHlwZSA9PT0gdmFyaWFibGUudHlwZSksICdyZWxhdGlvbk5hbWUnKTtcbiAgICAgICAgY29uc3QgZmlsdGVyRmllbGRzID0gW107XG4gICAgICAgIGxldCBvcmRlckJ5LFxuICAgICAgICAgICAgZmlsdGVyT3B0aW9ucyxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgZGJPcGVyYXRpb25PcHRpb25zLFxuICAgICAgICAgICAgZ2V0UmVsYXRlZFRhYmxlRGF0YVN1Y2Nlc3MsXG4gICAgICAgICAgICBnZXRSZWxhdGVkVGFibGVEYXRhRXJyb3I7XG4gICAgICAgIF8uZm9yRWFjaChvcHRpb25zLmZpbHRlckZpZWxkcywgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHZhbHVlLmZpZWxkTmFtZSA9IGtleTtcbiAgICAgICAgICAgIHZhbHVlLnR5cGUgPSBMaXZlVmFyaWFibGVVdGlscy5nZXRGaWVsZFR5cGUoY29sdW1uTmFtZSwgdmFyaWFibGUsIGtleSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGZvciAnaW4nIG1vZGUgd2UgYXJlIHRha2luZyB0aGUgaW5wdXQgYXMgY29tbWEgc2VwYXJhdGVkIHZhbHVlcyBhbmQgZm9yIGJldHdlZW4gaW4gdWkgdGhlcmUgYXJlIHR3byBkaWZmZXJlbnQgZmllbGRzXG4gICAgICAgICAgICAgKiBidXQgdGhlc2UgYXJlIHByb2Nlc3NlZCBhbmQgbWVyZ2VkIGludG8gYSBzaW5nbGUgdmFsdWUgd2l0aCBjb21tYSBhcyBzZXBhcmF0b3IuIEZvciB0aGVzZSBjb25kaXRpb25zIGxpa2UgJ2luJyBhbmQgJ2JldHdlZW4nLFxuICAgICAgICAgICAgICogZm9yIGJ1aWxkaW5nIHRoZSBxdWVyeSwgdGhlIGZ1bmN0aW9uIGV4cGVjdHMgdGhlIHZhbHVlcyB0byBiZSBhbiBhcnJheVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodmFsdWUuZmlsdGVyQ29uZGl0aW9uID09PSBEQl9DT05TVEFOVFMuREFUQUJBU0VfTUFUQ0hfTU9ERVMuaW4udG9Mb3dlckNhc2UoKSB8fCB2YWx1ZS5maWx0ZXJDb25kaXRpb24gPT09IERCX0NPTlNUQU5UUy5EQVRBQkFTRV9NQVRDSF9NT0RFUy5iZXR3ZWVuLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS52YWx1ZSA9IHZhbHVlLnZhbHVlLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWx0ZXJGaWVsZHMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmaWx0ZXJPcHRpb25zID0gTGl2ZVZhcmlhYmxlVXRpbHMuZ2V0RmlsdGVyT3B0aW9ucyh2YXJpYWJsZSwgZmlsdGVyRmllbGRzLCBvcHRpb25zKTtcbiAgICAgICAgcXVlcnkgPSBMaXZlVmFyaWFibGVVdGlscy5nZXRTZWFyY2hRdWVyeShmaWx0ZXJPcHRpb25zLCAnICcgKyAob3B0aW9ucy5sb2dpY2FsT3AgfHwgJ0FORCcpICsgJyAnLCB2YXJpYWJsZS5pZ25vcmVDYXNlKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZmlsdGVyRXhwcikge1xuICAgICAgICAgICAgY29uc3QgX2Nsb25lZEZpZWxkcyA9IGdldENsb25lZE9iamVjdChfLmlzT2JqZWN0KG9wdGlvbnMuZmlsdGVyRXhwcikgPyBvcHRpb25zLmZpbHRlckV4cHIgOiBKU09OLnBhcnNlKG9wdGlvbnMuZmlsdGVyRXhwcikpO1xuICAgICAgICAgICAgTGl2ZVZhcmlhYmxlVXRpbHMucHJvY2Vzc0ZpbHRlckZpZWxkcyhfY2xvbmVkRmllbGRzLnJ1bGVzLCB2YXJpYWJsZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJFeHBRdWVyeSA9IExpdmVWYXJpYWJsZVV0aWxzLmdlbmVyYXRlU2VhcmNoUXVlcnkoX2Nsb25lZEZpZWxkcy5ydWxlcywgX2Nsb25lZEZpZWxkcy5jb25kaXRpb24sIHZhcmlhYmxlLmlnbm9yZUNhc2UsIG9wdGlvbnMuc2tpcEVuY29kZSk7XG4gICAgICAgICAgICBpZiAocXVlcnkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlckV4cFF1ZXJ5ICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9ICcoJyArIHF1ZXJ5ICsgJykgQU5EICgnICsgZmlsdGVyRXhwUXVlcnkgKyAnKSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWx0ZXJFeHBRdWVyeSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IGZpbHRlckV4cFF1ZXJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkgPyAoJ3E9JyArIHF1ZXJ5KSA6ICcnO1xuICAgICAgICBhY3Rpb24gPSAnc2VhcmNoVGFibGVEYXRhV2l0aFF1ZXJ5JztcbiAgICAgICAgb3JkZXJCeSA9IF8uaXNFbXB0eShvcHRpb25zLm9yZGVyQnkpID8gJycgOiAnc29ydD0nICsgb3B0aW9ucy5vcmRlckJ5O1xuICAgICAgICBkYk9wZXJhdGlvbk9wdGlvbnMgPSB7XG4gICAgICAgICAgICBwcm9qZWN0SUQ6IHByb2plY3RJRCxcbiAgICAgICAgICAgIHNlcnZpY2U6IHZhcmlhYmxlLmdldFByZWZhYk5hbWUoKSA/ICcnIDogJ3NlcnZpY2VzJyxcbiAgICAgICAgICAgIGRhdGFNb2RlbE5hbWU6IHZhcmlhYmxlLmxpdmVTb3VyY2UsXG4gICAgICAgICAgICBlbnRpdHlOYW1lOiByZWxhdGVkVGFibGUgPyByZWxhdGVkVGFibGUudHlwZSA6ICcnLFxuICAgICAgICAgICAgcGFnZTogb3B0aW9ucy5wYWdlIHx8IDEsXG4gICAgICAgICAgICBzaXplOiBvcHRpb25zLnBhZ2VzaXplIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVybDogdmFyaWFibGUuZ2V0UHJlZmFiTmFtZSgpID8gKCRyb290U2NvcGUucHJvamVjdC5kZXBsb3llZFVybCArICcvcHJlZmFicy8nICsgdmFyaWFibGUuZ2V0UHJlZmFiTmFtZSgpKSA6ICRyb290U2NvcGUucHJvamVjdC5kZXBsb3llZFVybCxcbiAgICAgICAgICAgIGRhdGE6IHF1ZXJ5IHx8ICcnLFxuICAgICAgICAgICAgZmlsdGVyOiBMaXZlVmFyaWFibGVVdGlscy5nZXRXaGVyZUNsYXVzZUdlbmVyYXRvcih2YXJpYWJsZSwgb3B0aW9ucyksXG4gICAgICAgICAgICBzb3J0OiBvcmRlckJ5XG4gICAgICAgIH07XG4gICAgICAgIGdldFJlbGF0ZWRUYWJsZURhdGFTdWNjZXNzID0gKHJlczogYW55LCByZXNvbHZlOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXMgJiYgcmVzLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHJlcy5ib2R5O1xuICAgICAgICAgICAgICAgIC8qUmVtb3ZlIHRoZSBzZWxmIHJlbGF0ZWQgY29sdW1ucyBmcm9tIHRoZSBkYXRhLiBBcyBiYWNrZW5kIGlzIHJlc3RyaWN0aW5nIHRoZSBzZWxmIHJlbGF0ZWQgY29sdW1uIHRvIG9uZSBsZXZlbCwgSW4gbGl2ZWZvcm0gc2VsZWN0LCBkYXRhc2V0IGFuZCBkYXRhdmFsdWUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICogZXF1YWxpdHkgZG9lcyBub3Qgd29yay4gU28sIHJlbW92aW5nIHRoZSBzZWxmIHJlbGF0ZWQgY29sdW1ucyB0byBhY2hlaXZlIHRoZSBxdWFsaXR5Ki9cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gXy5tYXAocmVzcG9uc2UuY29udGVudCwgbyA9PiBfLm9taXQobywgc2VsZlJlbGF0ZWRDb2xzKSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwYWdpbmF0aW9uID0gT2JqZWN0LmFzc2lnbih7fSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwYWdpbmF0aW9uLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgZGVjb2RlRGF0YShkYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7ZGF0YTogZGF0YSwgcGFnaW5hdGlvbn07XG4gICAgICAgICAgICAgICAgdHJpZ2dlckZuKHN1Y2Nlc3MsIHJlc3VsdCk7XG5cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGdldFJlbGF0ZWRUYWJsZURhdGFFcnJvciA9IChlcnJNc2c6IGFueSwgcmVqZWN0OiBhbnkpID0+IHtcbiAgICAgICAgICAgIHRyaWdnZXJGbihlcnJvciwgZXJyTXNnKTtcbiAgICAgICAgICAgIHJlamVjdChlcnJNc2cpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYWtlQ2FsbCh2YXJpYWJsZSwgYWN0aW9uLCBkYk9wZXJhdGlvbk9wdGlvbnMpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgZ2V0UmVsYXRlZFRhYmxlRGF0YVN1Y2Nlc3MocmVzcG9uc2UsIHJlc29sdmUpO1xuICAgICAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgICAgICBnZXRSZWxhdGVkVGFibGVEYXRhRXJyb3IoZXJyLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRpc3RpbmN0IHJlY29yZHMgZm9yIGFuIGVudGl0eVxuICAgICAqIEBwYXJhbSB2YXJpYWJsZVxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIHN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0gZXJyb3JcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0RGlzdGluY3REYXRhQnlGaWVsZHModmFyaWFibGUsIG9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGRiT3BlcmF0aW9uID0gJ2dldERpc3RpbmN0RGF0YUJ5RmllbGRzJztcbiAgICAgICAgY29uc3QgcHJvamVjdElEID0gJHJvb3RTY29wZS5wcm9qZWN0LmlkIHx8ICRyb290U2NvcGUucHJvamVjdE5hbWU7XG4gICAgICAgIGNvbnN0IHJlcXVlc3REYXRhOiBhbnkgPSB7fTtcbiAgICAgICAgbGV0IHNvcnQ7XG4gICAgICAgIGxldCB0YWJsZU9wdGlvbnMsXG4gICAgICAgICAgICBkYk9wZXJhdGlvbk9wdGlvbnMsXG4gICAgICAgICAgICBnZXREaXN0aW5jdERhdGFCeUZpZWxkc1N1Y2Nlc3MsXG4gICAgICAgICAgICBnZXREaXN0aW5jdERhdGFCeUZpZWxkc0Vycm9yO1xuICAgICAgICBvcHRpb25zLnNraXBFbmNvZGUgPSB0cnVlO1xuICAgICAgICBvcHRpb25zLm9wZXJhdGlvbiA9ICdyZWFkJztcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRhYmxlT3B0aW9ucyA9IExpdmVWYXJpYWJsZVV0aWxzLnByZXBhcmVUYWJsZU9wdGlvbnModmFyaWFibGUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodGFibGVPcHRpb25zLnF1ZXJ5KSB7XG4gICAgICAgICAgICByZXF1ZXN0RGF0YS5maWx0ZXIgPSB0YWJsZU9wdGlvbnMucXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdERhdGEuZ3JvdXBCeUZpZWxkcyA9IF8uaXNBcnJheShvcHRpb25zLmZpZWxkcykgPyBvcHRpb25zLmZpZWxkcyA6IFtvcHRpb25zLmZpZWxkc107XG4gICAgICAgIHNvcnQgPSBvcHRpb25zLnNvcnQgfHwgcmVxdWVzdERhdGEuZ3JvdXBCeUZpZWxkc1swXSArICcgYXNjJztcbiAgICAgICAgc29ydCA9IHNvcnQgPyAnc29ydD0nICsgc29ydCA6ICcnO1xuICAgICAgICBkYk9wZXJhdGlvbk9wdGlvbnMgPSB7XG4gICAgICAgICAgICAncHJvamVjdElEJzogcHJvamVjdElELFxuICAgICAgICAgICAgJ3NlcnZpY2UnOiB2YXJpYWJsZS5nZXRQcmVmYWJOYW1lKCkgPyAnJyA6ICdzZXJ2aWNlcycsXG4gICAgICAgICAgICAnZGF0YU1vZGVsTmFtZSc6IHZhcmlhYmxlLmxpdmVTb3VyY2UsXG4gICAgICAgICAgICAnZW50aXR5TmFtZSc6IG9wdGlvbnMuZW50aXR5TmFtZSB8fCB2YXJpYWJsZS50eXBlLFxuICAgICAgICAgICAgJ3BhZ2UnOiBvcHRpb25zLnBhZ2UgfHwgMSxcbiAgICAgICAgICAgICdzaXplJzogb3B0aW9ucy5wYWdlc2l6ZSxcbiAgICAgICAgICAgICdzb3J0Jzogc29ydCxcbiAgICAgICAgICAgICdkYXRhJzogcmVxdWVzdERhdGEsXG4gICAgICAgICAgICAnZmlsdGVyJzogTGl2ZVZhcmlhYmxlVXRpbHMuZ2V0V2hlcmVDbGF1c2VHZW5lcmF0b3IodmFyaWFibGUsIG9wdGlvbnMpLFxuICAgICAgICAgICAgJ3VybCc6IHZhcmlhYmxlLmdldFByZWZhYk5hbWUoKSA/ICgkcm9vdFNjb3BlLnByb2plY3QuZGVwbG95ZWRVcmwgKyAnL3ByZWZhYnMvJyArIHZhcmlhYmxlLmdldFByZWZhYk5hbWUoKSkgOiAkcm9vdFNjb3BlLnByb2plY3QuZGVwbG95ZWRVcmxcbiAgICAgICAgfTtcbiAgICAgICAgZ2V0RGlzdGluY3REYXRhQnlGaWVsZHNTdWNjZXNzID0gKHJlc3BvbnNlOiBhbnksIHJlc29sdmU6IGFueSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHJlc3BvbnNlICYmIHJlc3BvbnNlLmVycm9yKSB8fCAhcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckZuKGVycm9yLCByZXNwb25zZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZXNwb25zZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSByZXNwb25zZS5ib2R5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2luYXRpb24gPSBPYmplY3QuYXNzaWduKHt9LCByZXNwb25zZS5ib2R5KTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcGFnaW5hdGlvbi5jb250ZW50O1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0ge2RhdGE6IHJlc3VsdC5jb250ZW50LCBwYWdpbmF0aW9ufTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRm4oc3VjY2VzcywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGdldERpc3RpbmN0RGF0YUJ5RmllbGRzRXJyb3IgPSAoZXJyb3JNc2c6IGFueSwgcmVqZWN0OiBhbnkpID0+IHtcbiAgICAgICAgICAgIHRyaWdnZXJGbihlcnJvciwgZXJyb3JNc2cpO1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yTXNnKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYWtlQ2FsbCh2YXJpYWJsZSwgZGJPcGVyYXRpb24sIGRiT3BlcmF0aW9uT3B0aW9ucykudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBnZXREaXN0aW5jdERhdGFCeUZpZWxkc1N1Y2Nlc3MocmVzcG9uc2UsIHJlc29sdmUpO1xuICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGdldERpc3RpbmN0RGF0YUJ5RmllbGRzRXJyb3IoZXJyb3IsIHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLypGdW5jdGlvbiB0byBnZXQgdGhlIGFnZ3JlZ2F0ZWQgZGF0YSBiYXNlZCBvbiB0aGUgZmllbGRzIGNob3NlbiovXG4gICAgcHVibGljIGdldEFnZ3JlZ2F0ZWREYXRhKHZhcmlhYmxlLCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICBjb25zdCBkZXBsb3llZFVSTCA9IGFwcE1hbmFnZXIuZ2V0RGVwbG95ZWRVUkwoKTtcbiAgICAgICAgaWYgKGRlcGxveWVkVVJMKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZ2dyZWdhdGVEYXRhKGRlcGxveWVkVVJMLCB2YXJpYWJsZSwgb3B0aW9ucywgc3VjY2VzcywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGRlZmluZUZpcnN0TGFzdFJlY29yZCh2YXJpYWJsZSkge1xuICAgICAgICBpZiAodmFyaWFibGUub3BlcmF0aW9uID09PSAncmVhZCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YXJpYWJsZSwgJ2ZpcnN0UmVjb3JkJywge1xuICAgICAgICAgICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdnZXQnOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLmdldCh2YXJpYWJsZS5kYXRhU2V0LCAnZGF0YVswXScsIHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YXJpYWJsZSwgJ2xhc3RSZWNvcmQnLCB7XG4gICAgICAgICAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2dldCc6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IF8uZ2V0KHZhcmlhYmxlLmRhdGFTZXQsICdkYXRhJywgW10pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtkYXRhLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGdldFByaW1hcnlLZXkodmFyaWFibGUpIHtcbiAgICAgICAgcmV0dXJuIExpdmVWYXJpYWJsZVV0aWxzLmdldFByaW1hcnlLZXkodmFyaWFibGUpO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgdGhlIHNlYXJjaCBxdWVyeSBwYXJhbXMuXG4gICAgcHVibGljIHByZXBhcmVSZXF1ZXN0UGFyYW1zKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHJlcXVlc3RQYXJhbXM7XG5cbiAgICAgICAgY29uc3Qgc2VhcmNoS2V5cyA9IF8uc3BsaXQob3B0aW9ucy5zZWFyY2hLZXksICcsJyksXG4gICAgICAgICAgICBtYXRjaE1vZGVzID0gXy5zcGxpdChvcHRpb25zLm1hdGNoTW9kZSwgJywnKSxcbiAgICAgICAgICAgIGZvcm1GaWVsZHMgPSB7fTtcblxuICAgICAgICBfLmZvckVhY2goc2VhcmNoS2V5cywgKGNvbE5hbWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBmb3JtRmllbGRzW2NvbE5hbWVdID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLnF1ZXJ5LFxuICAgICAgICAgICAgICAgIGxvZ2ljYWxPcDogJ0FORCcsXG4gICAgICAgICAgICAgICAgbWF0Y2hNb2RlOiBtYXRjaE1vZGVzW2luZGV4XSB8fCBtYXRjaE1vZGVzWzBdIHx8ICdzdGFydGlnbm9yZWNhc2UnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXF1ZXN0UGFyYW1zID0ge1xuICAgICAgICAgICAgZmlsdGVyRmllbGRzOiBmb3JtRmllbGRzLFxuICAgICAgICAgICAgcGFnZTogb3B0aW9ucy5wYWdlLFxuICAgICAgICAgICAgcGFnZXNpemU6IG9wdGlvbnMubGltaXQgfHwgb3B0aW9ucy5wYWdlc2l6ZSxcbiAgICAgICAgICAgIHNraXBEYXRhU2V0VXBkYXRlOiB0cnVlLCAvLyBkb250IHVwZGF0ZSB0aGUgYWN0dWFsIHZhcmlhYmxlIGRhdGFzZXQsXG4gICAgICAgICAgICBza2lwVG9nZ2xlU3RhdGU6IHRydWUsIC8vIERvbnQgY2hhbmdlIHRoZSB2YXJpYWJsZSB0b2dnbGUgc3RhdGUgYXMgdGhpcyBpcyBhIGluZGVwZW5kZW50IGNhbGxcbiAgICAgICAgICAgIGluRmxpZ2h0QmVoYXZpb3I6ICdleGVjdXRlQWxsJyxcbiAgICAgICAgICAgIGxvZ2ljYWxPcDogJ09SJyxcbiAgICAgICAgICAgIG9yZGVyQnk6IG9wdGlvbnMub3JkZXJieSA/IF8ucmVwbGFjZShvcHRpb25zLm9yZGVyYnksIC86L2csICcgJykgOiAnJ1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChvcHRpb25zLm9uQmVmb3Jlc2VydmljZWNhbGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMub25CZWZvcmVzZXJ2aWNlY2FsbChmb3JtRmllbGRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXF1ZXN0UGFyYW1zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZpbHRlcmVkIHJlY29yZHMgYmFzZWQgb24gc2VhcmNoS2V5XG4gICAgICogQHBhcmFtIHZhcmlhYmxlXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgdGhlIHNlYXJjaEtleSBhbmQgcXVlcnlUZXh0XG4gICAgICogQHBhcmFtIHN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0gZXJyb3JcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHB1YmxpYyBzZWFyY2hSZWNvcmRzKHZhcmlhYmxlLCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0gdGhpcy5wcmVwYXJlUmVxdWVzdFBhcmFtcyhvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5saXN0UmVjb3Jkcyh2YXJpYWJsZSwgcmVxdWVzdFBhcmFtcywgc3VjY2VzcywgZXJyb3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHVzZWQgaW4gb25CZWZvcmVVcGRhdGUgY2FsbCAtIGNhbGxlZCBsYXN0IGluIHRoZSBmdW5jdGlvbiAtIHVzZWQgaW4gb2xkIFZhcmlhYmxlcyB1c2luZyBkYXRhQmluZGluZy5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIG1pZ3JhdGVzIHRoZSBvbGQgZGF0YSBkYXRhQmluZGluZyB0byBmaWx0ZXJFeHByZXNzaW9ucyBlcXVpdmFsZW50IGZvcm1hdFxuICAgICAqIEBwYXJhbSB2YXJpYWJsZVxuICAgICAqIEBwYXJhbSBpbnB1dERhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyB1cGdyYWRlSW5wdXREYXRhVG9GaWx0ZXJFeHByZXNzaW9ucyh2YXJpYWJsZSwgcmVzcG9uc2UsIGlucHV0RGF0YSkge1xuICAgICAgICBpZiAoXy5pc09iamVjdChyZXNwb25zZSkpIHtcbiAgICAgICAgICAgIGlucHV0RGF0YSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgaW5wdXREYXRhLmNvbmRpdGlvbiA9ICdBTkQnO1xuICAgICAgICAgICAgaW5wdXREYXRhLnJ1bGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGlmIHRoZSB1c2VyIGRlbGV0ZXMgYSBwYXJ0aWN1bGFyIGNyaXRlcmlhLCB3ZSBuZWVkIHRvIHJlbW92ZSB0aGlzIGZvcm0gb3VyIGRhdGEgYXN3ZWxsLlxuICAgICAgICAgKiBzbyB3ZSBhcmUga2VlcGluZyBhIGNvcHkgb2YgaXQgYW5kIHRoZSBlbXB0eWluZyB0aGUgZXhpc3Rpbmcgb2JqZWN0IGFuZCBub3cgZmlsbCBpdCB3aXRoIHRoZVxuICAgICAgICAgKiB1c2VyIHNldCBjcml0ZXJpYS4gSWYgaXRzIGp1c3QgbW9kaWZpZWQsIGNoYW5nZSB0aGUgZGF0YSBhbmQgcHVzaCBpdCB0b2hlIHJ1bGVzIG9yIGVsc2UganVzdCBhZGQgYSBuZXcgY3JpdGVyaWFcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGNsb25lZFJ1bGVzID0gXy5jbG9uZURlZXAoaW5wdXREYXRhLnJ1bGVzKTtcbiAgICAgICAgaW5wdXREYXRhLnJ1bGVzID0gW107XG4gICAgICAgIF8uZm9yRWFjaChpbnB1dERhdGEsIGZ1bmN0aW9uICh2YWx1ZU9iaiwga2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAnY29uZGl0aW9uJyAmJiBrZXkgIT09ICdydWxlcycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZE9iaiA9IF8uZmluZChjbG9uZWRSdWxlcywgbyA9PiBvLnRhcmdldCA9PT0ga2V5KTtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUga2V5IGlzIGZvdW5kIHVwZGF0ZSB0aGUgdmFsdWUsIGVsc2UgY3JlYXRlIGEgbmV3IHJ1bGUgb2JqIGFuZCBhZGQgaXQgdG8gdGhlIGV4aXN0aW5nIHJ1bGVzXG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcmVkT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkT2JqLnZhbHVlID0gdmFsdWVPYmoudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkT2JqLm1hdGNoTW9kZSA9IHZhbHVlT2JqLm1hdGNoTW9kZSB8fCB2YWx1ZU9iai5maWx0ZXJDb25kaXRpb24gfHwgZmlsdGVyZWRPYmoubWF0Y2hNb2RlIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dERhdGEucnVsZXMucHVzaChmaWx0ZXJlZE9iaik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXREYXRhLnJ1bGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RhcmdldCc6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF0Y2hNb2RlJzogdmFsdWVPYmoubWF0Y2hNb2RlIHx8IHZhbHVlT2JqLmZpbHRlckNvbmRpdGlvbiB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IHZhbHVlT2JqLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlcXVpcmVkJzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbnB1dERhdGFba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbnB1dERhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdXNlZCBpbiBvbkJlZm9yZVVwZGF0ZSBjYWxsIC0gY2FsbGVkIGZpcnN0IGluIHRoZSBmdW5jdGlvbiAtIHVzZWQgaW4gb2xkIFZhcmlhYmxlcyB1c2luZyBkYXRhQmluZGluZy5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIG1pZ3JhdGVzIHRoZSBmaWx0ZXJFeHByZXNzaW9ucyBvYmplY3QgdG8gZmxhdCBtYXAgc3RydWN0dXJlXG4gICAgICogQHBhcmFtIHZhcmlhYmxlXG4gICAgICogQHBhcmFtIGlucHV0RGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHVibGljIGRvd25ncmFkZUZpbHRlckV4cHJlc3Npb25zVG9JbnB1dERhdGEodmFyaWFibGUsIGlucHV0RGF0YSkge1xuICAgICAgICBpZiAoaW5wdXREYXRhLmhhc093blByb3BlcnR5KCdnZXRGaWx0ZXJGaWVsZHMnKSkge1xuICAgICAgICAgICAgaW5wdXREYXRhID0gaW5wdXREYXRhLmdldEZpbHRlckZpZWxkcygpO1xuICAgICAgICB9XG4gICAgICAgIF8uZm9yRWFjaChpbnB1dERhdGEucnVsZXMsIGZ1bmN0aW9uIChydWxlT2JqKSB7XG4gICAgICAgICAgICBpZiAoIV8uaXNOaWwocnVsZU9iai50YXJnZXQpICYmIHJ1bGVPYmoudGFyZ2V0ICE9PSAnJykge1xuICAgICAgICAgICAgICAgIGlucHV0RGF0YVtydWxlT2JqLnRhcmdldF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IHJ1bGVPYmoudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICdtYXRjaE1vZGUnOiBydWxlT2JqLm1hdGNoTW9kZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW5wdXREYXRhO1xuICAgIH1cblxuICAgIHB1YmxpYyBjYW5jZWwodmFyaWFibGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCRxdWV1ZS5yZXF1ZXN0c1F1ZXVlLmhhcyh2YXJpYWJsZSkgJiYgdmFyaWFibGUuX29ic2VydmFibGUpIHtcbiAgICAgICAgICAgIHZhcmlhYmxlLl9vYnNlcnZhYmxlLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAkcXVldWUucHJvY2Vzcyh2YXJpYWJsZSk7XG4gICAgICAgICAgICAvLyBub3RpZnkgaW5mbGlnaHQgdmFyaWFibGVcbiAgICAgICAgICAgIHRoaXMubm90aWZ5SW5mbGlnaHQodmFyaWFibGUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IEJhc2VWYXJpYWJsZU1hbmFnZXIgfSBmcm9tICcuL2Jhc2UtdmFyaWFibGUubWFuYWdlcic7XG5cbmRlY2xhcmUgY29uc3QgXzogYW55O1xuXG5jb25zdCBjaGVja0VtcHR5T2JqZWN0ID0gKG9iajogYW55KSA9PiB7XG4gICAgbGV0IGlzRW1wdHkgPSB0cnVlO1xuICAgIF8uZm9yRWFjaChvYmosICh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgIGlmIChfLmlzRW1wdHkodmFsdWUpICYmICFfLmlzQm9vbGVhbih2YWx1ZSkgJiYgIV8uaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghXy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChfLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBJZiBhcnJheSwgY2hlY2sgaWYgYXJyYXkgaXMgZW1wdHkgb3IgaWYgaXQgaGFzIG9ubHkgb25lIHZhbHVlIGFuZCB0aGUgdmFsdWUgaXMgZW1wdHlcbiAgICAgICAgICAgIGlzRW1wdHkgPSBfLmlzRW1wdHkodmFsdWUpIHx8ICh2YWx1ZS5sZW5ndGggPT09IDEgPyBfLmlzRW1wdHkodmFsdWVbMF0pIDogZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgb2JqZWN0LCBsb29wIG92ZXIgdGhlIG9iamVjdCB0byBjaGVjayBpZiBpdCBpcyBlbXB0eSBvciBub3RcbiAgICAgICAgICAgIGlzRW1wdHkgPSBjaGVja0VtcHR5T2JqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNFbXB0eTsgLy8gaXNFbXB0eSBmYWxzZSB3aWxsIGJyZWFrIHRoZSBsb29wXG4gICAgfSk7XG4gICAgcmV0dXJuIGlzRW1wdHk7XG59O1xuXG5leHBvcnQgY2xhc3MgTW9kZWxWYXJpYWJsZU1hbmFnZXIgZXh0ZW5kcyBCYXNlVmFyaWFibGVNYW5hZ2VyIHtcbiAgICAvKlxuICAgICogQ2FzZTogYSBMSVNUIHR5cGUgc3RhdGljIHZhcmlhYmxlIGhhdmluZyBvbmx5IG9uZSBvYmplY3RcbiAgICAqIGFuZCB0aGUgb2JqZWN0IGhhcyBhbGwgZmllbGRzIGVtcHR5LCByZW1vdmUgdGhhdCBvYmplY3RcbiAgICAqL1xuICAgIHJlbW92ZUZpcnN0RW1wdHlPYmplY3QodmFyaWFibGU6IGFueSkge1xuICAgICAgICBpZiAoXy5pc0FycmF5KHZhcmlhYmxlLmRhdGFTZXQpICYmIHZhcmlhYmxlLmRhdGFTZXQubGVuZ3RoID09PSAxICYmIGNoZWNrRW1wdHlPYmplY3QodmFyaWFibGUuZGF0YVNldFswXSkpIHtcbiAgICAgICAgICAgIHZhcmlhYmxlLmRhdGFTZXQgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IGdldENsb25lZE9iamVjdCwgZ2V0VmFsaWRKU09OLCBpc0RlZmluZWQsIGlzUGFnZWFibGUsIGlzVmFsaWRXZWJVUkwsIHRyaWdnZXJGbiwgbm9vcCwgeG1sVG9Kc29uIH0gZnJvbSBcIi4uLy4uL3V0aWwvdXRpbHNcIjtcblxuaW1wb3J0IHsgdXBsb2FkIH0gZnJvbSAnLi4vLi4vdXRpbC9maWxlLXVwbG9hZC51dGlsJztcbmltcG9ydCB7IFNlcnZpY2VWYXJpYWJsZSB9IGZyb20gJy4uLy4uL21vZGVsL3ZhcmlhYmxlL3NlcnZpY2UtdmFyaWFibGUnO1xuaW1wb3J0IHsgU2VydmljZVZhcmlhYmxlVXRpbHMgfSBmcm9tICcuLi8uLi91dGlsL3ZhcmlhYmxlL3NlcnZpY2UtdmFyaWFibGUudXRpbHMnO1xuaW1wb3J0IHsgJHF1ZXVlIH0gZnJvbSAnLi4vLi4vdXRpbC9pbmZsaWdodC1xdWV1ZSc7XG5pbXBvcnQgeyBCYXNlVmFyaWFibGVNYW5hZ2VyIH0gZnJvbSAnLi9iYXNlLXZhcmlhYmxlLm1hbmFnZXInO1xuaW1wb3J0IHsgQ09OU1RBTlRTLCBWQVJJQUJMRV9DT05TVEFOVFMsIFdTX0NPTlNUQU5UUyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy92YXJpYWJsZXMuY29uc3RhbnRzJztcbmltcG9ydCB7IGFwcE1hbmFnZXIsIGZvcm1hdEV4cG9ydEV4cHJlc3Npb24sIHNldElucHV0LCBkZWNvZGVEYXRhLCBtZXRhZGF0YVNlcnZpY2UsIGdldEVyck1lc3NhZ2UgfSBmcm9tICcuLy4uLy4uL3V0aWwvdmFyaWFibGUvdmFyaWFibGVzLnV0aWxzJztcbmltcG9ydCB7IGdldEV2YWx1YXRlZE9yZGVyQnksIGluaXRpYXRlQ2FsbGJhY2ssIHNlY3VyaXR5U2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWwvdmFyaWFibGUvdmFyaWFibGVzLnV0aWxzJztcbmltcG9ydCB7IGdldEFjY2Vzc1Rva2VuLCBwZXJmb3JtQXV0aG9yaXphdGlvbiwgcmVtb3ZlQWNjZXNzVG9rZW4gfSBmcm9tICcuLi8uLi91dGlsL29BdXRoLnV0aWxzJztcbmltcG9ydCB7IEFkdmFuY2VkT3B0aW9ucyB9IGZyb20gJy4uLy4uL2FkdmFuY2VkLW9wdGlvbnMnO1xuaW1wb3J0IHsgUGFnaW5hdGlvblV0aWxzIH0gZnJvbSAnLi4vLi4vdXRpbC92YXJpYWJsZS9wYWdpbmF0aW9uLnV0aWxzJztcbmltcG9ydCB7IFZhcmlhYmxlRXZlbnRzIH0gZnJvbSBcIi4uLy4uL21vZGVsL2Jhc2UtdmFyaWFibGVcIjtcblxuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuXG5leHBvcnQgY2xhc3MgU2VydmljZVZhcmlhYmxlTWFuYWdlciBleHRlbmRzIEJhc2VWYXJpYWJsZU1hbmFnZXIge1xuXG4gICAgZmlsZVVwbG9hZFJlc3BvbnNlOiBhbnkgPSBbXTtcbiAgICBmaWxlVXBsb2FkQ291bnQgPSAwO1xuICAgIHRvdGFsRmlsZXNDb3VudCA9IDA7XG4gICAgc3VjY2Vzc0ZpbGVVcGxvYWRDb3VudCA9IDA7XG4gICAgZmFpbGVkRmlsZVVwbG9hZENvdW50ID0gMDtcblxuICAgIC8qKlxuICAgICAqIGZ1bmN0aW9uIHRvIHByb2Nlc3MgZXJyb3IgcmVzcG9uc2UgZnJvbSBhIHNlcnZpY2VcbiAgICAgKiBAcGFyYW0ge1NlcnZpY2VWYXJpYWJsZX0gdmFyaWFibGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXJyTXNnXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3JDQlxuICAgICAqIEBwYXJhbSB4aHJPYmpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNraXBOb3RpZmljYXRpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNraXBEZWZhdWx0Tm90aWZpY2F0aW9uXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHByb2Nlc3NFcnJvclJlc3BvbnNlKHZhcmlhYmxlOiBTZXJ2aWNlVmFyaWFibGUsIGVyck1zZzogc3RyaW5nLCBlcnJvckNCOiBGdW5jdGlvbiwgeGhyT2JqPzogYW55LCBza2lwTm90aWZpY2F0aW9uPzogYm9vbGVhbiwgc2tpcERlZmF1bHROb3RpZmljYXRpb24/OiBib29sZWFuLCApIHtcbiAgICAgICAgY29uc3QgbWV0aG9kSW5mbyA9IHRoaXMuZ2V0TWV0aG9kSW5mbyh2YXJpYWJsZSwge30sIHt9KTtcbiAgICAgICAgY29uc3Qgc2VjdXJpdHlEZWZuT2JqID0gXy5nZXQobWV0aG9kSW5mbywgJ3NlY3VyaXR5RGVmaW5pdGlvbnMuMCcpO1xuICAgICAgICBjb25zdCBhZHZhbmNlZE9wdGlvbnM6IEFkdmFuY2VkT3B0aW9ucyA9IHRoaXMucHJlcGFyZUNhbGxiYWNrT3B0aW9ucyh4aHJPYmopO1xuICAgICAgICAvLyBFVkVOVDogT05fRVJST1JcbiAgICAgICAgaWYgKCFza2lwTm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgICBpbml0aWF0ZUNhbGxiYWNrKFZBUklBQkxFX0NPTlNUQU5UUy5FVkVOVC5FUlJPUiwgdmFyaWFibGUsIGVyck1zZywgYWR2YW5jZWRPcHRpb25zLCBza2lwRGVmYXVsdE5vdGlmaWNhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF8uZ2V0KHNlY3VyaXR5RGVmbk9iaiwgJ3R5cGUnKSA9PT0gVkFSSUFCTEVfQ09OU1RBTlRTLlJFU1RfU0VSVklDRS5TRUNVUklUWV9ERUZOLk9BVVRIMlxuICAgICAgICAgICAgJiYgXy5pbmNsdWRlcyhbVkFSSUFCTEVfQ09OU1RBTlRTLkhUVFBfU1RBVFVTX0NPREUuVU5BVVRIT1JJWkVELCBWQVJJQUJMRV9DT05TVEFOVFMuSFRUUF9TVEFUVVNfQ09ERS5GT1JCSURERU5dLCBfLmdldCh4aHJPYmosICdzdGF0dXMnKSkpIHtcbiAgICAgICAgICAgIHJlbW92ZUFjY2Vzc1Rva2VuKHNlY3VyaXR5RGVmbk9ialsneC1XTS1QUk9WSURFUl9JRCddKTtcbiAgICAgICAgfVxuICAgICAgICAvKiB0cmlnZ2VyIGVycm9yIGNhbGxiYWNrICovXG4gICAgICAgIHRyaWdnZXJGbihlcnJvckNCLCBlcnJNc2cpO1xuXG4gICAgICAgaWYgKCFDT05TVEFOVFMuaXNTdHVkaW9Nb2RlKSB7XG4gICAgICAgICAgICAvKiBwcm9jZXNzIG5leHQgcmVxdWVzdHMgaW4gdGhlIHF1ZXVlICovXG4gICAgICAgICAgICB2YXJpYWJsZS5jYW5VcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgJHF1ZXVlLnByb2Nlc3ModmFyaWFibGUpO1xuXG4gICAgICAgICAgICAvLyBFVkVOVDogT05fQ0FOX1VQREFURVxuICAgICAgICAgICAgaW5pdGlhdGVDYWxsYmFjayhWQVJJQUJMRV9DT05TVEFOVFMuRVZFTlQuQ0FOX1VQREFURSwgdmFyaWFibGUsIGVyck1zZywgYWR2YW5jZWRPcHRpb25zKTtcbiAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZnVuY3Rpb24gdG8gcHJvY2VzcyBzdWNjZXNzIHJlc3BvbnNlIGZyb20gYSBzZXJ2aWNlXG4gICAgICogQHBhcmFtIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHZhcmlhYmxlXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gc3VjY2Vzc1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBwcm9jZXNzU3VjY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlLCB2YXJpYWJsZSwgb3B0aW9ucywgc3VjY2VzcywgcmVzSGVhZGVycz8sIG9wZXJhdGlvbkluZj8pIHtcbiAgICAgICAgbGV0IGRhdGFTZXQ7XG4gICAgICAgIGxldCBuZXdEYXRhU2V0O1xuICAgICAgICBsZXQgcGFnaW5hdGlvbiA9IHt9O1xuICAgICAgICBsZXQgYWR2YW5jZWRPcHRpb25zOiBBZHZhbmNlZE9wdGlvbnM7XG4gICAgICAgIGxldCBqc29uUGFyc2VkUmVzcG9uc2U6IGFueSA9IGdldFZhbGlkSlNPTihyZXNwb25zZSk7XG5cbiAgICAgICAgcmVzcG9uc2UgPSBpc0RlZmluZWQoanNvblBhcnNlZFJlc3BvbnNlKSA/IGpzb25QYXJzZWRSZXNwb25zZSA6ICh4bWxUb0pzb24ocmVzcG9uc2UpIHx8IHJlc3BvbnNlKTtcblxuICAgICAgICBjb25zdCBpc1Jlc3BvbnNlUGFnZWFibGUgPSBpc1BhZ2VhYmxlKHJlc3BvbnNlKTtcbiAgICAgICAgaWYgKHZhcmlhYmxlLnNlcnZpY2VUeXBlID09PSAnRGF0YVNlcnZpY2UnIHx8IHZhcmlhYmxlLnNlcnZpY2VUeXBlID09PSAnSmF2YVNlcnZpY2UnKSB7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVkRGF0YSA9IGRlY29kZURhdGEocmVzcG9uc2UpO1xuICAgICAgICAgICAgaWYgKF8uaXNTdHJpbmcocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBkZWNvZGVkRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSZXNwb25zZVBhZ2VhYmxlKSB7XG4gICAgICAgICAgICBkYXRhU2V0ID0gcmVzcG9uc2UuY29udGVudDtcbiAgICAgICAgICAgIHBhZ2luYXRpb24gPSBfLm9taXQocmVzcG9uc2UsICdjb250ZW50Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhU2V0ID0gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNlbmQgcGFnaW5hdGlvbiBvYmplY3Qgd2l0aCBhZHZhbmNlZE9wdGlvbnMgYWxsIHRoZSB0aW1lLlxuICAgICAgICAgKiBXaXRoIHRoaXMsIHVzZXIgY2FuIHByb3ZpZGUgcGFnaW5hdGlvbiBvcHRpb24sIGV2ZW4gaWYgaXQgaXMgbm90IHRoZXJlLlxuICAgICAgICAgKiBhcHBsaWNhYmxlIHRvIDNyZCBwYXJ0eSBzZXJ2aWNlcyB0aGF0IGRvIG5vdCBzdXBwb3J0IHBhZ2luYXRpb24gb3V0IG9mIHRoZSBib3guXG4gICAgICAgICAqL1xuICAgICAgICBhZHZhbmNlZE9wdGlvbnMgPSB0aGlzLnByZXBhcmVDYWxsYmFja09wdGlvbnMob3B0aW9ucy54aHJPYmosIHtwYWdpbmF0aW9uOiBwYWdpbmF0aW9uLCByYXdEYXRhOiBkYXRhU2V0fSk7XG5cbiAgICAgICAgLy8gRVZFTlQ6IE9OX1JFU1VMVFxuICAgICAgICBpbml0aWF0ZUNhbGxiYWNrKFZBUklBQkxFX0NPTlNUQU5UUy5FVkVOVC5SRVNVTFQsIHZhcmlhYmxlLCByZXNwb25zZSwgYWR2YW5jZWRPcHRpb25zKTtcblxuICAgICAgICAvLyB0cmlnZ2VyIHN1Y2Nlc3MgY2FsbGJhY2ssIHBhc3MgZGF0YSByZWNlaXZlZCBmcm9tIHNlcnZlciBhcyBpdCBpcy5cbiAgICAgICAgdHJpZ2dlckZuKHN1Y2Nlc3MsIHJlc3BvbnNlLCBwYWdpbmF0aW9uKTtcblxuICAgICAgICAvKiBpZiBkYXRhVHJhbnNmb3JtYXRpb24gZW5hYmxlZCwgdHJhbnNmb3JtIHRoZSBkYXRhICovXG4gICAgICAgIGlmICh2YXJpYWJsZS50cmFuc2Zvcm1hdGlvbkNvbHVtbnMpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtRGF0YShyZXNwb25zZSwgdmFyaWFibGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgYSBwcmltaXRpdmUgdHlwZSByZXNwb25zZSBpcyByZXR1cm5lZCwgd3JhcCBpdCBpbiBhbiBvYmplY3RcbiAgICAgICAgZGF0YVNldCA9ICghXy5pc09iamVjdChkYXRhU2V0KSkgPyB7J3ZhbHVlJzogZGF0YVNldH0gOiBkYXRhU2V0O1xuXG4gICAgICAgIC8vIEVWRU5UOiBPTl9QUkVQQVJFX1NFVERBVEFcbiAgICAgICAgbmV3RGF0YVNldCA9IGluaXRpYXRlQ2FsbGJhY2soVkFSSUFCTEVfQ09OU1RBTlRTLkVWRU5ULlBSRVBBUkVfU0VUREFUQSwgdmFyaWFibGUsIGRhdGFTZXQsIGFkdmFuY2VkT3B0aW9ucyk7XG4gICAgICAgIGlmIChpc0RlZmluZWQobmV3RGF0YVNldCkpIHtcbiAgICAgICAgICAgIC8vIHNldHRpbmcgbmV3RGF0YVNldCBhcyB0aGUgcmVzcG9uc2UgdG8gc2VydmljZSB2YXJpYWJsZSBvblByZXBhcmVTZXREYXRhXG4gICAgICAgICAgICBkYXRhU2V0ID0gbmV3RGF0YVNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlucHV0RmllbGRzID0gZ2V0Q2xvbmVkT2JqZWN0KG9wdGlvbnMuaW5wdXRGaWVsZHMgfHwgdmFyaWFibGUuZGF0YUJpbmRpbmcpO1xuXG4gICAgICAgIC8vIFdNUy0yMjM2MSA6IEZvciBjcnVkIHZhcmlhYmxlLCBhcHBseSBvcGVyYXRpb24gaW5mbyByZWNpdmVkIGVsc2UgZGVkdWNlIGZvciBzZXJ2aWNlIHZhcmlhYmxlc1xuICAgICAgICBjb25zdCBvcGVyYXRpb25JbmZvID0gb3BlcmF0aW9uSW5mID8gb3BlcmF0aW9uSW5mIDogdGhpcy5nZXRNZXRob2RJbmZvKHZhcmlhYmxlLCBpbnB1dEZpZWxkcywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHBhZ2luYXRpb25JbmZvID0gUGFnaW5hdGlvblV0aWxzLmdldFBhZ2luYXRpb25JbmZvKG9wZXJhdGlvbkluZm8sIHZhcmlhYmxlKTtcbiAgICAgICAgaWYgKHBhZ2luYXRpb25JbmZvKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBQYWdpbmF0aW9uVXRpbHMuZ2VuZXJhdGVQYWdpbmF0aW9uUmVzKG9wZXJhdGlvbkluZm8sIHBhZ2luYXRpb25JbmZvLCByZXNwb25zZSwgcmVzSGVhZGVycywgb3B0aW9ucywgdmFyaWFibGUpO1xuICAgICAgICAgICAgaWYgKCFfLmlzRW1wdHkocmVzKSkge1xuICAgICAgICAgICAgICAgIFBhZ2luYXRpb25VdGlscy5zZXRWYXJpYWJsZVBhZ2luYXRpb24odmFyaWFibGUsIHJlcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiB1cGRhdGUgdGhlIGRhdGFzZXQgYWdhaW5zdCB0aGUgdmFyaWFibGUsIGlmIHJlc3BvbnNlIGlzIG5vbi1vYmplY3QsIGluc2VydCB0aGUgcmVzcG9uc2UgaW4gJ3ZhbHVlJyBmaWVsZCBvZiBkYXRhU2V0ICovXG4gICAgICAgIGlmICghb3B0aW9ucy5mb3JjZVJ1bk1vZGUgJiYgIW9wdGlvbnMuc2tpcERhdGFTZXRVcGRhdGUpIHtcbiAgICAgICAgICAgIGlmICghdmFyaWFibGUuX3BhZ2luYXRpb25Db25maWcpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZS5wYWdpbmF0aW9uID0gcGFnaW5hdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhcmlhYmxlLmRhdGFTZXQgPSBkYXRhU2V0O1xuXG4gICAgICAgICAgICAvLyBsZWdhY3kgcHJvcGVydGllcyBpbiBkYXRhU2V0LCBbY29udGVudF1cbiAgICAgICAgICAgIGlmIChpc1Jlc3BvbnNlUGFnZWFibGUpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFyaWFibGUuZGF0YVNldCwgJ2NvbnRlbnQnLCB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhcmlhYmxlLmRhdGFTZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXJpYWJsZS5ub3RpZnkoVmFyaWFibGVFdmVudHMuQUZURVJfSU5WT0tFLCBbdGhpcywgZGF0YVNldF0pO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIEVWRU5UOiBPTl9TVUNDRVNTXG4gICAgICAgICAgICBpbml0aWF0ZUNhbGxiYWNrKFZBUklBQkxFX0NPTlNUQU5UUy5FVkVOVC5TVUNDRVNTLCB2YXJpYWJsZSwgZGF0YVNldCwgYWR2YW5jZWRPcHRpb25zKTtcbiAgICAgICAgICAgaWYgKCFDT05TVEFOVFMuaXNTdHVkaW9Nb2RlKSB7XG4gICAgICAgICAgICAgICAgLyogcHJvY2VzcyBuZXh0IHJlcXVlc3RzIGluIHRoZSBxdWV1ZSAqL1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlLmNhblVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgJHF1ZXVlLnByb2Nlc3ModmFyaWFibGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFVkVOVDogT05fQ0FOX1VQREFURVxuICAgICAgICAgICAgaW5pdGlhdGVDYWxsYmFjayhWQVJJQUJMRV9DT05TVEFOVFMuRVZFTlQuQ0FOX1VQREFURSwgdmFyaWFibGUsIGRhdGFTZXQsIGFkdmFuY2VkT3B0aW9ucyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB2YXJpYWJsZS5kYXRhU2V0LFxuICAgICAgICAgICAgcGFnaW5hdGlvbjogdmFyaWFibGUucGFnaW5hdGlvblxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByb3RlY3RlZCB1cGxvYWRGaWxlSW5Gb3JtRGF0YSh2YXJpYWJsZTogU2VydmljZVZhcmlhYmxlLCBvcHRpb25zOiBhbnksIHN1Y2Nlc3M6IEZ1bmN0aW9uLCBlcnJvcjogRnVuY3Rpb24sIGZpbGUsIHJlcXVlc3RQYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHVwbG9hZChmaWxlLCB2YXJpYWJsZSwgcmVxdWVzdFBhcmFtcy5kYXRhLCB7XG4gICAgICAgICAgICBmaWxlUGFyYW1OYW1lOiAnZmlsZXMnLFxuICAgICAgICAgICAgdXJsOiByZXF1ZXN0UGFyYW1zLnVybFxuICAgICAgICB9KTtcbiAgICAgICAgKHByb21pc2UgYXMgYW55KS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZpbGVVcGxvYWRDb3VudCsrO1xuICAgICAgICAgICAgdGhpcy5zdWNjZXNzRmlsZVVwbG9hZENvdW50Kys7XG4gICAgICAgICAgICB0aGlzLmZpbGVVcGxvYWRSZXNwb25zZS5wdXNoKGRhdGFbMF0pO1xuICAgICAgICAgICAgaWYgKHRoaXMudG90YWxGaWxlc0NvdW50ID09PSB0aGlzLmZpbGVVcGxvYWRDb3VudCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZhaWxlZEZpbGVVcGxvYWRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NTdWNjZXNzUmVzcG9uc2UodGhpcy5maWxlVXBsb2FkUmVzcG9uc2UsIHZhcmlhYmxlLCBvcHRpb25zLCBzdWNjZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxlVXBsb2FkUmVzcG9uc2UgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YXJpYWJsZS5vblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcE1hbmFnZXIgJiYgYXBwTWFuYWdlci5ub3RpZnlBcHAoYXBwTWFuYWdlci5nZXRBcHBMb2NhbGUoKS5NRVNTQUdFX0ZJTEVfVVBMT0FEX1NVQ0NFU1MsICdzdWNjZXNzJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbml0aWF0ZUNhbGxiYWNrKFZBUklBQkxFX0NPTlNUQU5UUy5FVkVOVC5FUlJPUiwgdmFyaWFibGUsIHRoaXMuZmlsZVVwbG9hZFJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxlVXBsb2FkUmVzcG9uc2UgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYXBwTWFuYWdlciAmJiBhcHBNYW5hZ2VyLm5vdGlmeUFwcChhcHBNYW5hZ2VyLmdldEFwcExvY2FsZSgpLk1FU1NBR0VfRklMRV9VUExPQURfRVJST1IsICdlcnJvcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVVcGxvYWRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWNjZXNzRmlsZVVwbG9hZENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnRvdGFsRmlsZXNDb3VudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSwgKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZmlsZVVwbG9hZENvdW50Kys7XG4gICAgICAgICAgICB0aGlzLmZhaWxlZEZpbGVVcGxvYWRDb3VudCsrO1xuICAgICAgICAgICAgdGhpcy5maWxlVXBsb2FkUmVzcG9uc2UucHVzaChlKTtcbiAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9IGdldEVyck1lc3NhZ2UoZSwgdmFyaWFibGUuaHR0cFNlcnZpY2UuZ2V0TG9jYWxlKCkpO1xuICAgICAgICAgICAgLy8gaWYgYSBmaWxlIHVwbG9hZCBmYWlsZWQsIG5vdGlmeSB0aGUgcHJvZ3Jlc3MgbGlzdGVuZXIgdG8gdGFrZSBhY3Rpb25cbiAgICAgICAgICAgIGlmICh2YXJpYWJsZS5fcHJvZ3Jlc3NPYnNlcnZhYmxlKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGUuX3Byb2dyZXNzT2JzZXJ2YWJsZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgJ3N0YXR1cyc6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgJ2ZpbGVOYW1lJzogZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAnZXJyTXNnJzogZXJyTXNnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy50b3RhbEZpbGVzQ291bnQgPT09IHRoaXMuZmlsZVVwbG9hZENvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzRXJyb3JSZXNwb25zZSh2YXJpYWJsZSwgZXJyTXNnLCBlcnJvciwgZSwgb3B0aW9ucy5za2lwTm90aWZpY2F0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVVcGxvYWRSZXNwb25zZSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZVVwbG9hZENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmZhaWxlZEZpbGVVcGxvYWRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy50b3RhbEZpbGVzQ291bnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH0sIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFyaWFibGUuX3Byb2dyZXNzT2JzZXJ2YWJsZSkge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlLl9wcm9ncmVzc09ic2VydmFibGUubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgICdwcm9ncmVzcyc6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICdzdGF0dXMnOiBWQVJJQUJMRV9DT05TVEFOVFMuRVZFTlQuUFJPR1JFU1MsXG4gICAgICAgICAgICAgICAgICAgICdmaWxlTmFtZSc6IGZpbGUubmFtZX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5pdGlhdGVDYWxsYmFjayhWQVJJQUJMRV9DT05TVEFOVFMuRVZFTlQuUFJPR1JFU1MsIHZhcmlhYmxlLCBkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSB1c2VyIGlzIGxvZ2dlZCBpbiBvciBub3QgYW5kIHJldHVybnMgYXBwcm9wcmlhdGUgZXJyb3JcbiAgICAgKiBJZiB1c2VyIGlzIG5vdCBsb2dnZWQgaW4sIFNlc3Npb24gdGltZW91dCBsb2dpYyBpcyBydW4sIGZvciB1c2VyIHRvIGxvZ2luXG4gICAgICogQHBhcmFtIHZhcmlhYmxlXG4gICAgICogQHJldHVybnMge2FueX1cbiAgICAgKi9cbiAgICBwcml2YXRlIGhhbmRsZUF1dGhFcnJvcih2YXJpYWJsZSwgc3VjY2VzcywgZXJyb3JDQiwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBpc1VzZXJBdXRoZW50aWNhdGVkID0gXy5nZXQoc2VjdXJpdHlTZXJ2aWNlLmdldCgpLCAnYXV0aGVudGljYXRlZCcpO1xuICAgICAgICBsZXQgaW5mbztcblxuICAgICAgICBpZiAoaXNVc2VyQXV0aGVudGljYXRlZCkge1xuICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnWW91XFwncmUgbm90IGF1dGhvcmlzZWQgdG8gYWNjZXNzIHRoZSByZXNvdXJjZSBcIicgKyB2YXJpYWJsZS5zZXJ2aWNlICsgJ1wiLidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnWW91XFwncmUgbm90IGF1dGhlbnRpY2F0ZWQgdG8gYWNjZXNzIHRoZSByZXNvdXJjZSBcIicgKyB2YXJpYWJsZS5zZXJ2aWNlICsgJ1wiLicsXG4gICAgICAgICAgICAgICAgICAgIHNraXBEZWZhdWx0Tm90aWZpY2F0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFwcE1hbmFnZXIucHVzaFRvU2Vzc2lvbkZhaWx1cmVSZXF1ZXN0cyh2YXJpYWJsZS5pbnZva2UuYmluZCh2YXJpYWJsZSwgb3B0aW9ucywgc3VjY2VzcywgZXJyb3JDQikpO1xuICAgICAgICAgICAgYXBwTWFuYWdlci5oYW5kbGU0MDEoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLndhcm4odmFyaWFibGUubmFtZSArICc6ICcgKyBpbmZvLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGVycm9yLCB3aGVuIHZhcmlhYmxlJ3MgbWV0YWRhdGEgaXMgbm90IGZvdW5kLiBUaGUgcmVhc29uIGZvciB0aGlzIGNhbiBiZTpcbiAgICAgKiAgLSBBUEkgaXMgc2VjdXJlIGFuZCB1c2VyIGlzIG5vdCBsb2dnZWQgaW5cbiAgICAgKiAgLSBBUEkgaXMgc2VjdXJlIGFuZCB1c2VyIGlzIGxvZ2dlZCBpbiBidXQgbm90IGF1dGhvcml6ZWRcbiAgICAgKiAgLSBUaGUgc2VydmljZWRlZnMgYXJlIG5vdCBnZW5lcmF0ZWQgcHJvcGVybHkgYXQgdGhlIGJhY2sgZW5kIChuZWVkIHRvIGVkaXQgdGhlIHZhcmlhYmxlIGFuZCByZS1ydW4gdGhlIHByb2plY3QpXG4gICAgICogQHBhcmFtIGluZm9cbiAgICAgKiBAcGFyYW0gdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gZXJyb3JDQlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGhhbmRsZVJlcXVlc3RNZXRhRXJyb3IoaW5mbywgdmFyaWFibGUsIHN1Y2Nlc3MsIGVycm9yQ0IsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZXJyX3R5cGUgPSBfLmdldChpbmZvLCAnZXJyb3IudHlwZScpO1xuXG4gICAgICAgIHN3aXRjaCAoZXJyX3R5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgVkFSSUFCTEVfQ09OU1RBTlRTLlJFU1RfU0VSVklDRS5FUlJfVFlQRS5OT19BQ0NFU1NUT0tFTjpcbiAgICAgICAgICAgICAgICBwZXJmb3JtQXV0aG9yaXphdGlvbih1bmRlZmluZWQsIGluZm8uc2VjdXJpdHlEZWZuT2JqW1ZBUklBQkxFX0NPTlNUQU5UUy5SRVNUX1NFUlZJQ0UuT0FVVEhfUFJPVklERVJfS0VZXSwgdGhpcy5pbnZva2UuYmluZCh0aGlzLCB2YXJpYWJsZSwgb3B0aW9ucywgc3VjY2VzcywgZXJyb3JDQiksIG51bGwsIHRoaXMuZ2V0UHJvdmlkZXJJbmZvKHZhcmlhYmxlLCBpbmZvLnNlY3VyaXR5RGVmbk9ialsneC1XTS1QUk9WSURFUl9JRCddKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzRXJyb3JSZXNwb25zZSh2YXJpYWJsZSwgaW5mby5lcnJvci5tZXNzYWdlLCBlcnJvckNCLCBvcHRpb25zLnhock9iaiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFZBUklBQkxFX0NPTlNUQU5UUy5SRVNUX1NFUlZJQ0UuRVJSX1RZUEUuVVNFUl9VTkFVVEhPUklTRUQ6XG4gICAgICAgICAgICAgICAgaW5mbyA9IHRoaXMuaGFuZGxlQXV0aEVycm9yKHZhcmlhYmxlLCBzdWNjZXNzLCBlcnJvckNCLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NFcnJvclJlc3BvbnNlKHZhcmlhYmxlLCBpbmZvLmVycm9yLm1lc3NhZ2UsIGVycm9yQ0IsIG9wdGlvbnMueGhyT2JqLCBvcHRpb25zLnNraXBOb3RpZmljYXRpb24sIGluZm8uZXJyb3Iuc2tpcERlZmF1bHROb3RpZmljYXRpb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBWQVJJQUJMRV9DT05TVEFOVFMuUkVTVF9TRVJWSUNFLkVSUl9UWVBFLk1FVEFEQVRBX01JU1NJTkc6XG4gICAgICAgICAgICBjYXNlIFZBUklBQkxFX0NPTlNUQU5UUy5SRVNUX1NFUlZJQ0UuRVJSX1RZUEUuQ1JVRF9PUEVSQVRJT05fTUlTU0lORzpcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5lcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZm8uZXJyb3IubWVzc2FnZSA9IGluZm8uZXJyb3IubWVzc2FnZS5yZXBsYWNlKCckdmFyaWFibGUnLCB2YXJpYWJsZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlYXNvbnM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJfdHlwZSA9PT0gVkFSSUFCTEVfQ09OU1RBTlRTLlJFU1RfU0VSVklDRS5FUlJfVFlQRS5NRVRBREFUQV9NSVNTSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb25zID0gWycxLiBZb3UgZGlkIG5vdCBQcmV2aWV3IHRoZSBhcHAgYWZ0ZXIgY3JlYXRpbmcgYSBWYXJpYWJsZSBmb3IgdGhlIGltcG9ydGVkIHNlcnZpY2UuJywgJzIuIFlvdSBkZWxldGVkIHRoZSBpbXBvcnRlZCBzZXJ2aWNlIHRoaXMgVmFyaWFibGUgaXMgbGlua2VkIHRvLiddO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29ucyA9IFsnMS4gWW91IGhhdmVuXFwndCBjaG9zZW4gYW4gZW5kcG9pbnQgZm9yICcgKyAgb3B0aW9ucy5vcGVyYXRpb24gKyAnIG9wZXJhdGlvbiBmb3IgdGhpcyBFbnRpdHkuJ107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGluZm8uZXJyb3IubWVzc2FnZSArICdcXG4gUG9zc2libGUgcmVhc29ucyBmb3IgdGhpczpcXG4gJyArIHJlYXNvbnMuam9pbignXFxuICcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzRXJyb3JSZXNwb25zZSh2YXJpYWJsZSwgaW5mby5lcnJvci5tZXNzYWdlLCBlcnJvckNCLCBvcHRpb25zLnhock9iaiwgb3B0aW9ucy5za2lwTm90aWZpY2F0aW9uLCBpbmZvLmVycm9yLnNraXBEZWZhdWx0Tm90aWZpY2F0aW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGluZm8uZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oaW5mby5lcnJvci5tZXNzYWdlLCB2YXJpYWJsZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzRXJyb3JSZXNwb25zZSh2YXJpYWJsZSwgaW5mby5lcnJvci5tZXNzYWdlLCBlcnJvckNCLCBvcHRpb25zLnhock9iaiwgb3B0aW9ucy5za2lwTm90aWZpY2F0aW9uLCBpbmZvLmVycm9yLnNraXBEZWZhdWx0Tm90aWZpY2F0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZnVuY3Rpb24gdG8gdHJhbnNmb3JtIHRoZSBzZXJ2aWNlIGRhdGEgYXMgYWNjb3JkaW5nIHRvIHRoZSB2YXJpYWJsZSBjb25maWd1cmF0aW9uXG4gICAgICogdGhpcyBpcyB1c2VkIHdoZW4gJ3RyYW5zZm9ybWF0aW9uQ29sdW1ucycgcHJvcGVydHkgaXMgc2V0IG9uIHRoZSB2YXJpYWJsZVxuICAgICAqIEBwYXJhbSBkYXRhOiBkYXRhIHJldHVybmVkIGZyb20gdGhlIHNlcnZpY2VcbiAgICAgKiBAdmFyaWFibGU6IHZhcmlhYmxlIG9iamVjdCB0cmlnZ2VyaW5nIHRoZSBzZXJ2aWNlXG4gICAgICovXG4gICAgcHJpdmF0ZSB0cmFuc2Zvcm1EYXRhKGRhdGEsIHZhcmlhYmxlKSB7XG4gICAgICAgIGRhdGEud21UcmFuc2Zvcm1lZERhdGEgPSBbXTtcblxuICAgICAgICBjb25zdCBjb2x1bW5zQXJyYXkgPSB2YXJpYWJsZS50cmFuc2Zvcm1hdGlvbkNvbHVtbnMsXG4gICAgICAgICAgICBkYXRhQXJyYXkgPSBfLmdldChkYXRhLCB2YXJpYWJsZS5kYXRhRmllbGQpIHx8IFtdLFxuICAgICAgICAgICAgdHJhbnNmb3JtZWREYXRhID0gZGF0YS53bVRyYW5zZm9ybWVkRGF0YTtcblxuICAgICAgICBfLmZvckVhY2goZGF0YUFycmF5LCBmdW5jdGlvbiAoZGF0dW0sIGluZGV4KSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZERhdGFbaW5kZXhdID0ge307XG4gICAgICAgICAgICBfLmZvckVhY2goY29sdW1uc0FycmF5LCBmdW5jdGlvbiAoY29sdW1uLCBjb2x1bW5JbmRleCkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkRGF0YVtpbmRleF1bY29sdW1uXSA9IGRhdHVtW2NvbHVtbkluZGV4XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIGdldHMgdGhlIHNlcnZpY2Ugb3BlcmF0aW9uIGluZm8gYWdhaW5zdCBhIHNlcnZpY2UgdmFyaWFibGVcbiAgICAgKiB0aGlzIGlzIGV4dHJhY3RlZCBmcm9tIHRoZSBtZXRhZGF0YXNlcnZpY2VcbiAgICAgKiBAcGFyYW0gdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gaW5wdXRGaWVsZHM6IHNhbXBsZSB2YWx1ZXMsIGlmIHByb3ZpZGVkLCB3aWxsIGJlIHNldCBhZ2FpbnN0IHBhcmFtcyBpbiB0aGUgZGVmaW5pdGlvblxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHJldHVybnMge2FueX1cbiAgICAgKi9cbiAgICBwcml2YXRlIGdldE1ldGhvZEluZm8odmFyaWFibGUsIGlucHV0RmllbGRzLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBtZXRob2RJbmZvO1xuICAgICAgICBpZiAoIV8uaXNFbXB0eShtZXRhZGF0YVNlcnZpY2UpKSB7XG4gICAgICAgICAgICBjb25zdCBzZXJ2aWNlRGVmID0gZ2V0Q2xvbmVkT2JqZWN0KG1ldGFkYXRhU2VydmljZS5nZXRCeU9wZXJhdGlvbklkKHZhcmlhYmxlLm9wZXJhdGlvbklkLCB2YXJpYWJsZS5nZXRQcmVmYWJOYW1lKCkpKTtcbiAgICAgICAgICAgIG1ldGhvZEluZm8gPSBzZXJ2aWNlRGVmID09PSBudWxsID8gbnVsbCA6IF8uZ2V0KHNlcnZpY2VEZWYsICd3bVNlcnZpY2VPcGVyYXRpb25JbmZvJyk7XG4gICAgICAgIH0gZWxzZSAge1xuICAgICAgICAgICAgbWV0aG9kSW5mbyA9IHZhcmlhYmxlLnNlcnZpY2VJbmZvO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtZXRob2RJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kSW5mbztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWN1cml0eURlZm5PYmogPSBfLmdldChtZXRob2RJbmZvLnNlY3VyaXR5RGVmaW5pdGlvbnMsICcwJyksXG4gICAgICAgICAgICBpc09BdXRoVHlwZVNlcnZpY2UgPSBzZWN1cml0eURlZm5PYmogJiYgKHNlY3VyaXR5RGVmbk9iai50eXBlID09PSBWQVJJQUJMRV9DT05TVEFOVFMuUkVTVF9TRVJWSUNFLlNFQ1VSSVRZX0RFRk4uT0FVVEgyKTtcbiAgICAgICAgaWYgKG1ldGhvZEluZm8ucGFyYW1ldGVycykge1xuICAgICAgICAgICAgbWV0aG9kSW5mby5wYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIHJlYWRPbmx5IHBhcmFtcyBpbiBjYXNlIG9mIGZvcm1EYXRhIGZpbGUgcGFyYW1zIHdpbGwgYmUgZHVwbGljYXRlZFxuICAgICAgICAgICAgICAgIGlmIChwYXJhbS5yZWFkT25seSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFtLnNhbXBsZVZhbHVlID0gaW5wdXRGaWVsZHNbcGFyYW0ubmFtZV07XG4gICAgICAgICAgICAgICAgLyogc3VwcG9ydGluZyBwYWdpbmF0aW9uIGZvciBxdWVyeSBzZXJ2aWNlIHZhcmlhYmxlICovXG4gICAgICAgICAgICAgICAgaWYgKFZBUklBQkxFX0NPTlNUQU5UUy5QQUdJTkFUSU9OX1BBUkFNUy5pbmRleE9mKHBhcmFtLm5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW0ubmFtZSA9PT0gJ3NpemUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbS5zYW1wbGVWYWx1ZSA9IG9wdGlvbnMuc2l6ZSB8fCBwYXJhbS5zYW1wbGVWYWx1ZSB8fCBwYXJzZUludCh2YXJpYWJsZS5tYXhSZXN1bHRzLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW0ubmFtZSA9PT0gJ3BhZ2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbS5zYW1wbGVWYWx1ZSA9IG9wdGlvbnMucGFnZSB8fCBwYXJhbS5zYW1wbGVWYWx1ZSB8fCAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtLm5hbWUgPT09ICdzb3J0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0uc2FtcGxlVmFsdWUgPSBnZXRFdmFsdWF0ZWRPcmRlckJ5KHZhcmlhYmxlLm9yZGVyQnksIG9wdGlvbnMub3JkZXJCeSkgfHwgcGFyYW0uc2FtcGxlVmFsdWUgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtLm5hbWUgPT09ICdhY2Nlc3NfdG9rZW4nICYmIGlzT0F1dGhUeXBlU2VydmljZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbS5zYW1wbGVWYWx1ZSA9IGdldEFjY2Vzc1Rva2VuKHNlY3VyaXR5RGVmbk9ialtWQVJJQUJMRV9DT05TVEFOVFMuUkVTVF9TRVJWSUNFLk9BVVRIX1BST1ZJREVSX0tFWV0sIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRob2RJbmZvO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogZ2V0cyB0aGUgcHJvdmlkZXIgaW5mbyBhZ2FpbnN0IGEgc2VydmljZSB2YXJpYWJsZSdzIHByb3ZpZGVyXG4gICAgICogdGhpcyBpcyBleHRyYWN0ZWQgZnJvbSB0aGUgbWV0YWRhdGFzZXJ2aWNlXG4gICAgICogQHBhcmFtIHZhcmlhYmxlXG4gICAgICogQHBhcmFtIHByb3ZpZGVySWRcbiAgICAgKiBAcmV0dXJucyB7YW55fVxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0UHJvdmlkZXJJbmZvKHZhcmlhYmxlLCBwcm92aWRlcklkKSB7XG4gICAgICAgIHJldHVybiBnZXRDbG9uZWRPYmplY3QobWV0YWRhdGFTZXJ2aWNlPy5nZXRCeVByb3ZpZGVySWQocHJvdmlkZXJJZCwgdmFyaWFibGUuZ2V0UHJlZmFiTmFtZSgpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGFueSBvZiB0aGUgZmlsZXMgYXJlIGluIG9uUHJvZ3Jlc3Mgc3RhdGVcbiAgICAgKi9cbiAgICBwcml2YXRlIGlzRmlsZVVwbG9hZEluUHJvZ3Jlc3MoZGF0YUJpbmRpbmdzKSB7XG4gICAgICAgIGxldCBmaWxlc1N0YXR1cyA9IGZhbHNlO1xuICAgICAgICBfLmZvckVhY2goZGF0YUJpbmRpbmdzLCAoZGF0YUJpbmRpbmcpID0+IHtcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkoZGF0YUJpbmRpbmcpICYmIGRhdGFCaW5kaW5nWzBdIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChkYXRhQmluZGluZywgKGZpbGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUuc3RhdHVzID09PSAnb25Qcm9ncmVzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzU3RhdHVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbGVzU3RhdHVzO1xuICAgIH1cblxuICAgIC8vIE1ha2VzIHRoZSBjYWxsIGZvciBVcGxvYWRpbmcgZmlsZS8gZmlsZXNcbiAgICBwcm90ZWN0ZWQgdXBsb2FkRmlsZSh2YXJpYWJsZSwgb3B0aW9ucywgc3VjY2VzcywgZXJyb3IsIGlucHV0RmllbGRzLCByZXF1ZXN0UGFyYW1zICkge1xuICAgICAgICBsZXQgZmlsZVBhcmFtQ291bnQgPSAwO1xuICAgICAgICBjb25zdCBmaWxlQXJyOiBhbnkgPSBbXSwgcHJvbUFycjogYW55ID0gW107XG4gICAgICAgIF8uZm9yRWFjaChpbnB1dEZpZWxkcywgKGlucHV0RmllbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkoaW5wdXRGaWVsZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRGaWVsZFswXSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZVBhcmFtQ291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKGlucHV0RmllbGQsIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBGaWxlIHx8IF8uZmluZChfLnZhbHVlcyhpbnB1dCksIG8gPT4gbyBpbnN0YW5jZW9mIEJsb2IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlQXJyLnB1c2goaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b3RhbEZpbGVzQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVQYXJhbUNvdW50ID0gZmlsZVBhcmFtQ291bnQgfHwgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRGaWVsZCBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZVBhcmFtQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b3RhbEZpbGVzQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgZmlsZUFyci5wdXNoKGlucHV0RmllbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmaWxlUGFyYW1Db3VudCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGlucHV0RmllbGRzLmZpbGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goZmlsZUFyciwgKGZpbGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbUFyci5wdXNoKHRoaXMudXBsb2FkRmlsZUluRm9ybURhdGEodmFyaWFibGUsIG9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yLCBmaWxlLCByZXF1ZXN0UGFyYW1zKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21BcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51cGxvYWRGaWxlSW5Gb3JtRGF0YSh2YXJpYWJsZSwgb3B0aW9ucywgc3VjY2VzcywgZXJyb3IsIGZpbGVBcnJbMF0sIHJlcXVlc3RQYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJveHkgZm9yIHRoZSBpbnZva2UgY2FsbFxuICAgICAqIFJlcXVlc3QgSW5mbyBpcyBjb25zdHJ1Y3RlZFxuICAgICAqIGlmIGVycm9yIGZvdW5kLCBlcnJvciBpcyB0aHJvd25cbiAgICAgKiBlbHNlLCBjYWxsIGlzIG1hZGVcbiAgICAgKiBAcGFyYW0ge1NlcnZpY2VWYXJpYWJsZX0gdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvclxuICAgICAqIEByZXR1cm5zIHthbnl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2ludm9rZSAodmFyaWFibGU6IFNlcnZpY2VWYXJpYWJsZSwgb3B0aW9uczogYW55LCBzdWNjZXNzOiBGdW5jdGlvbiwgZXJyb3I6IEZ1bmN0aW9uKSB7XG4gICAgICAgIGxldCBpbnB1dEZpZWxkcyA9IGdldENsb25lZE9iamVjdChvcHRpb25zLmlucHV0RmllbGRzIHx8IHZhcmlhYmxlLmRhdGFCaW5kaW5nKTtcbiAgICAgICAgLy8gRVZFTlQ6IE9OX0JFRk9SRV9VUERBVEVcbiAgICAgICAgY29uc3Qgb3V0cHV0OiBhbnkgPSBpbml0aWF0ZUNhbGxiYWNrKFZBUklBQkxFX0NPTlNUQU5UUy5FVkVOVC5CRUZPUkVfVVBEQVRFLCB2YXJpYWJsZSwgaW5wdXRGaWVsZHMsIG9wdGlvbnMpO1xuICAgICAgICBsZXQgc3VjY2Vzc0hhbmRsZXI7XG4gICAgICAgIGxldCBlcnJvckhhbmRsZXI7XG5cbiAgICAgICAgaWYgKG91dHB1dCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICRxdWV1ZS5wcm9jZXNzKHZhcmlhYmxlKTtcbiAgICAgICAgICAgIHRyaWdnZXJGbihlcnJvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF8uaXNPYmplY3Qob3V0cHV0KSkge1xuICAgICAgICAgICAgaW5wdXRGaWVsZHMgPSBvdXRwdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvcGVyYXRpb25JbmZvID0gdGhpcy5nZXRNZXRob2RJbmZvKHZhcmlhYmxlLCBpbnB1dEZpZWxkcywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RQYXJhbXMgPSBTZXJ2aWNlVmFyaWFibGVVdGlscy5jb25zdHJ1Y3RSZXF1ZXN0UGFyYW1zKHZhcmlhYmxlLCBvcGVyYXRpb25JbmZvLCBpbnB1dEZpZWxkcywgb3B0aW9ucyk7XG4gICAgICAgIC8vIGNoZWNrIGVycm9yc1xuICAgICAgICBpZiAocmVxdWVzdFBhcmFtcy5lcnJvcikge1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IHRoaXMuaGFuZGxlUmVxdWVzdE1ldGFFcnJvcihyZXF1ZXN0UGFyYW1zLCB2YXJpYWJsZSwgc3VjY2VzcywgZXJyb3IsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgcmVhc29uID0gKF8uZ2V0KGluZm8sICdlcnJvci5tZXNzYWdlJykgfHwgJ0FuIGVycm9yIG9jY3VycmVkIHdoaWxlIHRyaWdnZXJpbmcgdGhlIHZhcmlhYmxlOiAnKSArICc6ICcgKyAgdmFyaWFibGUubmFtZTtcbiAgICAgICAgICAgIHRyaWdnZXJGbihlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbGUgdXBsb2FkXG4gICAgICAgIGlmIChTZXJ2aWNlVmFyaWFibGVVdGlscy5pc0ZpbGVVcGxvYWRSZXF1ZXN0KHZhcmlhYmxlKSkge1xuICAgICAgICAgICAgY29uc3QgdXBsb2FkUHJvbWlzZSA9IHRoaXMudXBsb2FkRmlsZSh2YXJpYWJsZSwgb3B0aW9ucywgc3VjY2VzcywgZXJyb3IsIGlucHV0RmllbGRzLCByZXF1ZXN0UGFyYW1zKTtcbiAgICAgICAgICAgIGlmICh1cGxvYWRQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwbG9hZFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaWxlIGRvd25sb2FkXG4gICAgICAgIGlmIChvcGVyYXRpb25JbmZvICYmIF8uaXNBcnJheShvcGVyYXRpb25JbmZvLnByb2R1Y2VzKSAmJiBfLmluY2x1ZGVzKG9wZXJhdGlvbkluZm8ucHJvZHVjZXMsIFdTX0NPTlNUQU5UUy5DT05URU5UX1RZUEVTLk9DVEVUX1NUUkVBTSkpIHtcbiAgICAgICAgICAgIC8vIFRvRG8gLSB2YXJpYWJsZSBzZXBlcmF0aW9uXG4gICAgICAgICAgICByZXR1cm4gdmFyaWFibGUuc2ltdWxhdGVGaWxlRG93bmxvYWQocmVxdWVzdFBhcmFtcywgdmFyaWFibGUuZGF0YUJpbmRpbmcuZmlsZSB8fCB2YXJpYWJsZS5uYW1lLCB2YXJpYWJsZS5kYXRhQmluZGluZy5leHBvcnRUeXBlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhdGVDYWxsYmFjayhWQVJJQUJMRV9DT05TVEFOVFMuRVZFTlQuU1VDQ0VTUywgdmFyaWFibGUsIG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgICRxdWV1ZS5wcm9jZXNzKHZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRm4oc3VjY2Vzcyk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhdGVDYWxsYmFjayhWQVJJQUJMRV9DT05TVEFOVFMuRVZFTlQuRVJST1IsIHZhcmlhYmxlLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICAkcXVldWUucHJvY2Vzcyh2YXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckZuKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm90aWZ5IHZhcmlhYmxlIHByb2dyZXNzXG4gICAgICAgIHRoaXMubm90aWZ5SW5mbGlnaHQodmFyaWFibGUsICFvcHRpb25zLnNraXBUb2dnbGVTdGF0ZSk7XG5cbiAgICAgICAgc3VjY2Vzc0hhbmRsZXIgPSAocmVzcG9uc2UsIHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS50eXBlIHx8IHJlc3BvbnNlICYmIHJlc3BvbnNlLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IHJlc3BvbnNlLmJvZHkgfHwgcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5wcm9jZXNzU3VjY2Vzc1Jlc3BvbnNlKHJlcywgdmFyaWFibGUsIF8uZXh0ZW5kKG9wdGlvbnMsIHsneGhyT2JqJzogcmVzcG9uc2V9KSwgc3VjY2VzcywgcmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgLy8gbm90aWZ5IHZhcmlhYmxlIHN1Y2Nlc3NcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUluZmxpZ2h0KHZhcmlhYmxlLCBmYWxzZSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZXJyb3JIYW5kbGVyID0gKGVyciwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlcnJNc2cgPSBnZXRFcnJNZXNzYWdlKGVyciwgdmFyaWFibGUuaHR0cFNlcnZpY2UuZ2V0TG9jYWxlKCkpO1xuICAgICAgICAgICAgLy8gbm90aWZ5IHZhcmlhYmxlIGVycm9yXG4gICAgICAgICAgICB0aGlzLm5vdGlmeUluZmxpZ2h0KHZhcmlhYmxlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NFcnJvclJlc3BvbnNlKHZhcmlhYmxlLCBlcnJNc2csIGVycm9yLCBlcnIsIG9wdGlvbnMuc2tpcE5vdGlmaWNhdGlvbik7XG4gICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJNc2csXG4gICAgICAgICAgICAgICAgZGV0YWlsczogZXJyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBtYWtlIHRoZSBjYWxsIGFuZCByZXR1cm4gYSBwcm9taXNlIHRvIHRoZSB1c2VyIHRvIHN1cHBvcnQgc2NyaXB0IGNhbGxzIG1hZGUgYnkgdXNlcnNcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMucmVzcG9uc2VUeXBlID0gJ3RleHQnOyAvLyB0aGlzIGlzIHRvIHJldHVybiB0ZXh0IHJlc3BvbnNlLiBKU09OICYgWE1MLXRvLUpTT04gcGFyc2luZyBpcyBoYW5kbGVkIGluIHN1Y2Nlc3MgaGFuZGxlci5cbiAgICAgICAgICAgIC8vIFRvRG8gLSB2YXJpYWJsZSBzZXBlcmF0aW9uXG4gICAgICAgICAgICAvLyB0aGlzLmh0dHBDYWxsKHJlcXVlc3RQYXJhbXMsIHZhcmlhYmxlKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgLy8gICAgIHN1Y2Nlc3NIYW5kbGVyKHJlc3BvbnNlLCByZXNvbHZlKTtcbiAgICAgICAgICAgIC8vIH0sIGVyciA9PiB7XG4gICAgICAgICAgICAvLyAgICAgY29uc3QgdmFsaWRKU09OID0gZ2V0VmFsaWRKU09OKGVyci5lcnJvcik7XG4gICAgICAgICAgICAvLyAgICAgZXJyLmVycm9yID0gaXNEZWZpbmVkKHZhbGlkSlNPTikgPyB2YWxpZEpTT04gOiBlcnIuZXJyb3I7XG4gICAgICAgICAgICAvLyAgICAgZXJyb3JIYW5kbGVyKGVyciwgcmVqZWN0KTtcbiAgICAgICAgICAgIC8vIH0pO1xuICAgICAgICAgICAgLy8gdGhlIF9vYnNlcnZhYmxlIHByb3BlcnR5IG9uIHZhcmlhYmxlIGlzIHVzZWQgc3RvcmUgdGhlIG9ic2VydmFibGUgdXNpbmcgd2hpY2ggdGhlIG5ldHdvcmsgY2FsbCBpcyBtYWRlXG4gICAgICAgICAgICAvLyB0aGlzIGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgdmFyaWFibGUgY2FsbHMuXG4gICAgICAgICAgICB2YXJpYWJsZS5odHRwU2VydmljZS5zZW5kQ2FsbChyZXF1ZXN0UGFyYW1zLCB2YXJpYWJsZSkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzSGFuZGxlcihyZXNwb25zZSwgcmVzb2x2ZSk7XG4gICAgICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkSlNPTiA9IGdldFZhbGlkSlNPTihlcnIuZXJyb3IpO1xuICAgICAgICAgICAgICAgIGVyci5lcnJvciA9IGlzRGVmaW5lZCh2YWxpZEpTT04pID8gdmFsaWRKU09OIDogZXJyLmVycm9yO1xuICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlcihlcnIsIHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogUFVCTElDICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLy9cblxuICAgIHB1YmxpYyBpbnZva2UodmFyaWFibGUsIG9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAvLyBhcHBNYW5hZ2VyLm5vdGlmeSgnY2hlY2stc3RhdGUtcGVyc2lzdGVuY2Utb3B0aW9ucycsIHtcbiAgICAgICAgLy8gICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIC8vICAgICB2YXJpYWJsZTogdmFyaWFibGVcbiAgICAgICAgLy8gfSk7XG4gICAgICAgIG9wdGlvbnMuaW5wdXRGaWVsZHMgPSBvcHRpb25zLmlucHV0RmllbGRzIHx8IGdldENsb25lZE9iamVjdCh2YXJpYWJsZS5kYXRhQmluZGluZyk7XG4gICAgICAgIHJldHVybiAkcXVldWUuc3VibWl0KHZhcmlhYmxlKS50aGVuKHRoaXMuX2ludm9rZS5iaW5kKHRoaXMsIHZhcmlhYmxlLCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvciksIGVycm9yKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0UGFnaW5hdGlvbih2YXJpYWJsZSwgZGF0YSkge1xuICAgICAgICB2YXJpYWJsZS5fcGFnaW5hdGlvbkNvbmZpZyA9IGRhdGE7XG4gICAgfVxuXG4gICAgcHVibGljIGRvd25sb2FkKHZhcmlhYmxlLCBvcHRpb25zLCBzdWNjZXNzSGFuZGxlciwgZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBjb25zdCBpbnB1dFBhcmFtcyAgPSBnZXRDbG9uZWRPYmplY3QodmFyaWFibGUuZGF0YUJpbmRpbmcpO1xuICAgICAgICBjb25zdCBpbnB1dERhdGEgPSBvcHRpb25zLmRhdGEgfHwge307XG4gICAgICAgIGNvbnN0IG1ldGhvZEluZm8gICA9IHRoaXMuZ2V0TWV0aG9kSW5mbyh2YXJpYWJsZSwgaW5wdXRQYXJhbXMsIG9wdGlvbnMpO1xuICAgICAgICBsZXQgcmVxdWVzdFBhcmFtcztcblxuICAgICAgICBtZXRob2RJbmZvLnJlbGF0aXZlUGF0aCArPSAnL2V4cG9ydCc7XG4gICAgICAgIHJlcXVlc3RQYXJhbXMgPSBTZXJ2aWNlVmFyaWFibGVVdGlscy5jb25zdHJ1Y3RSZXF1ZXN0UGFyYW1zKHZhcmlhYmxlLCBtZXRob2RJbmZvLCBpbnB1dFBhcmFtcyk7XG5cbiAgICAgICAgcmVxdWVzdFBhcmFtcy5kYXRhID0gaW5wdXREYXRhO1xuICAgICAgICByZXF1ZXN0UGFyYW1zLmRhdGEuZmllbGRzID0gZm9ybWF0RXhwb3J0RXhwcmVzc2lvbihpbnB1dERhdGEuZmllbGRzIHx8IFtdKTtcblxuICAgICAgICAvLyBleHRyYSBvcHRpb25zIHByb3ZpZGVkLCB0aGVzZSBtYXkgYmUgdXNlZCBpbiBmdXR1cmUgZm9yIGludGVncmF0aW5nIGV4cG9ydCBmZWF0dXJlIHdpdGggZXh0LiBzZXJ2aWNlc1xuICAgICAgICByZXF1ZXN0UGFyYW1zLm1ldGhvZCA9IG9wdGlvbnMuaHR0cE1ldGhvZCB8fCAnUE9TVCc7XG4gICAgICAgIHJlcXVlc3RQYXJhbXMudXJsID0gb3B0aW9ucy51cmwgfHwgcmVxdWVzdFBhcmFtcy51cmw7XG5cbiAgICAgICAgLy8gSWYgcmVxdWVzdCBwYXJhbXMgcmV0dXJucyBlcnJvciB0aGVuIHNob3cgYW4gZXJyb3IgdG9hc3RlclxuICAgICAgICBpZiAoXy5oYXNJbihyZXF1ZXN0UGFyYW1zLCAnZXJyb3IubWVzc2FnZScpKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRm4oZXJyb3JIYW5kbGVyLCByZXF1ZXN0UGFyYW1zLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlcXVlc3RQYXJhbXMuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlLmh0dHBTZXJ2aWNlLnNlbmQocmVxdWVzdFBhcmFtcykudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgaXNWYWxpZFdlYlVSTChyZXNwb25zZS5ib2R5LnJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHJlc3BvbnNlLmJvZHkucmVzdWx0O1xuICAgICAgICAgICAgICAgIHRyaWdnZXJGbihzdWNjZXNzSGFuZGxlciwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbml0aWF0ZUNhbGxiYWNrKFZBUklBQkxFX0NPTlNUQU5UUy5FVkVOVC5FUlJPUiwgdmFyaWFibGUsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRm4oZXJyb3JIYW5kbGVyLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIChyZXNwb25zZSwgeGhyT2JqKSA9PiB7XG4gICAgICAgICAgICBpbml0aWF0ZUNhbGxiYWNrKFZBUklBQkxFX0NPTlNUQU5UUy5FVkVOVC5FUlJPUiwgdmFyaWFibGUsIHJlc3BvbnNlLCB4aHJPYmopO1xuICAgICAgICAgICAgdHJpZ2dlckZuKGVycm9ySGFuZGxlciwgcmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0SW5wdXRQYXJtcyh2YXJpYWJsZSkge1xuICAgICAgICBsZXQgd21TZXJ2aWNlT3BlcmF0aW9uSW5mbztcbiAgICAgICAgaWYgKCFfLmlzRW1wdHkobWV0YWRhdGFTZXJ2aWNlKSkge1xuICAgICAgICAgICAgd21TZXJ2aWNlT3BlcmF0aW9uSW5mbyA9IF8uZ2V0KG1ldGFkYXRhU2VydmljZS5nZXRCeU9wZXJhdGlvbklkKHZhcmlhYmxlLm9wZXJhdGlvbklkLCB2YXJpYWJsZS5nZXRQcmVmYWJOYW1lKCkpLCAnd21TZXJ2aWNlT3BlcmF0aW9uSW5mbycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd21TZXJ2aWNlT3BlcmF0aW9uSW5mbyA9IHZhcmlhYmxlLnNlcnZpY2VJbmZvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfLmdldCh3bVNlcnZpY2VPcGVyYXRpb25JbmZvLCAncGFyYW1ldGVycycpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXRJbnB1dCh2YXJpYWJsZSwga2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHNldElucHV0KHZhcmlhYmxlLmRhdGFCaW5kaW5nLCBrZXksIHZhbCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhbiBvbiBnb2luZyBzZXJ2aWNlIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gJGZpbGVcbiAgICAgKi9cbiAgICBwdWJsaWMgY2FuY2VsKHZhcmlhYmxlLCAkZmlsZT8pIHtcbiAgICAgICAgLy8gQ0hlY2tzIGlmIHRoZXJlIGlzIGFueSBwZW5kaW5nIHJlcXVlc3RzIGluIHRoZSBxdWV1ZVxuICAgICAgICBpZiAoJHF1ZXVlLnJlcXVlc3RzUXVldWUuaGFzKHZhcmlhYmxlKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3QgaXMgYSBGaWxlIHVwbG9hZCByZXF1ZXN0IHRoZW4gbW9kaWZ5IHRoZSBlbGVtZW50cyBhc3NvY2lhdGVkIHdpdGggZmlsZSB1cGxvYWRcbiAgICAgICAgICAgIC8vIGVsc2UgdW5zdWJzY3JpYmUgZnJvbSB0aGUgb2JzZXJ2YWJsZSBvbiB0aGUgdmFyaWFibGUuXG4gICAgICAgICAgICBpZiAoU2VydmljZVZhcmlhYmxlVXRpbHMuaXNGaWxlVXBsb2FkUmVxdWVzdCh2YXJpYWJsZSkpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZS5odHRwU2VydmljZS5jYW5jZWwodmFyaWFibGUsICRmaWxlKTtcbiAgICAgICAgICAgICAgICAkZmlsZS5zdGF0dXMgPSAnYWJvcnQnO1xuICAgICAgICAgICAgICAgIHRoaXMudG90YWxGaWxlc0NvdW50LS07XG4gICAgICAgICAgICAgICAgaW5pdGlhdGVDYWxsYmFjayhWQVJJQUJMRV9DT05TVEFOVFMuRVZFTlQuQUJPUlQsIHZhcmlhYmxlLCAkZmlsZSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRmlsZVVwbG9hZEluUHJvZ3Jlc3ModmFyaWFibGUuZGF0YUJpbmRpbmcpICYmIHRoaXMudG90YWxGaWxlc0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICRxdWV1ZS5wcm9jZXNzKHZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90aWZ5IGluZmxpZ2h0IHZhcmlhYmxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5SW5mbGlnaHQodmFyaWFibGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZS5odHRwU2VydmljZS5jYW5jZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGUuaHR0cFNlcnZpY2UuY2FuY2VsKHZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgJHF1ZXVlLnByb2Nlc3ModmFyaWFibGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBub3RpZnkgaW5mbGlnaHQgdmFyaWFibGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlJbmZsaWdodCh2YXJpYWJsZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBkZWZpbmVGaXJzdExhc3RSZWNvcmQodmFyaWFibGUpIHtcbiAgICAgICAgaWYgKHZhcmlhYmxlLmlzTGlzdCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhcmlhYmxlLCAnZmlyc3RSZWNvcmQnLCB7XG4gICAgICAgICAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2dldCc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YVNldCA9IHZhcmlhYmxlLmRhdGFTZXQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBwcm9jZWR1cmUodjEpIGRhdGEgZG9lc24ndCBjb21lIHVuZGVyIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uaGVhZChkYXRhU2V0ICYmIGRhdGFTZXQuY29udGVudCkgfHwgXy5oZWFkKGRhdGFTZXQpIHx8IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhcmlhYmxlLCAnbGFzdFJlY29yZCcsIHtcbiAgICAgICAgICAgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZ2V0JzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhU2V0ID0gdmFyaWFibGUuZGF0YVNldDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHByb2NlZHVyZSh2MSkgZGF0YSBkb2Vzbid0IGNvbWUgdW5kZXIgY29udGVudFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5sYXN0KGRhdGFTZXQgJiYgZGF0YVNldC5jb250ZW50KSB8fCBfLmxhc3QoZGF0YVNldCkgfHwge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZXRzIHRoZSBpbnB1dCBwYXJhbXMgb2YgdGhlIHNlcnZpY2UgdmFyaWFibGUgYW5kIGFsc28gYWRkIHBhcmFtcyBmcm9tIHRoZSBzZWFyY2hLZXlzIChmaWx0ZXJmaWVsZHMpXG4gICAgcHJpdmF0ZSBnZXRRdWVyeVBhcmFtcyhmaWx0ZXJGaWVsZHMsIHNlYXJjaFZhbHVlLCB2YXJpYWJsZSkge1xuICAgICAgICBjb25zdCBpbnB1dFBhcmFtcyA9IHRoaXMuZ2V0SW5wdXRQYXJtcyh2YXJpYWJsZSk7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gU2VydmljZVZhcmlhYmxlVXRpbHMuZXhjbHVkZVBhZ2luYXRpb25QYXJhbXMoaW5wdXRQYXJhbXMpO1xuICAgICAgICBjb25zdCBpbnB1dEZpZWxkcyA9IHt9O1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHNvbWUgcGFyYW0gdmFsdWUgaXMgYWxyZWFkeSBhdmFpbGFibGUgaW4gZGF0YWJpbmRpbmcgYW5kIHVwZGF0ZSB0aGUgaW5wdXRGaWVsZHMgYWNjb3JkaW5nbHlcbiAgICAgICAgXy5tYXAodmFyaWFibGUuZGF0YUJpbmRpbmcsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBpbnB1dEZpZWxkc1trZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGFkZCB0aGUgcXVlcnkgcGFyYW1zIG1lbnRpb25lZCBpbiB0aGUgc2VhcmNoa2V5IHRvIGlucHV0RmllbGRzXG4gICAgICAgIF8uZm9yRWFjaChmaWx0ZXJGaWVsZHMsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKF8uaW5jbHVkZXMocXVlcnlQYXJhbXMsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlucHV0RmllbGRzW3ZhbHVlXSA9IHNlYXJjaFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaW5wdXRGaWVsZHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBmaWx0ZXJlZCByZWNvcmRzIGJhc2VkIG9uIHNlYXJjaEtleSBhbmQgcXVlcnlUZXh0LlxuICAgICAqIEBwYXJhbSB2YXJpYWJsZVxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIHN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0gZXJyb3JcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHB1YmxpYyBzZWFyY2hSZWNvcmRzKHZhcmlhYmxlLCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICBjb25zdCBpbnB1dEZpZWxkcyA9IHRoaXMuZ2V0UXVlcnlQYXJhbXMoXy5zcGxpdChvcHRpb25zLnNlYXJjaEtleSwgJywnKSwgb3B0aW9ucy5xdWVyeSwgdmFyaWFibGUpO1xuXG4gICAgICAgIGNvbnN0IHJlcXVlc3RQYXJhbXMgPSB7XG4gICAgICAgICAgICBwYWdlOiBvcHRpb25zLnBhZ2UsXG4gICAgICAgICAgICBwYWdlc2l6ZTogb3B0aW9ucy5wYWdlc2l6ZSxcbiAgICAgICAgICAgIHNraXBEYXRhU2V0VXBkYXRlOiB0cnVlLCAvLyBkb250IHVwZGF0ZSB0aGUgYWN0dWFsIHZhcmlhYmxlIGRhdGFzZXQsXG4gICAgICAgICAgICBza2lwVG9nZ2xlU3RhdGU6IHRydWUsIC8vIERvbnQgY2hhbmdlIHRoZSB2YXJpYmFsZSB0b2dnbGUgc3RhdGUgYXMgdGhpcyBpcyBhIGluZGVwZW5kZW50IGNhbGxcbiAgICAgICAgICAgIGluRmxpZ2h0QmVoYXZpb3I6ICdleGVjdXRlQWxsJyxcbiAgICAgICAgICAgIGlucHV0RmllbGRzOiBpbnB1dEZpZWxkc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChvcHRpb25zLm9uQmVmb3Jlc2VydmljZWNhbGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMub25CZWZvcmVzZXJ2aWNlY2FsbChpbnB1dEZpZWxkcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5pbnZva2UodmFyaWFibGUsIHJlcXVlc3RQYXJhbXMsIHN1Y2Nlc3MsIGVycm9yKS5jYXRjaChub29wKTtcbiAgICB9XG59XG5cbiIsImltcG9ydCB7IEJhc2VBY3Rpb24gfSBmcm9tICcuLi9iYXNlLWFjdGlvbic7XG5pbXBvcnQgeyBWQVJJQUJMRV9DT05TVEFOVFMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvdmFyaWFibGVzLmNvbnN0YW50cyc7XG5pbXBvcnQgeyBWYXJpYWJsZU1hbmFnZXJGYWN0b3J5IH0gZnJvbSAnLi4vLi4vZmFjdG9yeS92YXJpYWJsZS1tYW5hZ2VyLmZhY3RvcnknO1xuXG5jb25zdCAgZ2V0TWFuYWdlciA9ICgpID0+IHtcbiAgICByZXR1cm4gVmFyaWFibGVNYW5hZ2VyRmFjdG9yeS5nZXQoVkFSSUFCTEVfQ09OU1RBTlRTLkNBVEVHT1JZLlRJTUVSKTtcbn07XG5cbmV4cG9ydCBjbGFzcyBUaW1lckFjdGlvbiBleHRlbmRzIEJhc2VBY3Rpb24ge1xuICAgIHByaXZhdGUgY3VycmVudE9wdGlvbnM7XG4gICAgcHJpdmF0ZSByZXBlYXRpbmcgPSBmYWxzZTtcbiAgICBwcml2YXRlIF9pc0ZpcmVkID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3Rvcih2YXJpYWJsZTogYW55KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgdmFyaWFibGUpO1xuICAgIH1cblxuICAgIC8vIEJhY2t3YXJkIGNvbXBhdGlibGUgbWV0aG9kXG4gICAgZmlyZShvcHRpb25zLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICBpZih0aGlzLnJlcGVhdGluZykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICB0aGlzLl9pc0ZpcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0TWFuYWdlcigpLnRyaWdnZXIodGhpcywgb3B0aW9ucywgc3VjY2VzcywgZXJyb3IpO1xuICAgIH1cblxuICAgIGludm9rZShvcHRpb25zLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5maXJlKG9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9XG5cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHJldHVybiBnZXRNYW5hZ2VyKCkuY2FuY2VsKHRoaXMpO1xuICAgIH1cblxuICAgIG11dGUoKSB7XG4gICAgICAgIHN1cGVyLm11dGUoKTtcbiAgICAgICAgaWYodGhpcy5yZXBlYXRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1bm11dGUoKSB7XG4gICAgICAgIHN1cGVyLnVubXV0ZSgpO1xuICAgICAgICBpZih0aGlzLnJlcGVhdGluZyAmJiB0aGlzLl9pc0ZpcmVkKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUodGhpcy5jdXJyZW50T3B0aW9ucywgbnVsbCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBEYXRhU291cmNlIH0gZnJvbSBcIi4uL3R5cGVzL3R5cGVzXCI7XG5pbXBvcnQgRGF0YXNldFV0aWwgZnJvbSAnLi4vdXRpbC9kYXRhc2V0LXV0aWwnO1xuaW1wb3J0IHtnZXRUYXJnZXQsIGdldFRhcmdldE5vZGVLZXksIGdldFRhcmdldE9iaiwgc2V0VmFsdWVUb05vZGV9IGZyb20gXCIuLi91dGlsL3ZhcmlhYmxlL3ZhcmlhYmxlcy51dGlsc1wiO1xuaW1wb3J0IHtnZXRDbG9uZWRPYmplY3R9IGZyb20gXCIuLi91dGlsL3V0aWxzXCI7XG5cbmRlY2xhcmUgY29uc3QgXztcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlQWN0aW9uIHtcblxuICAgIHByb3RlY3RlZCBfaWQ6IHN0cmluZztcblxuICAgIG5hbWU6IHN0cmluZztcbiAgICBvd25lcjogc3RyaW5nO1xuICAgIGNhdGVnb3J5OiBzdHJpbmc7XG4gICAgZGF0YVNldDogYW55O1xuICAgIGRhdGFCaW5kaW5nOiBhbnk7XG4gICAgX2NvbnRleHQ6IGFueTtcbiAgICBpc011dGVkID0gZmFsc2U7XG5cbiAgICBleGVjdXRlKG9wZXJhdGlvbiwgb3B0aW9ucykge1xuICAgICAgICBsZXQgcmV0dXJuVmFsO1xuICAgICAgICBzd2l0Y2ggKG9wZXJhdGlvbikge1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5HRVRfTkFNRTpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLm5hbWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGFTb3VyY2UuT3BlcmF0aW9uLkdFVF9VTklRVUVfSURFTlRJRklFUjpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLl9pZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uR0VUX0NPTlRFWFRfSURFTlRJRklFUjpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR1cm5WYWw7XG4gICAgfVxuXG4gICAgaW52b2tlT25QYXJhbUNoYW5nZShvYmosIG5ld1ZhbCwgb2xkVmFsKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG9iai50YXJnZXQsXG4gICAgICAgICAgICByb290ID0gZ2V0VGFyZ2V0KHRoaXMpLFxuICAgICAgICAgICAgdGFyZ2V0T2JqID0gZ2V0VGFyZ2V0T2JqKG9iaiwgcm9vdCwgdGhpcyksXG4gICAgICAgICAgICB0YXJnZXROb2RlS2V5ID0gZ2V0VGFyZ2V0Tm9kZUtleSh0YXJnZXQpO1xuICAgICAgICBpZiAoKG5ld1ZhbCA9PT0gb2xkVmFsICYmIF8uaXNVbmRlZmluZWQobmV3VmFsKSkgfHwgKF8uaXNVbmRlZmluZWQobmV3VmFsKSAmJiAoIV8uaXNVbmRlZmluZWQob2xkVmFsKSB8fCAhXy5pc1VuZGVmaW5lZCh0YXJnZXRPYmpbdGFyZ2V0Tm9kZUtleV0pKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTa2lwIGNsb25pbmcgZm9yIGJsb2IgY29sdW1uXG4gICAgICAgIGlmICghXy5pbmNsdWRlcyhbJ2Jsb2InLCAnZmlsZSddLCBvYmoudHlwZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbCA9IGdldENsb25lZE9iamVjdChuZXdWYWwpO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlVG9Ob2RlKHRhcmdldCwgb2JqLCByb290LCB0aGlzLCBuZXdWYWwpOyAvLyBjbG9uaW5nIG5ld1ZhbCB0byBrZWVwIHRoZSBzb3VyY2UgY2xlYW5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzKTtcbiAgICB9XG5cbiAgICBnZXREYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU2V0O1xuICAgIH1cblxuICAgIHNldERhdGEoZGF0YVNldDogYW55KSB7XG4gICAgICAgIGlmIChEYXRhc2V0VXRpbC5pc1ZhbGlkRGF0YXNldChkYXRhU2V0KSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhU2V0ID0gZGF0YVNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU2V0O1xuICAgIH1cblxuICAgIGdldFZhbHVlKGtleTogc3RyaW5nLCBpbmRleDogbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBEYXRhc2V0VXRpbC5nZXRWYWx1ZSh0aGlzLmRhdGFTZXQsIGtleSwgaW5kZXgpO1xuICAgIH1cblxuICAgIHNldFZhbHVlKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSB7XG4gICAgICAgIHJldHVybiBEYXRhc2V0VXRpbC5zZXRWYWx1ZSh0aGlzLmRhdGFTZXQsIGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGdldEl0ZW0oaW5kZXg6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gRGF0YXNldFV0aWwuZ2V0SXRlbSh0aGlzLmRhdGFTZXQsIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCwgYSBudW1iZXIgaW4gaWRlYWwgY2FzZVxuICAgICAqICAgICAgICBpdCBjYW4gYmUgdGhlIG9iamVjdCB0byBiZSByZXBsYWNlZCBieSB0aGUgcGFzc2VkIHZhbHVlXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnMge2FueX1cbiAgICAgKi9cbiAgICBzZXRJdGVtKGluZGV4OiBhbnksIHZhbHVlOiBhbnkpIHtcbiAgICAgICAgcmV0dXJuIERhdGFzZXRVdGlsLnNldEl0ZW0odGhpcy5kYXRhU2V0LCBpbmRleCwgdmFsdWUpO1xuICAgIH1cblxuICAgIGFkZEl0ZW0odmFsdWU6IGFueSwgaW5kZXg6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gRGF0YXNldFV0aWwuYWRkSXRlbSh0aGlzLmRhdGFTZXQsIHZhbHVlLCBpbmRleCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlSXRlbShpbmRleDogYW55LCBleGFjdE1hdGNoOiBib29sZWFuKSB7XG4gICAgICAgIHJldHVybiBEYXRhc2V0VXRpbC5yZW1vdmVJdGVtKHRoaXMuZGF0YVNldCwgaW5kZXgsIGV4YWN0TWF0Y2gpO1xuICAgIH1cblxuICAgIGNsZWFyRGF0YSgpIHtcbiAgICAgICAgdGhpcy5kYXRhU2V0ID0gRGF0YXNldFV0aWwuZ2V0VmFsaWREYXRhc2V0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTZXQ7XG4gICAgfVxuXG4gICAgZ2V0Q291bnQoKSB7XG4gICAgICAgIHJldHVybiBEYXRhc2V0VXRpbC5nZXRDb3VudCh0aGlzLmRhdGFTZXQpO1xuICAgIH1cblxuICAgIGluaXQoKSB7XG4gICAgfVxuXG4gICAgbXV0ZSgpIHtcbiAgICAgICAgdGhpcy5pc011dGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB1bm11dGUoKSB7XG4gICAgICAgIHRoaXMuaXNNdXRlZCA9IGZhbHNlO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IERhdGFTb3VyY2UgfSBmcm9tICcuLi90eXBlcy90eXBlcyc7XG5cbmltcG9ydCBEYXRhc2V0VXRpbCBmcm9tICcuLi91dGlsL2RhdGFzZXQtdXRpbCc7XG5pbXBvcnQge1xuICAgIGdldFRhcmdldE5vZGVLZXksXG4gICAgZ2V0VGFyZ2V0T2JqLFxuICAgIGdldFRhcmdldCxcbiAgICBzZXRWYWx1ZVRvTm9kZSxcbiAgICBpbnRlcm5hbEJvdW5kTm9kZU1hcCxcbiAgICB1cGRhdGVJbnRlcm5hbE5vZGVzXG59IGZyb20gXCIuLi91dGlsL3ZhcmlhYmxlL3ZhcmlhYmxlcy51dGlsc1wiO1xuaW1wb3J0IHtnZXRDbG9uZWRPYmplY3R9IGZyb20gXCIuLi91dGlsL3V0aWxzXCI7XG5pbXBvcnQgeyBFdmVudE5vdGlmaWVyLCBEZWZhdWx0RXZlbnROb3RpZmllciB9IGZyb20gXCIuLi90eXBlcy9ldmVudC1ub3RpZmllclwiO1xuZGVjbGFyZSBjb25zdCBfOiBhbnk7XG5leHBvcnQgZW51bSBWYXJpYWJsZUV2ZW50cyB7XG4gICAgQkVGT1JFX0lOVk9LRSA9ICdiZWZvcmVJbnZva2UnLFxuICAgIEFGVEVSX0lOVk9LRSA9ICdhZnRlckludm9rZSdcbn07XG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVZhcmlhYmxlIGltcGxlbWVudHMgRXZlbnROb3RpZmllciB7XG5cbiAgICBwcm90ZWN0ZWQgX2lkOiBzdHJpbmc7XG5cbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgb3duZXI6IHN0cmluZztcbiAgICBjYXRlZ29yeTogc3RyaW5nO1xuICAgIGlzTGlzdDogYm9vbGVhbjtcbiAgICBkYXRhU2V0OiBhbnk7XG4gICAgZGF0YUJpbmRpbmc6IGFueTtcbiAgICBfY29udGV4dDogYW55O1xuICAgIGlzTXV0ZWQgPSBmYWxzZTtcbiAgICBwYXJhbXM7XG4gICAgcGFyYW1Qcm92aWRlcjtcbiAgICBwcml2YXRlIGV2ZW50Tm90aWZpZXIgPSBuZXcgRGVmYXVsdEV2ZW50Tm90aWZpZXIoKTtcblxuICAgIG5vdGlmeSAoZXZlbnQ6IHN0cmluZywgYXJnczogYW55W10pIHtcbiAgICAgICAgdGhpcy5ldmVudE5vdGlmaWVyLm5vdGlmeShldmVudCwgYXJncyk7XG4gICAgfVxuXG4gICAgc3Vic2NyaWJlIChldmVudDogc3RyaW5nLCBmbjogRnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnROb3RpZmllci5zdWJzY3JpYmUoZXZlbnQsIGZuKTtcbiAgICB9XG5cbiAgICBleGVjdXRlKG9wZXJhdGlvbjogYW55LCBvcHRpb25zOiBhbnkpIHtcbiAgICAgICAgbGV0IHJldHVyblZhbDtcbiAgICAgICAgc3dpdGNoIChvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uR0VUX05BTUU6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gdGhpcy5uYW1lO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5HRVRfVU5JUVVFX0lERU5USUZJRVI6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gdGhpcy5faWQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGFTb3VyY2UuT3BlcmF0aW9uLkdFVF9DT05URVhUX0lERU5USUZJRVI6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uQUREX0lURU06XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gdGhpcy5hZGRJdGVtKG9wdGlvbnMuaXRlbSwgXy5vbWl0KG9wdGlvbnMsICdpdGVtJykpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5TRVRfSVRFTTpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLnNldEl0ZW0ob3B0aW9ucy5wcmV2SXRlbSwgb3B0aW9ucy5pdGVtLCAgXy5vbWl0KG9wdGlvbnMsICdwcmV2SXRlbScsICdpdGVtJykpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5SRU1PVkVfSVRFTTpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLnJlbW92ZUl0ZW0ob3B0aW9ucy5pdGVtLCBfLm9taXQob3B0aW9ucywgJ2l0ZW0nKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbDtcbiAgICB9XG5cbiAgICBpbnZva2VPblBhcmFtQ2hhbmdlKG9iaj8sIG5ld1ZhbD8sIG9sZFZhbD8pIHtcbiAgICAgICAgY29uc3QgcnVuTW9kZSA9IHRydWU7XG4gICAgICAgIGlmKCFvYmopIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSBvYmo/LnRhcmdldCxcbiAgICAgICAgICAgICAgICByb290ID0gZ2V0VGFyZ2V0KHRoaXMpLFxuICAgICAgICAgICAgdGFyZ2V0T2JqID0gZ2V0VGFyZ2V0T2JqKG9iaiwgcm9vdCwgdGhpcyksXG4gICAgICAgICAgICB0YXJnZXROb2RlS2V5ID0gZ2V0VGFyZ2V0Tm9kZUtleSh0YXJnZXQpO1xuICAgICAgICBpZiAoKG5ld1ZhbCA9PT0gb2xkVmFsICYmIF8uaXNVbmRlZmluZWQobmV3VmFsKSkgfHwgKF8uaXNVbmRlZmluZWQobmV3VmFsKSAmJiAoIV8uaXNVbmRlZmluZWQob2xkVmFsKSB8fCAhXy5pc1VuZGVmaW5lZCh0YXJnZXRPYmpbdGFyZ2V0Tm9kZUtleV0pKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTa2lwIGNsb25pbmcgZm9yIGJsb2IgY29sdW1uXG4gICAgICAgIGlmICghXy5pbmNsdWRlcyhbJ2Jsb2InLCAnZmlsZSddLCBvYmoudHlwZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbCA9IGdldENsb25lZE9iamVjdChuZXdWYWwpO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlVG9Ob2RlKHRhcmdldCwgb2JqLCByb290LCB0aGlzLCBuZXdWYWwpOyAvLyBjbG9uaW5nIG5ld1ZhbCB0byBrZWVwIHRoZSBzb3VyY2UgY2xlYW5cbiAgICAgICAgaWYgKHJ1bk1vZGUpIHtcbiAgICAgICAgICAgIC8qc2V0IHRoZSBpbnRlcm5hbCBib3VuZCBub2RlIG1hcCB3aXRoIHRoZSBsYXRlc3QgdXBkYXRlZCB2YWx1ZSovXG4gICAgICAgICAgICBpZiAoIWludGVybmFsQm91bmROb2RlTWFwLmhhcyh0aGlzKSkge1xuICAgICAgICAgICAgICAgIGludGVybmFsQm91bmROb2RlTWFwLnNldCh0aGlzLCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfLnNldChpbnRlcm5hbEJvdW5kTm9kZU1hcC5nZXQodGhpcyksIFt0aGlzLm5hbWUsIHJvb3QsIHRhcmdldF0sIG5ld1ZhbCk7XG4gICAgICAgICAgICAvKnVwZGF0ZSB0aGUgaW50ZXJuYWwgbm9kZXMgYWZ0ZXIgaW50ZXJuYWwgbm9kZSBtYXAgaXMgc2V0Ki9cbiAgICAgICAgICAgIGlmIChfLmlzT2JqZWN0KG5ld1ZhbCkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVJbnRlcm5hbE5vZGVzKHRhcmdldCwgcm9vdCwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzKTtcbiAgICB9XG5cbiAgICBnZXREYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU2V0O1xuICAgIH1cblxuICAgIHNldERhdGEoZGF0YVNldDogYW55KSB7XG4gICAgICAgIGlmIChEYXRhc2V0VXRpbC5pc1ZhbGlkRGF0YXNldChkYXRhU2V0LCB0aGlzLmlzTGlzdCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNldCA9IGRhdGFTZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNldDtcbiAgICB9XG5cbiAgICBnZXRWYWx1ZShrZXk6IHN0cmluZywgaW5kZXg6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gRGF0YXNldFV0aWwuZ2V0VmFsdWUodGhpcy5kYXRhU2V0LCBrZXksIGluZGV4LCB0aGlzLmlzTGlzdCk7XG4gICAgfVxuXG4gICAgc2V0VmFsdWUoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgICAgICAgcmV0dXJuIERhdGFzZXRVdGlsLnNldFZhbHVlKHRoaXMuZGF0YVNldCwga2V5LCB2YWx1ZSwgdGhpcy5pc0xpc3QpO1xuICAgIH1cblxuICAgIGdldEl0ZW0oaW5kZXg6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gRGF0YXNldFV0aWwuZ2V0SXRlbSh0aGlzLmRhdGFTZXQsIGluZGV4LCB0aGlzLmlzTGlzdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXgsIGEgbnVtYmVyIGluIGlkZWFsIGNhc2VcbiAgICAgKiAgICAgICAgaXQgY2FuIGJlIHRoZSBvYmplY3QgdG8gYmUgcmVwbGFjZWQgYnkgdGhlIHBhc3NlZCB2YWx1ZVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHthbnl9XG4gICAgICovXG4gICAgc2V0SXRlbShpbmRleDogYW55LCB2YWx1ZTogYW55LCBvcHRpb25zPzogYW55KSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLmdldENoaWxkRGV0YWlscyhvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIERhdGFzZXRVdGlsLnNldEl0ZW0odGhpcy5kYXRhU2V0LCBpbmRleCwgdmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRvIGdldCB0YXJnZXQgbm9kZSBvcHRpb25zIGxpa2UgcGF0aCwgcGFyZW50SW5kZXggYW5kIGlzTGlzdFxuICAgICAqIEBwYXJhbSBvcHRpb25zOiBwcm92aWRlZCBvcHRpb25zXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKiBFeGFtcGxlOiBpZiB3ZSBoYXZlIHBhcmVudCBkYXRhc2V0IGFzIG9iamVjdCBhbmQgd2UgYXJlIHBlcmZvcm1pbmcgb3BlcmF0aW9ucyBvbiBpbm5lciBsaXN0IHRoZW4gd2UgaGF2ZSB0byBzZXQgaXNMaXN0IGFzIHRydWUuXG4gICAgICogU28gZmluZGluZyB0aGUgdGFyZ2V0IG5vZGUgdHlwZSBhbmQgdXBkYXRpbmcgdGhlIGlzTGlzdCBvcHRpb24uXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRDaGlsZERldGFpbHMgKG9wdGlvbnM6IGFueSkge1xuICAgICAgICBsZXQgcGFyZW50SW5kZXgsIGlzTGlzdCA9IHRoaXMuaXNMaXN0LCBwYXRoO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnBhdGgpIHtcbiAgICAgICAgICAgIHBhdGggPSBvcHRpb25zLnBhdGg7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0Tm9kZTtcbiAgICAgICAgICAgIGlmIChpc0xpc3QpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRJbmRleCA9IG9wdGlvbnMucGFyZW50SW5kZXggfHwgMDtcbiAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gIF8uZ2V0KHRoaXMuZGF0YVNldFtwYXJlbnRJbmRleF0sIG9wdGlvbnMucGF0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBfLmdldCh0aGlzLmRhdGFTZXQsIG9wdGlvbnMucGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc0xpc3QgPSB0YXJnZXROb2RlID8gXy5pc0FycmF5KHRhcmdldE5vZGUpID8gdHJ1ZSA6IGZhbHNlIDogdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge3BhdGgsIGlzTGlzdCwgcGFyZW50SW5kZXh9O1xuICAgIH1cblxuICAgIGFkZEl0ZW0odmFsdWU6IGFueSwgb3B0aW9ucz86IGFueSkge1xuICAgICAgICBsZXQgaW5kZXg7XG4gICAgICAgIGlmIChfLmlzTnVtYmVyKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBpbmRleCA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF8uaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgICAgIGluZGV4ID0gb3B0aW9ucy5pbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLmdldENoaWxkRGV0YWlscyhvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIERhdGFzZXRVdGlsLmFkZEl0ZW0odGhpcy5kYXRhU2V0LCB2YWx1ZSwgaW5kZXgsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJlbW92ZUl0ZW0oaW5kZXg6IGFueSwgb3B0aW9ucz86IGFueSkge1xuICAgICAgICBsZXQgZXhhY3RNYXRjaCwgcGFyZW50SW5kZXg7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoXy5pc0Jvb2xlYW4ob3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBleGFjdE1hdGNoID0gb3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfLmlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgZXhhY3RNYXRjaCA9IG9wdGlvbnMuZXhhY3RNYXRjaDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0xpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SW5kZXggPSBvcHRpb25zLnBhcmVudEluZGV4IHx8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEYXRhc2V0VXRpbC5yZW1vdmVJdGVtKHRoaXMuZGF0YVNldCwgaW5kZXgsIHsgZXhhY3RNYXRjaCwgcGF0aDogXy5nZXQob3B0aW9ucywgJ3BhdGgnKSwgcGFyZW50SW5kZXggfSk7XG4gICAgfVxuXG4gICAgY2xlYXJEYXRhKCkge1xuICAgICAgICB0aGlzLmRhdGFTZXQgPSBEYXRhc2V0VXRpbC5nZXRWYWxpZERhdGFzZXQodGhpcy5pc0xpc3QpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU2V0O1xuICAgIH1cblxuICAgIGdldENvdW50KCkge1xuICAgICAgICByZXR1cm4gRGF0YXNldFV0aWwuZ2V0Q291bnQodGhpcy5kYXRhU2V0LCB0aGlzLmlzTGlzdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBwcmVmYWIgbmFtZSBpZiB0aGUgdmFyaWFibGUgaXMgZm9ybSBhIHByZWZhYlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0UHJlZmFiTmFtZSgpIHtcbiAgICAgICAgY29uc3QgcHJlZmFibmFtZSA9IHRoaXMuX2NvbnRleHQgJiYgKHRoaXMuX2NvbnRleHQucHJlZmFibmFtZSB8fCB0aGlzLl9jb250ZXh0LnByZWZhYk5hbWUpO1xuICAgICAgICAvLyBfX3NlbGZfXyBpcyBhIHByZWZhYiBuYW1lIGdpdmVuIHRvIGEgcHJlZmFiIHdoaWNoIGlzIHJ1biBpbiBwcmV2aWV3IG1vZGVcbiAgICAgICAgcmV0dXJuIHByZWZhYm5hbWUgIT09ICdfX3NlbGZfXycgJiYgcHJlZmFibmFtZTtcbiAgICB9XG5cbiAgICBtdXRlKCkge1xuICAgICAgICB0aGlzLmlzTXV0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHVubXV0ZSgpIHtcbiAgICAgICAgdGhpcy5pc011dGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgXG4gICAgfVxufVxuIiwiaW1wb3J0IHtDcnVkVmFyaWFibGV9IGZyb20gJy4vdmFyaWFibGUvY3J1ZC12YXJpYWJsZSc7XG5cbmV4cG9ydCBjbGFzcyBDUlVEQ3JlYXRlIHtcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHZhcmlhYmxlOiBDcnVkVmFyaWFibGUsIHByaXZhdGUgbWFuYWdlcikge1xuICAgIH1cbiAgICBzZXRJbnB1dChrZXksIHZhbD8sIG9wdGlvbnM/KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuc2V0SW5wdXQodGhpcy52YXJpYWJsZSwga2V5LCB2YWwsIG9wdGlvbnMsICdjcmVhdGUnKTtcbiAgICB9XG4gICAgaW52b2tlKG9wdGlvbnM/LCBzdWNjZXNzPywgZXJyb3I/KSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBvcHRpb25zLm9wZXJhdGlvbiA9ICdjcmVhdGUnO1xuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmludm9rZSh0aGlzLnZhcmlhYmxlLCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfVxufVxuIiwiaW1wb3J0IHtDcnVkVmFyaWFibGV9IGZyb20gJy4vdmFyaWFibGUvY3J1ZC12YXJpYWJsZSc7XG5cbmV4cG9ydCBjbGFzcyBDUlVERGVsZXRlIHtcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHZhcmlhYmxlOiBDcnVkVmFyaWFibGUsIHByaXZhdGUgbWFuYWdlcikge1xuICAgIH1cbiAgICBzZXRJbnB1dChrZXksIHZhbD8sIG9wdGlvbnM/KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuc2V0SW5wdXQodGhpcy52YXJpYWJsZSwga2V5LCB2YWwsIG9wdGlvbnMsICdkZWxldGUnKTtcbiAgICB9XG4gICAgaW52b2tlKG9wdGlvbnM/LCBzdWNjZXNzPywgZXJyb3I/KSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBvcHRpb25zLm9wZXJhdGlvbiA9ICdkZWxldGUnO1xuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmludm9rZSh0aGlzLnZhcmlhYmxlLCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfVxufVxuIiwiaW1wb3J0IHtDcnVkVmFyaWFibGV9IGZyb20gJy4vdmFyaWFibGUvY3J1ZC12YXJpYWJsZSc7XG5cbmV4cG9ydCBjbGFzcyBDUlVETGlzdCB7XG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSB2YXJpYWJsZTogQ3J1ZFZhcmlhYmxlLCBwcml2YXRlIG1hbmFnZXIpIHtcbiAgICB9XG4gICAgc2V0SW5wdXQoa2V5LCB2YWw/LCBvcHRpb25zPykge1xuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLnNldElucHV0KHRoaXMudmFyaWFibGUsIGtleSwgdmFsLCBvcHRpb25zLCAnbGlzdCcpO1xuICAgIH1cbiAgICBpbnZva2Uob3B0aW9ucz8sIHN1Y2Nlc3M/LCBlcnJvcj8pIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIG9wdGlvbnMub3BlcmF0aW9uID0gJ2xpc3QnO1xuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmludm9rZSh0aGlzLnZhcmlhYmxlLCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfVxufVxuIiwiaW1wb3J0IHtDcnVkVmFyaWFibGV9IGZyb20gJy4vdmFyaWFibGUvY3J1ZC12YXJpYWJsZSc7XG5cbmV4cG9ydCBjbGFzcyBDUlVEVXBkYXRlIHtcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHZhcmlhYmxlOiBDcnVkVmFyaWFibGUsIHByaXZhdGUgbWFuYWdlcikge1xuICAgIH1cbiAgICBzZXRJbnB1dChrZXksIHZhbD8sIG9wdGlvbnM/KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuc2V0SW5wdXQodGhpcy52YXJpYWJsZSwga2V5LCB2YWwsIG9wdGlvbnMsICd1cGRhdGUnKTtcbiAgICB9XG4gICAgaW52b2tlKG9wdGlvbnM/LCBzdWNjZXNzPywgZXJyb3I/KSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBvcHRpb25zLm9wZXJhdGlvbiA9ICd1cGRhdGUnO1xuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmludm9rZSh0aGlzLnZhcmlhYmxlLCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQmFzZVZhcmlhYmxlIH0gZnJvbSAnLi4vYmFzZS12YXJpYWJsZSc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBcGlBd2FyZVZhcmlhYmxlIGV4dGVuZHMgQmFzZVZhcmlhYmxlIHtcblxuICAgIHNlcnZpY2U6IHN0cmluZztcbiAgICBvcGVyYXRpb246IHN0cmluZztcbiAgICBjb250cm9sbGVyOiBzdHJpbmc7XG4gICAgb3BlcmF0aW9uSWQ6IHN0cmluZztcbiAgICBvcGVyYXRpb25UeXBlOiBzdHJpbmc7XG4gICAgc2VydmljZVR5cGU6IHN0cmluZztcbiAgICBtYXhSZXN1bHRzOiBudW1iZXI7XG4gICAgc3RhcnRVcGRhdGU6IGJvb2xlYW47XG4gICAgYXV0b1VwZGF0ZTogYm9vbGVhbjtcbiAgICBpbkZsaWdodEJlaGF2aW9yOiBib29sZWFuO1xuICAgIHRyYW5zZm9ybWF0aW9uUmVxdWlyZWQ6IGJvb2xlYW47XG4gICAgY2FuVXBkYXRlOiBib29sZWFuO1xuICAgIHBhZ2luYXRpb25UcmFuc2Zvcm1hdGlvblJlcXVpcmVkOiBib29sZWFuO1xuXG4gICAgZmlyc3RSZWNvcmQ6IGFueTtcbiAgICBsYXN0UmVjb3JkOiBhbnk7XG5cbiAgICBvbkJlZm9yZVVwZGF0ZTogc3RyaW5nO1xuICAgIG9uUmVzdWx0OiBzdHJpbmc7XG4gICAgb25FcnJvcjogc3RyaW5nO1xuICAgIG9uQmVmb3JlRGF0YXNldFJlYWR5OiBzdHJpbmc7XG4gICAgb25TdWNjZXNzOiBzdHJpbmc7XG59XG4iLCJpbXBvcnQgeyBpc0RlZmluZWQgfSBmcm9tIFwiLi4vLi4vdXRpbC91dGlsc1wiO1xuaW1wb3J0IHsgRGF0YVNvdXJjZSwgSURhdGFTb3VyY2UgfSBmcm9tIFwiLi4vLi4vdHlwZXMvdHlwZXNcIjtcbmltcG9ydCB7IFZhcmlhYmxlTWFuYWdlckZhY3RvcnkgfSBmcm9tICcuLi8uLi9mYWN0b3J5L3ZhcmlhYmxlLW1hbmFnZXIuZmFjdG9yeSc7XG5pbXBvcnQgeyBBcGlBd2FyZVZhcmlhYmxlIH0gZnJvbSAnLi9hcGktYXdhcmUtdmFyaWFibGUnO1xuaW1wb3J0IHsgVkFSSUFCTEVfQ09OU1RBTlRTIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL3ZhcmlhYmxlcy5jb25zdGFudHMnO1xuaW1wb3J0IHsgQ3J1ZFZhcmlhYmxlTWFuYWdlciB9IGZyb20gJy4uLy4uL21hbmFnZXIvdmFyaWFibGUvY3J1ZC12YXJpYWJsZS5tYW5hZ2VyJztcbmltcG9ydCB7IFNlcnZpY2VWYXJpYWJsZVV0aWxzIH0gZnJvbSAnLi4vLi4vdXRpbC92YXJpYWJsZS9zZXJ2aWNlLXZhcmlhYmxlLnV0aWxzJztcbmltcG9ydCB7Q1JVRExpc3R9IGZyb20gJy4uL2NydWQtbGlzdCc7XG5pbXBvcnQge0NSVURDcmVhdGV9IGZyb20gJy4uL2NydWQtY3JlYXRlJztcbmltcG9ydCB7Q1JVRFVwZGF0ZX0gZnJvbSAnLi4vY3J1ZC11cGRhdGUnO1xuaW1wb3J0IHtDUlVERGVsZXRlfSBmcm9tICcuLi9jcnVkLWRlbGV0ZSc7XG5cbmRlY2xhcmUgY29uc3QgXztcblxuY29uc3QgZ2V0TWFuYWdlciA9ICgpOiBDcnVkVmFyaWFibGVNYW5hZ2VyID0+IHtcbiAgICByZXR1cm4gVmFyaWFibGVNYW5hZ2VyRmFjdG9yeS5nZXQoVkFSSUFCTEVfQ09OU1RBTlRTLkNBVEVHT1JZLkNSVUQpO1xufTtcblxuZXhwb3J0IGNsYXNzIENydWRWYXJpYWJsZSBleHRlbmRzIEFwaUF3YXJlVmFyaWFibGUgaW1wbGVtZW50cyBJRGF0YVNvdXJjZSB7XG5cbiAgICAvLyBVc2VkIHRvIHRyYWNrIHByb2dyZXNzIG9mIGZpbGUgdXBsb2FkXG4gICAgX3Byb2dyZXNzT2JzZXJ2YWJsZTtcbiAgICAvLyBVc2VkIHRvIHRyYWNrIGEgdmFyaWFibGUgaHR0cCBjYWxsLCBzbyB0aGF0IGl0IGNhbiBiZSBjYW5jZWxsZWQgYXQgYW55IHBvaW50IG9mIHRpbWUgZHVyaW5nIGl0cyBleGVjdXRpb25cbiAgICBfb2JzZXJ2YWJsZTtcbiAgICBwYWdpbmF0aW9uO1xuICAgIGxpc3Q7XG4gICAgY3JlYXRlO1xuICAgIHVwZGF0ZTtcbiAgICBkZWxldGU7XG4gICAgc2ltdWxhdGVGaWxlRG93bmxvYWQ7XG4gICAgc2VydmljZUluZm87XG4gICAgaHR0cFNlcnZpY2U7XG5cbiAgICBjb25zdHJ1Y3Rvcih2YXJpYWJsZTogYW55KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcyBhcyBhbnksIHZhcmlhYmxlKTtcbiAgICAgICAgLy8gZm9yIGhhdmluZyBzZXBhcmF0ZSBzZXRJbnB1dCBtZXRob2RzIGZvciBlYWNoIHR5cGVcbiAgICAgICAgdGhpcy5saXN0ICAgPSBuZXcgQ1JVRExpc3QodGhpcywgZ2V0TWFuYWdlcigpKTtcbiAgICAgICAgdGhpcy5jcmVhdGUgPSBuZXcgQ1JVRENyZWF0ZSh0aGlzLCBnZXRNYW5hZ2VyKCkpO1xuICAgICAgICB0aGlzLnVwZGF0ZSA9IG5ldyBDUlVEVXBkYXRlKHRoaXMsIGdldE1hbmFnZXIoKSk7XG4gICAgICAgIHRoaXMuZGVsZXRlID0gbmV3IENSVUREZWxldGUodGhpcywgZ2V0TWFuYWdlcigpKTtcbiAgICB9XG5cblxuICAgIGV4ZWN1dGUob3BlcmF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCByZXR1cm5WYWwgPSBzdXBlci5leGVjdXRlKG9wZXJhdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChpc0RlZmluZWQocmV0dXJuVmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAob3BlcmF0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIERhdGFTb3VyY2UuT3BlcmF0aW9uLklTX0FQSV9BV0FSRTpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5TVVBQT1JUU19DUlVEOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5TVVBQT1JUU19ESVNUSU5DVF9BUEk6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGFTb3VyY2UuT3BlcmF0aW9uLklTX1BBR0VBQkxFOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IHRoaXMuaGFzUGFnaW5hdGlvbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5JU19TT1JUQUJMRTpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLmhhc1BhZ2luYXRpb24oKSAmJiAhKHRoaXMgYXMgYW55KS5fcGFnaW5hdGlvbkNvbmZpZztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uU1VQUE9SVFNfU0VSVkVSX0ZJTFRFUjpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uU0VUX0lOUFVUOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IHRoaXMuc2V0SW5wdXQob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGFTb3VyY2UuT3BlcmF0aW9uLkxJU1RfUkVDT1JEUzpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLmludm9rZShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uSU5WT0tFIDpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLmludm9rZShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uVVBEQVRFIDpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLmludm9rZShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uU0VBUkNIX1JFQ09SRFM6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gdGhpcy5zZWFyY2hSZWNvcmRzKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5ET1dOTE9BRDpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLmRvd25sb2FkKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5HRVRfUEFHSU5HX09QVElPTlM6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gdGhpcy5wYWdpbmF0aW9uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5JU19VUERBVEVfUkVRVUlSRUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gdGhpcy5pc1VwZGF0ZVJlcXVpcmVkKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5JU19CT1VORF9UT19MT0NBTEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGFTb3VyY2UuT3BlcmF0aW9uLkNBTkNFTDpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLmNhbmNlbChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uSU5TRVJUX1JFQ09SRCA6XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vcGVyYXRpb24gPSAnY3JlYXRlJztcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLmludm9rZShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uVVBEQVRFX1JFQ09SRCA6XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vcGVyYXRpb24gPSAndXBkYXRlJztcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLmludm9rZShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uREVMRVRFX1JFQ09SRCA6XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vcGVyYXRpb24gPSAnZGVsZXRlJztcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLmludm9rZShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uU0VUX1BBR0lOQVRJT046XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gdGhpcy5zZXRQYWdpbmF0aW9uKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0ge307XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbDtcbiAgICB9XG5cbiAgICBoYXNQYWdpbmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sbGVyID09PSBWQVJJQUJMRV9DT05TVEFOVFMuQ09OVFJPTExFUl9UWVBFLlFVRVJZIHx8ICFfLmlzRW1wdHkodGhpcy5wYWdpbmF0aW9uKTtcbiAgICB9XG5cbiAgICBpbnZva2Uob3B0aW9ucz8sIHN1Y2Nlc3M/LCBlcnJvcj8pIHtcbiAgICAgICAgcmV0dXJuIGdldE1hbmFnZXIoKS5pbnZva2UodGhpcywgb3B0aW9ucywgc3VjY2VzcywgZXJyb3IpO1xuICAgIH1cblxuICAgIGNyZWF0ZVJlY29yZChvcHRpb25zPywgc3VjY2Vzcz8sIGVycm9yPykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy5vcGVyYXRpb24gPSAnY3JlYXRlJztcbiAgICAgICAgcmV0dXJuIGdldE1hbmFnZXIoKS5pbnZva2UodGhpcywgb3B0aW9ucywgc3VjY2VzcywgZXJyb3IpO1xuICAgIH1cblxuICAgIGxpc3RSZWNvcmRzKG9wdGlvbnM/LCBzdWNjZXNzPywgZXJyb3I/KSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBvcHRpb25zLm9wZXJhdGlvbiA9ICdsaXN0JztcbiAgICAgICAgcmV0dXJuIGdldE1hbmFnZXIoKS5pbnZva2UodGhpcywgb3B0aW9ucywgc3VjY2VzcywgZXJyb3IpO1xuICAgIH1cblxuICAgIHVwZGF0ZVJlY29yZChvcHRpb25zPywgc3VjY2Vzcz8sIGVycm9yPykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy5vcGVyYXRpb24gPSAndXBkYXRlJztcbiAgICAgICAgcmV0dXJuIGdldE1hbmFnZXIoKS5pbnZva2UodGhpcywgb3B0aW9ucywgc3VjY2VzcywgZXJyb3IpO1xuICAgIH1cblxuICAgIGRlbGV0ZVJlY29yZChvcHRpb25zPywgc3VjY2Vzcz8sIGVycm9yPykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy5vcGVyYXRpb24gPSAnZGVsZXRlJztcbiAgICAgICAgcmV0dXJuIGdldE1hbmFnZXIoKS5pbnZva2UodGhpcywgb3B0aW9ucywgc3VjY2VzcywgZXJyb3IpO1xuICAgIH1cblxuICAgIGRvd25sb2FkKG9wdGlvbnMsIHN1Y2Nlc3M/LCBlcnJvcj8pIHtcbiAgICAgICAgcmV0dXJuIGdldE1hbmFnZXIoKS5kb3dubG9hZCh0aGlzLCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfVxuXG4gICAgc2V0SW5wdXQoa2V5LCB2YWw/LCBvcHRpb25zPykge1xuICAgICAgICByZXR1cm4gZ2V0TWFuYWdlcigpLnNldElucHV0KHRoaXMsIGtleSwgdmFsLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBzZWFyY2hSZWNvcmRzKG9wdGlvbnMsIHN1Y2Nlc3M/LCBlcnJvcj8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGdldE1hbmFnZXIoKS5zZWFyY2hSZWNvcmRzKHRoaXMsIG9wdGlvbnMsIChyZXNwb25zZSwgcGFnaW5hdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoe2RhdGE6IHJlc3BvbnNlLmNvbnRlbnQgfHwgcmVzcG9uc2UsIHBhZ2luYXRpb259KTtcbiAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlzVXBkYXRlUmVxdWlyZWQoaGFzRGF0YSkge1xuICAgICAgICBjb25zdCBpbnB1dEZpZWxkcyA9IGdldE1hbmFnZXIoKS5nZXRJbnB1dFBhcm1zKHRoaXMpO1xuICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IFNlcnZpY2VWYXJpYWJsZVV0aWxzLmV4Y2x1ZGVQYWdpbmF0aW9uUGFyYW1zKGlucHV0RmllbGRzKTtcblxuICAgICAgICBpZiAoIXF1ZXJ5UGFyYW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgcXVlcnkgcGFyYW1zIGFuZCB2YXJpYWJsZSBkYXRhIGlzIGF2YWlsYWJsZSB0aGVuIHdlIGRvbid0IG5lZWQgdmFyaWFibGUgdXBkYXRlLCBzbyByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIGlmIChoYXNEYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY2FuY2VsKG9wdGlvbnM/KSB7XG4gICAgICAgIHJldHVybiBnZXRNYW5hZ2VyKCkuY2FuY2VsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHNldFBhZ2luYXRpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZ2V0TWFuYWdlcigpLnNldFBhZ2luYXRpb24odGhpcywgZGF0YSk7XG4gICAgfVxuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgZ2V0TWFuYWdlcigpLmluaXRCaW5kaW5nKHRoaXMpO1xuICAgICAgICBnZXRNYW5hZ2VyKCkuZGVmaW5lRmlyc3RMYXN0UmVjb3JkKHRoaXMpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGlzRGVmaW5lZCwgZ2V0Q2xvbmVkT2JqZWN0IH0gZnJvbSBcIi4uLy4uL3V0aWwvdXRpbHNcIjtcbmltcG9ydCB7IERhdGFTb3VyY2UsIElEYXRhU291cmNlIH0gZnJvbSBcIi4uLy4uL3R5cGVzL3R5cGVzXCI7XG5cbmltcG9ydCB7IFZhcmlhYmxlTWFuYWdlckZhY3RvcnkgfSBmcm9tICcuLi8uLi9mYWN0b3J5L3ZhcmlhYmxlLW1hbmFnZXIuZmFjdG9yeSc7XG5pbXBvcnQgeyBBcGlBd2FyZVZhcmlhYmxlIH0gZnJvbSAnLi9hcGktYXdhcmUtdmFyaWFibGUnO1xuaW1wb3J0IHsgVkFSSUFCTEVfQ09OU1RBTlRTIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL3ZhcmlhYmxlcy5jb25zdGFudHMnO1xuaW1wb3J0IHsgTGl2ZVZhcmlhYmxlTWFuYWdlciB9IGZyb20gJy4uLy4uL21hbmFnZXIvdmFyaWFibGUvbGl2ZS12YXJpYWJsZS5tYW5hZ2VyJztcbmltcG9ydCB7ZGVib3VuY2VWYXJpYWJsZUNhbGx9IGZyb20gXCIuLi8uLi91dGlsL3ZhcmlhYmxlL3ZhcmlhYmxlcy51dGlsc1wiO1xuZGVjbGFyZSBjb25zdCBfO1xuY29uc3QgZ2V0TWFuYWdlciA9ICgpOiBMaXZlVmFyaWFibGVNYW5hZ2VyID0+IHtcbiAgICByZXR1cm4gVmFyaWFibGVNYW5hZ2VyRmFjdG9yeS5nZXQoVkFSSUFCTEVfQ09OU1RBTlRTLkNBVEVHT1JZLkxJVkUpO1xufTtcblxuZXhwb3J0IGNsYXNzIExpdmVWYXJpYWJsZSBleHRlbmRzIEFwaUF3YXJlVmFyaWFibGUgaW1wbGVtZW50cyBJRGF0YVNvdXJjZSB7XG5cbiAgICBtYXRjaE1vZGU7XG4gICAgbGl2ZVNvdXJjZTtcbiAgICBwcm9wZXJ0aWVzTWFwO1xuICAgIHBhZ2luYXRpb247XG4gICAgdHlwZTtcbiAgICBvcmRlckJ5O1xuICAgIF9vcHRpb25zO1xuICAgIC8vIFVzZWQgdG8gdHJhY2sgYSB2YXJpYWJsZSBodHRwIGNhbGwsIHNvIHRoYXQgaXQgY2FuIGJlIGNhbmNlbGxlZCBhdCBhbnkgcG9pbnQgb2YgdGltZSBkdXJpbmcgaXRzIGV4ZWN1dGlvblxuICAgIF9vYnNlcnZhYmxlO1xuICAgIGZpbHRlckV4cHJlc3Npb25zO1xuXG4gICAgY29uc3RydWN0b3IodmFyaWFibGU6IGFueSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMgYXMgYW55LCB2YXJpYWJsZSk7XG4gICAgfVxuXG4gICAgZXhlY3V0ZShvcGVyYXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHJldHVyblZhbCA9IHN1cGVyLmV4ZWN1dGUob3BlcmF0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKGlzRGVmaW5lZChyZXR1cm5WYWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uSVNfQVBJX0FXQVJFOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGFTb3VyY2UuT3BlcmF0aW9uLlNVUFBPUlRTX0NSVUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uU1VQUE9SVFNfRElTVElOQ1RfQVBJOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGFTb3VyY2UuT3BlcmF0aW9uLklTX1BBR0VBQkxFOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGFTb3VyY2UuT3BlcmF0aW9uLklTX1NPUlRBQkxFOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGFTb3VyY2UuT3BlcmF0aW9uLlNVUFBPUlRTX1NFUlZFUl9GSUxURVI6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uR0VUX09QRVJBVElPTl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IHRoaXMub3BlcmF0aW9uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5HRVRfUkVMQVRFRF9QUklNQVJZX0tFWVM6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gdGhpcy5nZXRSZWxhdGVkVGFibGVQcmltYXJ5S2V5cyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uR0VUX0VOVElUWV9OQU1FOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IHRoaXMucHJvcGVydGllc01hcC5lbnRpdHlOYW1lO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5MSVNUX1JFQ09SRFM6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gdGhpcy5saXN0UmVjb3JkcyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uVVBEQVRFX1JFQ09SRCA6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gdGhpcy51cGRhdGVSZWNvcmQob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGFTb3VyY2UuT3BlcmF0aW9uLklOU0VSVF9SRUNPUkQgOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IHRoaXMuaW5zZXJ0UmVjb3JkKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5ERUxFVEVfUkVDT1JEIDpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLmRlbGV0ZVJlY29yZChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uSU5WT0tFIDpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLmludm9rZShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uVVBEQVRFIDpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLnVwZGF0ZShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uR0VUX1JFTEFURURfVEFCTEVfREFUQTpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLmdldFJlbGF0ZWRUYWJsZURhdGEob3B0aW9ucy5yZWxhdGVkRmllbGQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5HRVRfRElTVElOQ1RfREFUQV9CWV9GSUVMRFM6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gdGhpcy5nZXREaXN0aW5jdERhdGFCeUZpZWxkcyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uR0VUX0FHR1JFR0FURURfREFUQTpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLmdldEFnZ3JlZ2F0ZWREYXRhKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5HRVRfTUFUQ0hfTU9ERTpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLm1hdGNoTW9kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uRE9XTkxPQUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gdGhpcy5kb3dubG9hZChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uR0VUX1BST1BFUlRJRVNfTUFQOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IHRoaXMucHJvcGVydGllc01hcDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uR0VUX1BSSU1BUllfS0VZOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IHRoaXMuZ2V0UHJpbWFyeUtleSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5HRVRfQkxPQl9VUkw6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gYHNlcnZpY2VzLyR7dGhpcy5saXZlU291cmNlfS8ke3RoaXMudHlwZX0vJHtvcHRpb25zLnByaW1hcnlWYWx1ZX0vY29udGVudC8ke29wdGlvbnMuY29sdW1uTmFtZX1gO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5HRVRfT1BUSU9OUzpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLl9vcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5TRUFSQ0hfUkVDT1JEUzpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLnNlYXJjaFJlY29yZHMob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGFTb3VyY2UuT3BlcmF0aW9uLkdFVF9SRVFVRVNUX1BBUkFNUzpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLmdldFJlcXVlc3RQYXJhbXMob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGFTb3VyY2UuT3BlcmF0aW9uLkdFVF9QQUdJTkdfT1BUSU9OUzpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLnBhZ2luYXRpb247XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGFTb3VyY2UuT3BlcmF0aW9uLklTX1VQREFURV9SRVFVSVJFRDpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5JU19CT1VORF9UT19MT0NBTEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGFTb3VyY2UuT3BlcmF0aW9uLkNBTkNFTDpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0ge307XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbDtcbiAgICB9XG5cbiAgICBsaXN0UmVjb3JkcyhvcHRpb25zPywgc3VjY2Vzcz8sIGVycm9yPykge1xuICAgICAgICByZXR1cm4gZ2V0TWFuYWdlcigpLmxpc3RSZWNvcmRzKHRoaXMsIG9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9XG5cbiAgICB1cGRhdGVSZWNvcmQob3B0aW9ucz8sIHN1Y2Nlc3M/LCBlcnJvcj8pIHtcbiAgICAgICAgcmV0dXJuIGdldE1hbmFnZXIoKS51cGRhdGVSZWNvcmQodGhpcywgb3B0aW9ucywgc3VjY2VzcywgZXJyb3IpO1xuICAgIH1cblxuICAgIGluc2VydFJlY29yZChvcHRpb25zPywgc3VjY2Vzcz8sIGVycm9yPykge1xuICAgICAgICByZXR1cm4gZ2V0TWFuYWdlcigpLmluc2VydFJlY29yZCh0aGlzLCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfVxuXG4gICAgZGVsZXRlUmVjb3JkKG9wdGlvbnM/LCBzdWNjZXNzPywgZXJyb3I/KSB7XG4gICAgICAgIHJldHVybiBnZXRNYW5hZ2VyKCkuZGVsZXRlUmVjb3JkKHRoaXMsIG9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9XG5cbiAgICBzZXRJbnB1dChrZXksIHZhbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZ2V0TWFuYWdlcigpLnNldElucHV0KHRoaXMsIGtleSwgdmFsLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBzZXRGaWx0ZXIoa2V5LCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIGdldE1hbmFnZXIoKS5zZXRGaWx0ZXIodGhpcywga2V5LCB2YWwpO1xuICAgIH1cblxuICAgIGRvd25sb2FkKG9wdGlvbnMsIHN1Y2Nlc3M/LCBlcnJvcj8pIHtcbiAgICAgICAgcmV0dXJuIGdldE1hbmFnZXIoKS5kb3dubG9hZCh0aGlzLCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfVxuXG4gICAgaW52b2tlKG9wdGlvbnM/LCBzdWNjZXNzPywgZXJyb3I/KSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5vcGVyYXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2luc2VydCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0UmVjb3JkKG9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlUmVjb3JkKG9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlUmVjb3JkKG9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdFJlY29yZHMob3B0aW9ucywgc3VjY2VzcywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0UmVsYXRlZFRhYmxlUHJpbWFyeUtleXMoY29sdW1uTmFtZSkge1xuICAgICAgICByZXR1cm4gZ2V0TWFuYWdlcigpLmdldFJlbGF0ZWRUYWJsZVByaW1hcnlLZXlzKHRoaXMsIGNvbHVtbk5hbWUpO1xuICAgIH1cblxuICAgIGdldFJlbGF0ZWRUYWJsZURhdGEoY29sdW1uTmFtZSwgb3B0aW9ucywgc3VjY2Vzcz8sIGVycm9yPykge1xuICAgICAgICByZXR1cm4gZ2V0TWFuYWdlcigpLmdldFJlbGF0ZWRUYWJsZURhdGEodGhpcywgY29sdW1uTmFtZSwgb3B0aW9ucywgc3VjY2VzcywgZXJyb3IpO1xuICAgIH1cblxuICAgIGdldERpc3RpbmN0RGF0YUJ5RmllbGRzKG9wdGlvbnMsIHN1Y2Nlc3M/LCBlcnJvcj8pIHtcbiAgICAgICAgcmV0dXJuIGdldE1hbmFnZXIoKS5nZXREaXN0aW5jdERhdGFCeUZpZWxkcyh0aGlzLCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfVxuXG4gICAgZ2V0QWdncmVnYXRlZERhdGEob3B0aW9ucywgc3VjY2Vzcz8sIGVycm9yPykge1xuICAgICAgICByZXR1cm4gZ2V0TWFuYWdlcigpLmdldEFnZ3JlZ2F0ZWREYXRhKHRoaXMsIG9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9XG5cbiAgICBnZXRQcmltYXJ5S2V5KCkge1xuICAgICAgICByZXR1cm4gZ2V0TWFuYWdlcigpLmdldFByaW1hcnlLZXkodGhpcyk7XG4gICAgfVxuXG4gICAgc2VhcmNoUmVjb3JkcyhvcHRpb25zLCBzdWNjZXNzPywgZXJyb3I/KSB7XG4gICAgICAgIHJldHVybiBnZXRNYW5hZ2VyKCkuc2VhcmNoUmVjb3Jkcyh0aGlzLCBvcHRpb25zLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfVxuXG4gICAgZ2V0UmVxdWVzdFBhcmFtcyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBnZXRNYW5hZ2VyKCkucHJlcGFyZVJlcXVlc3RQYXJhbXMob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgX2Rvd25ncmFkZUlucHV0RGF0YShkYXRhKSB7XG4gICAgICAgIHJldHVybiBnZXRNYW5hZ2VyKCkuZG93bmdyYWRlRmlsdGVyRXhwcmVzc2lvbnNUb0lucHV0RGF0YSh0aGlzLCBkYXRhKTtcbiAgICB9XG5cbiAgICBfdXBncmFkZUlucHV0RGF0YShyZXNwb25zZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gZ2V0TWFuYWdlcigpLnVwZ3JhZGVJbnB1dERhdGFUb0ZpbHRlckV4cHJlc3Npb25zKHRoaXMsIHJlc3BvbnNlLCBkYXRhKTtcbiAgICB9XG5cbiAgICBzZXRPcmRlckJ5KGV4cHJlc3Npb24pIHtcbiAgICAgICAgdGhpcy5vcmRlckJ5ID0gZXhwcmVzc2lvbjtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JkZXJCeTtcbiAgICB9XG5cbiAgICAvLyBsZWdhY3kgbWV0aG9kXG4gICAgdXBkYXRlKG9wdGlvbnM/LCBzdWNjZXNzPywgZXJyb3I/KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludm9rZShvcHRpb25zLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfVxuXG4gICAgY3JlYXRlUmVjb3JkKG9wdGlvbnM/LCBzdWNjZXNzPywgZXJyb3I/KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydFJlY29yZChvcHRpb25zLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfVxuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgZ2V0TWFuYWdlcigpLmluaXRCaW5kaW5nKHRoaXMsICdkYXRhQmluZGluZycsIHRoaXMub3BlcmF0aW9uID09PSAncmVhZCcgPyAnZmlsdGVyRmllbGRzJyA6ICdpbnB1dEZpZWxkcycpO1xuICAgICAgICBpZiAodGhpcy5vcGVyYXRpb24gPT09ICdyZWFkJykge1xuICAgICAgICAgICAgZ2V0TWFuYWdlcigpLmluaXRGaWx0ZXJFeHByZXNzaW9uQmluZGluZyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRNYW5hZ2VyKCkuZGVmaW5lRmlyc3RMYXN0UmVjb3JkKHRoaXMpO1xuICAgIH1cblxuICAgIGludm9rZU9uRmlsdGVydEV4cHJlc3Npb25DaGFuZ2Uob2JqLCB0YXJnZXROb2RlS2V5LCBuZXdWYWwsIG9sZFZhbCkge1xuICAgICAgICBjb25zb2xlLmxvZygnZmlsdGVyIGV4cHIgY2hhbmdlZCcsIG5ld1ZhbCwgb2xkVmFsKTtcbiAgICAgICAgICAgIGlmICgobmV3VmFsID09PSBvbGRWYWwgJiYgXy5pc1VuZGVmaW5lZChuZXdWYWwpKSB8fCAoXy5pc1VuZGVmaW5lZChuZXdWYWwpICYmICFfLmlzVW5kZWZpbmVkKG9sZFZhbCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2tpcCBjbG9uaW5nIGZvciBibG9iIGNvbHVtblxuICAgICAgICAgICAgaWYgKCFfLmluY2x1ZGVzKFsnYmxvYicsICdmaWxlJ10sIG9iai50eXBlKSkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbCA9IGdldENsb25lZE9iamVjdChuZXdWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eTogd2hlcmUgd2UgYXJlIGFsbG93aW5nIHRoZSB1c2VyIHRvIGJpbmQgY29tcGxldGUgb2JqZWN0XG4gICAgICAgICAgICBpZiAob2JqLnRhcmdldCA9PT0gJ2RhdGFCaW5kaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgZXhpc3RpbmcgZGF0YWJpbmRpbmcgZWxlbWVudFxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyRXhwcmVzc2lvbnMucnVsZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAvLyBub3cgYWRkIGFsbCB0aGUgcmV0dXJuZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKG5ld1ZhbCwgZnVuY3Rpb24gKHZhbHVlLCB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJFeHByZXNzaW9ucy5ydWxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0YXJnZXQnOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXRjaE1vZGUnOiBvYmoubWF0Y2hNb2RlIHx8ICdzdGFydGlnbm9yZWNhc2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlcXVpcmVkJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICcnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzZXR0aW5nIHZhbHVlIHRvIHRoZSByb290IG5vZGVcbiAgICAgICAgICAgICAgICBvYmpbdGFyZ2V0Tm9kZUtleV0gPSBuZXdWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wZXJhdGlvbiA9PT0gJ3JlYWQnKSB7XG4gICAgICAgICAgICAvKiBpZiBhdXRvLXVwZGF0ZSBzZXQgZm9yIHRoZSB2YXJpYWJsZSB3aXRoIHJlYWQgb3BlcmF0aW9uIG9ubHksIGdldCBpdHMgZGF0YSAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b1VwZGF0ZSAmJiAhXy5pc1VuZGVmaW5lZChuZXdWYWwpICYmIF8uaXNGdW5jdGlvbih0aGlzLnVwZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBkZWJvdW5jZVZhcmlhYmxlQ2FsbCh0aGlzLCAndXBkYXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBpZiBhdXRvLXVwZGF0ZSBzZXQgZm9yIHRoZSB2YXJpYWJsZSB3aXRoIHJlYWQgb3BlcmF0aW9uIG9ubHksIGdldCBpdHMgZGF0YSAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b1VwZGF0ZSAmJiAhXy5pc1VuZGVmaW5lZChuZXdWYWwpICYmIF8uaXNGdW5jdGlvbih0aGlzW3RoaXMub3BlcmF0aW9uICsgJ1JlY29yZCddKSkge1xuICAgICAgICAgICAgICAgIGRlYm91bmNlVmFyaWFibGVDYWxsKHRoaXMsIHRoaXMub3BlcmF0aW9uICsgJ1JlY29yZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGlzLmludm9rZSgpO1xuICAgIH1cblxuICAgIGNhbmNlbChvcHRpb25zPykge1xuICAgICAgICByZXR1cm4gZ2V0TWFuYWdlcigpLmNhbmNlbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBEYXRhU291cmNlLCBJRGF0YVNvdXJjZSB9IGZyb20gJy4uLy4uL3R5cGVzL3R5cGVzJztcbmltcG9ydCB7IGlzRGVmaW5lZCB9IGZyb20gXCIuLi8uLi91dGlsL3V0aWxzXCI7XG5cbmltcG9ydCB7IFZhcmlhYmxlTWFuYWdlckZhY3RvcnkgfSBmcm9tICcuLi8uLi9mYWN0b3J5L3ZhcmlhYmxlLW1hbmFnZXIuZmFjdG9yeSc7XG5pbXBvcnQgeyBCYXNlVmFyaWFibGUgfSBmcm9tICcuLi9iYXNlLXZhcmlhYmxlJztcbmltcG9ydCB7IFZBUklBQkxFX0NPTlNUQU5UUyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy92YXJpYWJsZXMuY29uc3RhbnRzJztcbmltcG9ydCB7IGFwcE1hbmFnZXIgfSBmcm9tICcuLi8uLi91dGlsL3ZhcmlhYmxlL3ZhcmlhYmxlcy51dGlscyc7XG5cbmNvbnN0IGdldE1hbmFnZXIgPSAoKSA9PiB7XG4gICAgcmV0dXJuIFZhcmlhYmxlTWFuYWdlckZhY3RvcnkuZ2V0KFZBUklBQkxFX0NPTlNUQU5UUy5DQVRFR09SWS5NT0RFTCk7XG59O1xuXG5leHBvcnQgY2xhc3MgTW9kZWxWYXJpYWJsZSBleHRlbmRzIEJhc2VWYXJpYWJsZSBpbXBsZW1lbnRzIElEYXRhU291cmNlIHtcblxuICAgIHR5cGU6IGFueTtcbiAgICBzYXZlSW5QaG9uZWdhcDogYW55O1xuXG4gICAgY29uc3RydWN0b3IodmFyaWFibGU6IGFueSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMgYXMgYW55LCB2YXJpYWJsZSk7XG4gICAgfVxuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMaXN0KSB7XG4gICAgICAgICAgICBnZXRNYW5hZ2VyKCkucmVtb3ZlRmlyc3RFbXB0eU9iamVjdCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldE1hbmFnZXIoKS5pbml0QmluZGluZyh0aGlzLCAnZGF0YUJpbmRpbmcnLCAnZGF0YVNldCcpO1xuICAgIH1cblxuICAgIGV4ZWN1dGUob3BlcmF0aW9uOiBhbnksIG9wdGlvbnM6IGFueSkge1xuICAgICAgICBsZXQgcmV0dXJuVmFsID0gc3VwZXIuZXhlY3V0ZShvcGVyYXRpb24sIG9wdGlvbnMpO1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHJldHVyblZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWw7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKG9wZXJhdGlvbikge1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5JU19BUElfQVdBUkU6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGFTb3VyY2UuT3BlcmF0aW9uLlNVUFBPUlRTX0NSVUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGFTb3VyY2UuT3BlcmF0aW9uLlNVUFBPUlRTX0RJU1RJTkNUX0FQSTpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uSVNfUEFHRUFCTEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGFTb3VyY2UuT3BlcmF0aW9uLklTX1NPUlRBQkxFOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5TVVBQT1JUU19TRVJWRVJfRklMVEVSOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5JU19CT1VORF9UT19MT0NBTEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gdGhpcy5pc0JvdW5kVG9Mb2NhbGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uR0VUX0RFRkFVTFRfTE9DQUxFOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IHRoaXMuZ2V0RGVmYXVsdExvY2FsZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB7fTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsO1xuICAgIH1cblxuICAgIGlzQm91bmRUb0xvY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSA9PT0gJ3N1cHBvcnRlZExvY2FsZSc7XG4gICAgfVxuXG4gICAgZ2V0RGVmYXVsdExvY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIGFwcE1hbmFnZXIuZ2V0U2VsZWN0ZWRMb2NhbGUoKTtcbiAgICB9XG5cbn1cbiIsImltcG9ydCB7IGlzRGVmaW5lZCB9IGZyb20gXCIuLi8uLi91dGlsL3V0aWxzXCI7XG5pbXBvcnQgeyBEYXRhU291cmNlLCBJRGF0YVNvdXJjZSB9IGZyb20gXCIuLi8uLi90eXBlcy90eXBlc1wiO1xuXG5pbXBvcnQgeyBWYXJpYWJsZU1hbmFnZXJGYWN0b3J5IH0gZnJvbSAnLi4vLi4vZmFjdG9yeS92YXJpYWJsZS1tYW5hZ2VyLmZhY3RvcnknO1xuaW1wb3J0IHsgQXBpQXdhcmVWYXJpYWJsZSB9IGZyb20gJy4vYXBpLWF3YXJlLXZhcmlhYmxlJztcbmltcG9ydCB7IFZBUklBQkxFX0NPTlNUQU5UUyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy92YXJpYWJsZXMuY29uc3RhbnRzJztcbmltcG9ydCB7IFNlcnZpY2VWYXJpYWJsZU1hbmFnZXIgfSBmcm9tICcuLi8uLi9tYW5hZ2VyL3ZhcmlhYmxlL3NlcnZpY2UtdmFyaWFibGUubWFuYWdlcic7XG5pbXBvcnQgeyBTZXJ2aWNlVmFyaWFibGVVdGlscyB9IGZyb20gJy4uLy4uL3V0aWwvdmFyaWFibGUvc2VydmljZS12YXJpYWJsZS51dGlscyc7XG5pbXBvcnQge0h0dHBDbGllbnRTZXJ2aWNlfSBmcm9tIFwiLi4vLi4vdHlwZXMvaHR0cC1jbGllbnQuc2VydmljZVwiO1xuXG5kZWNsYXJlIGNvbnN0IF86IGFueTtcblxuY29uc3QgZ2V0TWFuYWdlciA9ICgpOiBTZXJ2aWNlVmFyaWFibGVNYW5hZ2VyID0+IHtcbiAgICByZXR1cm4gVmFyaWFibGVNYW5hZ2VyRmFjdG9yeS5nZXQoVkFSSUFCTEVfQ09OU1RBTlRTLkNBVEVHT1JZLlNFUlZJQ0UpO1xufTtcblxuXG5leHBvcnQgaW50ZXJmYWNlIFNWQ29uZmlnIHtcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgZGF0YVNldDogYW55LFxuICAgIGlzTGlzdDogYm9vbGVhbixcbiAgICBzZXJ2aWNlOiBzdHJpbmcsXG4gICAgb3BlcmF0aW9uOiBzdHJpbmcsXG4gICAgb3BlcmF0aW9uSWQ6IHN0cmluZyxcbiAgICBkYXRhQmluZGluZzogYW55O1xuICAgIHNlcnZpY2VJbmZvPzogYW55LFxuICAgIGh0dHBDbGllbnRTZXJ2aWNlOiBIdHRwQ2xpZW50U2VydmljZVxufVxuXG5leHBvcnQgY2xhc3MgU2VydmljZVZhcmlhYmxlIGV4dGVuZHMgQXBpQXdhcmVWYXJpYWJsZSBpbXBsZW1lbnRzIElEYXRhU291cmNlIHtcblxuICAgIC8vIFVzZWQgdG8gdHJhY2sgcHJvZ3Jlc3Mgb2YgZmlsZSB1cGxvYWRcbiAgICBfcHJvZ3Jlc3NPYnNlcnZhYmxlO1xuICAgIC8vIFVzZWQgdG8gdHJhY2sgYSB2YXJpYWJsZSBodHRwIGNhbGwsIHNvIHRoYXQgaXQgY2FuIGJlIGNhbmNlbGxlZCBhdCBhbnkgcG9pbnQgb2YgdGltZSBkdXJpbmcgaXRzIGV4ZWN1dGlvblxuICAgIF9vYnNlcnZhYmxlO1xuICAgIHBhZ2luYXRpb247XG4gICAgc2ltdWxhdGVGaWxlRG93bmxvYWQ7XG4gICAgc2VydmljZUluZm87XG4gICAgaHR0cFNlcnZpY2U7XG5cbiAgICBjb25zdHJ1Y3Rvcih2YXJpYWJsZTogU1ZDb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzIGFzIGFueSwgdmFyaWFibGUpO1xuICAgICAgICB0aGlzLnNlcnZpY2VJbmZvID0gdmFyaWFibGUuc2VydmljZUluZm87XG4gICAgICAgIHRoaXMuaHR0cFNlcnZpY2UgPSB2YXJpYWJsZS5odHRwQ2xpZW50U2VydmljZTtcbiAgICB9XG5cbiAgICBleGVjdXRlKG9wZXJhdGlvbiwgb3B0aW9ucykge1xuICAgICAgICBsZXQgcmV0dXJuVmFsID0gc3VwZXIuZXhlY3V0ZShvcGVyYXRpb24sIG9wdGlvbnMpO1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHJldHVyblZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWw7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKG9wZXJhdGlvbikge1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5JU19BUElfQVdBUkU6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uU1VQUE9SVFNfQ1JVRDpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uU1VQUE9SVFNfRElTVElOQ1RfQVBJOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5JU19QQUdFQUJMRTpcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgYm90aCBjbGllbnQgYW5kIHNlcnZlciBzaWRlIHBhZ2luYXRpb24gZXhpc3RlbmNlXG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gdGhpcy5oYXNQYWdpbmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGFTb3VyY2UuT3BlcmF0aW9uLklTX1NPUlRBQkxFOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IHRoaXMuaGFzUGFnaW5hdGlvbigpICYmICEodGhpcyBhcyBhbnkpLl9wYWdpbmF0aW9uQ29uZmlnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5TVVBQT1JUU19TRVJWRVJfRklMVEVSOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5TRVRfSU5QVVQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gdGhpcy5zZXRJbnB1dChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uTElTVF9SRUNPUkRTOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IHRoaXMuaW52b2tlKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5JTlZPS0UgOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IHRoaXMuaW52b2tlKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5VUERBVEUgOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IHRoaXMudXBkYXRlKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5TRUFSQ0hfUkVDT1JEUzpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLnNlYXJjaFJlY29yZHMob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGFTb3VyY2UuT3BlcmF0aW9uLkRPV05MT0FEOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IHRoaXMuZG93bmxvYWQob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGFTb3VyY2UuT3BlcmF0aW9uLkdFVF9QQUdJTkdfT1BUSU9OUzpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLnBhZ2luYXRpb247XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGFTb3VyY2UuT3BlcmF0aW9uLklTX1VQREFURV9SRVFVSVJFRDpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLmlzVXBkYXRlUmVxdWlyZWQob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERhdGFTb3VyY2UuT3BlcmF0aW9uLklTX0JPVU5EX1RPX0xPQ0FMRTpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGF0YVNvdXJjZS5PcGVyYXRpb24uQ0FOQ0VMOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbCA9IHRoaXMuY2FuY2VsKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEYXRhU291cmNlLk9wZXJhdGlvbi5TRVRfUEFHSU5BVElPTjpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB0aGlzLnNldFBhZ2luYXRpb24ob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSB7fTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsO1xuICAgIH1cblxuICAgIGhhc1BhZ2luYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXIgPT09IFZBUklBQkxFX0NPTlNUQU5UUy5DT05UUk9MTEVSX1RZUEUuUVVFUlkgfHwgIV8uaXNFbXB0eSh0aGlzLnBhZ2luYXRpb24pO1xuICAgIH1cblxuICAgIGludm9rZShvcHRpb25zPywgc3VjY2Vzcz8sIGVycm9yPykge1xuICAgICAgICAvLyByZXR1cm4gdGhpcy5pbnZva2VWYXIoKTtcbiAgICAgICAgcmV0dXJuIGdldE1hbmFnZXIoKS5pbnZva2UodGhpcywgb3B0aW9ucywgc3VjY2VzcywgZXJyb3IpO1xuICAgIH1cblxuICAgIHVwZGF0ZShvcHRpb25zLCBzdWNjZXNzPywgZXJyb3I/KSB7XG4gICAgICAgIHJldHVybiBnZXRNYW5hZ2VyKCkuaW52b2tlKHRoaXMsIG9wdGlvbnMsIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9XG5cbiAgICBkb3dubG9hZChvcHRpb25zLCBzdWNjZXNzPywgZXJyb3I/KSB7XG4gICAgICAgIHJldHVybiBnZXRNYW5hZ2VyKCkuZG93bmxvYWQodGhpcywgb3B0aW9ucywgc3VjY2VzcywgZXJyb3IpO1xuICAgIH1cblxuICAgIHNldElucHV0KGtleSwgdmFsPywgb3B0aW9ucz8pIHtcbiAgICAgICAgcmV0dXJuIGdldE1hbmFnZXIoKS5zZXRJbnB1dCh0aGlzLCBrZXksIHZhbCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgc2VhcmNoUmVjb3JkcyhvcHRpb25zLCBzdWNjZXNzPywgZXJyb3I/KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBnZXRNYW5hZ2VyKCkuc2VhcmNoUmVjb3Jkcyh0aGlzLCBvcHRpb25zLCAocmVzcG9uc2UsIHBhZ2luYXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHtkYXRhOiByZXNwb25zZS5jb250ZW50IHx8IHJlc3BvbnNlLCBwYWdpbmF0aW9ufSk7XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpc1VwZGF0ZVJlcXVpcmVkKGhhc0RhdGEpIHtcbiAgICAgICAgY29uc3QgaW5wdXRGaWVsZHMgPSBnZXRNYW5hZ2VyKCkuZ2V0SW5wdXRQYXJtcyh0aGlzKTtcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSBTZXJ2aWNlVmFyaWFibGVVdGlscy5leGNsdWRlUGFnaW5hdGlvblBhcmFtcyhpbnB1dEZpZWxkcyk7XG5cbiAgICAgICAgaWYgKCFxdWVyeVBhcmFtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgYW55IHF1ZXJ5IHBhcmFtcyBhbmQgdmFyaWFibGUgZGF0YSBpcyBhdmFpbGFibGUgdGhlbiB3ZSBkb24ndCBuZWVkIHZhcmlhYmxlIHVwZGF0ZSwgc28gcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICBpZiAoaGFzRGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHNldFBhZ2luYXRpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZ2V0TWFuYWdlcigpLnNldFBhZ2luYXRpb24odGhpcywgZGF0YSk7XG4gICAgfVxuXG4gICAgY2FuY2VsKG9wdGlvbnM/KSB7XG4gICAgICAgIHJldHVybiBnZXRNYW5hZ2VyKCkuY2FuY2VsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGluaXQoKSB7XG4gICAgICAgIGdldE1hbmFnZXIoKS5pbml0QmluZGluZyh0aGlzKTtcbiAgICAgICAgZ2V0TWFuYWdlcigpLmRlZmluZUZpcnN0TGFzdFJlY29yZCh0aGlzKTtcbiAgICB9XG59XG4iLCJleHBvcnQgY2xhc3MgRGVmYXVsdEV2ZW50Tm90aWZpZXIgaW1wbGVtZW50cyBFdmVudE5vdGlmaWVyIHtcbiAgICBwcml2YXRlIGxpc3RlbmVycyA9IHt9IGFzIGFueTtcblxuICAgIHB1YmxpYyBub3RpZnkoZXZlbnQ6IHN0cmluZywgYXJnczogYW55W10pIHtcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnRdLmZvckVhY2goKGw6IEZ1bmN0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgbCAmJiBsLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgc3Vic2NyaWJlKGV2ZW50OiBzdHJpbmcsIGZuOiBGdW5jdGlvbikge1xuICAgICAgICB0aGlzLmxpc3RlbmVyc1tldmVudF0gPSB0aGlzLmxpc3RlbmVyc1tldmVudF0gfHwgW107XG4gICAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50XS5wdXNoKGZuKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICAgICAgY29uc3QgaSA9IGV2ZW50TGlzdGVuZXJzLmZpbmRJbmRleCgoZm5pOiBGdW5jdGlvbikgPT4gZm5pID09PSBmbik7XG4gICAgICAgICAgICBldmVudExpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50Tm90aWZpZXIge1xuICAgIG5vdGlmeTogKGV2ZW50OiBzdHJpbmcsIGFyZ3M6IGFueVtdKSA9PiB2b2lkO1xuICAgIHN1YnNjcmliZTogKGV2ZW50OiBzdHJpbmcsIGZuOiBGdW5jdGlvbikgPT4gRnVuY3Rpb247XG59IiwiZXhwb3J0IGludGVyZmFjZSBIdHRwQ2xpZW50U2VydmljZSB7XG4gICAgc2VuZDogKG9wdGlvbnMsIHZhcmlhYmxlKSA9PiB2b2lkO1xuICAgIHNlbmRDYWxsQXNPYnNlcnZhYmxlPzogKG9wdGlvbnMpID0+IHZvaWQ7XG4gICAgZ2V0TG9jYWxlPzogKCkgPT4gdm9pZDtcbiAgICBzZW5kQ2FsbDogIChvcHRpb25zLCB2YXJpYWJsZSkgPT4gdm9pZDtcbiAgICBjYW5jZWw6ICh2YXJpYWJsZSwgJGZpbGU/KSA9PiB2b2lkO1xuICAgIHVwbG9hZEZpbGU6ICh1cmw6IGFueSwgZGF0YTogYW55LCB2YXJpYWJsZTogYW55LCBvcHRpb25zPzogYW55KSA9PiB2b2lkO1xufVxuIiwiZXhwb3J0IGNsYXNzIElEYXRhU291cmNlIHtcbiAgICBleGVjdXRlOiAob3BlcmF0aW9uOiBPcGVyYXRpb24sIG9wdGlvbnM/OiBhbnkpID0+IGJvb2xlYW4gfCBzdHJpbmcgfCBQcm9taXNlPGFueT47XG59XG5cbmVudW0gT3BlcmF0aW9uIHtcbiAgICBMSVNUX1JFQ09SRFMgPSAnbGlzdFJlY29yZHMnLFxuICAgIFVQREFURV9SRUNPUkQgPSAndXBkYXRlUmVjb3JkJyxcbiAgICBJTlNFUlRfUkVDT1JEID0gJ2luc2VydFJlY29yZCcsXG4gICAgREVMRVRFX1JFQ09SRCA9ICdkZWxldGVSZWNvcmQnLFxuICAgIElOVk9LRSA9ICdpbnZva2UnLFxuICAgIFVQREFURSA9ICd1cGRhdGUnLFxuICAgIE5PVElGWSA9ICdub3RpZnknLFxuICAgIElTX0FQSV9BV0FSRSA9ICdpc0FwaUF3YXJlJyxcbiAgICBTVVBQT1JUU19DUlVEID0gJ3N1cHBvcnRzQ1JVRCcsXG4gICAgU1VQUE9SVFNfRElTVElOQ1RfQVBJID0gJ3N1cHBvcnRzRGlzdGluY3RBUEknLFxuICAgIElTX1BBR0VBQkxFID0gJ2lzUGFnZWFibGUnLFxuICAgIElTX1NPUlRBQkxFID0gXCJpc1NvcnRhYmxlXCIsXG4gICAgR0VUX09QRVJBVElPTl9UWVBFID0gJ2dldE9wZXJhdGlvblR5cGUnLFxuICAgIEdFVF9SRUxBVEVEX1BSSU1BUllfS0VZUyA9ICdnZXRSZWxhdGVkVGFibGVQcmltYXJ5S2V5cycsXG4gICAgR0VUX0VOVElUWV9OQU1FID0gJ2dldEVudGl0eU5hbWUnLFxuICAgIFNFVF9JTlBVVCA9ICdzZXRpbnB1dCcsXG4gICAgR0VUX1JFTEFURURfVEFCTEVfREFUQSA9ICdnZXRSZWxhdGVkVGFibGVEYXRhJyxcbiAgICBHRVRfRElTVElOQ1RfREFUQV9CWV9GSUVMRFMgPSAnZ2V0RGlzdGluY3REYXRhQnlGaWVsZHMnLFxuICAgIEdFVF9BR0dSRUdBVEVEX0RBVEEgPSAnZ2V0QWdncmVnYXRlZERhdGEnLFxuICAgIEdFVF9NQVRDSF9NT0RFID0gJ2dldE1hdGNoTW9kZScsXG4gICAgRE9XTkxPQUQgPSAnZG93bmxvYWQnLFxuICAgIEdFVF9OQU1FID0gJ2dldE5hbWUnLFxuICAgIEdFVF9QUk9QRVJUSUVTX01BUCA9ICdnZXRQcm9wZXJ0aWVzTWFwJyxcbiAgICBHRVRfUFJJTUFSWV9LRVkgPSAnZ2V0UHJpbWFyeUtleScsXG4gICAgR0VUX0JMT0JfVVJMID0gJ2dldEJsb2JVUkwnLFxuICAgIFNVUFBPUlRTX1NFUlZFUl9GSUxURVIgPSAnc3VwcG9ydHNTZXJ2ZXJGaWx0ZXInLFxuICAgIEdFVF9PUFRJT05TID0gJ2dldE9wdGlvbnMnLFxuICAgIFNFQVJDSF9SRUNPUkRTID0gJ3NlYXJjaFJlY29yZHMnLFxuICAgIEdFVF9SRVFVRVNUX1BBUkFNUyA9ICdnZXRSZXF1ZXN0UGFyYW1zJyxcbiAgICBHRVRfUEFHSU5HX09QVElPTlMgPSAnZ2V0UGFnaW5nT3B0aW9ucycsXG4gICAgRkVUQ0hfRElTVElOQ1RfVkFMVUVTID0gJ2ZldGNoRGlzdGluY3RWYWx1ZXMnLFxuICAgIEdFVF9VTklRVUVfSURFTlRJRklFUiA9ICdnZXRVbmlxdWVJZGVudGlmaWVyJyxcbiAgICBHRVRfQ09OVEVYVF9JREVOVElGSUVSID0gJ2dldENvbnRleHRJZGVudGlmaWVyJyxcbiAgICBJU19VUERBVEVfUkVRVUlSRUQgPSAnaXNVcGRhdGVSZXF1aXJlZCcsXG4gICAgQUREX0lURU0gPSAnYWRkSXRlbScsXG4gICAgU0VUX0lURU0gPSAnc2V0SXRlbScsXG4gICAgUkVNT1ZFX0lURU0gPSAncmVtb3ZlSXRlbScsXG4gICAgSVNfQk9VTkRfVE9fTE9DQUxFID0gJ2lzQm91bmRUb0xvY2FsZScsXG4gICAgR0VUX0RFRkFVTFRfTE9DQUxFID0gJ2dldERlZmF1bHRMb2NhbGUnLFxuICAgIENBTkNFTCA9ICdjYW5jZWwnLFxuICAgIFNFVF9QQUdJTkFUSU9OID0gJ3NldFBhZ2luYXRpb24nXG59XG5cbmV4cG9ydCBjb25zdCBEYXRhU291cmNlID0ge1xuICAgIE9wZXJhdGlvblxufTsiLCJkZWNsYXJlIGNvbnN0IF86IGFueTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0YXNldFV0aWwge1xuXG4gICAgc3RhdGljIGlzVmFsaWREYXRhc2V0KGRhdGFTZXQ6IGFueSwgaXNMaXN0PzogYm9vbGVhbikge1xuICAgICAgICBpZiAoIWRhdGFTZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGFycmF5IHR5cGUgZGF0YXNldCBmb3IgbGlzdCB0eXBlIHZhcmlhYmxlXG4gICAgICAgIGlmIChpc0xpc3QgJiYgIV8uaXNBcnJheShkYXRhU2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hhbmdlIHRoZSBkYXRhU2V0XG4gICAgICAgIHJldHVybiBkYXRhU2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRWYWx1ZShkYXRhU2V0OiBhbnksIGtleTogYW55LCBpbmRleDogYW55LCBpc0xpc3Q/OiBib29sZWFuKSB7XG4gICAgICAgIGluZGV4ID0gaW5kZXggfHwgMDtcblxuICAgICAgICAvLyByZXR1cm4gdGhlIHZhbHVlIGFnYWluc3QgdGhlIHNwZWNpZmllZCBrZXlcbiAgICAgICAgcmV0dXJuIGlzTGlzdCA/IGRhdGFTZXRbaW5kZXhdW2tleV0gOiBkYXRhU2V0W2tleV07XG4gICAgfVxuXG4gICAgc3RhdGljIHNldFZhbHVlKGRhdGFTZXQ6IGFueSwga2V5OiBhbnksIHZhbHVlOiBhbnksIGlzTGlzdD86IGJvb2xlYW4pIHtcbiAgICAgICAgLy8gY2hlY2sgcGFyYW0gc2FuaXR5XG4gICAgICAgIGlmIChrZXkgJiYgIWlzTGlzdCkge1xuICAgICAgICAgICAgZGF0YVNldFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gdGhlIG5ldyBkYXRhU2V0XG4gICAgICAgIHJldHVybiBkYXRhU2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRJdGVtKGRhdGFTZXQ6IGFueSwgaW5kZXg6IGFueSwgaXNMaXN0PzogYm9vbGVhbikge1xuICAgICAgICAvLyByZXR1cm4gdGhlIG9iamVjdCBhZ2FpbnN0IHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICAgICAgcmV0dXJuIGlzTGlzdCA/IGRhdGFTZXRbaW5kZXhdIDogZGF0YVNldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGZpbmQgdGFyZ2V0IG5vZGVcbiAgICAgKiBAcGFyYW0gZGF0YVNldDogcHJvdmlkZWQgZGF0YVNldFxuICAgICAqIEBwYXJhbSBvcHRpb25zOiBwcm92aWRlZCBvcHRpb25zXG4gICAgICogQHJldHVybnMge2FueX0gdGFyZ2V0bm9kZVxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGdldFRhcmdldE5vZGUoZGF0YVNldDogYW55LCBvcHRpb25zOiBhbnkpIHtcbiAgICAgICAgZGF0YVNldCA9IG9wdGlvbnMucGFyZW50SW5kZXggIT09IHVuZGVmaW5lZCA/ICBkYXRhU2V0W29wdGlvbnMucGFyZW50SW5kZXhdIDogZGF0YVNldDtcbiAgICAgICAgcmV0dXJuIF8uZ2V0KGRhdGFTZXQsIG9wdGlvbnMucGF0aCk7XG4gICAgfVxuXG4gICAgc3RhdGljIHNldEl0ZW0oZGF0YVNldDogYW55LCBpOiBhbnksIHZhbHVlOiBhbnksIG9wdGlvbnM/OiBhbnkpIHtcbiAgICAgICAgbGV0IGluZGV4O1xuXG4gICAgICAgIC8vIGNoZWNrIHBhcmFtIHNhbml0eVxuICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZChpKSB8fCAhb3B0aW9ucy5pc0xpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhU2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8uaXNPYmplY3QoaSkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gXy5maW5kSW5kZXgoZGF0YVNldCwgaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5wYXRoKSB7XG4gICAgICAgICAgICBjb25zdCBpbm5lckFycmF5ID0gRGF0YXNldFV0aWwuZ2V0VGFyZ2V0Tm9kZShkYXRhU2V0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGlubmVyRWxlbWluZGV4ID0gXy5maW5kSW5kZXgoaW5uZXJBcnJheSwgaSk7XG4gICAgICAgICAgICBpZiAoaW5uZXJFbGVtaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICBpbm5lckFycmF5W2lubmVyRWxlbWluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIHZhbHVlIGFnYWluc3QgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgICAgICAgICAgICAgIGRhdGFTZXRbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gdGhlIG5ldyBkYXRhU2V0XG4gICAgICAgIHJldHVybiBkYXRhU2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBhZGRJdGVtKGRhdGFTZXQ6IGFueSwgdmFsdWU6IGFueSwgaW5kZXg6IGFueSwgb3B0aW9ucz86IGFueSkge1xuICAgICAgICAvLyBjaGVjayBwYXJhbSBzYW5pdHlcbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQodmFsdWUpIHx8ICFvcHRpb25zLmlzTGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFTZXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdGhlIHZhbHVlIGFnYWluc3QgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgICAgICBpZiAob3B0aW9ucy5wYXRoKSB7XG4gICAgICAgICAgICBjb25zdCBpbm5lckFycmF5ID0gRGF0YXNldFV0aWwuZ2V0VGFyZ2V0Tm9kZShkYXRhU2V0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChpbm5lckFycmF5KSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGluZGV4IHNhbml0eVxuICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXggIT09IHVuZGVmaW5lZCA/IGluZGV4IDogaW5uZXJBcnJheS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaW5uZXJBcnJheS5zcGxpY2UoaW5kZXgsIDAsIHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICBvcHRpb25zLnBhcmVudEluZGV4ICE9PSB1bmRlZmluZWQgPyBfLnNldChkYXRhU2V0W29wdGlvbnMucGFyZW50SW5kZXhdLCBvcHRpb25zLnBhdGgsIFt2YWx1ZV0pIDogXy5zZXQoZGF0YVNldCwgb3B0aW9ucy5wYXRoLCBbdmFsdWVdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGluZGV4IHNhbml0eVxuICAgICAgICAgICAgaW5kZXggPSBpbmRleCAhPT0gdW5kZWZpbmVkID8gaW5kZXggOiBkYXRhU2V0Lmxlbmd0aDtcbiAgICAgICAgICAgIGRhdGFTZXQuc3BsaWNlKGluZGV4LCAwLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gdGhlIG5ldyBkYXRhU2V0XG4gICAgICAgIHJldHVybiBkYXRhU2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFTZXRcbiAgICAgKiBAcGFyYW0gaSwgY2FuIGJlIGluZGV4IHZhbHVlIG9mIHRoZSBvYmplY3QvZWxlbWVudCBpbiBhcnJheVxuICAgICAqICAgICAgb3JcbiAgICAgKiB0aGUgd2hvbGUgb2JqZWN0IHdoaWNoIG5lZWRzIHRvIGJlIHJlbW92ZWRcbiAgICAgKiBAcGFyYW0gZXhhY3RNYXRjaFxuICAgICAqIEByZXR1cm5zIHthbnl9XG4gICAgICovXG4gICAgc3RhdGljIHJlbW92ZUl0ZW0oZGF0YVNldDogYW55LCBpOiBhbnksIG9wdGlvbnM6IGFueSkge1xuICAgICAgICBsZXQgaW5kZXgsIGV4YWN0TWF0Y2g7XG4gICAgICAgIC8vIGNoZWNrIGZvciBpbmRleCBzYW5pdHlcbiAgICAgICAgaSA9IGkgIT09IHVuZGVmaW5lZCA/IGkgOiBkYXRhU2V0Lmxlbmd0aCAtIDE7XG5cbiAgICAgICAgaWYgKF8uaXNCb29sZWFuKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBleGFjdE1hdGNoID0gb3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBpZiAoXy5pc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICAgICAgZXhhY3RNYXRjaCA9IG9wdGlvbnMuZXhhY3RNYXRjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLmlzT2JqZWN0KGkpKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYXRoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5uZXJBcnJheSA9IERhdGFzZXRVdGlsLmdldFRhcmdldE5vZGUoZGF0YVNldCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5uZXJFbGVtaW5kZXggPSBfLmZpbmRJbmRleChpbm5lckFycmF5LCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJFbGVtaW5kZXggPiAtMSAmJiAoIWV4YWN0TWF0Y2ggfHwgKGV4YWN0TWF0Y2ggJiYgXy5pc0VxdWFsKGlubmVyQXJyYXlbaW5uZXJFbGVtaW5kZXhdLCBpKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlubmVyQXJyYXkuc3BsaWNlKGlubmVyRWxlbWluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gXy5maW5kSW5kZXgoZGF0YVNldCwgaSk7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBleGFjdE1hdGNoIHByb3BlcnR5IGlzIHNldCB0byB0cnVlIGRlbGV0ZSBvbmx5IHdoZW4gZXZlcnkgcHJvcGVydHkgdmFsdWVzIGFyZSBzYW1lKi9cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSAmJiAoIWV4YWN0TWF0Y2ggfHwgKGV4YWN0TWF0Y2ggJiYgXy5pc0VxdWFsKGRhdGFTZXRbaW5kZXhdLCBpKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTZXQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhU2V0LnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gdGhlIG5ldyBkYXRhU2V0XG4gICAgICAgIHJldHVybiBkYXRhU2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRWYWxpZERhdGFzZXQoaXNMaXN0PzogYm9vbGVhbikge1xuICAgICAgICByZXR1cm4gaXNMaXN0ID8gW10gOiB7fTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0Q291bnQoZGF0YVNldDogYW55LCBpc0xpc3Q/OiBib29sZWFuKSB7XG4gICAgICAgIHJldHVybiBpc0xpc3QgPyBkYXRhU2V0Lmxlbmd0aCA6IE9iamVjdC5rZXlzKGRhdGFTZXQpLmxlbmd0aDtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyB0cmlnZ2VyRm4gfSBmcm9tICcuL3V0aWxzJztcblxuaW1wb3J0IHsgTm90aWZ5UHJvbWlzZSB9IGZyb20gJy4vbm90aWZ5LXByb21pc2UnO1xuXG4vLyBkZWNsYXJlIGNvbnN0IF86IGFueTtcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5cbmVudW0gVVBMT0FEX1NUQVRVUyB7XG4gICAgUVVFVUVEICAgICAgICA9ICdxdWV1ZWQnLFxuICAgIElOX1BST0dSRVNTICAgPSAnaW5wcm9ncmVzcycsXG4gICAgU1VDQ0VTUyAgICAgICA9ICdzdWNjZXNzJyxcbiAgICBFUlJPUiAgICAgICAgID0gJ2Vycm9yJyxcbiAgICBBQk9SVEVEICAgICAgID0gJ2Fib3J0J1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1FdmVudChldmVudDogYW55KSB7XG4gICAgZXZlbnQudGFyZ2V0ID0gZXZlbnQudGFyZ2V0IHx8IHtcbiAgICAgICAgc3RhdHVzOiBldmVudC5yZXNwb25zZUNvZGUsXG4gICAgICAgIHJlc3BvbnNlOiBldmVudC5yZXNwb25zZVxuICAgIH07XG4gICAgcmV0dXJuIGV2ZW50O1xufVxuXG5jbGFzcyBGaWxlVHJhbnNmZXJPYmplY3Qge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBzaXplOiBzdHJpbmc7XG4gICAgc3RhdHVzOiBzdHJpbmc7XG4gICAgdHJhbnNmZXJGbjogRnVuY3Rpb247XG4gICAgYWJvcnRGbjogRnVuY3Rpb247XG4gICAgcHJvbWlzZTogYW55O1xuICAgIHByb2dyZXNzOiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihmaWxlOiBhbnksIHRyYW5zZmVyRm46IGFueSwgcHJvbWlzZTogYW55LCBhYm9ydEZuOiBhbnkpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gZmlsZS5uYW1lO1xuICAgICAgICB0aGlzLnNpemUgPSBmaWxlLnNpemUgfHwgJyc7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gVVBMT0FEX1NUQVRVUy5RVUVVRUQ7XG4gICAgICAgIHRoaXMudHJhbnNmZXJGbiA9IHRyYW5zZmVyRm47XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgIHRoaXMuYWJvcnRGbiA9IGFib3J0Rm47XG4gICAgfVxuXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gVVBMT0FEX1NUQVRVUy5RVUVVRUQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gVVBMT0FEX1NUQVRVUy5JTl9QUk9HUkVTUztcbiAgICAgICAgICAgIHRyaWdnZXJGbih0aGlzLnRyYW5zZmVyRm4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhlbihvblN1Y2Nlc3M6IGFueSwgb25FcnJvcjogYW55LCBvblByb2dyZXNzOiBhbnkpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMucHJvbWlzZS50aGVuKGZ1bmN0aW9uIChldmVudDogYW55KSB7XG4gICAgICAgICAgICBzZWxmLnN0YXR1cyA9IFVQTE9BRF9TVEFUVVMuU1VDQ0VTUztcbiAgICAgICAgICAgIHRyaWdnZXJGbihvblN1Y2Nlc3MsIGV2ZW50KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGV2ZW50OiBhbnkpIHtcbiAgICAgICAgICAgIHNlbGYuc3RhdHVzID0gVVBMT0FEX1NUQVRVUy5FUlJPUjtcbiAgICAgICAgICAgIHRyaWdnZXJGbihvbkVycm9yLCBldmVudCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChldmVudDogYW55KSB7XG4gICAgICAgICAgICBzZWxmLnByb2dyZXNzID0gTWF0aC5yb3VuZChldmVudC5sb2FkZWQgLyBldmVudC50b3RhbCAqIDEwMCk7XG4gICAgICAgICAgICB0cmlnZ2VyRm4ob25Qcm9ncmVzcywgZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZmluYWxseShvbkZpbmFsPzogYW55KSB7XG4gICAgICAgIHRoaXMucHJvbWlzZS5maW5hbGx5KG9uRmluYWwpO1xuICAgIH1cblxuICAgIC8qIGFib3J0cyB0aGUgZmlsZSB1cGxvYWQgKi9cbiAgICBhYm9ydCgpIHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBVUExPQURfU1RBVFVTLkFCT1JURUQ7XG4gICAgICAgIHRyaWdnZXJGbih0aGlzLmFib3J0Rm4pO1xuICAgICAgICB0aGlzLmZpbmFsbHkoKTtcbiAgICB9XG5cbn1cblxuY2xhc3MgQWpheEZpbGVUcmFuc2Zlck9iamVjdCBleHRlbmRzIEZpbGVUcmFuc2Zlck9iamVjdCB7XG4gICAgY29uc3RydWN0b3IoZmlsZTogYW55LCB0cmFuc2ZlckZuOiBhbnksIHByb21pc2U6IGFueSwgYWJvcnRGbjogYW55KSB7XG4gICAgICAgIHN1cGVyKGZpbGUsIHRyYW5zZmVyRm4sIHByb21pc2UsIGFib3J0Rm4pO1xuICAgIH1cbn1cblxuLyogdXBsb2FkIGZpbGUgdXNpbmcgZmlsZVRyYW5zZmVyICovXG5mdW5jdGlvbiB1cGxvYWRXaXRoRmlsZVRyYW5zZmVyKGZpbGU6IGFueSwgdXJsOiBhbnksIG9wdGlvbnM6IGFueSkge31cblxuZnVuY3Rpb24gYXBwZW5kRmlsZVRvRm9ybURhdGEoZmlsZTogYW55LCBmZDogYW55LCBvcHRpb25zOiBhbnkpIHtcbiAgICAvKiBhcHBlbmQgZmlsZSB0byBmb3JtIGRhdGEgKi9cbiAgICBpZiAoXy5pc0FycmF5KGZpbGUpKSB7XG4gICAgICAgIF8uZm9yRWFjaChmaWxlLCBmdW5jdGlvbiAoZmlsZU9iamVjdDogYW55KSB7XG4gICAgICAgICAgICBmZC5hcHBlbmQob3B0aW9ucy5wYXJhbU5hbWUsIGZpbGVPYmplY3QuY29udGVudCB8fCBmaWxlT2JqZWN0LCBmaWxlT2JqZWN0Lm5hbWUpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoZmlsZSkpIHtcbiAgICAgICAgZmQuYXBwZW5kKG9wdGlvbnMucGFyYW1OYW1lLCBmaWxlLmNvbnRlbnQgfHwgZmlsZSwgZmlsZS5uYW1lKTtcbiAgICB9XG59XG5cbi8qIHVwbG9hZCBmaWxlIHdpdGggYWpheCBjYWxsaW5nICovXG5mdW5jdGlvbiB1cGxvYWRXaXRoQWpheChmaWxlOiBhbnksIHZhcmlhYmxlOiBhbnksIGZkOiBhbnksIHVybDogYW55LCBvcHRpb25zOiBhbnkpIHtcbiAgICBjb25zdCBjbG9uZUZEID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgY29uc3QgaXRlcmF0ZSA9ICh2YWx1ZTogYW55LCBrZXk6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlT2JqZWN0ID0gKF8uaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZVswXSA6IHZhbHVlKTtcbiAgICAgICAgaWYgKCEoZmlsZU9iamVjdCBpbnN0YW5jZW9mIEZpbGUgfHwgZmlsZU9iamVjdCBpbnN0YW5jZW9mIEJsb2IpKSB7XG4gICAgICAgICAgICBjbG9uZUZELmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gVGhlIGZvcmVlYWNoIG1ldGhvZCBvbiBmb3JtIGRhdGEgZG9lc24ndCBleGlzdCBpbiBJRS4gSGVuY2Ugd2UgY2hlY2sgaWYgaXQgZXhpc3RzXG4gICAgLy8gb3IgZWxzZSB1c2UgdGhlIGxvZGFzaCBmb3JFYWNoXG4gICAgaWYgKGZkLmZvckVhY2gpIHtcbiAgICAgICAgZmQuZm9yRWFjaChpdGVyYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfLmZvckVhY2goZmQsIGl0ZXJhdGUpO1xuICAgIH1cbiAgICBhcHBlbmRGaWxlVG9Gb3JtRGF0YShmaWxlLCBjbG9uZUZELCBvcHRpb25zKTtcblxuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgTm90aWZ5UHJvbWlzZSgocmVzb2x2ZTogYW55LCByZWplY3Q6IGFueSwgbm90aWZ5OiBhbnkpID0+IHtcbiAgICAgICAgLy8gVG9EbyAtIHZhcmlhYmxlIHNlcGVyYXRpb25cbiAgICAgICAgdmFyaWFibGUuaHR0cFNlcnZpY2UudXBsb2FkRmlsZSh1cmwsIGNsb25lRkQsIHZhcmlhYmxlLCB7bm90aWZ5OiBub3RpZnl9KS50aGVuKChkYXRhOiBhbnkpID0+IHtcbiAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfSwgKGVycm9yOiBhbnkpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBmaWxlLl91cGxvYWRQcm9ncmVzcyA9IHZhcmlhYmxlLnJlcXVlc3Q7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLyogdXBsb2FkIHRoZSBmaWxlIC0gSUU5IHN1cHBvcnQgKi9cbi8vIGZ1bmN0aW9uIHVwbG9hZFdpdGhJZnJhbWUoZmlsZSwgdXJsLCBvcHRpb25zKSB7fVxuXG4vKiB1cGxvYWQgdGhlIG5leHQgZmlsZSBkZXBlbmRpbmcgb24gdGhlIHN0YXR1cyAqL1xuZnVuY3Rpb24gc3Rhck5leHRGaWxlVHJhbnNmZXIoZnRzOiBhbnkpIHtcbiAgICBjb25zdCBmdCA9IF8uZmluZChmdHMsIGZ1bmN0aW9uIChmOiBhbnkpIHtcbiAgICAgICAgcmV0dXJuIGYuc3RhdHVzID09PSBVUExPQURfU1RBVFVTLlFVRVVFRDtcbiAgICB9KTtcbiAgICBpZiAoZnQpIHtcbiAgICAgICAgZnQuc3RhcnQoKTtcbiAgICAgICAgZnQuZmluYWxseShzdGFyTmV4dEZpbGVUcmFuc2Zlci5iaW5kKHVuZGVmaW5lZCwgZnRzKSk7XG4gICAgfVxufVxuXG4vKiB1cGxvYWQgdGhlIG1heCBubyBvZiBmaWxlcyBhdCBvbmNlIGkuZS4gdHdvIGF0IG9uY2UgYmFzZWQgb24gbWF4Ki9cbmZ1bmN0aW9uIHN0YXJ0RmlsZVRyYW5zZmVycyhmdHM6IGFueSwgbWF4OiBhbnkpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgbGVuID0gZnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoaSA8IG1heCAmJiBpIDwgbGVuKSB7XG4gICAgICAgIHN0YXJOZXh0RmlsZVRyYW5zZmVyKGZ0cyk7XG4gICAgICAgIGkrKztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzTW9iaWxlQXBwKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHVwbG9hZHMgdGhlIGZpbGUgdG8gdGhlIGdpdmVuIHVybCBlbmRwb2ludC5cbiAqXG4gKiBAcGFyYW0gZmlsZSBmaWxlIHRvIHVwbG9hZFxuICogQHBhcmFtIHVybCBodHRwIGVuZHBvaW50IHRvIHdoaWNoIHRoZSBmaWxlIGhhcyB0byBiZSBzdWJtaXR0ZWQuXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnMgYSBwcm9taXNlIHRvIGxpc3RlbiBmb3Igc3VjY2VzcywgZXZlbnQsIG9uUHJvZ3Jlc3MuXG4gKiAgT25lIGNhbiBhbHNvIGFib3J0IHRoZSB1cGxvYWQgYnkgc2ltcGx5IGNhbGxpbmcgYWJvcnQgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGxvYWQoZmlsZXM6IGFueSwgdmFyaWFibGU6IGFueSwgZmQ6IGFueSwgY29uZmlnOiBhbnksIG9wdGlvbnM/OiBhbnkpIHtcbiAgICBvcHRpb25zID0gXy5leHRlbmQoe1xuICAgICAgICAncGFyYW1OYW1lJyA6IGNvbmZpZy5maWxlUGFyYW1OYW1lXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHVwbG9hZFdpdGhBamF4KGZpbGVzLCB2YXJpYWJsZSwgZmQsIGNvbmZpZy51cmwsIG9wdGlvbnMpO1xuICAgIC8vIGxldCBmaWxlVHJhbnNmZXJzID0gW10sXG4gICAgLy8gICAgIHVybCA9IGNvbmZpZy51cGxvYWRVcmw7XG4gICAgLy8gb3B0aW9ucyA9IF8uZXh0ZW5kKHtcbiAgICAvLyAgICAgJ3BhcmFtTmFtZScgOiBjb25maWcuZmlsZVBhcmFtTmFtZVxuICAgIC8vIH0sIG9wdGlvbnMpO1xuICAgIC8vXG4gICAgLy8gaWYgKGlzTW9iaWxlQXBwKCkpIHtcbiAgICAvLyAgICAgXy5mb3JFYWNoKGZpbGVzLCBmdW5jdGlvbiAoZmlsZSkge1xuICAgIC8vICAgICAgICAgZmlsZVRyYW5zZmVycy5wdXNoKHVwbG9hZFdpdGhGaWxlVHJhbnNmZXIoZmlsZSwgdXJsLCBvcHRpb25zKSk7XG4gICAgLy8gICAgIH0pO1xuICAgIC8vIH0gZWxzZSBpZiAoKHdpbmRvdyBhcyBhbnkpLkZvcm1EYXRhKSB7XG4gICAgLy8gICAgIF8uZm9yRWFjaChmaWxlcywgZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAvLyAgICAgICAgIGZpbGVUcmFuc2ZlcnMucHVzaCh1cGxvYWRXaXRoQWpheChmaWxlLCB1cmwsIG9wdGlvbnMpKTtcbiAgICAvLyAgICAgfSk7XG4gICAgLy8gfSBlbHNlIHtcbiAgICAvLyAgICAgXy5mb3JFYWNoKGZpbGVzLCBmdW5jdGlvbiAoZmlsZSkge1xuICAgIC8vICAgICAgICAgZmlsZVRyYW5zZmVycy5wdXNoKHVwbG9hZFdpdGhJZnJhbWUoZmlsZSwgdXJsLCBvcHRpb25zKSk7XG4gICAgLy8gICAgIH0pO1xuICAgIC8vIH1cbiAgICAvLyBzdGFydEZpbGVUcmFuc2ZlcnMoZmlsZVRyYW5zZmVycywgMik7XG4gICAgLy8gcmV0dXJuIGZpbGVUcmFuc2ZlcnM7XG59XG4iLCJjbGFzcyBJbmZsaWdodFF1ZXVlIHtcbiAgICByZXF1ZXN0c1F1ZXVlID0gbmV3IE1hcCgpO1xuXG4gICAgLyoqXG4gICAgICogcHVzaGVzIHRoZSBwcm9jZXNzIGFnYWluc3QgYSB2YXJpYWJsZSBpbiBpdHMgcXVldWVcbiAgICAgKiBAcGFyYW0gdmFyaWFibGVcbiAgICAgKiBAcGFyYW0ge3tyZXNvbHZlOiAodmFsdWU/OiBhbnkpID0+IHZvaWQ7IHJlamVjdDogKHJlYXNvbj86IGFueSkgPT4gdm9pZH19IHBhcmFtMlxuICAgICAqIHRoZSByZXNvbHZlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIG9uXG4gICAgICovXG4gICAgcHJpdmF0ZSBhZGRUb1F1ZXVlKHZhcmlhYmxlOiBhbnksIHBhcmFtMjoge3Jlc29sdmU6ICh2YWx1ZT86IChhbnkpKSA9PiB2b2lkOyByZWplY3Q6IChyZWFzb24/OiBhbnkpID0+IHZvaWR9KSB7XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3RzUXVldWUuaGFzKHZhcmlhYmxlKSkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0c1F1ZXVlLmdldCh2YXJpYWJsZSkucHVzaChwYXJhbTIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VzID0gW107XG4gICAgICAgICAgICBwcm9jZXNzZXMucHVzaCh7cmVzb2x2ZTogcGFyYW0yLnJlc29sdmUsIHJlamVjdDogcGFyYW0yLnJlamVjdCwgYWN0aXZlOiBmYWxzZX0pO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0c1F1ZXVlLnNldCh2YXJpYWJsZSwgcHJvY2Vzc2VzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSByZWplY3QgbWV0aG9kIGFnYWluc3QgdGhlIHBhc3NlZCBwcm9jZXNzXG4gICAgICogQHBhcmFtIHByb2Nlc3NcbiAgICAgKi9cbiAgICBwcml2YXRlIHJlamVjdFByb2Nlc3MocHJvY2VzczogYW55KSB7XG4gICAgICAgIHByb2Nlc3MucmVqZWN0KCdQUk9DRVNTX1JFSkVDVEVEX0lOX1FVRVVFJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2xlYXJzIHRoZSBxdWV1ZSBhZ2FpbnN0IGEgdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gdmFyaWFibGVcbiAgICAgKi9cbiAgICBwdWJsaWMgY2xlYXIodmFyaWFibGU6IGFueSkge1xuICAgICAgICB0aGlzLnJlcXVlc3RzUXVldWUuZGVsZXRlKHZhcmlhYmxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBleGVjdXRlcyB0aGUgbi93IGNhbGxzIGZvciBhIHNwZWNpZmllZCB2YXJpYWJsZSBwdXNoZWQgaW4gaXRzIHJlc3BlY3RpdmUgcXVldWUgKHB1c2hlZCB3aGlsZSBpdCB3YXMgaW5GbGlnaHQpXG4gICAgICogQHBhcmFtIHZhcmlhYmxlXG4gICAgICovXG4gICAgcHJvY2Vzcyh2YXJpYWJsZTogYW55KSB7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlczogW2FueV0gPSB0aGlzLnJlcXVlc3RzUXVldWUuZ2V0KHZhcmlhYmxlKTtcbiAgICAgICAgbGV0IG5leHRQcm9jZXNzO1xuXG4gICAgICAgIC8vIHByb2Nlc3MgcmVxdWVzdCBxdWV1ZSBmb3IgdGhlIHZhcmlhYmxlIG9ubHkgaWYgaXQgaXMgbm90IGVtcHR5XG4gICAgICAgIGlmICghcHJvY2Vzc2VzIHx8ICFwcm9jZXNzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKHZhcmlhYmxlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG9ubHkgb25lIGl0ZW0gaW4gcXVldWVcbiAgICAgICAgaWYgKHByb2Nlc3Nlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIG5leHRQcm9jZXNzID0gcHJvY2Vzc2VzWzBdO1xuICAgICAgICAgICAgaWYgKG5leHRQcm9jZXNzLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIodmFyaWFibGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0UHJvY2Vzcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG5leHRQcm9jZXNzLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodmFyaWFibGUuaW5GbGlnaHRCZWhhdmlvcikge1xuICAgICAgICAgICAgY2FzZSAnZXhlY3V0ZUxhc3QnOlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvY2Vzc2VzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdFByb2Nlc3MocHJvY2Vzc2VzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VzLnNwbGljZSgwLCBwcm9jZXNzZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2V4ZWN1dGVBbGwnOlxuICAgICAgICAgICAgICAgIG5leHRQcm9jZXNzID0gcHJvY2Vzc2VzLnNwbGljZSgwLCAxKVswXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFByb2Nlc3MuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQcm9jZXNzID0gcHJvY2Vzc2VzLnNwbGljZSgwLCAxKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dFByb2Nlc3MuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBuZXh0UHJvY2Vzcy5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvY2Vzc2VzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdFByb2Nlc3MocHJvY2Vzc2VzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhcih2YXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbml0aWFsaXplcyB0aGUgcXVldWUgYWdhaW5zdCBhIHZhcmlhYmxlIGFuZCBtYWtlcyB0aGUgZmlyc3QgcHJvY2VzcyBjYWxsXG4gICAgICogSWYgYWxyZWFkeSBpbml0aWFsaXplZCBhbmQgYSBwcm9jZXNzIGluIHF1ZXVlIGlzIGluIHByb2dyZXNzLCB0aGUgcXVldWUgaXMgbm90IHByb2Nlc3NlZC5cbiAgICAgKiBUbyBwcm9jZXNzIHRoZSBuZXh0IGl0ZW0gaW4gdGhlIHF1ZXVlLCB0aGUgcHJvY2VzcyBtZXRob2QgaGFzIHRvIGJlIGNhbGxlZCBmcm9tIHRoZSBjYWxsZXIuXG4gICAgICogQHBhcmFtIHZhcmlhYmxlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBzdWJtaXQodmFyaWFibGU6IGFueSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRUb1F1ZXVlKHZhcmlhYmxlLCB7cmVzb2x2ZTogcmVzb2x2ZSwgcmVqZWN0OiByZWplY3R9KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMucmVxdWVzdHNRdWV1ZS5nZXQodmFyaWFibGUpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2YXJpYWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0ICRxdWV1ZSA9IG5ldyBJbmZsaWdodFF1ZXVlKCk7XG4iLCJleHBvcnQgY2xhc3MgTm90aWZ5UHJvbWlzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihmbjogYW55KSB7XG4gICAgICAgIGNvbnN0IG5vdGlmeVF1ZXVlOiBhbnkgPSBbXSxcbiAgICAgICAgICAgIG5vdGlmeSA9IChzdGF0dXM6IGFueSkgPT4ge1xuICAgICAgICAgICAgbm90aWZ5UXVldWUuZm9yRWFjaCgoZm4xOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICBmbjEoc3RhdHVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGNsZWFuVXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG5vdGlmeVF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcDEgPSAgbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICBmbihyZXMsIHJlaiwgbm90aWZ5KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgKHAxIGFzIGFueSkuc3VwZXJUaGVuID0gcDEudGhlbi5iaW5kKHAxKTtcbiAgICAgICAgKHAxIGFzIGFueSkudGhlbiA9IChvblJlc29sdmU6IGFueSwgb25SZWplY3Q6IGFueSwgb25Ob3RpZnk6IGFueSkgPT4ge1xuICAgICAgICAgICAgKHAxIGFzIGFueSkuc3VwZXJUaGVuKFxuICAgICAgICAgICAgICAgIChyZXNwb25zZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9uUmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuVXAoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIChyZWFzb246IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvblJlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICBjbGVhblVwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChvbk5vdGlmeSkge1xuICAgICAgICAgICAgICAgIG5vdGlmeVF1ZXVlLnB1c2gob25Ob3RpZnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcDE7XG4gICAgfVxufVxuXG4vLyBsZXQgbmV3UHJvbWlzZSA9IG5ldyBQcm9taXNlV2l0aE5vdGlmeSgocmVzb2x2ZSwgcmVqZWN0LCBub3RpZnkpID0+IHtcbi8vICAgICBzZXRJbnRlcnZhbChub3RpZnksIDEwMDApO1xuLy8gfSlcbi8vIGNvbnNvbGUubG9nKG5ld1Byb21pc2UpXG4vLyBuZXdQcm9taXNlLnRoZW4odW5kZWZpbmVkLCB1bmRlZmluZWQsICgpID0+IGNvbnNvbGUubG9nKDMpKTtcbiIsImltcG9ydCB7IG9hdXRoU2VydmljZSwgYXBwTWFuYWdlciB9IGZyb20gJy4vdmFyaWFibGUvdmFyaWFibGVzLnV0aWxzJztcblxuZXhwb3J0IGNvbnN0IHBlcmZvcm1BdXRob3JpemF0aW9uID0gKHVybDogYW55LCBwcm92aWRlcklkOiBhbnksIG9uU3VjY2VzczogYW55LCBvbkVycm9yOiBhbnksIHNlY3VyaXR5T2JqPzogYW55KSA9PiB7XG4gICAgb2F1dGhTZXJ2aWNlPy5wZXJmcm9tT0F1dGhvcml6YXRpb24odXJsLCBwcm92aWRlcklkLCBvblN1Y2Nlc3MsIG9uRXJyb3IsIHNlY3VyaXR5T2JqLCBhcHBNYW5hZ2VyLmdldEN1c3RvbVVybFNjaGVtZSgpLCBhcHBNYW5hZ2VyLmdldERlcGxveWVkVVJMKCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEFjY2Vzc1Rva2VuID0gKHByb3ZpZGVyOiBhbnksIGNoZWNrTG9hY2xTdG9yYWdlOiBhbnkpID0+IHtcbiAgICByZXR1cm4gb2F1dGhTZXJ2aWNlPy5nZXRBY2Nlc3NUb2tlbiAmJiBvYXV0aFNlcnZpY2UuZ2V0QWNjZXNzVG9rZW4ocHJvdmlkZXIsIGNoZWNrTG9hY2xTdG9yYWdlKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZW1vdmVBY2Nlc3NUb2tlbiA9IChwcm92aWRlcjogYW55KSA9PiB7XG4gICAgb2F1dGhTZXJ2aWNlLnJlbW92ZUFjY2Vzc1Rva2VuKHByb3ZpZGVyKTtcbn1cbiIsIi8vIGRlY2xhcmUgY29uc3QgWDJKUzogYW55O1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IFgySlMgZnJvbSAneDJqcyc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuZXhwb3J0IGNvbnN0IERhdGFUeXBlID0ge1xuICAgIElOVEVHRVIgOiAnaW50ZWdlcicsXG4gICAgQklHX0lOVEVHRVIgOiAnYmlnX2ludGVnZXInLFxuICAgIFNIT1JUIDogJ3Nob3J0JyxcbiAgICBGTE9BVCA6ICdmbG9hdCcsXG4gICAgQklHX0RFQ0lNQUwgOiAnYmlnX2RlY2ltYWwnLFxuICAgIERPVUJMRSA6ICdkb3VibGUnLFxuICAgIExPTkcgOiAnbG9uZycsXG4gICAgQllURSA6ICdieXRlJyxcbiAgICBTVFJJTkcgOiAnc3RyaW5nJyxcbiAgICBDSEFSQUNURVIgOiAnY2hhcmFjdGVyJyxcbiAgICBURVhUIDogJ3RleHQnLFxuICAgIERBVEUgOiAnZGF0ZScsXG4gICAgVElNRSA6ICd0aW1lJyxcbiAgICBUSU1FU1RBTVAgOiAndGltZXN0YW1wJyxcbiAgICBEQVRFVElNRSA6ICdkYXRldGltZScsXG4gICAgTE9DQUxEQVRFVElNRSA6ICdsb2NhbGRhdGV0aW1lJyxcbiAgICBCT09MRUFOIDogJ2Jvb2xlYW4nLFxuICAgIExJU1QgOiAnbGlzdCcsXG4gICAgQ0xPQiA6ICdjbG9iJyxcbiAgICBCTE9CIDogJ2Jsb2InXG59XG5leHBvcnQgY29uc3QgREVGQVVMVF9GT1JNQVRTID0ge1xuICAgIERBVEUgOiBcInl5eXktTU0tZGRcIixcbiAgICBUSU1FIDogXCJISDptbTpzc1wiLFxuICAgIFRJTUVTVEFNUCA6IFwidGltZXN0YW1wXCIsXG4gICAgREFURVRJTUUgOiBcInl5eXktTU0tZGRUSEg6bW06c3NcIixcbiAgICBMT0NBTERBVEVUSU1FIDogXCJ5eXl5LU1NLWRkVEhIOm1tOnNzXCIsXG4gICAgREFURVRJTUVfT1JBQ0xFIDogXCJ5eXl5LU1NLWRkIEhIOm1tOnNzXCIsXG4gICAgREFURV9USU1FIDogXCJ5eXl5LU1NLWRkIEhIOm1tOnNzXCJcbn1cbmNvbnN0IFJFR0VYID0ge1xuICAgIFNOQUtFX0NBU0U6IC9bQS1aXS9nLFxuICAgIEFORFJPSUQ6IC9BbmRyb2lkL2ksXG4gICAgSVBIT05FOiAvaVBob25lL2ksXG4gICAgSVBPRDogL2lQb2QvaSxcbiAgICBJUEFEOiAvaVBhZC9pLFxuICAgIE1BQzogL01hYy9pLFxuICAgIEFORFJPSURfVEFCTEVUOiAvYW5kcm9pZHxhbmRyb2lkIDMuMHx4b29tfHNjaC1pODAwfHBsYXlib29rfHRhYmxldHxraW5kbGUvaSxcbiAgICBNT0JJTEU6IC9Nb2JpbGUvaSxcbiAgICBXSU5ET1dTOiAvV2luZG93cyBQaG9uZS9pLFxuICAgIFNVUFBPUlRFRF9JTUFHRV9GT1JNQVQ6IC9cXC4oYm1wfGdpZnxqcGV8anBnfGpwZWd8dGlmfHRpZmZ8cGJtfHBuZ3xpY28pJC9pLFxuICAgIFNVUFBPUlRFRF9GSUxFX0ZPUk1BVDogL1xcLih0eHR8anN8Y3NzfGh0bWx8c2NyaXB0fHByb3BlcnRpZXN8anNvbnxqYXZhfHhtbHxzbWR8eG1pfHNxbHxsb2d8d3NkbHx2bXxmdGx8anJ4bWx8eW1sfHlhbWx8bWR8bGVzc3xqc3ApJC9pLFxuICAgIFNVUFBPUlRFRF9BVURJT19GT1JNQVQ6IC9cXC4obXAzfG9nZ3x3ZWJtfHdtYXwzZ3B8d2F2fG00YSkkL2ksXG4gICAgU1VQUE9SVEVEX1ZJREVPX0ZPUk1BVDogL1xcLihtcDR8b2dnfHdlYm18d212fG1wZWd8bXBnfGF2aXxtb3YpJC9pLFxuICAgIFBBR0VfUkVTT1VSQ0VfUEFUSDogL15cXC9wYWdlc1xcLy4qXFwuKGpzfGNzc3xodG1sfGpzb24pJC8sXG4gICAgTUlOX1BBR0VfUkVTT1VSQ0VfUEFUSDogLy4qKHBhZ2UubWluLmh0bWwpJC8sXG4gICAgVkFMSURfRU1BSUw6IC9eW2EtekEtWl1bXFx3LitdK0BbYS16QS1aX10rP1xcLlthLXpBLVouXXsxLDR9W2EtekEtWl0kLyxcbiAgICBWQUxJRF9XRUJfVVJMOiAvXihodHRwW3NdPzpcXC9cXC8pKHd3d1xcLil7MCwxfVthLXpBLVowLTk9Oj9cXC9cXC5cXC1dKyhcXC5bYS16QS1aXXsyLDV9W1xcLl17MCwxfSk/LyxcbiAgICBWQUxJRF9XRUJTT0NLRVRfVVJMOiAvXih3c1tzXT86XFwvXFwvKSh3d3dcXC4pezAsMX1bYS16QS1aMC05PTo/XFwvXFwuXFwtXSsoXFwuW2EtekEtWl17Miw1fVtcXC5dezAsMX0pPy8sXG4gICAgVkFMSURfUkVMQVRJVkVfVVJMOiAvXig/IXd3d1xcLnwoPzpodHRwfGZ0cClzPzpcXC9cXC98W0EtWmEtel06XFxcXHxcXC9cXC8pLiovLFxuICAgIFJFUExBQ0VfUEFUVEVSTjogL1xcJFxceyhbXlxcfV0rKVxcfS9nLFxuICAgIFpJUF9GSUxFOiAvXFwuemlwJC9pLFxuICAgIEVYRV9GSUxFOiAvXFwuZXhlJC9pLFxuICAgIE5PX1FVT1RFU19BTExPV0VEOiAvXlteJ3xcIl0qJC8sXG4gICAgTk9fRE9VQkxFX1FVT1RFU19BTExPV0VEOiAvXlteXCJdKiQvLFxuICAgIFZBTElEX0hUTUw6IC88W2Etel1bXFxzXFxTXSo+L2ksXG4gICAgVkFMSURfUEFTU1dPUkQ6IC9eWzAtOWEtekEtWi1fLkAmKiEjJCVdKyQvLFxuICAgIFNQRUNJQUxfQ0hBUkFDVEVSUzogL1teQS1aMC05YS16X10rL2ksXG4gICAgQVBQX1NFUlZFUl9VUkxfRk9STUFUOiAvXihodHRwW3NdPzpcXC9cXC8pKHd3d1xcLil7MCwxfVthLXpBLVowLTlcXC5cXC1dKyhbOl0/WzAtOV17Miw1fXxcXC5bYS16QS1aXXsyLDV9W1xcLl17MCwxfSlcXC8rW14/IyY9XSskLyxcbiAgICBKU09OX0RBVEVfRk9STUFUOiAvXFxkezR9LVswLTFdXFxkLVswLTNdXFxkKFRbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZC5cXGR7MSwzfVokKT8vLFxuICAgIERBVEFfVVJMOiAvXlxccypkYXRhOihbYS16XStcXC9bYS16MC05LSsuXSsoO1thLXotXSs9W2EtejAtOS1dKyk/KT8oO2Jhc2U2NCk/LChbYS16MC05ISQmJywoKSorOz1cXC0uX346QFxcLz8lXFxzXSopXFxzKiQvaVxufVxuY29uc3QgTlVNQkVSX1RZUEVTID0gWydpbnQnLCBEYXRhVHlwZS5JTlRFR0VSLCBEYXRhVHlwZS5GTE9BVCwgRGF0YVR5cGUuRE9VQkxFLCBEYXRhVHlwZS5MT05HLCBEYXRhVHlwZS5TSE9SVCwgRGF0YVR5cGUuQllURSwgRGF0YVR5cGUuQklHX0lOVEVHRVIsIERhdGFUeXBlLkJJR19ERUNJTUFMXTtcbmV4cG9ydCBjb25zdCBub29wID0gKC4uLmFyZ3M6IGFueSkgPT4geyB9O1xuZnVuY3Rpb24qIGlkR2VuZXJhdG9yKHRva2VuOiBhbnkpIHtcbiAgICBsZXQgaWQgPSAxO1xuICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHlpZWxkIGAke3Rva2VufSR7aWQrK31gO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBpc1ZhbGlkV2ViVVJMID0gKHVybDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgcmV0dXJuIChSRUdFWC5WQUxJRF9XRUJfVVJMKS50ZXN0KHVybCk7XG59O1xuXG4vKkZ1bmN0aW9uIHRvIGNoZWNrIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgYSBwYWdlYWJsZSBvYmplY3Qgb3Igbm90LiovXG5leHBvcnQgY29uc3QgaXNQYWdlYWJsZSA9IChvYmo6IGFueSk6IGJvb2xlYW4gPT4ge1xuICAgIGNvbnN0IHBhZ2VhYmxlID0ge1xuICAgICAgICAnY29udGVudCc6IFtdLFxuICAgICAgICAnZmlyc3QnOiB0cnVlLFxuICAgICAgICAnbGFzdCc6IHRydWUsXG4gICAgICAgICdudW1iZXInOiAwLFxuICAgICAgICAnbnVtYmVyT2ZFbGVtZW50cyc6IDEwLFxuICAgICAgICAnc2l6ZSc6IDIwLFxuICAgICAgICAnc29ydCc6IG51bGwsXG4gICAgICAgICd0b3RhbEVsZW1lbnRzJzogMTAsXG4gICAgICAgICd0b3RhbFBhZ2VzJzogMVxuICAgIH07XG4gICAgLy8gcGFnaW5hdGVkIG9iamVjdCBtYXkgb3IgbWF5IG5vdCBjb250YWluICdlbXB0eScgcHJvcGVydHkuIEluIGVpdGhlciBjYXNlLCBQYWdlYWJsZSBzaG91bGQgcmV0dXJuIGFzIHRydWUuXG4gICAgY29uc3QgcGFnaW5hdGVkT2JqID0gXy5vbWl0KG9iaiwgJ2VtcHR5Jyk7XG4gICAgcmV0dXJuIChfLmlzRXF1YWwoXy5rZXlzKHBhZ2VhYmxlKSwgXy5rZXlzKHBhZ2luYXRlZE9iaikuc29ydCgpKSk7XG59O1xuXG5leHBvcnQgY2xhc3MgSURHZW5lcmF0b3Ige1xuICAgIHByaXZhdGUgZ2VuZXJhdG9yOiBJdGVyYXRvcjxhbnk+O1xuXG4gICAgY29uc3RydWN0b3Ioa2V5OiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBpZEdlbmVyYXRvcihrZXkpO1xuICAgIH1cblxuICAgIHB1YmxpYyBuZXh0VWlkKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgfVxufVxuLy8gVG9EbyAtIHZhcmlhYmxlIHNlcGVyYXRpb25cbmV4cG9ydCBjb25zdCBoYXNDb3Jkb3ZhID0gKCkgPT4ge1xuICAgIHJldHVybiAhIXdpbmRvd1snY29yZG92YSddO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlbW92ZUV4dHJhU2xhc2hlcyA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICBjb25zdCBiYXNlNjRyZWdleCA9IC9eZGF0YTppbWFnZVxcLyhbYS16XXsyLH0pO2Jhc2U2NCwvO1xuICAgIGlmIChfLmlzU3RyaW5nKHVybCkpIHtcbiAgICAgICAgLypcbiAgICAgICAgKiBzdXBwb3J0IGZvciBtb2JpbGUgYXBwcyBoYXZpbmcgbG9jYWwgZmlsZSBwYXRoIHVybCBzdGFydGluZyB3aXRoIGZpbGU6Ly8vIGFuZFxuICAgICAgICAqIHN1cHBvcnQgZm9yIGJhc2U2NCBmb3JtYXRcbiAgICAgICAgKiAqL1xuICAgICAgICBpZiAoXy5zdGFydHNXaXRoKHVybCwgJ2ZpbGU6Ly8vJykgfHwgYmFzZTY0cmVnZXgudGVzdCh1cmwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmwucmVwbGFjZShuZXcgUmVnRXhwKCcoW146XVxcLykoXFwvKSsnLCAnZycpLCAnJDEnKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGlzRGVmaW5lZCA9ICh2OiBhbnkpID0+ICd1bmRlZmluZWQnICE9PSB0eXBlb2YgdjtcbmV4cG9ydCBjb25zdCBpc09iamVjdCA9ICh2OiBhbnkpID0+IG51bGwgIT09IHYgJiYgJ29iamVjdCcgPT09IHR5cGVvZiB2O1xuLyogcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBkYXRhIHR5cGUgbWF0Y2hlcyBudW1iZXIgdHlwZSAqL1xuZXhwb3J0IGNvbnN0IGlzTnVtYmVyVHlwZSA9ICh0eXBlOiBhbnkpOiBib29sZWFuID0+IHtcbiAgICByZXR1cm4gKE5VTUJFUl9UWVBFUy5pbmRleE9mKGV4dHJhY3RUeXBlKHR5cGUpLnRvTG93ZXJDYXNlKCkpICE9PSAtMSk7XG59O1xuXG4vKlxuKiBleHRyYWN0cyBhbmQgcmV0dXJucyB0aGUgbGFzdCBiaXQgZnJvbSBmdWxsIHR5cGVSZWYgb2YgYSBmaWVsZFxuKiBlLmcuIHJldHVybnMgJ1N0cmluZycgZm9yIHR5cGVSZWYgPSAnamF2YS5sYW5nLlN0cmluZydcbiogQHBhcmFtczoge3R5cGVSZWZ9IHR5cGUgcmVmZXJlbmNlXG4qL1xuZXhwb3J0IGNvbnN0IGV4dHJhY3RUeXBlID0gKHR5cGVSZWY6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgbGV0IHR5cGU7XG4gICAgaWYgKCF0eXBlUmVmKSB7XG4gICAgICAgIHJldHVybiBEYXRhVHlwZS5TVFJJTkc7XG4gICAgfVxuICAgIHR5cGUgPSB0eXBlUmVmICYmIHR5cGVSZWYuc3Vic3RyaW5nKHR5cGVSZWYubGFzdEluZGV4T2YoJy4nKSArIDEpO1xuICAgIHR5cGUgPSB0eXBlICYmIHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICB0eXBlID0gdHlwZSA9PT0gRGF0YVR5cGUuTE9DQUxEQVRFVElNRSA/IERhdGFUeXBlLkRBVEVUSU1FIDogdHlwZTtcbiAgICByZXR1cm4gdHlwZTtcbn07XG4vKkZ1bmN0aW9uIHRvIGNoZWNrIGlmIGRhdGUgdGltZSB0eXBlKi9cbmV4cG9ydCBjb25zdCBpc0RhdGVUaW1lVHlwZSA9ICh0eXBlOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoXy5pbmNsdWRlcyh0eXBlLCAnLicpKSB7XG4gICAgICAgIHR5cGUgPSBfLnRvTG93ZXIoZXh0cmFjdFR5cGUodHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm4gXy5pbmNsdWRlcyhbRGF0YVR5cGUuREFURSwgRGF0YVR5cGUuVElNRSwgRGF0YVR5cGUuVElNRVNUQU1QLCBEYXRhVHlwZS5EQVRFVElNRSwgRGF0YVR5cGUuTE9DQUxEQVRFVElNRV0sIHR5cGUpO1xufTtcbmV4cG9ydCBjb25zdCBnZXRWYWxpZEpTT04gPSAoY29udGVudDogYW55KSA9PiB7XG4gICAgaWYgKCFjb250ZW50KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEludFZhbHVlID0gcGFyc2VJbnQoY29udGVudCwgMTApO1xuICAgICAgICAvKm9idGFpbmluZyBqc29uIGZyb20gZWRpdG9yIGNvbnRlbnQgc3RyaW5nKi9cbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KGNvbnRlbnQpIHx8ICFpc05hTihwYXJzZWRJbnRWYWx1ZSkgPyBjb250ZW50IDogSlNPTi5wYXJzZShjb250ZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qdGVybWluYXRpbmcgZXhlY3V0aW9uIGlmIG5ldyB2YXJpYWJsZSBvYmplY3QgaXMgbm90IHZhbGlkIGpzb24uKi9cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHhtbFRvSnNvbiA9ICh4bWxTdHJpbmc6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHgyanNPYmogPSBuZXcgWDJKUyh7ICdlbXB0eU5vZGVGb3JtJzogJ2NvbnRlbnQnLCAnYXR0cmlidXRlUHJlZml4JzogJycsICdlbmFibGVUb1N0cmluZ0Z1bmMnOiBmYWxzZSB9KTtcbiAgICBsZXQganNvbiA9IHgyanNPYmoueG1sMmpzKHhtbFN0cmluZyk7XG4gICAgaWYgKGpzb24pIHtcbiAgICAgICAganNvbiA9IF8uZ2V0KGpzb24sIE9iamVjdC5rZXlzKGpzb24pWzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59O1xuLypcbiAqIFV0aWwgbWV0aG9kIHRvIHJlcGxhY2UgcGF0dGVybnMgaW4gc3RyaW5nIHdpdGggb2JqZWN0IGtleXMgb3IgYXJyYXkgdmFsdWVzXG4gKiBFeGFtcGxlczpcbiAqIFV0aWxzLnJlcGxhY2UoJ0hlbGxvLCAke2ZpcnN0fSAke2xhc3R9ICEnLCB7Zmlyc3Q6ICd3YXZlbWFrZXInLCBsYXN0OiAnbmcnfSkgLS0+IEhlbGxvLCB3YXZlbWFrZXIgbmdcbiAqIFV0aWxzLnJlcGxhY2UoJ0hlbGxvLCAkezB9ICR7MX0gIScsIFsnd2F2ZW1ha2VyJywnbmcnXSkgLS0+IEhlbGxvLCB3YXZlbWFrZXIgbmdcbiAqIEV4YW1wbGVzIGlmIHBhcnNlRXJyb3IgaXMgdHJ1ZTpcbiAqIFV0aWxzLnJlcGxhY2UoJ0hlbGxvLCB7MH0gezF9ICEnLCBbJ3dhdmVtYWtlcicsJ25nJ10pIC0tPiBIZWxsbywgd2F2ZW1ha2VyIG5nXG4gKi9cbmV4cG9ydCBjb25zdCByZXBsYWNlID0gKHRlbXBsYXRlOiBhbnksIG1hcDogYW55LCBwYXJzZUVycm9yPzogYm9vbGVhbikgPT4ge1xuICAgIGxldCByZWdFeCA9IFJFR0VYLlJFUExBQ0VfUEFUVEVSTjtcbiAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgcmVnRXggPSAvXFx7KFteXFx9XSspXFx9L2c7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UocmVnRXgsIGZ1bmN0aW9uIChtYXRjaDogYW55LCBrZXk6IGFueSkge1xuICAgICAgICByZXR1cm4gXy5nZXQobWFwLCBrZXkpO1xuICAgIH0pO1xufTtcbi8qKlxuICogcHJlcGFyZSBhIGJsb2Igb2JqZWN0IGJhc2VkIG9uIHRoZSBjb250ZW50IGFuZCBjb250ZW50IHR5cGUgcHJvdmlkZWRcbiAqIGlmIGNvbnRlbnQgaXMgYmxvYiBpdHNlbGYsIHNpbXBseSByZXR1cm5zIGl0IGJhY2tcbiAqIEBwYXJhbSB2YWxcbiAqIEBwYXJhbSB2YWxDb250ZW50VHlwZVxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRCbG9iID0gKHZhbDogYW55LCB2YWxDb250ZW50VHlwZT86IGFueSkgPT4ge1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGNvbnN0IGpzb25WYWwgPSBnZXRWYWxpZEpTT04odmFsKTtcbiAgICBpZiAoanNvblZhbCAmJiBqc29uVmFsIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIHZhbCA9IG5ldyBCbG9iKFtKU09OLnN0cmluZ2lmeShqc29uVmFsKV0sIHsgdHlwZTogdmFsQ29udGVudFR5cGUgfHwgJ2FwcGxpY2F0aW9uL2pzb24nIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ldyBCbG9iKFt2YWxdLCB7IHR5cGU6IHZhbENvbnRlbnRUeXBlIHx8ICd0ZXh0L3BsYWluJyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGRlZXAgY2xvbmVkIHJlcGxpY2Egb2YgdGhlIHBhc3NlZCBvYmplY3QvYXJyYXlcbiAqIEBwYXJhbSBvYmplY3Qgb2JqZWN0L2FycmF5IHRvIGNsb25lXG4gKiBAcmV0dXJucyBhIGNsb25lIG9mIHRoZSBwYXNzZWQgb2JqZWN0XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRDbG9uZWRPYmplY3QgPSAob2JqZWN0OiBhbnkpID0+IHtcbiAgICByZXR1cm4gXy5jbG9uZURlZXAob2JqZWN0KTtcbn07XG4vKipcbiAqIHRoaXMgbWV0aG9kIGNoZWNrcyBpZiBhIGdpdmVuIHN0cmluZyBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gc3RyaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBzdHJpbmdTdGFydHNXaXRoID0gKHN0cjogc3RyaW5nLCBzdGFydHNXaXRoOiBzdHJpbmcsIGlnbm9yZUNhc2U/OiBib29sZWFuKTogYm9vbGVhbiA9PiB7XG4gICAgaWYgKCFzdHIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHJlZ0V4ID0gbmV3IFJlZ0V4cCgnXicgKyBzdGFydHNXaXRoLCBpZ25vcmVDYXNlID8gJ2knIDogJycpO1xuXG4gICAgcmV0dXJuIHJlZ0V4LnRlc3Qoc3RyKTtcbn07XG4vKmZ1bmN0aW9uIHRvIGNoZWNrIGlmIGZuIGlzIGEgZnVuY3Rpb24gYW5kIHRoZW4gZXhlY3V0ZSovXG5leHBvcnQgZnVuY3Rpb24gdHJpZ2dlckZuKGZuOiBhbnksIC4uLmFyZ21udHM6IGFueSkge1xuICAgIC8qIFVzZSBvZiBzbGljZSBvbiBhcmd1bWVudHMgd2lsbCBtYWtlIHRoaXMgZnVuY3Rpb24gbm90IG9wdGltaXphYmxlXG4gICAgKiBodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkL3dpa2kvT3B0aW1pemF0aW9uLWtpbGxlcnMjMzItbGVha2luZy1hcmd1bWVudHNcbiAgICAqICovXG5cbiAgICBsZXQgc3RhcnQgPSAxO1xuICAgIGNvbnN0IGxlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gc3RhcnQpO1xuICAgIGZvciAoc3RhcnQ7IHN0YXJ0IDwgbGVuOyBzdGFydCsrKSB7XG4gICAgICAgIGFyZ3Nbc3RhcnQgLSAxXSA9IGFyZ3VtZW50c1tzdGFydF07XG4gICAgfVxuXG4gICAgaWYgKF8uaXNGdW5jdGlvbihmbikpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbn1cblxuLypcbiAqIFV0aWwgbWV0aG9kIHRvIGZpbmQgdGhlIHZhbHVlIG9mIGEga2V5IGluIHRoZSBvYmplY3RcbiAqIGlmIGtleSBub3QgZm91bmQgYW5kIGNyZWF0ZSBpcyB0cnVlLCBhbiBvYmplY3QgaXMgY3JlYXRlZCBhZ2FpbnN0IHRoYXQgbm9kZVxuICogRXhhbXBsZXM6XG4gKiB2YXIgYSA9IHtcbiAqICBiOiB7XG4gKiAgICAgIGMgOiB7XG4gKiAgICAgICAgICBkOiAndGVzdCdcbiAqICAgICAgfVxuICogIH1cbiAqIH1cbiAqIFV0aWxzLmZpbmRWYWx1ZShhLCAnYi5jLmQnKSAtLT4gJ3Rlc3QnXG4gKiBVdGlscy5maW5kVmFsdWUoYSwgJ2IuYycpIC0tPiB7ZDogJ3Rlc3QnfVxuICogVXRpbHMuZmluZFZhbHVlKGEsICdlJykgLS0+IHVuZGVmaW5lZFxuICogVXRpbHMuZmluZFZhbHVlKGEsICdlJywgdHJ1ZSkgLS0+IHt9IGFuZCBhIHdpbGwgYmVjb21lOlxuICoge1xuICogICBiOiB7XG4gKiAgICAgIGMgOiB7XG4gKiAgICAgICAgICBkOiAndGVzdCdcbiAqICAgICAgfVxuICogIH0sXG4gKiAgZToge1xuICogIH1cbiAqIH1cbiAqL1xuZXhwb3J0IGNvbnN0IGZpbmRWYWx1ZU9mID0gKG9iajogYW55LCBrZXk6IGFueSwgY3JlYXRlPzogYW55KSA9PiB7XG5cbiAgICBpZiAoIW9iaiB8fCAha2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWNyZWF0ZSkge1xuICAgICAgICByZXR1cm4gXy5nZXQob2JqLCBrZXkpO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcnRzID0ga2V5LnNwbGl0KCcuJyksXG4gICAgICAgIGtleXM6IGFueSA9IFtdO1xuXG4gICAgbGV0IHNraXBQcm9jZXNzaW5nO1xuXG4gICAgcGFydHMuZm9yRWFjaCgocGFydDogYW55KSA9PiB7XG4gICAgICAgIGlmICghcGFydHMubGVuZ3RoKSB7IC8vIGlmIHRoZSBwYXJ0IG9mIGEga2V5IGlzIG5vdCB2YWxpZCwgc2tpcCB0aGUgcHJvY2Vzc2luZy5cbiAgICAgICAgICAgIHNraXBQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN1YlBhcnRzID0gcGFydC5tYXRjaCgvXFx3Ky9nKTtcbiAgICAgICAgbGV0IHN1YlBhcnQ7XG5cbiAgICAgICAgd2hpbGUgKHN1YlBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3ViUGFydCA9IHN1YlBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICBrZXlzLnB1c2goeyAna2V5Jzogc3ViUGFydCwgJ3ZhbHVlJzogc3ViUGFydHMubGVuZ3RoID8gW10gOiB7fSB9KTsgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gY3JlYXRlIGFuIGFycmF5IG9yIGFuIG9iamVjdFxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoc2tpcFByb2Nlc3NpbmcpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBrZXlzLmZvckVhY2goKF9rZXk6IGFueSkgPT4ge1xuICAgICAgICBsZXQgdGVtcE9iaiA9IG9ialtfa2V5LmtleV07XG4gICAgICAgIGlmICghaXNPYmplY3QodGVtcE9iaikpIHtcbiAgICAgICAgICAgIHRlbXBPYmogPSBnZXRWYWxpZEpTT04odGVtcE9iaik7XG4gICAgICAgICAgICBpZiAoIXRlbXBPYmopIHtcbiAgICAgICAgICAgICAgICB0ZW1wT2JqID0gX2tleS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvYmpbX2tleS5rZXldID0gdGVtcE9iajtcbiAgICAgICAgb2JqID0gdGVtcE9iajtcbiAgICB9KTtcblxuICAgIHJldHVybiBvYmo7XG59O1xuIiwiaW1wb3J0IHsgZ2V0Q2xvbmVkT2JqZWN0LCByZW1vdmVFeHRyYVNsYXNoZXMgfSBmcm9tICcuLi91dGlscyc7XG5cbmltcG9ydCB7IFZBUklBQkxFX1VSTFMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvdmFyaWFibGVzLmNvbnN0YW50cyc7XG5pbXBvcnQgeyBodHRwU2VydmljZSB9IGZyb20gJy4vdmFyaWFibGVzLnV0aWxzJztcblxuZGVjbGFyZSBjb25zdCBfO1xuXG5jb25zdCBpc1N0dWRpb01vZGUgPSBmYWxzZTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQ29uZmlnID0gKHNlcnZpY2VQYXJhbXM6IGFueSk6IGFueSA9PiB7XG5cbiAgICBsZXQgdmFsLCBwYXJhbSwgY29uZmlnO1xuICAgIGNvbnN0IHVybFBhcmFtcyA9IHNlcnZpY2VQYXJhbXMudXJsUGFyYW1zO1xuXG4gICAgLypnZXQgdGhlIGNvbmZpZyBvdXQgb2YgYmFzZVNlcnZpY2VNYW5hZ2VyKi9cbiAgICBpZiAoVkFSSUFCTEVfVVJMUy5oYXNPd25Qcm9wZXJ0eShzZXJ2aWNlUGFyYW1zLnRhcmdldCkgJiYgVkFSSUFCTEVfVVJMU1tzZXJ2aWNlUGFyYW1zLnRhcmdldF0uaGFzT3duUHJvcGVydHkoc2VydmljZVBhcmFtcy5hY3Rpb24pKSB7XG4gICAgICAgIGNvbmZpZyA9IGdldENsb25lZE9iamVjdChWQVJJQUJMRV9VUkxTW3NlcnZpY2VQYXJhbXMudGFyZ2V0XVtzZXJ2aWNlUGFyYW1zLmFjdGlvbl0pO1xuXG4gICAgICAgIC8qVG8gaGFuZGxlIGR5bmFtaWMgdXJscywgYXBwZW5kIHRoZSBzZXJ2aWNlUGFyYW1zLmNvbmZpZy51cmwgd2l0aCB0aGUgc3RhdGljIHVybChpLmUuLCBjb25maWcudXJsKSovXG4gICAgICAgIGlmIChzZXJ2aWNlUGFyYW1zLmNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnLnVybCA9IChzZXJ2aWNlUGFyYW1zLmNvbmZpZy51cmwgfHwgJycpICsgY29uZmlnLnVybDtcbiAgICAgICAgICAgIGNvbmZpZy5tZXRob2QgPSBzZXJ2aWNlUGFyYW1zLmNvbmZpZy5tZXRob2QgfHwgY29uZmlnLm1ldGhvZDtcbiAgICAgICAgICAgIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG5cbiAgICAgICAgICAgIC8vIFRPRE9bU2h1YmhhbV0gLSBjaGFuZ2UgdG8gZm9yIC0gb2ZcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNlcnZpY2VQYXJhbXMuY29uZmlnLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBzZXJ2aWNlUGFyYW1zLmNvbmZpZy5oZWFkZXJzW2tleV07XG4gICAgICAgICAgICAgICAgY29uZmlnLmhlYWRlcnNba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiBjaGVjayBmb3IgdXJsIHBhcmFtZXRlcnMgdG8gcmVwbGFjZSB0aGUgdXJsICovXG4gICAgICAgIGlmICh1cmxQYXJhbXMpIHtcbiAgICAgICAgICAgIGZvciAocGFyYW0gaW4gdXJsUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVybFBhcmFtcy5oYXNPd25Qcm9wZXJ0eShwYXJhbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdXJsUGFyYW1zW3BhcmFtXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHZhbCkgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcudXJsID0gY29uZmlnLnVybC5yZXBsYWNlKG5ldyBSZWdFeHAoJzonICsgcGFyYW0sICdnJyksIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBjaGVjayBmb3IgZGF0YSAqL1xuICAgICAgICBpZiAoc2VydmljZVBhcmFtcy5wYXJhbXMpIHtcbiAgICAgICAgICAgIGNvbmZpZy5wYXJhbXMgPSBzZXJ2aWNlUGFyYW1zLnBhcmFtcztcbiAgICAgICAgfVxuICAgICAgICAvKiBjaGVjayBmb3IgZGF0YSAqL1xuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoc2VydmljZVBhcmFtcy5kYXRhKSkge1xuICAgICAgICAgICAgY29uZmlnLmRhdGEgPSBzZXJ2aWNlUGFyYW1zLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgLyogY2hlY2sgZm9yIGRhdGEgcGFyYW1ldGVycywgd3JpdHRlbiB0byBzdXBwb3J0IG9sZCBzZXJ2aWNlIGNhbGxzICguanNvbiBjYWxscykgKi9cbiAgICAgICAgaWYgKHNlcnZpY2VQYXJhbXMuZGF0YVBhcmFtcykge1xuICAgICAgICAgICAgY29uZmlnLmRhdGEucGFyYW1zID0gc2VydmljZVBhcmFtcy5kYXRhUGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIC8qIGNoZWNrIGZvciBoZWFkZXJzICovXG4gICAgICAgIGlmIChzZXJ2aWNlUGFyYW1zLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIGNvbmZpZy5oZWFkZXJzID0gc2VydmljZVBhcmFtcy5oZWFkZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogc2V0IGV4dHJhIGNvbmZpZyBmbGFncyAqL1xuICAgICAgICBjb25maWcuYnlQYXNzUmVzdWx0ICAgID0gc2VydmljZVBhcmFtcy5ieVBhc3NSZXN1bHQ7XG4gICAgICAgIGNvbmZpZy5pc0RpcmVjdENhbGwgICAgPSBzZXJ2aWNlUGFyYW1zLmlzRGlyZWN0Q2FsbDtcbiAgICAgICAgY29uZmlnLmlzRXh0VVJMICAgICAgICA9IHNlcnZpY2VQYXJhbXMuaXNFeHRVUkw7XG4gICAgICAgIGNvbmZpZy5wcmV2ZW50TXVsdGlwbGUgPSBzZXJ2aWNlUGFyYW1zLnByZXZlbnRNdWx0aXBsZTtcbiAgICAgICAgY29uZmlnLnJlc3BvbnNlVHlwZSAgICA9IHNlcnZpY2VQYXJhbXMucmVzcG9uc2VUeXBlO1xuXG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVDb25uZWN0aW9uUGFyYW1zID0gKHBhcmFtcywgYWN0aW9uKSA9PiB7XG4gICAgbGV0IGNvbm5lY3Rpb25QYXJhbXMsXG4gICAgICAgIHVybFBhcmFtcyxcbiAgICAgICAgcmVxdWVzdERhdGE7XG4gICAgcmVxdWVzdERhdGEgPSBwYXJhbXMuZGF0YTtcblxuICAgIHVybFBhcmFtcyA9IHtcbiAgICAgICAgcHJvamVjdElEICAgICAgICA6IHBhcmFtcy5wcm9qZWN0SUQsXG4gICAgICAgIHNlcnZpY2UgICAgICAgICAgOiAhXy5pc1VuZGVmaW5lZChwYXJhbXMuc2VydmljZSkgPyBwYXJhbXMuc2VydmljZSA6ICdzZXJ2aWNlcycsXG4gICAgICAgIGRhdGFNb2RlbE5hbWUgICAgOiBwYXJhbXMuZGF0YU1vZGVsTmFtZSxcbiAgICAgICAgZW50aXR5TmFtZSAgICAgICA6IHBhcmFtcy5lbnRpdHlOYW1lLFxuICAgICAgICBxdWVyeU5hbWUgICAgICAgIDogcGFyYW1zLnF1ZXJ5TmFtZSxcbiAgICAgICAgcXVlcnlQYXJhbXMgICAgICA6IHBhcmFtcy5xdWVyeVBhcmFtcyxcbiAgICAgICAgcHJvY2VkdXJlTmFtZSAgICA6IHBhcmFtcy5wcm9jZWR1cmVOYW1lLFxuICAgICAgICBwcm9jZWR1cmVQYXJhbXMgIDogcGFyYW1zLnByb2NlZHVyZVBhcmFtcyxcbiAgICAgICAgaWQgICAgICAgICAgICAgICA6IHBhcmFtcy5pZCxcbiAgICAgICAgcmVsYXRlZEZpZWxkTmFtZSA6IHBhcmFtcy5yZWxhdGVkRmllbGROYW1lLFxuICAgICAgICBwYWdlICAgICAgICAgICAgIDogcGFyYW1zLnBhZ2UsXG4gICAgICAgIHNpemUgICAgICAgICAgICAgOiBwYXJhbXMuc2l6ZSxcbiAgICAgICAgc29ydCAgICAgICAgICAgICA6IHBhcmFtcy5zb3J0XG4gICAgfTtcbiAgICBjb25uZWN0aW9uUGFyYW1zID0ge1xuICAgICAgICB0YXJnZXQgICAgOiAnREFUQUJBU0UnLFxuICAgICAgICBhY3Rpb24gICAgOiBhY3Rpb24sXG4gICAgICAgIHVybFBhcmFtcyA6IHVybFBhcmFtcyxcbiAgICAgICAgZGF0YSAgICAgIDogcmVxdWVzdERhdGEgfHwgJycsXG4gICAgICAgIGNvbmZpZyAgICA6IHtcbiAgICAgICAgICAgICd1cmwnIDogcGFyYW1zLnVybFxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbm5lY3Rpb25QYXJhbXMgPSBwYXJzZUNvbmZpZyhjb25uZWN0aW9uUGFyYW1zKTtcbiAgICAvLyBUT0RPOiBSZW1vdmUgYWZ0ZXIgYmFja2VuZCBmaXhcbiAgICBjb25uZWN0aW9uUGFyYW1zLnVybCA9IHJlbW92ZUV4dHJhU2xhc2hlcyhjb25uZWN0aW9uUGFyYW1zLnVybCk7XG5cbiAgICByZXR1cm4gY29ubmVjdGlvblBhcmFtcztcbn07XG5cbmNvbnN0IGluaXRpYXRlQWN0aW9uID0gKGFjdGlvbiwgcGFyYW1zLCBzdWNjZXNzQ2FsbGJhY2s/LCBmYWlsdXJlQ2FsbGJhY2s/LCBub3Byb3h5PykgPT4ge1xuICAgIGxldCBjb25uZWN0aW9uUGFyYW1zLFxuICAgICAgICB1cmxQYXJhbXMsXG4gICAgICAgIHJlcXVlc3REYXRhLFxuICAgICAgICBwYXJhbSxcbiAgICAgICAgdmFsLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGh0dHBEZXRhaWxzO1xuXG4gICAgLypcbiAgICBjb25maWcgICAgICA9IGdldENsb25lZE9iamVjdChjb25maWdbYWN0aW9uXSk7XG4gICAgaGVhZGVycyAgICAgPSBjb25maWcgJiYgY29uZmlnLmhlYWRlcnM7XG5cbiAgICByZXF1ZXN0RGF0YSA9IHBhcmFtcy5kYXRhO1xuXG4gICAgdXJsUGFyYW1zID0ge1xuICAgICAgICBwcm9qZWN0SUQgICAgICAgIDogcGFyYW1zLnByb2plY3RJRCxcbiAgICAgICAgc2VydmljZSAgICAgICAgICA6ICFfLmlzVW5kZWZpbmVkKHBhcmFtcy5zZXJ2aWNlKSA/IHBhcmFtcy5zZXJ2aWNlIDogJ3NlcnZpY2VzJyxcbiAgICAgICAgZGF0YU1vZGVsTmFtZSAgICA6IHBhcmFtcy5kYXRhTW9kZWxOYW1lLFxuICAgICAgICBlbnRpdHlOYW1lICAgICAgIDogcGFyYW1zLmVudGl0eU5hbWUsXG4gICAgICAgIHF1ZXJ5TmFtZSAgICAgICAgOiBwYXJhbXMucXVlcnlOYW1lLFxuICAgICAgICBxdWVyeVBhcmFtcyAgICAgIDogcGFyYW1zLnF1ZXJ5UGFyYW1zLFxuICAgICAgICBwcm9jZWR1cmVOYW1lICAgIDogcGFyYW1zLnByb2NlZHVyZU5hbWUsXG4gICAgICAgIHByb2NlZHVyZVBhcmFtcyAgOiBwYXJhbXMucHJvY2VkdXJlUGFyYW1zLFxuICAgICAgICBpZCAgICAgICAgICAgICAgIDogcGFyYW1zLmlkLFxuICAgICAgICByZWxhdGVkRmllbGROYW1lIDogcGFyYW1zLnJlbGF0ZWRGaWVsZE5hbWUsXG4gICAgICAgIHBhZ2UgICAgICAgICAgICAgOiBwYXJhbXMucGFnZSxcbiAgICAgICAgc2l6ZSAgICAgICAgICAgICA6IHBhcmFtcy5zaXplLFxuICAgICAgICBzb3J0ICAgICAgICAgICAgIDogcGFyYW1zLnNvcnRcbiAgICB9O1xuICAgICovXG4gICAgaWYgKHBhcmFtcy51cmwgJiYgaXNTdHVkaW9Nb2RlICYmICFub3Byb3h5KSB7XG4vKlxuICAgICAgICAvISogQ2hlY2sgZm9yIHVybCBwYXJhbWV0ZXJzIHRvIHJlcGxhY2UgdGhlIFVSTC5cbiAgICAgICAgICogU28gdGhlIHZhcmlhYmxlIHBhcmFtZXRlcnMgaW4gdGhlIFVSTCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBhY3R1YWwgcGFyYW1ldGVyIHZhbHVlcy4qIS9cbiAgICAgICAgaWYgKHVybFBhcmFtcykge1xuICAgICAgICAgICAgZm9yIChwYXJhbSBpbiB1cmxQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodXJsUGFyYW1zLmhhc093blByb3BlcnR5KHBhcmFtKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB1cmxQYXJhbXNbcGFyYW1dO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQodmFsKSAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy51cmwgPSBjb25maWcudXJsLnJlcGxhY2UobmV3IFJlZ0V4cCgnOicgKyBwYXJhbSwgJ2cnKSwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoZWFkZXJzID0gaGVhZGVycyB8fCB7fTtcbiAgICAgICAgaGVhZGVycy5za2lwU2VjdXJpdHkgPSAndHJ1ZSc7XG4gICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gaGVhZGVyc1snQ29udGVudC1UeXBlJ10gfHwgJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAvISooISRyb290U2NvcGUucHJlZmVyZW5jZXMud29ya3NwYWNlLmxvYWRYRG9tYWluQXBwRGF0YVVzaW5nUHJveHkgaXMgYWRkZWQgaW4gZW5kcG9pbnRBZGRyZXNzIHRvIGRpZmZlcmVudGlhdGUgZGVza3RvcCBmcm9tIHNhYXMqIS9cbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3Rlc3RSdW5RdWVyeScpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaHR0cERldGFpbHMgPSB7XG4gICAgICAgICAgICAgICAgJ2VuZHBvaW50QWRkcmVzcycgICA6ICR3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyAoISRyb290U2NvcGUucHJlZmVyZW5jZXMud29ya3NwYWNlLmxvYWRYRG9tYWluQXBwRGF0YVVzaW5nUHJveHkgPyAoJy8vJyArICR3aW5kb3cubG9jYXRpb24uaG9zdCkgOiAnJykgKyBwYXJhbXMudXJsICsgY29uZmlnLnVybCxcbiAgICAgICAgICAgICAgICAnbWV0aG9kJyAgICAgICAgICAgIDogY29uZmlnLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAnY29udGVudC1UeXBlJyAgICAgIDogJ211bHRpcGFydC9mb3JtLWRhdGEnLFxuICAgICAgICAgICAgICAgICdoZWFkZXJzJyAgICAgICAgICAgOiBoZWFkZXJzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVxdWVzdERhdGEuYXBwZW5kKFNXQUdHRVJfQ09OU1RBTlRTLldNX0hUVFBfSlNPTiwgbmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KGh0dHBEZXRhaWxzKV0sIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25QYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgJ2RhdGEnOiByZXF1ZXN0RGF0YSxcbiAgICAgICAgICAgICAgICAnaGVhZGVycyc6IGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgJ3VybFBhcmFtcycgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdElEOiAkcm9vdFNjb3BlLnByb2plY3QuaWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29ubmVjdGlvblBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAnZGF0YSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2VuZHBvaW50QWRkcmVzcycgICA6ICR3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyAoISRyb290U2NvcGUucHJlZmVyZW5jZXMud29ya3NwYWNlLmxvYWRYRG9tYWluQXBwRGF0YVVzaW5nUHJveHkgPyAoJy8vJyArICR3aW5kb3cubG9jYXRpb24uaG9zdCkgOiAnJykgKyBwYXJhbXMudXJsICsgY29uZmlnLnVybCxcbiAgICAgICAgICAgICAgICAgICAgJ21ldGhvZCcgICAgICAgICAgICA6IGNvbmZpZy5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICdyZXF1ZXN0Qm9keScgICAgICAgOiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0RGF0YSksXG4gICAgICAgICAgICAgICAgICAgICdoZWFkZXJzJyAgICAgICAgICAgOiBoZWFkZXJzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAndXJsUGFyYW1zJyAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0SUQ6ICRyb290U2NvcGUucHJvamVjdC5pZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgV2ViU2VydmljZS50ZXN0UmVzdFNlcnZpY2UoY29ubmVjdGlvblBhcmFtcywgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkRGF0YSA9IGdldFZhbGlkSlNPTihyZXNwb25zZS5yZXNwb25zZUJvZHkpLFxuICAgICAgICAgICAgICAgIGVyck1zZyxcbiAgICAgICAgICAgICAgICBsb2NhbGVPYmplY3Q7XG4gICAgICAgICAgICBpZiAocGFyc2VkRGF0YS5oYXNPd25Qcm9wZXJ0eSgncmVzdWx0JykpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRm4oc3VjY2Vzc0NhbGxiYWNrLCBwYXJzZWREYXRhLnJlc3VsdCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlZERhdGEuaGFzT3duUHJvcGVydHkoJ2Vycm9yJykpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRm4oZmFpbHVyZUNhbGxiYWNrLCAocGFyc2VkRGF0YS5lcnJvciAmJiBwYXJzZWREYXRhLmVycm9yLm1lc3NhZ2UpIHx8IHBhcnNlZERhdGEuZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJzZWREYXRhLmhhc093blByb3BlcnR5KCdlcnJvckRldGFpbHMnKSkge1xuICAgICAgICAgICAgICAgIGxvY2FsZU9iamVjdCA9ICRyb290U2NvcGUubG9jYWxlIHx8ICRyb290U2NvcGUuYXBwTG9jYWxlO1xuICAgICAgICAgICAgICAgIGVyck1zZyA9IGdldENsb25lZE9iamVjdChsb2NhbGVPYmplY3RbcGFyc2VkRGF0YS5lcnJvckRldGFpbHMuY29kZV0pO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJGbihmYWlsdXJlQ2FsbGJhY2ssIHJlcGxhY2UoZXJyTXNnLCBwYXJzZWREYXRhLmVycm9yRGV0YWlscy5kYXRhKSB8fCBwYXJzZWREYXRhLmVycm9yRGV0YWlscyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJGbihzdWNjZXNzQ2FsbGJhY2ssIHBhcnNlZERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmYWlsdXJlQ2FsbGJhY2spOyovXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29ubmVjdGlvblBhcmFtcyA9IGdlbmVyYXRlQ29ubmVjdGlvblBhcmFtcyhwYXJhbXMsIGFjdGlvbik7XG4gICAgICAgIHBhcmFtcy5vcGVyYXRpb24gPSBhY3Rpb247XG4gICAgICAgIHJldHVybiBodHRwU2VydmljZS5zZW5kQ2FsbEFzT2JzZXJ2YWJsZSh7XG4gICAgICAgICAgICB1cmw6IGNvbm5lY3Rpb25QYXJhbXMudXJsLFxuICAgICAgICAgICAgbWV0aG9kOiBjb25uZWN0aW9uUGFyYW1zLm1ldGhvZCxcbiAgICAgICAgICAgIGRhdGE6IGNvbm5lY3Rpb25QYXJhbXMuZGF0YSxcbiAgICAgICAgICAgIGhlYWRlcnM6IGNvbm5lY3Rpb25QYXJhbXMuaGVhZGVyc1xuICAgICAgICB9LCBwYXJhbXMpO1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBMVlNlcnZpY2UgPSB7XG4gICAgc2VhcmNoVGFibGVEYXRhV2l0aFF1ZXJ5OiAocGFyYW1zLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykgPT4gaW5pdGlhdGVBY3Rpb24oJ3NlYXJjaFRhYmxlRGF0YVdpdGhRdWVyeScsIHBhcmFtcywgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spLFxuICAgIGV4ZWN1dGVBZ2dyZWdhdGVRdWVyeTogKHBhcmFtcywgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spID0+IGluaXRpYXRlQWN0aW9uKCdleGVjdXRlQWdncmVnYXRlUXVlcnknLCBwYXJhbXMsIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSxcbiAgICBzZWFyY2hUYWJsZURhdGE6IChwYXJhbXMsIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSA9PiBpbml0aWF0ZUFjdGlvbignc2VhcmNoVGFibGVEYXRhJywgcGFyYW1zLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayksXG4gICAgcmVhZFRhYmxlRGF0YTogKHBhcmFtcywgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spID0+IGluaXRpYXRlQWN0aW9uKCdyZWFkVGFibGVEYXRhJywgcGFyYW1zLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayksXG4gICAgaW5zZXJ0VGFibGVEYXRhOiAocGFyYW1zLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykgPT4gaW5pdGlhdGVBY3Rpb24oJ2luc2VydFRhYmxlRGF0YScsIHBhcmFtcywgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spLFxuICAgIGluc2VydE11bHRpUGFydFRhYmxlRGF0YTogKHBhcmFtcywgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spID0+IGluaXRpYXRlQWN0aW9uKCdpbnNlcnRNdWx0aVBhcnRUYWJsZURhdGEnLCBwYXJhbXMsIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSxcbiAgICB1cGRhdGVUYWJsZURhdGE6IChwYXJhbXMsIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSA9PiBpbml0aWF0ZUFjdGlvbigndXBkYXRlVGFibGVEYXRhJywgcGFyYW1zLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayksXG4gICAgdXBkYXRlQ29tcG9zaXRlVGFibGVEYXRhOiAocGFyYW1zLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykgPT4gaW5pdGlhdGVBY3Rpb24oJ3VwZGF0ZUNvbXBvc2l0ZVRhYmxlRGF0YScsIHBhcmFtcywgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spLFxuICAgIHBlcmlvZFVwZGF0ZUNvbXBvc2l0ZVRhYmxlRGF0YTogKHBhcmFtcywgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spID0+IGluaXRpYXRlQWN0aW9uKCdwZXJpb2RVcGRhdGVDb21wb3NpdGVUYWJsZURhdGEnLCBwYXJhbXMsIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSxcbiAgICB1cGRhdGVNdWx0aVBhcnRUYWJsZURhdGE6IChwYXJhbXMsIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSA9PiBpbml0aWF0ZUFjdGlvbigndXBkYXRlTXVsdGlQYXJ0VGFibGVEYXRhJywgcGFyYW1zLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayksXG4gICAgdXBkYXRlTXVsdGlQYXJ0Q29tcG9zaXRlVGFibGVEYXRhOiAocGFyYW1zLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykgPT4gaW5pdGlhdGVBY3Rpb24oJ3VwZGF0ZU11bHRpUGFydENvbXBvc2l0ZVRhYmxlRGF0YScsIHBhcmFtcywgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spLFxuICAgIGRlbGV0ZVRhYmxlRGF0YTogKHBhcmFtcywgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spID0+IGluaXRpYXRlQWN0aW9uKCdkZWxldGVUYWJsZURhdGEnLCBwYXJhbXMsIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSxcbiAgICBkZWxldGVDb21wb3NpdGVUYWJsZURhdGE6IChwYXJhbXMsIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSA9PiBpbml0aWF0ZUFjdGlvbignZGVsZXRlQ29tcG9zaXRlVGFibGVEYXRhJywgcGFyYW1zLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayksXG4gICAgcGVyaW9kRGVsZXRlQ29tcG9zaXRlVGFibGVEYXRhOiAocGFyYW1zLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykgPT4gaW5pdGlhdGVBY3Rpb24oJ3BlcmlvZERlbGV0ZUNvbXBvc2l0ZVRhYmxlRGF0YScsIHBhcmFtcywgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spLFxuICAgIGV4cG9ydFRhYmxlRGF0YTogcGFyYW1zID0+IGluaXRpYXRlQWN0aW9uKCdleHBvcnRUYWJsZURhdGEnLCBwYXJhbXMpLFxuICAgIGdldERpc3RpbmN0RGF0YUJ5RmllbGRzOiBwYXJhbXMgPT4gaW5pdGlhdGVBY3Rpb24oJ2dldERpc3RpbmN0RGF0YUJ5RmllbGRzJywgcGFyYW1zKSxcbiAgICBjb3VudFRhYmxlRGF0YVdpdGhRdWVyeTogKHBhcmFtcywgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spID0+IGluaXRpYXRlQWN0aW9uKCdjb3VudFRhYmxlRGF0YVdpdGhRdWVyeScsIHBhcmFtcywgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spXG59O1xuIiwiaW1wb3J0IHsgaGFzQ29yZG92YSwgZ2V0Q2xvbmVkT2JqZWN0LCBpc0RhdGVUaW1lVHlwZSwgaXNEZWZpbmVkLCByZXBsYWNlLCB0cmlnZ2VyRm4sIGlzTnVtYmVyVHlwZSB9IGZyb20gXCIuLi8uLi91dGlsL3V0aWxzXCI7XG5pbXBvcnQgeyAkcm9vdFNjb3BlLCBEQl9DT05TVEFOVFMsIFNXQUdHRVJfQ09OU1RBTlRTIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL3ZhcmlhYmxlcy5jb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0RXZhbHVhdGVkT3JkZXJCeSwgZm9ybWF0RGF0ZSB9IGZyb20gJy4vdmFyaWFibGVzLnV0aWxzJztcblxuZGVjbGFyZSBjb25zdCBfLCBtb21lbnQ7XG5cbmV4cG9ydCBjbGFzcyBMaXZlVmFyaWFibGVVdGlscyB7XG5cbiAgICBzdGF0aWMgaXNDb21wb3NpdGVLZXkocHJpbWFyeUtleSkge1xuICAgICAgICByZXR1cm4gIXByaW1hcnlLZXkgfHwgKHByaW1hcnlLZXkgJiYgKCFwcmltYXJ5S2V5Lmxlbmd0aCB8fCBwcmltYXJ5S2V5Lmxlbmd0aCA+IDEpKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNOb1ByaW1hcnlLZXkocHJpbWFyeUtleSkge1xuICAgICAgICByZXR1cm4gKCFwcmltYXJ5S2V5IHx8IChwcmltYXJ5S2V5ICYmICFwcmltYXJ5S2V5Lmxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIHRoZSBVUkwgYmFzZWQgb24gdGhlIHByaW1hcnkga2V5cyBhbmQgdGhlaXIgdmFsdWVzXG4gICAgc3RhdGljIGdldENvbXBvc2l0ZUlEVVJMKHByaW1hcnlLZXlzRGF0YSkge1xuICAgICAgICBsZXQgY29tcG9zaXRlSWQgPSAnJztcbiAgICAgICAgLy8gIExvb3Agb3ZlciB0aGUgJ2NvbXBvc2l0ZUtleXNEYXRhJyBhbmQgY29uc3RydWN0IHRoZSAnY29tcG9zaXRlSWQnLlxuICAgICAgICBfLmZvckVhY2gocHJpbWFyeUtleXNEYXRhLCAocGFyYW1WYWx1ZSwgcGFyYW1OYW1lKSA9PiB7XG4gICAgICAgICAgICBjb21wb3NpdGVJZCArPSBwYXJhbU5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1WYWx1ZSkgKyAnJic7XG4gICAgICAgIH0pO1xuICAgICAgICBjb21wb3NpdGVJZCA9IGNvbXBvc2l0ZUlkLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZUlkO1xuICAgIH1cblxuXG4gICAgLy8gQ2hlY2sgaWYgdGFibGUgaGFzIGJsb2IgY29sdW1uXG4gICAgc3RhdGljIGhhc0Jsb2IodmFyaWFibGUpIHtcbiAgICAgICAgcmV0dXJuIF8uZmluZChfLmdldCh2YXJpYWJsZSwgWydwcm9wZXJ0aWVzTWFwJywgJ2NvbHVtbnMnXSksIHsndHlwZSc6ICdibG9iJ30pO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRQcmltYXJ5S2V5KHZhcmlhYmxlKSB7XG4gICAgICAgIGlmICghdmFyaWFibGUucHJvcGVydGllc01hcCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhcmlhYmxlLnByb3BlcnRpZXNNYXAucHJpbWFyeUZpZWxkcykge1xuICAgICAgICAgICAgcmV0dXJuIHZhcmlhYmxlLnByb3BlcnRpZXNNYXAucHJpbWFyeUZpZWxkcztcbiAgICAgICAgfVxuICAgICAgICAvKk9sZCBwcm9qZWN0cyBkbyBub3QgaGF2ZSBwcmltYXJ5IGZpZWxkcy4gR2V0IHByaW1hcnkga2V5IGZyb20gdGhlIGNvbHVtbnMqL1xuICAgICAgICBjb25zdCBwcmltYXJ5S2V5ID0gW107XG4gICAgICAgIC8qTG9vcCB0aHJvdWdoIHRoZSBwcm9wZXJ0aWVzTWFwIGFuZCBnZXQgdGhlIHByaW1hcnkga2V5IGNvbHVtbi4qL1xuICAgICAgICBfLmZvckVhY2godmFyaWFibGUucHJvcGVydGllc01hcC5jb2x1bW5zLCAoaW5kZXgsIGNvbHVtbikgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbHVtbi5pc1ByaW1hcnlLZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uLmlzUmVsYXRlZCAmJiAoIV8uaW5jbHVkZXMoY29sdW1uLnJlbGF0ZWRGaWVsZE5hbWUsIHByaW1hcnlLZXkpKSkge1xuICAgICAgICAgICAgICAgICAgICBwcmltYXJ5S2V5LnB1c2goY29sdW1uLnJlbGF0ZWRGaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIV8uaW5jbHVkZXMoY29sdW1uLmZpZWxkTmFtZSwgcHJpbWFyeUtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleS5wdXNoKGNvbHVtbi5maWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcmltYXJ5S2V5O1xuICAgIH1cblxuICAgIC8vICBDb25zdHJ1Y3QgdGhlIFVSTCBmb3IgYmxvYiBjb2x1bW5zIGFuZCBzZXQgaXQgaW4gdGhlIGRhdGEsIHNvIHRoYXQgd2lkZ2V0cyBjYW4gdXNlIHRoaXNcbiAgICBzdGF0aWMgcHJvY2Vzc0Jsb2JDb2x1bW5zKHJlc3BvbnNlRGF0YSwgdmFyaWFibGUpIHtcbiAgICAgICAgaWYgKCFyZXNwb25zZURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9iQ29scyA9IF8ubWFwKF8uZmlsdGVyKHZhcmlhYmxlLnByb3BlcnRpZXNNYXAuY29sdW1ucywgeyd0eXBlJzogJ2Jsb2InfSksICdmaWVsZE5hbWUnKSxcbiAgICAgICAgICAgIGRlcGxveWVkVXJsID0gXy50cmltKCRyb290U2NvcGUucHJvamVjdC5kZXBsb3llZFVybCk7XG4gICAgICAgIGxldCBocmVmID0gJycsXG4gICAgICAgICAgICBwcmltYXJ5S2V5cztcblxuICAgICAgICBpZiAoXy5pc0VtcHR5KGJsb2JDb2xzKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0NvcmRvdmEoKSkge1xuICAgICAgICAgICAgaHJlZiArPSBfLmVuZHNXaXRoKGRlcGxveWVkVXJsLCAnLycpID8gZGVwbG95ZWRVcmwgOiBkZXBsb3llZFVybCArICcvJztcbiAgICAgICAgfVxuICAgICAgICBocmVmICs9ICgodmFyaWFibGUuX3ByZWZhYk5hbWUgIT09ICcnICYmIHZhcmlhYmxlLl9wcmVmYWJOYW1lICE9PSB1bmRlZmluZWQpID8gJ3ByZWZhYnMvJyArIHZhcmlhYmxlLl9wcmVmYWJOYW1lIDogJ3NlcnZpY2VzJykgKyAnLycgKyB2YXJpYWJsZS5saXZlU291cmNlICsgJy8nICsgdmFyaWFibGUudHlwZSArICcvJztcbiAgICAgICAgcHJpbWFyeUtleXMgPSB2YXJpYWJsZS5wcm9wZXJ0aWVzTWFwLnByaW1hcnlGaWVsZHMgfHwgdmFyaWFibGUucHJvcGVydGllc01hcC5wcmltYXJ5S2V5cztcbiAgICAgICAgXy5mb3JFYWNoKHJlc3BvbnNlRGF0YSwgZGF0YSA9PiB7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChibG9iQ29scywgY29sID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcG9zaXRlS2V5c0RhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbY29sXSA9PT0gbnVsbCB8fCAhXy5pc0VtcHR5KF8udHJpbShkYXRhW2NvbF0pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChMaXZlVmFyaWFibGVVdGlscy5pc0NvbXBvc2l0ZUtleShwcmltYXJ5S2V5cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlLZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGVLZXlzRGF0YVtrZXldID0gZGF0YVtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2NvbF0gPSBocmVmICsgJ2NvbXBvc2l0ZS1pZC9jb250ZW50LycgKyBjb2wgKyAnPycgKyBMaXZlVmFyaWFibGVVdGlscy5nZXRDb21wb3NpdGVJRFVSTChjb21wb3NpdGVLZXlzRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2NvbF0gPSBocmVmICsgZGF0YVtfLmpvaW4ocHJpbWFyeUtleXMpXSArICcvY29udGVudC8nICsgY29sO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRIaWJlcm5hdGVPclNxbFR5cGUodmFyaWFibGUsIGZpZWxkTmFtZSwgdHlwZSwgZW50aXR5TmFtZT86IHN0cmluZykge1xuICAgICAgICBjb25zdCBjb2x1bW5zID0gdmFyaWFibGUucHJvcGVydGllc01hcC5jb2x1bW5zO1xuICAgICAgICBsZXQgY29sdW1uLFxuICAgICAgICAgICAgcmVsYXRlZENvbHMsXG4gICAgICAgICAgICByZWxhdGVkQ29sLFxuICAgICAgICAgICAgY29sdW1uUGFydHM7XG4gICAgICAgIGlmIChfLmluY2x1ZGVzKGZpZWxkTmFtZSwgJy4nKSkge1xuICAgICAgICAgICAgY29sdW1uUGFydHMgPSBmaWVsZE5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIGlmIChjb2x1bW5QYXJ0cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbHVtbiA9IF8uZmluZChjb2x1bW5zLCBjb2wgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2wuZmllbGROYW1lID09PSBjb2x1bW5QYXJ0c1swXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVsYXRlZENvbHMgPSBjb2x1bW4gJiYgY29sdW1uLmNvbHVtbnM7XG4gICAgICAgICAgICByZWxhdGVkQ29sID0gXy5maW5kKHJlbGF0ZWRDb2xzLCBjb2wgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2wuZmllbGROYW1lID09PSBjb2x1bW5QYXJ0c1sxXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlbGF0ZWRDb2wgJiYgcmVsYXRlZENvbFt0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICBjb2x1bW4gPSBfLmZpbmQoY29sdW1ucywgY29sID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjb2wuZmllbGROYW1lID09PSBmaWVsZE5hbWUgfHwgY29sLnJlbGF0ZWRDb2x1bW5OYW1lID09PSBmaWVsZE5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNvbHVtbiAmJiBlbnRpdHlOYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRpdHkgPSBfLmZpbmQoY29sdW1ucywgY29sID0+IGNvbC5yZWxhdGVkRW50aXR5TmFtZSA9PT0gZW50aXR5TmFtZSk7XG4gICAgICAgICAgICBjb2x1bW4gPSBfLmZpbmQoZW50aXR5LmNvbHVtbnMsIGNvbCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbC5maWVsZE5hbWUgPT09IGZpZWxkTmFtZSB8fCBjb2wucmVsYXRlZENvbHVtbk5hbWUgPT09IGZpZWxkTmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2x1bW4gJiYgY29sdW1uW3R5cGVdO1xuICAgIH1cblxuICAgIC8qRnVuY3Rpb24gdG8gZ2V0IHRoZSBzcWxUeXBlIG9mIHRoZSBzcGVjaWZpZWQgZmllbGQuKi9cbiAgICBzdGF0aWMgZ2V0U3FsVHlwZSh2YXJpYWJsZSwgZmllbGROYW1lLCBlbnRpdHlOYW1lPzogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBMaXZlVmFyaWFibGVVdGlscy5nZXRIaWJlcm5hdGVPclNxbFR5cGUodmFyaWFibGUsIGZpZWxkTmFtZSwgJ3R5cGUnLCBlbnRpdHlOYW1lKTtcbiAgICB9XG5cbiAgICAvKkZ1bmN0aW9uIHRvIGNoZWNrIGlmIHRoZSBzcGVjaWZpZWQgZmllbGQgaGFzIGEgb25lLXRvLW1hbnkgcmVsYXRpb24gb3Igbm90LiovXG4gICAgc3RhdGljIGlzUmVsYXRlZEZpZWxkTWFueSh2YXJpYWJsZSwgZmllbGROYW1lKSB7XG4gICAgICAgIGNvbnN0IGNvbHVtbnMgPSB2YXJpYWJsZS5wcm9wZXJ0aWVzTWFwLmNvbHVtbnMsXG4gICAgICAgICAgICBjb2x1bW5zQ291bnQgPSBjb2x1bW5zLmxlbmd0aDtcbiAgICAgICAgbGV0IGluZGV4LFxuICAgICAgICAgICAgY29sdW1uO1xuICAgICAgICAvKkxvb3AgdGhyb3VnaCB0aGUgY29sdW1ucyBvZiB0aGUgbGl2ZVZhcmlhYmxlKi9cbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgY29sdW1uc0NvdW50OyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5zW2luZGV4XTtcbiAgICAgICAgICAgIC8qSWYgdGhlIHNwZWNpZmllZCBmaWVsZCBpcyBmb3VuZCBpbiB0aGUgY29sdW1ucyBvZiB0aGUgdmFyaWFibGUsXG4gICAgICAgICAgICAqIHRoZW4gaXQgaGFzIGEgbWFueS10by1vbmUgcmVsYXRpb24uKi9cbiAgICAgICAgICAgIGlmIChjb2x1bW4uZmllbGROYW1lID09PSBmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzU3RyaW5nVHlwZSh0eXBlKSB7XG4gICAgICAgIHJldHVybiBfLmluY2x1ZGVzKFsndGV4dCcsICdzdHJpbmcnXSwgXy50b0xvd2VyKHR5cGUpKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0U1FMRmllbGRUeXBlKHZhcmlhYmxlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChfLmluY2x1ZGVzKFsndGltZXN0YW1wJywgJ2RhdGV0aW1lJywgJ2RhdGUnXSwgb3B0aW9ucy50eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMudHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTGl2ZVZhcmlhYmxlVXRpbHMuZ2V0U3FsVHlwZSh2YXJpYWJsZSwgb3B0aW9ucy5maWVsZE5hbWUpIHx8IG9wdGlvbnMudHlwZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0QXR0cmlidXRlTmFtZSh2YXJpYWJsZSwgZmllbGROYW1lKSB7XG4gICAgICAgIGxldCBhdHRyTmFtZSA9IGZpZWxkTmFtZTtcbiAgICAgICAgdmFyaWFibGUucHJvcGVydGllc01hcC5jb2x1bW5zLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgICAgICAgIGlmIChjb2x1bW4uZmllbGROYW1lID09PSBmaWVsZE5hbWUgJiYgY29sdW1uLmlzUmVsYXRlZCkge1xuICAgICAgICAgICAgICAgIGF0dHJOYW1lID0gY29sdW1uLnJlbGF0ZWRGaWVsZE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXR0ck5hbWU7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldEZpbHRlckNvbmRpdGlvbihmaWx0ZXJDb25kaXRpb24pIHtcbiAgICAgICAgaWYgKF8uaW5jbHVkZXMoREJfQ09OU1RBTlRTLkRBVEFCQVNFX1JBTkdFX01BVENIX01PREVTLCBmaWx0ZXJDb25kaXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyQ29uZGl0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEQl9DT05TVEFOVFMuREFUQUJBU0VfTUFUQ0hfTU9ERVNbJ2V4YWN0J107XG4gICAgfVxuXG4gICAgc3RhdGljIGdldEZpbHRlck9wdGlvbih2YXJpYWJsZSwgZmllbGRPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgZmllbGRWYWx1ZSA9IGZpZWxkT3B0aW9ucy52YWx1ZSxcbiAgICAgICAgICAgIGZpbHRlck9wdGlvbixcbiAgICAgICAgICAgIGZpbHRlckNvbmRpdGlvbjtcblxuICAgICAgICBjb25zdCBtYXRjaE1vZGVzID0gREJfQ09OU1RBTlRTLkRBVEFCQVNFX01BVENIX01PREVTLFxuICAgICAgICAgICAgZmllbGROYW1lID0gZmllbGRPcHRpb25zLmZpZWxkTmFtZSxcbiAgICAgICAgICAgIGZpZWxkUmVxdWlyZWQgPSBmaWVsZE9wdGlvbnMucmVxdWlyZWQgfHwgZmFsc2UsXG4gICAgICAgICAgICBmaWVsZFR5cGUgPSBMaXZlVmFyaWFibGVVdGlscy5nZXRTUUxGaWVsZFR5cGUodmFyaWFibGUsIGZpZWxkT3B0aW9ucyk7XG5cbiAgICAgICAgZmlsdGVyQ29uZGl0aW9uID0gbWF0Y2hNb2Rlc1tmaWVsZE9wdGlvbnMubWF0Y2hNb2RlXSB8fCBtYXRjaE1vZGVzW2ZpZWxkT3B0aW9ucy5maWx0ZXJDb25kaXRpb25dIHx8IGZpZWxkT3B0aW9ucy5maWx0ZXJDb25kaXRpb247XG5cbiAgICAgICAgZmllbGRPcHRpb25zLnR5cGUgPSBmaWVsZFR5cGU7XG4gICAgICAgIC8qIGlmIHRoZSBmaWVsZCB2YWx1ZSBpcyBhbiBvYmplY3QoY29tcGxleCB0eXBlKSwgbG9vcCBvdmVyIGVhY2ggZmllbGQgaW5zaWRlIGFuZCBwdXNoIG9ubHkgZmlyc3QgbGV2ZWwgZmllbGRzICovXG4gICAgICAgIGlmIChfLmlzT2JqZWN0KGZpZWxkVmFsdWUpICYmICFfLmlzQXJyYXkoZmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0TGV2ZWxWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIF8uZm9yRWFjaChmaWVsZFZhbHVlLCAoc3ViRmllbGRWYWx1ZSwgc3ViRmllbGROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN1YkZpZWxkVmFsdWUgJiYgIV8uaXNPYmplY3Qoc3ViRmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RMZXZlbFZhbHVlcy5wdXNoKGZpZWxkTmFtZSArICcuJyArIHN1YkZpZWxkTmFtZSArICc9JyArIHN1YkZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0TGV2ZWxWYWx1ZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5pbmNsdWRlcyhEQl9DT05TVEFOVFMuREFUQUJBU0VfRU1QVFlfTUFUQ0hfTU9ERVMsIGZpbHRlckNvbmRpdGlvbikpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPSBMaXZlVmFyaWFibGVVdGlscy5nZXRBdHRyaWJ1dGVOYW1lKHZhcmlhYmxlLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgLy8gRm9yIG5vbiBzdHJpbmcgdHlwZXMgZW1wdHkgbWF0Y2ggbW9kZXMgYXJlIG5vdCBzdXBwb3J0ZWQsIHNvIGNvbnZlcnQgdGhlbSB0byBudWxsIG1hdGNoIG1vZGVzLlxuICAgICAgICAgICAgaWYgKGZpZWxkVHlwZSAmJiAhTGl2ZVZhcmlhYmxlVXRpbHMuaXNTdHJpbmdUeXBlKGZpZWxkVHlwZSkpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJDb25kaXRpb24gPSBEQl9DT05TVEFOVFMuREFUQUJBU0VfTlVMTF9FTVBUWV9NQVRDSFtmaWx0ZXJDb25kaXRpb25dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsdGVyT3B0aW9uID0ge1xuICAgICAgICAgICAgICAgICdhdHRyaWJ1dGVOYW1lJzogYXR0cmlidXRlTmFtZSxcbiAgICAgICAgICAgICAgICAnYXR0cmlidXRlVmFsdWUnOiAnJyxcbiAgICAgICAgICAgICAgICAnYXR0cmlidXRlVHlwZSc6IF8udG9VcHBlcihmaWVsZFR5cGUpLFxuICAgICAgICAgICAgICAgICdmaWx0ZXJDb25kaXRpb24nOiBmaWx0ZXJDb25kaXRpb24sXG4gICAgICAgICAgICAgICAgJ3JlcXVpcmVkJzogZmllbGRSZXF1aXJlZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNlYXJjaFdpdGhRdWVyeSkge1xuICAgICAgICAgICAgICAgIGZpbHRlck9wdGlvbi5pc1ZhcmlhYmxlRmlsdGVyID0gZmllbGRPcHRpb25zLmlzVmFyaWFibGVGaWx0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyT3B0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmaW5lZChmaWVsZFZhbHVlKSAmJiBmaWVsZFZhbHVlICE9PSBudWxsICYmIGZpZWxkVmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICAvKkJhc2VkIG9uIHRoZSBzcWxUeXBlIG9mIHRoZSBmaWVsZCwgZm9ybWF0IHRoZSB2YWx1ZSAmIHNldCB0aGUgZmlsdGVyIGNvbmRpdGlvbi4qL1xuICAgICAgICAgICAgaWYgKGZpZWxkVHlwZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9IF8uaXNBcnJheShmaWVsZFZhbHVlKSA/IF8ucmVkdWNlKGZpZWxkVmFsdWUsIChyZXN1bHQsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghXy5pc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgW10pIDogcGFyc2VJbnQoZmllbGRWYWx1ZSwgMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyQ29uZGl0aW9uID0gZmlsdGVyQ29uZGl0aW9uID8gTGl2ZVZhcmlhYmxlVXRpbHMuZ2V0RmlsdGVyQ29uZGl0aW9uKGZpbHRlckNvbmRpdGlvbikgOiBtYXRjaE1vZGVzWydleGFjdCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkYXRldGltZSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RpbWVzdGFtcCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUb0RvIC0gdmFyaWFibGUgc2VwZXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9IGZvcm1hdERhdGUoZmllbGRWYWx1ZSwgZmllbGRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlckNvbmRpdGlvbiA9IGZpbHRlckNvbmRpdGlvbiA/IExpdmVWYXJpYWJsZVV0aWxzLmdldEZpbHRlckNvbmRpdGlvbihmaWx0ZXJDb25kaXRpb24pIDogbWF0Y2hNb2Rlc1snZXhhY3QnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfLmlzQXJyYXkoZmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJDb25kaXRpb24gPSBfLmluY2x1ZGVzKFttYXRjaE1vZGVzWydpbiddLCBtYXRjaE1vZGVzWydub3RpbiddXSwgZmlsdGVyQ29uZGl0aW9uKSA/IGZpbHRlckNvbmRpdGlvbiA6IG1hdGNoTW9kZXNbJ2V4YWN0J107XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlckNvbmRpdGlvbiA9IGZpbHRlckNvbmRpdGlvbiB8fCBtYXRjaE1vZGVzWydhbnl3aGVyZWlnbm9yZWNhc2UnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyQ29uZGl0aW9uID0gZmlsdGVyQ29uZGl0aW9uID8gTGl2ZVZhcmlhYmxlVXRpbHMuZ2V0RmlsdGVyQ29uZGl0aW9uKGZpbHRlckNvbmRpdGlvbikgOiBtYXRjaE1vZGVzWydleGFjdCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJDb25kaXRpb24gPSBfLmlzU3RyaW5nKGZpZWxkVmFsdWUpID8gbWF0Y2hNb2Rlc1snYW55d2hlcmVpZ25vcmVjYXNlJ10gOiBtYXRjaE1vZGVzWydleGFjdCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9IExpdmVWYXJpYWJsZVV0aWxzLmdldEF0dHJpYnV0ZU5hbWUodmFyaWFibGUsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICBmaWx0ZXJPcHRpb24gPSB7XG4gICAgICAgICAgICAgICAgJ2F0dHJpYnV0ZU5hbWUnOiBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgICAgICdhdHRyaWJ1dGVWYWx1ZSc6IGZpZWxkVmFsdWUsXG4gICAgICAgICAgICAgICAgJ2F0dHJpYnV0ZVR5cGUnOiBfLnRvVXBwZXIoZmllbGRUeXBlKSxcbiAgICAgICAgICAgICAgICAnZmlsdGVyQ29uZGl0aW9uJzogZmlsdGVyQ29uZGl0aW9uLFxuICAgICAgICAgICAgICAgICdyZXF1aXJlZCc6IGZpZWxkUmVxdWlyZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zZWFyY2hXaXRoUXVlcnkpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJPcHRpb24uaXNWYXJpYWJsZUZpbHRlciA9IGZpZWxkT3B0aW9ucy5pc1ZhcmlhYmxlRmlsdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlck9wdGlvbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXRGaWx0ZXJPcHRpb25zKHZhcmlhYmxlLCBmaWx0ZXJGaWVsZHMsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGZpbHRlck9wdGlvbnMgPSBbXTtcbiAgICAgICAgXy5lYWNoKGZpbHRlckZpZWxkcywgKGZpZWxkT3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyT3B0aW9uID0gTGl2ZVZhcmlhYmxlVXRpbHMuZ2V0RmlsdGVyT3B0aW9uKHZhcmlhYmxlLCBmaWVsZE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKCFfLmlzTmlsKGZpbHRlck9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICBpZiAoXy5pc0FycmF5KGZpbHRlck9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyT3B0aW9ucyA9IGZpbHRlck9wdGlvbnMuY29uY2F0KGZpbHRlck9wdGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyT3B0aW9ucy5wdXNoKGZpbHRlck9wdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbHRlck9wdGlvbnM7XG4gICAgfVxuXG4gICAgLy8gV3JhcCB0aGUgZmllbGQgbmFtZSBhbmQgdmFsdWUgaW4gbG93ZXIoKSBpbiBpZ25vcmUgY2FzZSBzY2VuYXJpb1xuICAgIC8vIFRPRE86IENoYW5nZSB0aGUgZnVuY3Rpb24gbmFtZSB0byByZXByZXNlbnQgdGhlIGFkZGVkIGZ1bmN0aW9uYWxpdHkgb2YgaWRlbnRpZmllcnMgZm9yIGRhdGV0aW1lLCB0aW1lc3RhbXAgYW5kIGZsb2F0IHR5cGVzLiBQcmV2aW91c2x5IG9ubHkgbG93ZXIgd2FzIHdhcmFwcGVkLlxuICAgIHN0YXRpYyB3cmFwSW5Mb3dlckNhc2UodmFsdWUsIG9wdGlvbnMsIGlnbm9yZUNhc2UsIGlzRmllbGQ/KSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBfLnRvTG93ZXIob3B0aW9ucy5hdHRyaWJ1dGVUeXBlKTtcbiAgICAgICAgLy8gSWYgaWdub3JlIGNhc2UgaXMgdHJ1ZSBhbmQgdHlwZSBpcyBzdHJpbmcvIHRleHQgYW5kIG1hdGNoIG1vZGUgaXMgc3RyaW5nIHR5cGUsIHdyYXAgaW4gbG93ZXIoKVxuICAgICAgICBpZiAoaWdub3JlQ2FzZSAmJiAoIXR5cGUgfHwgTGl2ZVZhcmlhYmxlVXRpbHMuaXNTdHJpbmdUeXBlKHR5cGUpKSAmJiBfLmluY2x1ZGVzKERCX0NPTlNUQU5UUy5EQVRBQkFTRV9TVFJJTkdfTU9ERVMsIG9wdGlvbnMuZmlsdGVyQ29uZGl0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuICdsb3dlcignICsgdmFsdWUgKyAnKSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHN0YXRpYyBlbmNvZGVBbmRBZGRRdW90ZXModmFsdWUsIHR5cGUsIHNraXBFbmNvZGUpIHtcbiAgICAgICAgbGV0IGVuY29kZWRWYWx1ZSA9IHNraXBFbmNvZGUgPyB2YWx1ZSA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgICAgIHR5cGUgPSBfLnRvTG93ZXIodHlwZSk7XG4gICAgICAgIGVuY29kZWRWYWx1ZSA9IF8ucmVwbGFjZShlbmNvZGVkVmFsdWUsIC8nL2csICdcXCdcXCcnKTtcbiAgICAgICAgLy8gRm9yIG51bWJlciB0eXBlcywgZG9uJ3Qgd3JhcCB0aGUgdmFsdWUgaW4gcXVvdGVzXG4gICAgICAgIGlmICgoaXNOdW1iZXJUeXBlKHR5cGUpICYmIHR5cGUgIT09ICdmbG9hdCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnXFwnJyArIGVuY29kZWRWYWx1ZSArICdcXCcnO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRQYXJhbVZhbHVlKHZhbHVlLCBvcHRpb25zLCBpZ25vcmVDYXNlLCBza2lwRW5jb2RlKSB7XG4gICAgICAgIGxldCBwYXJhbTtcbiAgICAgICAgY29uc3QgZmlsdGVyQ29uZGl0aW9uID0gb3B0aW9ucy5maWx0ZXJDb25kaXRpb24sXG4gICAgICAgICAgICBkYk1vZGVzID0gREJfQ09OU1RBTlRTLkRBVEFCQVNFX01BVENIX01PREVTLFxuICAgICAgICAgICAgdHlwZSA9IG9wdGlvbnMuYXR0cmlidXRlVHlwZTtcbiAgICAgICAgaWYgKF8uaW5jbHVkZXMoREJfQ09OU1RBTlRTLkRBVEFCQVNFX0VNUFRZX01BVENIX01PREVTLCBmaWx0ZXJDb25kaXRpb24pKSB7XG4gICAgICAgICAgICAvLyBGb3IgZW1wdHkgbWF0Y2htb2Rlcywgbm8gdmFsdWUgaXMgcmVxdWlyZWRcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGZpbHRlckNvbmRpdGlvbikge1xuICAgICAgICAgICAgY2FzZSBkYk1vZGVzLnN0YXJ0aWdub3JlY2FzZTpcbiAgICAgICAgICAgIGNhc2UgZGJNb2Rlcy5zdGFydDpcbiAgICAgICAgICAgICAgICBwYXJhbSA9IExpdmVWYXJpYWJsZVV0aWxzLmVuY29kZUFuZEFkZFF1b3Rlcyh2YWx1ZSArICclJywgdHlwZSwgc2tpcEVuY29kZSk7XG4gICAgICAgICAgICAgICAgcGFyYW0gPSBMaXZlVmFyaWFibGVVdGlscy53cmFwSW5Mb3dlckNhc2UocGFyYW0sIG9wdGlvbnMsIGlnbm9yZUNhc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBkYk1vZGVzLmVuZGlnbm9yZWNhc2U6XG4gICAgICAgICAgICBjYXNlIGRiTW9kZXMuZW5kOlxuICAgICAgICAgICAgICAgIHBhcmFtID0gTGl2ZVZhcmlhYmxlVXRpbHMuZW5jb2RlQW5kQWRkUXVvdGVzKCclJyArIHZhbHVlLCB0eXBlLCBza2lwRW5jb2RlKTtcbiAgICAgICAgICAgICAgICBwYXJhbSA9IExpdmVWYXJpYWJsZVV0aWxzLndyYXBJbkxvd2VyQ2FzZShwYXJhbSwgb3B0aW9ucywgaWdub3JlQ2FzZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGRiTW9kZXMubm93aGVyZWlnbm9yZWNhc2U6XG4gICAgICAgICAgICBjYXNlIGRiTW9kZXMubm93aGVyZTpcbiAgICAgICAgICAgIGNhc2UgZGJNb2Rlcy5hbnl3aGVyZWlnbm9yZWNhc2U6XG4gICAgICAgICAgICBjYXNlIGRiTW9kZXMuYW55d2hlcmU6XG4gICAgICAgICAgICAgICAgcGFyYW0gPSBMaXZlVmFyaWFibGVVdGlscy5lbmNvZGVBbmRBZGRRdW90ZXMoJyUnICsgdmFsdWUgKyAnJScsIHR5cGUsIHNraXBFbmNvZGUpO1xuICAgICAgICAgICAgICAgIHBhcmFtID0gTGl2ZVZhcmlhYmxlVXRpbHMud3JhcEluTG93ZXJDYXNlKHBhcmFtLCBvcHRpb25zLCBpZ25vcmVDYXNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZGJNb2Rlcy5iZXR3ZWVuOlxuICAgICAgICAgICAgICAgIHBhcmFtID0gXy5qb2luKF8ubWFwKHZhbHVlLCB2YWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTGl2ZVZhcmlhYmxlVXRpbHMud3JhcEluTG93ZXJDYXNlKExpdmVWYXJpYWJsZVV0aWxzLmVuY29kZUFuZEFkZFF1b3Rlcyh2YWwsIHR5cGUsIHNraXBFbmNvZGUpLCBvcHRpb25zLCBpZ25vcmVDYXNlKTtcbiAgICAgICAgICAgICAgICB9KSwgJyBhbmQgJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGRiTW9kZXMuaW46XG4gICAgICAgICAgICBjYXNlIGRiTW9kZXMubm90aW46XG4gICAgICAgICAgICAgICAgcGFyYW0gPSBfLmpvaW4oXy5tYXAodmFsdWUsIHZhbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBMaXZlVmFyaWFibGVVdGlscy53cmFwSW5Mb3dlckNhc2UoTGl2ZVZhcmlhYmxlVXRpbHMuZW5jb2RlQW5kQWRkUXVvdGVzKHZhbCwgdHlwZSwgc2tpcEVuY29kZSksIG9wdGlvbnMsIGlnbm9yZUNhc2UpO1xuICAgICAgICAgICAgICAgIH0pLCAnLCAnKTtcbiAgICAgICAgICAgICAgICBwYXJhbSA9ICcoJyArIHBhcmFtICsgJyknO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLypjYXNlIGRiTW9kZXMuZXhhY3RpZ25vcmVjYXNlOlxuICAgICAgICAgICAgY2FzZSBkYk1vZGVzLmV4YWN0OlxuICAgICAgICAgICAgY2FzZSBkYk1vZGVzLm5vdGVxdWFsczpcbiAgICAgICAgICAgIFRoZSBhYm92ZSB0aHJlZSBjYXNlcyB3aWxsIGJlIGhhbmRsZWQgYnkgZGVmYXVsdCovXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHBhcmFtID0gTGl2ZVZhcmlhYmxlVXRpbHMuZW5jb2RlQW5kQWRkUXVvdGVzKHZhbHVlLCB0eXBlLCBza2lwRW5jb2RlKTtcbiAgICAgICAgICAgICAgICBwYXJhbSA9IExpdmVWYXJpYWJsZVV0aWxzLndyYXBJbkxvd2VyQ2FzZShwYXJhbSwgb3B0aW9ucywgaWdub3JlQ2FzZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzRGVmaW5lZChwYXJhbSkgPyBwYXJhbSA6ICcnO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRTZWFyY2hRdWVyeShmaWx0ZXJPcHRpb25zLCBvcGVyYXRvciwgaWdub3JlQ2FzZSwgc2tpcEVuY29kZT8pIHtcbiAgICAgICAgbGV0IHF1ZXJ5O1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICAgICAgXy5mb3JFYWNoKGZpbHRlck9wdGlvbnMsIGZpZWxkVmFsdWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZFZhbHVlLmF0dHJpYnV0ZVZhbHVlLFxuICAgICAgICAgICAgICAgIGRiTW9kZXMgPSBEQl9DT05TVEFOVFMuREFUQUJBU0VfTUFUQ0hfTU9ERVMsXG4gICAgICAgICAgICAgICAgaXNWYWxBcnJheSA9IF8uaXNBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgICBsZXQgZmllbGROYW1lID0gZmllbGRWYWx1ZS5hdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgICAgIGZpbHRlckNvbmRpdGlvbiA9IGZpZWxkVmFsdWUuZmlsdGVyQ29uZGl0aW9uLFxuICAgICAgICAgICAgICAgIG1hdGNoTW9kZUV4cHIsXG4gICAgICAgICAgICAgICAgcGFyYW1WYWx1ZTtcbiAgICAgICAgICAgIC8vIElmIHZhbHVlIGlzIGFuIGVtcHR5IGFycmF5LCBkbyBub3QgZ2VuZXJhdGUgdGhlIHF1ZXJ5XG4gICAgICAgICAgICAvLyBJZiB2YWx1ZXMgaXMgTmFOIGFuZCBudW1iZXIgdHlwZSwgZG8gbm90IGdlbmVyYXRlIHF1ZXJ5IGZvciB0aGlzIGZpZWxkXG4gICAgICAgICAgICBpZiAoKGlzVmFsQXJyYXkgJiYgXy5pc0VtcHR5KHZhbHVlKSkgfHwgKCFpc1ZhbEFycmF5ICYmIGlzTmFOKHZhbHVlKSAmJiAoaXNOdW1iZXJUeXBlKGZpZWxkVmFsdWUuYXR0cmlidXRlVHlwZSkpKSB8fCAoIWlzVmFsQXJyYXkgJiYgKGlzTmFOKHZhbHVlKSAmJiAhbW9tZW50KHZhbHVlKS5pc1ZhbGlkKCkgJiYgaXNEYXRlVGltZVR5cGUoXy50b0xvd2VyKGZpZWxkVmFsdWUuYXR0cmlidXRlVHlwZSkpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNWYWxBcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGFycmF5IGlzIHZhbHVlIGFuZCBtb2RlIGlzIGJldHdlZW4sIHBhc3MgYmV0d2Vlbi4gRWxzZSBwYXNzIGFzIGluIHF1ZXJ5XG4gICAgICAgICAgICAgICAgZmlsdGVyQ29uZGl0aW9uID0gZmlsdGVyQ29uZGl0aW9uID09PSBkYk1vZGVzLmJldHdlZW4gfHwgZmlsdGVyQ29uZGl0aW9uID09PSBkYk1vZGVzLm5vdGluID8gZmlsdGVyQ29uZGl0aW9uIDogZGJNb2Rlcy5pbjtcbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlLmZpbHRlckNvbmRpdGlvbiA9IGZpbHRlckNvbmRpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGNoTW9kZUV4cHIgPSBEQl9DT05TVEFOVFMuREFUQUJBU0VfTUFUQ0hfTU9ERVNfV0lUSF9RVUVSWVtmaWx0ZXJDb25kaXRpb25dO1xuICAgICAgICAgICAgcGFyYW1WYWx1ZSA9IExpdmVWYXJpYWJsZVV0aWxzLmdldFBhcmFtVmFsdWUodmFsdWUsIGZpZWxkVmFsdWUsIGlnbm9yZUNhc2UsIHNraXBFbmNvZGUpO1xuICAgICAgICAgICAgZmllbGROYW1lID0gTGl2ZVZhcmlhYmxlVXRpbHMud3JhcEluTG93ZXJDYXNlKGZpZWxkTmFtZSwgZmllbGRWYWx1ZSwgaWdub3JlQ2FzZSk7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChyZXBsYWNlKG1hdGNoTW9kZUV4cHIsIFtmaWVsZE5hbWUsIHBhcmFtVmFsdWVdKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBxdWVyeSA9IF8uam9pbihwYXJhbXMsIG9wZXJhdG9yKTsgLy8gZW1wdHkgc3BhY2UgYWRkZWQgaW50ZW50aW9uYWxseSBhcm91bmQgT1JcbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNyZWF0aW5nIHRoZSBwcm9wZXIgdmFsdWVzIGZyb20gdGhlIGFjdHVhbCBvYmplY3QgbGlrZSBmb3IgYmV0d2VlbixpbiBtYXRjaE1vZGVzIHZhbHVlIGhhcyB0byBiZSBhbiBhcnJheSBsaWtlIFsxLDJdXG4gICAgICogQHBhcmFtIHJ1bGVzIHJlY3Vyc2l2ZSBmaWx0ZXJleHByZXNzaW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0gdmFyaWFibGUgdmFyaWFibGUgb2JqZWN0XG4gICAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9uc1xuICAgICAqL1xuICAgIHN0YXRpYyBwcm9jZXNzRmlsdGVyRmllbGRzKHJ1bGVzLCB2YXJpYWJsZSwgb3B0aW9ucykge1xuICAgICAgICBfLnJlbW92ZShydWxlcywgcnVsZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcnVsZSAmJiAoXy5pc1N0cmluZyhydWxlLnZhbHVlKSAmJiBydWxlLnZhbHVlLmluZGV4T2YoJ2JpbmQ6JykgPT09IDAgfHwgKHJ1bGUubWF0Y2hNb2RlID09PSAnYmV0d2VlbicgPyAoXy5pc1N0cmluZyhydWxlLnNlY29uZHZhbHVlKSAmJiBydWxlLnNlY29uZHZhbHVlLmluZGV4T2YoJ2JpbmQ6JykgPT09IDApIDogZmFsc2UpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgXy5mb3JFYWNoKHJ1bGVzLCAocnVsZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChydWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUucnVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgTGl2ZVZhcmlhYmxlVXRpbHMucHJvY2Vzc0ZpbHRlckZpZWxkcyhydWxlLnJ1bGVzLCB2YXJpYWJsZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfLmlzTnVsbChydWxlLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcnVsZS5tYXRjaE1vZGUudG9Mb3dlckNhc2UoKSA9PT0gREJfQ09OU1RBTlRTLkRBVEFCQVNFX01BVENIX01PREVTLmJldHdlZW4udG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKF8uaXNBcnJheShydWxlLnZhbHVlKSA/IHJ1bGUudmFsdWUgOiBbcnVsZS52YWx1ZSwgcnVsZS5zZWNvbmR2YWx1ZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAocnVsZS5tYXRjaE1vZGUudG9Mb3dlckNhc2UoKSA9PT0gREJfQ09OU1RBTlRTLkRBVEFCQVNFX01BVENIX01PREVTLmluLnRvTG93ZXJDYXNlKCkgfHwgcnVsZS5tYXRjaE1vZGUudG9Mb3dlckNhc2UoKSA9PT0gREJfQ09OU1RBTlRTLkRBVEFCQVNFX01BVENIX01PREVTLm5vdGluLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoXy5pc0FycmF5KHJ1bGUudmFsdWUpID8gcnVsZS52YWx1ZSA6IChydWxlLnZhbHVlID8gcnVsZS52YWx1ZS5zcGxpdCgnLCcpLm1hcCh2YWwgPT4gdmFsLnRyaW0oKSkgOiAnJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcnVsZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlc1tpbmRleF0gPSBMaXZlVmFyaWFibGVVdGlscy5nZXRGaWx0ZXJPcHRpb24odmFyaWFibGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmllbGROYW1lJzogcnVsZS50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiBydWxlLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlcXVpcmVkJzogcnVsZS5yZXF1aXJlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmlsdGVyQ29uZGl0aW9uJzogcnVsZS5tYXRjaE1vZGUgfHwgb3B0aW9ucy5tYXRjaE1vZGUgfHwgdmFyaWFibGUubWF0Y2hNb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFNlYXJjaEZpZWxkKGZpZWxkVmFsdWUsIGlnbm9yZUNhc2UsIHNraXBFbmNvZGUpIHtcbiAgICAgICAgbGV0IGZpZWxkTmFtZSA9IGZpZWxkVmFsdWUuYXR0cmlidXRlTmFtZTtcbiAgICAgICAgbGV0IG1hdGNoTW9kZUV4cHI7XG4gICAgICAgIGxldCBwYXJhbVZhbHVlO1xuICAgICAgICBsZXQgZmlsdGVyQ29uZGl0aW9uID0gZmllbGRWYWx1ZS5maWx0ZXJDb25kaXRpb247XG5cbiAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZFZhbHVlLmF0dHJpYnV0ZVZhbHVlO1xuICAgICAgICBjb25zdCBpc1ZhbEFycmF5ID0gXy5pc0FycmF5KHZhbHVlKTtcbiAgICAgICAgY29uc3QgZGJNb2RlcyA9IERCX0NPTlNUQU5UUy5EQVRBQkFTRV9NQVRDSF9NT0RFUztcblxuICAgICAgICAvLyBJZiB2YWx1ZSBpcyBhbiBlbXB0eSBhcnJheSwgZG8gbm90IGdlbmVyYXRlIHRoZSBxdWVyeVxuICAgICAgICAvLyBJZiB2YWx1ZXMgaXMgTmFOIGFuZCBudW1iZXIgdHlwZSwgZG8gbm90IGdlbmVyYXRlIHF1ZXJ5IGZvciB0aGlzIGZpZWxkXG4gICAgICAgIGlmICgoaXNWYWxBcnJheSAmJiBfLmlzRW1wdHkodmFsdWUpKSB8fFxuICAgICAgICAgICAgKGlzVmFsQXJyYXkgJiYgXy5zb21lKHZhbHVlLCB2YWwgPT4gKF8uaXNOdWxsKHZhbCkgfHwgXy5pc05hTih2YWwpIHx8IHZhbCA9PT0gJycpKSkgfHxcbiAgICAgICAgICAgICghaXNWYWxBcnJheSAmJiAoaXNOYU4odmFsdWUpICYmIChpc051bWJlclR5cGUoZmllbGRWYWx1ZS5hdHRyaWJ1dGVUeXBlKSkpKSB8fFxuICAgICAgICAgICAgKCFpc1ZhbEFycmF5ICYmIChpc05hTih2YWx1ZSkgJiYgIW1vbWVudCh2YWx1ZSkuaXNWYWxpZCgpICYmIGlzRGF0ZVRpbWVUeXBlKF8udG9Mb3dlcihmaWVsZFZhbHVlLmF0dHJpYnV0ZVR5cGUpKSkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVmFsQXJyYXkpIHtcbiAgICAgICAgICAgIC8vIElmIGFycmF5IGlzIHZhbHVlIGFuZCBtb2RlIGlzIGJldHdlZW4sIHBhc3MgYmV0d2Vlbi4gRWxzZSBwYXNzIGFzIGluIHF1ZXJ5XG4gICAgICAgICAgICBmaWx0ZXJDb25kaXRpb24gPSBmaWx0ZXJDb25kaXRpb24gPT09IGRiTW9kZXMuYmV0d2VlbiB8fCBmaWx0ZXJDb25kaXRpb24gPT09IGRiTW9kZXMubm90aW4gPyBmaWx0ZXJDb25kaXRpb24gOiBkYk1vZGVzLmluO1xuICAgICAgICAgICAgZmllbGRWYWx1ZS5maWx0ZXJDb25kaXRpb24gPSBmaWx0ZXJDb25kaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2hNb2RlRXhwciA9IERCX0NPTlNUQU5UUy5EQVRBQkFTRV9NQVRDSF9NT0RFU19XSVRIX1FVRVJZW2ZpbHRlckNvbmRpdGlvbl07XG4gICAgICAgIHBhcmFtVmFsdWUgPSBMaXZlVmFyaWFibGVVdGlscy5nZXRQYXJhbVZhbHVlKHZhbHVlLCBmaWVsZFZhbHVlLCBpZ25vcmVDYXNlLCBza2lwRW5jb2RlKTtcbiAgICAgICAgZmllbGROYW1lID0gTGl2ZVZhcmlhYmxlVXRpbHMud3JhcEluTG93ZXJDYXNlKGZpZWxkTmFtZSwgZmllbGRWYWx1ZSwgaWdub3JlQ2FzZSk7XG4gICAgICAgIHJldHVybiByZXBsYWNlKG1hdGNoTW9kZUV4cHIsIFtmaWVsZE5hbWUsIHBhcmFtVmFsdWVdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgd2hldGhlciB0byB1c2UgaWdub3JlY2FzZSBhdCBlYWNoIGNyaXRlcmlhIGxldmVsIGFuZCBub3QgdXNlIHRoZSB2YXJpYWJsZVxuICAgICAqIGxldmVsIGlzSWdub3JlQ2FzZSBmbGFnIGFuZCBhcHBseSBpdCB0byBhbGwgdGhlIHJ1bGVzLlxuICAgICAqIEluc3RlYWQgb2YgYWRkaW5nIGFuIGV4dHJhIHBhcmFtIHRvIHRoZSBjcml0ZXJpYSBvYmplY3QsIHdlIGhhdmUgYWRkZWQgZmV3IG90aGVyIG1hdGNobW9kZXMgZm9yIHN0cmluZyB0eXBlcyBsaWtlXG4gICAgICogYW55d2hlcmUgd2l0aCBhbnl3aGVyZWlnbm9yZWNhc2UsIHN0YXJ0IHdpdGggc3RhcnRpZ25vcmVjYXNlLCBlbmQgd2l0aCBlbmRpZ25vcmVjYXNlLCBleGFjdCB3aXRoIGV4YWN0aWdub3JlY2FzZSxcbiAgICAgKiBTbyB3aGlsZSBjcmVhdGluZyB0aGUgY3JpdGVyaWEgaXRzZWxkIHVzZXIgY2FuIGNob29zZSB3aGV0aGVyIHRvIHVzZSBpZ25vcmUgY2FzZSBvciBub3QgZm9yIGEgcGFydGljdWxhciBjb2x1bW4gd2hpbGUgcXVlcnlpbmdcbiAgICAgKiBAcGFyYW0gbWF0Y2hNb2RlXG4gICAgICogQHBhcmFtIGlnbm9yZUNhc2VcbiAgICAgKiBAcmV0dXJucyB7Kn0gYm9vbGVhblxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRJZ25vcmVDYXNlKG1hdGNoTW9kZSwgaWdub3JlQ2FzZSkge1xuICAgICAgICBjb25zdCBtYXRjaE1vZGVzID0gREJfQ09OU1RBTlRTLkRBVEFCQVNFX01BVENIX01PREVTO1xuICAgICAgICBpZiAoXy5pbmRleE9mKFttYXRjaE1vZGVzWydhbnl3aGVyZSddLCBtYXRjaE1vZGVzWydub3doZXJlJ10sIG1hdGNoTW9kZXNbJ3N0YXJ0J10sIG1hdGNoTW9kZXNbJ2VuZCddLCBtYXRjaE1vZGVzWydleGFjdCddXSwgbWF0Y2hNb2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXy5pbmRleE9mKFttYXRjaE1vZGVzWydhbnl3aGVyZWlnbm9yZWNhc2UnXSwgbWF0Y2hNb2Rlc1snbm93aGVyZWlnbm9yZWNhc2UnXSwgbWF0Y2hNb2Rlc1snc3RhcnRpZ25vcmVjYXNlJ10sIG1hdGNoTW9kZXNbJ2VuZGlnbm9yZWNhc2UnXSwgbWF0Y2hNb2Rlc1snZXhhY3RpZ25vcmVjYXNlJ11dLCBtYXRjaE1vZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlnbm9yZUNhc2U7XG4gICAgfVxuXG4gICAgc3RhdGljIGdlbmVyYXRlU2VhcmNoUXVlcnkocnVsZXMsIGNvbmRpdGlvbiwgaWdub3JlQ2FzZSwgc2tpcEVuY29kZSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICAgICAgXy5mb3JFYWNoKHJ1bGVzLCBydWxlID0+IHtcbiAgICAgICAgICAgIGlmIChydWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUucnVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBMaXZlVmFyaWFibGVVdGlscy5nZW5lcmF0ZVNlYXJjaFF1ZXJ5KHJ1bGUucnVsZXMsIHJ1bGUuY29uZGl0aW9uLCBpZ25vcmVDYXNlLCBza2lwRW5jb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXJ5ICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goJygnICsgcXVlcnkgKyAnKScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VhcmNoRmllbGQgPSBMaXZlVmFyaWFibGVVdGlscy5nZXRTZWFyY2hGaWVsZChydWxlLCBMaXZlVmFyaWFibGVVdGlscy5nZXRJZ25vcmVDYXNlKHJ1bGUuZmlsdGVyQ29uZGl0aW9uLCBpZ25vcmVDYXNlKSwgc2tpcEVuY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghXy5pc05pbChzZWFyY2hGaWVsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHNlYXJjaEZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfLmpvaW4ocGFyYW1zLCAnICcgKyBjb25kaXRpb24gKyAnICcpO1xuICAgIH1cblxuICAgIHN0YXRpYyBwcmVwYXJlVGFibGVPcHRpb25zRm9yRmlsdGVyRXhwcyh2YXJpYWJsZSwgb3B0aW9ucywgY2xvbmVkRmllbGRzKSB7XG4gICAgICAgIGlmICghaXNEZWZpbmVkKG9wdGlvbnMuc2VhcmNoV2l0aFF1ZXJ5KSkge1xuICAgICAgICAgICAgb3B0aW9ucy5zZWFyY2hXaXRoUXVlcnkgPSB0cnVlOyAvLyBVc2luZyBxdWVyeSBhcGkgaW5zdGVhZCBvZiAgc2VhcmNoIGFwaVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmlsdGVyT3B0aW9ucyA9IFtdO1xuICAgICAgICBjb25zdCBtYXRjaE1vZGVzID0gREJfQ09OU1RBTlRTLkRBVEFCQVNFX01BVENIX01PREVTO1xuICAgICAgICBsZXQgb3JkZXJCeUZpZWxkcyxcbiAgICAgICAgICAgIG9yZGVyQnlPcHRpb25zLFxuICAgICAgICAgICAgcXVlcnk7XG4gICAgICAgIGxldCBjbG9uZWRPYmogPSBjbG9uZWRGaWVsZHMgfHwgZ2V0Q2xvbmVkT2JqZWN0KHZhcmlhYmxlLmZpbHRlckV4cHJlc3Npb25zKTtcblxuICAgICAgICAvLyBpZiBmaWx0ZXJleHByZXNzaW9uIGZyb20gbGl2ZSBmaWx0ZXIgaXMgcHJlc2VudCB1c2UgaXQgdG8gcXVlcnlcbiAgICAgICAgaWYgKG9wdGlvbnMuZmlsdGVyRXhwciAmJiAhXy5pc0VtcHR5KG9wdGlvbnMuZmlsdGVyRXhwcikpIHtcbiAgICAgICAgICAgIGNsb25lZE9iaiA9IG9wdGlvbnMuZmlsdGVyRXhwcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBsaXZlIGZpbHRlciBydW50aW1lIHZhbHVlc1xuICAgICAgICBsZXQgZmlsdGVyUnVsZXM6IGFueSA9IHt9O1xuICAgICAgICBpZiAoIV8uaXNFbXB0eShvcHRpb25zLmZpbHRlckZpZWxkcykpIHtcbiAgICAgICAgICAgIGxldCBvcGVyYXRvciA9ICcnO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBpbiBvcHRpb25zLmZpbHRlckZpZWxkcykge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yID0gb3B0aW9ucy5maWx0ZXJGaWVsZHNbZmllbGRdWydsb2dpY2FsT3AnXSB8fCAnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbHRlclJ1bGVzID0geydjb25kaXRpb24nOiBvcHRpb25zLmxvZ2ljYWxPcCB8fCBvcGVyYXRvciB8fCAnQU5EJywgJ3J1bGVzJzogW119O1xuICAgICAgICAgICAgXy5mb3JFYWNoKG9wdGlvbnMuZmlsdGVyRmllbGRzLCAoZmlsdGVyT2JqLCBmaWx0ZXJOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyQ29uZGl0aW9uID0gbWF0Y2hNb2Rlc1tmaWx0ZXJPYmoubWF0Y2hNb2RlXSB8fCBtYXRjaE1vZGVzW2ZpbHRlck9iai5maWx0ZXJDb25kaXRpb25dIHx8IGZpbHRlck9iai5maWx0ZXJDb25kaXRpb247XG4gICAgICAgICAgICAgICAgaWYgKF8uaW5jbHVkZXMoREJfQ09OU1RBTlRTLkRBVEFCQVNFX0VNUFRZX01BVENIX01PREVTLCBmaWx0ZXJDb25kaXRpb24pIHx8XG4gICAgICAgICAgICAgICAgICAgICghXy5pc05pbChmaWx0ZXJPYmoudmFsdWUpICYmIGZpbHRlck9iai52YWx1ZSAhPT0gJycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBmaWx0ZXJPYmoudHlwZSB8fCBMaXZlVmFyaWFibGVVdGlscy5nZXRTcWxUeXBlKHZhcmlhYmxlLCBmaWx0ZXJOYW1lLCBvcHRpb25zLmVudGl0eU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBydWxlT2JqID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RhcmdldCc6IGZpbHRlck5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF0Y2hNb2RlJzogZmlsdGVyT2JqLm1hdGNoTW9kZSB8fCAoTGl2ZVZhcmlhYmxlVXRpbHMuaXNTdHJpbmdUeXBlKHR5cGUpID8gJ3N0YXJ0aWdub3JlY2FzZScgOiAnZXhhY3QnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IGZpbHRlck9iai52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXF1aXJlZCc6IGZpbHRlck9iai5yZXF1aXJlZCB8fCBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJSdWxlcy5ydWxlcy5wdXNoKHJ1bGVPYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghXy5pc0VtcHR5KGNsb25lZE9iaikpIHtcbiAgICAgICAgICAgIGlmICghXy5pc05pbChmaWx0ZXJSdWxlcy5ydWxlcykgJiYgZmlsdGVyUnVsZXMucnVsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gY29tYmluZSBib3RoIHRoZSBydWxlcyB1c2luZyAnQU5EJ1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBSdWxlcyA9IHsnY29uZGl0aW9uJzogJ0FORCcsICdydWxlcyc6IFtdfTtcbiAgICAgICAgICAgICAgICB0ZW1wUnVsZXMucnVsZXMucHVzaChnZXRDbG9uZWRPYmplY3QoY2xvbmVkT2JqKSk7XG4gICAgICAgICAgICAgICAgdGVtcFJ1bGVzLnJ1bGVzLnB1c2goZmlsdGVyUnVsZXMpO1xuICAgICAgICAgICAgICAgIGNsb25lZE9iaiA9IHRlbXBSdWxlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsb25lZE9iaiA9IGZpbHRlclJ1bGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgTGl2ZVZhcmlhYmxlVXRpbHMucHJvY2Vzc0ZpbHRlckZpZWxkcyhjbG9uZWRPYmoucnVsZXMsIHZhcmlhYmxlLCBvcHRpb25zKTtcbiAgICAgICAgcXVlcnkgPSBMaXZlVmFyaWFibGVVdGlscy5nZW5lcmF0ZVNlYXJjaFF1ZXJ5KGNsb25lZE9iai5ydWxlcywgY2xvbmVkT2JqLmNvbmRpdGlvbiwgdmFyaWFibGUuaWdub3JlQ2FzZSwgb3B0aW9ucy5za2lwRW5jb2RlKTtcblxuICAgICAgICBvcmRlckJ5RmllbGRzID0gZ2V0RXZhbHVhdGVkT3JkZXJCeSh2YXJpYWJsZS5vcmRlckJ5LCBvcHRpb25zLm9yZGVyQnkpO1xuICAgICAgICBvcmRlckJ5T3B0aW9ucyA9IG9yZGVyQnlGaWVsZHMgPyAnc29ydD0nICsgb3JkZXJCeUZpZWxkcyA6ICcnO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnZmlsdGVyJyA6IGZpbHRlck9wdGlvbnMsXG4gICAgICAgICAgICAnc29ydCcgICA6IG9yZGVyQnlPcHRpb25zLFxuICAgICAgICAgICAgJ3F1ZXJ5JyAgOiBxdWVyeVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHN0YXRpYyBwcmVwYXJlVGFibGVPcHRpb25zKHZhcmlhYmxlLCBvcHRpb25zLCBjbG9uZWRGaWVsZHM/KSB7XG4gICAgICAgIGlmICh2YXJpYWJsZS5vcGVyYXRpb24gPT09ICdyZWFkJykge1xuICAgICAgICAgICAgcmV0dXJuIExpdmVWYXJpYWJsZVV0aWxzLnByZXBhcmVUYWJsZU9wdGlvbnNGb3JGaWx0ZXJFeHBzKHZhcmlhYmxlLCBvcHRpb25zLCBjbG9uZWRGaWVsZHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNEZWZpbmVkKG9wdGlvbnMuc2VhcmNoV2l0aFF1ZXJ5KSkge1xuICAgICAgICAgICAgb3B0aW9ucy5zZWFyY2hXaXRoUXVlcnkgPSB0cnVlOyAvLyAgVXNpbmcgcXVlcnkgYXBpIGluc3RlYWQgb2YgIHNlYXJjaCBhcGlcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXJGaWVsZHMgPSBbXTtcbiAgICAgICAgbGV0IGZpbHRlck9wdGlvbnMgPSBbXSxcbiAgICAgICAgICAgIG9yZGVyQnlGaWVsZHMsXG4gICAgICAgICAgICBvcmRlckJ5T3B0aW9ucyxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgb3B0aW9uc1F1ZXJ5O1xuICAgICAgICBjbG9uZWRGaWVsZHMgPSBjbG9uZWRGaWVsZHMgfHwgdmFyaWFibGUuZmlsdGVyRmllbGRzO1xuICAgICAgICAvLyBnZXQgdGhlIGZpbHRlciBmaWVsZHMgZnJvbSB0aGUgdmFyaWFibGVcbiAgICAgICAgXy5mb3JFYWNoKGNsb25lZEZpZWxkcywgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSAmJiAoIW9wdGlvbnMuZmlsdGVyRmllbGRzIHx8ICFvcHRpb25zLmZpbHRlckZpZWxkc1trZXldIHx8IG9wdGlvbnMuZmlsdGVyRmllbGRzW2tleV0ubG9naWNhbE9wID09PSAnQU5EJykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5maWVsZE5hbWUgPSBrZXk7XG4gICAgICAgICAgICAgICAgaWYgKExpdmVWYXJpYWJsZVV0aWxzLmlzU3RyaW5nVHlwZShMaXZlVmFyaWFibGVVdGlscy5nZXRTUUxGaWVsZFR5cGUodmFyaWFibGUsIHZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZmlsdGVyQ29uZGl0aW9uID0gREJfQ09OU1RBTlRTLkRBVEFCQVNFX01BVENIX01PREVTW3ZhbHVlLm1hdGNoTW9kZSB8fCB2YXJpYWJsZS5tYXRjaE1vZGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZS5pc1ZhcmlhYmxlRmlsdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmaWx0ZXJGaWVsZHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBnZXQgdGhlIGZpbHRlciBmaWVsZHMgZnJvbSB0aGUgb3B0aW9uc1xuICAgICAgICBfLmZvckVhY2gob3B0aW9ucy5maWx0ZXJGaWVsZHMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICB2YWx1ZS5maWVsZE5hbWUgPSBrZXk7XG4gICAgICAgICAgICB2YWx1ZS5maWx0ZXJDb25kaXRpb24gPSBEQl9DT05TVEFOVFMuREFUQUJBU0VfTUFUQ0hfTU9ERVNbdmFsdWUubWF0Y2hNb2RlIHx8IG9wdGlvbnMubWF0Y2hNb2RlIHx8IHZhcmlhYmxlLm1hdGNoTW9kZV07XG4gICAgICAgICAgICBmaWx0ZXJGaWVsZHMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodmFyaWFibGUub3BlcmF0aW9uID09PSAncmVhZCcgfHwgb3B0aW9ucy5vcGVyYXRpb24gPT09ICdyZWFkJykge1xuICAgICAgICAgICAgZmlsdGVyT3B0aW9ucyA9IExpdmVWYXJpYWJsZVV0aWxzLmdldEZpbHRlck9wdGlvbnModmFyaWFibGUsIGZpbHRlckZpZWxkcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgLyppZiBzZWFyY2hXaXRoUXVlcnkgaXMgdHJ1ZSwgdGhlbiBjb252ZXJ0IHRoZSBpbnB1dCBwYXJhbXMgaW50byBxdWVyeSBzdHJpbmcuIEZvciBleGFtcGxlIGlmIGZpcnN0TmFtZSBhbmQgbGFzdE5hbWVcbiAgICAgICAgIHNob3VsZCBiZSBzZW50IGFzIHBhcmFtcyB0aGVuIHF1ZXJ5IHN0cmluZyB3aWxsIGJlIHE9J2ZpcnN0TmFtZSBjb250YWluaW5nICdzb21lVmFsdWUnIE9SIGxhc3ROYW1lIGNvbnRhaW5pbmcgJ3NvbWVWYWx1ZScnXG4gICAgICAgICAqL1xuICAgICAgICBpZiAob3B0aW9ucy5zZWFyY2hXaXRoUXVlcnkgJiYgZmlsdGVyT3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIHF1ZXJ5IGZvciB2YXJpYWJsZSBmaWx0ZXIgZmllbGRzLiBUaGlzIGhhcyBBTkQgbG9naWNhbCBvcGVyYXRvclxuICAgICAgICAgICAgcXVlcnkgPSBMaXZlVmFyaWFibGVVdGlscy5nZXRTZWFyY2hRdWVyeShfLmZpbHRlcihmaWx0ZXJPcHRpb25zLCB7J2lzVmFyaWFibGVGaWx0ZXInOiB0cnVlfSksICcgQU5EICcsIHZhcmlhYmxlLmlnbm9yZUNhc2UsIG9wdGlvbnMuc2tpcEVuY29kZSk7XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBxdWVyeSBmb3Igb3B0aW9uIGZpbHRlciBmaWVsZHMuIFRoaXMgaGFzIGRlZmF1bHQgbG9naWNhbCBvcGVyYXRvciBhcyBPUlxuICAgICAgICAgICAgb3B0aW9uc1F1ZXJ5ID0gTGl2ZVZhcmlhYmxlVXRpbHMuZ2V0U2VhcmNoUXVlcnkoXy5maWx0ZXIoZmlsdGVyT3B0aW9ucywgeydpc1ZhcmlhYmxlRmlsdGVyJzogdW5kZWZpbmVkfSksICcgJyArIChvcHRpb25zLmxvZ2ljYWxPcCB8fCAnQU5EJykgKyAnICcsIHZhcmlhYmxlLmlnbm9yZUNhc2UsIG9wdGlvbnMuc2tpcEVuY29kZSk7XG4gICAgICAgICAgICBpZiAob3B0aW9uc1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYm90aCB2YXJpYWJsZSBhbmQgb3B0aW9uIHF1ZXJ5IGFyZSBwcmVzZW50LCBtZXJnZSB0aGVtIHdpdGggQU5EXG4gICAgICAgICAgICAgICAgcXVlcnkgPSBxdWVyeSA/IChxdWVyeSArICcgQU5EICggJyArIG9wdGlvbnNRdWVyeSArICcgKScpIDogb3B0aW9uc1F1ZXJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9yZGVyQnlGaWVsZHMgPSBnZXRFdmFsdWF0ZWRPcmRlckJ5KHZhcmlhYmxlLm9yZGVyQnksIG9wdGlvbnMub3JkZXJCeSk7XG4gICAgICAgIG9yZGVyQnlPcHRpb25zID0gb3JkZXJCeUZpZWxkcyA/ICdzb3J0PScgKyBvcmRlckJ5RmllbGRzIDogJyc7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdmaWx0ZXInOiBmaWx0ZXJPcHRpb25zLFxuICAgICAgICAgICAgJ3NvcnQnOiBvcmRlckJ5T3B0aW9ucyxcbiAgICAgICAgICAgICdxdWVyeSc6IHF1ZXJ5XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyogRnVuY3Rpb24gdG8gY2hlY2sgaWYgc3BlY2lmaWVkIGZpZWxkIGlzIG9mIHR5cGUgZGF0ZSovXG4gICAgc3RhdGljIGdldEZpZWxkVHlwZShmaWVsZE5hbWUsIHZhcmlhYmxlLCByZWxhdGVkRmllbGQ/KSB7XG4gICAgICAgIGxldCBmaWVsZFR5cGUsXG4gICAgICAgICAgICBjb2x1bW5zLFxuICAgICAgICAgICAgcmVzdWx0O1xuICAgICAgICBpZiAodmFyaWFibGUucHJvcGVydGllc01hcCkge1xuICAgICAgICAgICAgY29sdW1ucyA9IHZhcmlhYmxlLnByb3BlcnRpZXNNYXAuY29sdW1ucyB8fCBbXTtcbiAgICAgICAgICAgIHJlc3VsdCA9IF8uZmluZChjb2x1bW5zLCBvYmogPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmouZmllbGROYW1lID09PSBmaWVsZE5hbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGlmIHJlbGF0ZWQgZmllbGQgbmFtZSBwYXNzZWQsIGdldCBpdHMgdHlwZSBmcm9tIGNvbHVtbnMgaW5zaWRlIHRoZSBjdXJyZW50IGZpZWxkXG4gICAgICAgICAgICBpZiAocmVsYXRlZEZpZWxkICYmIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF8uZmluZChyZXN1bHQuY29sdW1ucywgb2JqID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iai5maWVsZE5hbWUgPT09IHJlbGF0ZWRGaWVsZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpZWxkVHlwZSA9IHJlc3VsdCAmJiByZXN1bHQudHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGRUeXBlO1xuICAgIH1cblxuICAgIC8vIFByZXBhcmUgZm9ybURhdGEgZm9yIGJsb2IgY29sdW1uc1xuICAgIHN0YXRpYyBwcmVwYXJlRm9ybURhdGEodmFyaWFibGVEZXRhaWxzLCByb3dPYmplY3QpIHtcbiAgICAgICAgY29uc3QgZm9ybURhdGE6IGFueSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICBmb3JtRGF0YS5yb3dEYXRhID0gXy5jbG9uZShyb3dPYmplY3QpO1xuICAgICAgICBfLmZvckVhY2gocm93T2JqZWN0LCAoY29sVmFsdWUsIGNvbE5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChMaXZlVmFyaWFibGVVdGlscy5nZXRGaWVsZFR5cGUoY29sTmFtZSwgdmFyaWFibGVEZXRhaWxzKSA9PT0gJ2Jsb2InKSB7XG4gICAgICAgICAgICAgICAgaWYgKF8uaXNPYmplY3QoY29sVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfLmlzQXJyYXkoY29sVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2goY29sVmFsdWUsIGZpbGVPYmplY3QgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChjb2xOYW1lLCBmaWxlT2JqZWN0LCBmaWxlT2JqZWN0Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoY29sTmFtZSwgY29sVmFsdWUsIGNvbFZhbHVlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJvd09iamVjdFtjb2xOYW1lXSA9IGNvbFZhbHVlICE9PSBudWxsID8gJycgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKFNXQUdHRVJfQ09OU1RBTlRTLldNX0RBVEFfSlNPTiwgbmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KHJvd09iamVjdCldLCB7XG4gICAgICAgICAgICB0eXBlOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gZm9ybURhdGE7XG4gICAgfVxuXG4gICAgc3RhdGljIHRyYXZlcnNlRmlsdGVyRXhwcmVzc2lvbnMoZmlsdGVyRXhwcmVzc2lvbnMsIHRyYXZlcnNlQ2FsbGJhY2tGbikge1xuICAgICAgICBpZiAoZmlsdGVyRXhwcmVzc2lvbnMgJiYgZmlsdGVyRXhwcmVzc2lvbnMucnVsZXMpIHtcbiAgICAgICAgICAgIF8uZm9yRWFjaChmaWx0ZXJFeHByZXNzaW9ucy5ydWxlcywgKGZpbEV4cE9iaiwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmaWxFeHBPYmoucnVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgTGl2ZVZhcmlhYmxlVXRpbHMudHJhdmVyc2VGaWx0ZXJFeHByZXNzaW9ucyhmaWxFeHBPYmosIHRyYXZlcnNlQ2FsbGJhY2tGbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyaWdnZXJGbih0cmF2ZXJzZUNhbGxiYWNrRm4sIGZpbHRlckV4cHJlc3Npb25zLCBmaWxFeHBPYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhdmVyc2VzIHJlY3Vyc2l2ZWx5IHRoZSBmaWx0ZXJFeHByZXNzaW9ucyBvYmplY3QgYW5kIGlmIHRoZXJlIGlzIGFueSByZXF1aXJlZCBmaWVsZCBwcmVzZW50IHdpdGggbm8gdmFsdWUsXG4gICAgICogdGhlbiB3ZSB3aWxsIHJldHVybiB3aXRob3V0IHByb2NlZWRpbmcgZnVydGhlci4gSXRzIHVwdG8gdGhlIGRldmVsb3BlciB0byBwcm92aWRlIHRoZSBtYW5kYXRvcnkgdmFsdWUsXG4gICAgICogaWYgaGUgd2FudHMgdG8gYXNzaWduIGl0IGluIHRlaCBvbmJlZm9yZTxkZWxldGUvaW5zZXJ0L3VwZGF0ZT5mdW5jdGlvbiB0aGVuIG1ha2UgdGhhdCBmaWVsZCBpblxuICAgICAqIHRoZSBmaWx0ZXIgcXVlcnkgc2VjdGlvbiBhcyBvcHRpb25hbFxuICAgICAqIEBwYXJhbSBmaWx0ZXJFeHByZXNzaW9ucyAtIHJlY3Vyc2l2ZSBydWxlIE9iamVjdFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCBvciBib29sZWFuLiBPYmplY3QgaWYgZXZlcnl0aGluZyBnZXRzIHZhbGlkYXRlZCBvciBlbHNlIGp1c3QgYm9vbGVhbiBpbmRpY2F0aW5nIGZhaWx1cmUgaW4gdGhlIHZhbGlkYXRpb25zXG4gICAgICovXG4gICAgc3RhdGljIGdldEZpbHRlckV4cHJGaWVsZHMoZmlsdGVyRXhwcmVzc2lvbnMpIHtcbiAgICAgICAgbGV0IGlzUmVxdWlyZWRGaWVsZEFic2VudCA9IGZhbHNlO1xuICAgICAgICBjb25zdCB0cmF2ZXJzZUNhbGxiYWNrRm4gPSAocGFyZW50RmlsRXhwT2JqLCBmaWxFeHBPYmopID0+IHtcbiAgICAgICAgICAgIGlmIChmaWxFeHBPYmpcbiAgICAgICAgICAgICAgICAmJiBmaWxFeHBPYmoucmVxdWlyZWRcbiAgICAgICAgICAgICAgICAmJiAoKF8uaW5kZXhPZihbJ251bGwnLCAnaXNub3RudWxsJywgJ2VtcHR5JywgJ2lzbm90ZW1wdHknLCAnbnVsbG9yZW1wdHknXSwgZmlsRXhwT2JqLm1hdGNoTW9kZSkgPT09IC0xKSAmJiBmaWxFeHBPYmoudmFsdWUgPT09ICcnKSkge1xuICAgICAgICAgICAgICAgIGlzUmVxdWlyZWRGaWVsZEFic2VudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBMaXZlVmFyaWFibGVVdGlscy50cmF2ZXJzZUZpbHRlckV4cHJlc3Npb25zKGZpbHRlckV4cHJlc3Npb25zLCB0cmF2ZXJzZUNhbGxiYWNrRm4pO1xuICAgICAgICByZXR1cm4gaXNSZXF1aXJlZEZpZWxkQWJzZW50ID8gIWlzUmVxdWlyZWRGaWVsZEFic2VudCA6IGZpbHRlckV4cHJlc3Npb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhcmlhYmxlXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24oKj0pOiAqfSByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggc2hvdWxkIGJlIGNhbGxlZCBmb3IgdGhlIHdoZXJlIGNsYXVzZS5cbiAgICAgKiBUaGlzIHJldHVybiBmdW5jdGlvbiBjYW4gdGFrZSBhIGZ1bmN0aW9uIGFzIGFyZ3VtZW50LiBUaGlzIGFyZ3VtZW50IGZ1bmN0aW9uIGNhbiBtb2RpZnkgdGhlIGZpbHRlciBmaWVsZHNcbiAgICAgKiBiZWZvcmUgZ2VuZXJhdGluZyB3aGVyZSBjbGF1c2UuXG4gICAgICovXG4gICAgc3RhdGljIGdldFdoZXJlQ2xhdXNlR2VuZXJhdG9yKHZhcmlhYmxlLCBvcHRpb25zLCB1cGRhdGVkRmlsdGVyRmllbGRzPzogYW55KSB7XG4gICAgICAgIHJldHVybiAobW9kaWZpZXIsIHNraXBFbmNvZGU/OiBib29sZWFuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbG9uZWRGaWVsZHMgPSBMaXZlVmFyaWFibGVVdGlscy5nZXRGaWx0ZXJFeHByRmllbGRzKGdldENsb25lZE9iamVjdCh1cGRhdGVkRmlsdGVyRmllbGRzIHx8IHZhcmlhYmxlLmZpbHRlckV4cHJlc3Npb25zKSk7XG4gICAgICAgICAgICAvLyB0aGlzIGZsYWcgc2tpcHMgdGhlIGVuY29kaW5nIG9mIHRoZSBxdWVyeVxuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChza2lwRW5jb2RlKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2tpcEVuY29kZSA9IHNraXBFbmNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kaWZpZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGluZyB0aGUgc2NlbmFyaW8gd2hlcmUgdmFyaWFibGUgY2FuIGFsc28gaGF2ZSBmaWx0ZXJGaWVsZHNcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5maWx0ZXJGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXIoY2xvbmVkRmllbGRzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb2RpZmllcihjbG9uZWRGaWVsZHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBMaXZlVmFyaWFibGVVdGlscy5wcmVwYXJlVGFibGVPcHRpb25zKHZhcmlhYmxlLCBvcHRpb25zLCBjbG9uZWRGaWVsZHMpLnF1ZXJ5O1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuIiwiaW1wb3J0IHsgam1lc3BhdGggfSBmcm9tICdAbWV0cmljaG9yL2ptZXNwYXRoJztcblxuLy8gZGVjbGFyZSBjb25zdCBfOiBhbnk7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuXG5leHBvcnQgY2xhc3MgUGFnaW5hdGlvblV0aWxzIHtcbiAgICAvKipcbiAgICAgKiBNb2RpZmllcyB0aGUgcXVlcnkgdmFsdWVzIHdpdGggdGhlIHBhZ2luYXRpb24gaW5mbyB3aGljaCBpcyByZXRyaWV2ZWQgZnJvbSB0aGUgcHJldmlvdXMgQVBJIHJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSB2YXJpYWJsZSB3aXRoaG9sZHMgdmFyaWFibGUgaW5mb3JtYXRpb24gXG4gICAgICogQHBhcmFtIG9wZXJhdGlvbkluZm8gaGFzIG1ldGFkYXRhIG9mIHRoZSB2YXJpYWJsZSBcbiAgICAgKiBAcGFyYW0gcGFnaW5hdGlvbkluZm8gaGFzIG1ldGFkYXRhIG9mIHRoZSB2YXJpYWJsZSBwYWdpbmF0aW9uIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7dm9pZH0gVGhpcyBtZXRob2QgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nXG4gICAgICovXG4gICAgc3RhdGljIHNldFBhZ2luYXRpb25RdWVyeVBhcmFtcyh2YXJpYWJsZSwgb3BlcmF0aW9uSW5mbywgcGFnaW5hdGlvbkluZm8pIHtcbiAgICAgICAgb3BlcmF0aW9uSW5mby5wYXJhbWV0ZXJzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAvLyBwYWdpbmF0aW9uIGlucHV0IGluZm9ybWF0aW9uIHZhcmllcyBiYXNlZCBvbiB0aGUgdHlwZVxuICAgICAgICAgICAgbGV0IGlucHV0UGFyYW07XG4gICAgICAgICAgICBpZiAocGFnaW5hdGlvbkluZm8udHlwZSA9PT0gJ29mZnNldCcgfHwgcGFnaW5hdGlvbkluZm8uaW5wdXQub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaW5wdXRQYXJhbSA9ICdvZmZzZXQnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dFBhcmFtID0gJ3BhZ2UnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbW9kaWZpZXMgcXVlcnkgdmFsdWVzIGJhc2VkIG9uIHRoZSBwYWdpbmF0aW9uIG9mIHZhcmlhYmxlXG4gICAgICAgICAgICAvLyBjb21wYXJlIHBhcmFtZXRlciBuYW1lIHdpdGggdGhlIGlucHV0IHBhcmFtZXRlcidzIHN0YXJ0aW5nIG5hbWluZyBrZXkgKGV4OiBjaGFubmVsY29udGV4dCBpbiBjaGFubmVsY29udGV4dC5wYWdpbmF0aW9uKVxuICAgICAgICAgICAgaWYgKGVsZW1lbnQubmFtZSA9PT0gcGFnaW5hdGlvbkluZm8uaW5wdXRbaW5wdXRQYXJhbV0uc3BsaXQoJy4nKVswXSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2FtcGxlVmFsdWUgPSB2YXJpYWJsZS5wYWdpbmF0aW9uWydwYWdlJ107XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQubmFtZSA9PT0gcGFnaW5hdGlvbkluZm8uaW5wdXQuc2l6ZS5zcGxpdCgnLicpWzBdKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zYW1wbGVWYWx1ZSA9IHZhcmlhYmxlLnBhZ2luYXRpb25bJ3NpemUnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBwYWdpbmF0aW9uIG9uIHRoZSB2YXJpYWJsZSBiYXNlZCBvbiB0aGUgcmVzcG9uc2Ugb2YgdGhlIHRyaWdnZXJlZCBhcGkgY2FsbC5cbiAgICAgKiBAcGFyYW0gdmFyaWFibGUgd2l0aGhvbGRzIHZhcmlhYmxlIGluZm9ybWF0aW9uIFxuICAgICAqIEBwYXJhbSByZXNwb25zZSBoYXMgZGF0YSBvZiB0aGUgYXBpIGNhbGwncyByZXNwb25zZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIGhhcyBpbmZvIG9mIHRoZSBhcGkncyBxdWVyeSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyB7dm9pZH0gVGhpcyBtZXRob2QgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nXG4gICAgICovXG4gICAgc3RhdGljIHNldFZhcmlhYmxlUGFnaW5hdGlvbih2YXJpYWJsZSwgcmVzcG9uc2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF2YXJpYWJsZS5wYWdpbmF0aW9uKSB7XG4gICAgICAgICAgICB2YXJpYWJsZS5wYWdpbmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIGVtcHR5OiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXJpYWJsZS5wYWdpbmF0aW9uWydzaXplJ10gPSByZXNwb25zZS5zaXplO1xuICAgICAgICB2YXJpYWJsZS5wYWdpbmF0aW9uWydwYWdlJ10gPSAgcmVzcG9uc2UucGFnZSB8fCAwO1xuICAgICAgICB2YXJpYWJsZS5wYWdpbmF0aW9uWyd0b3RhbEVsZW1lbnRzJ10gPSByZXNwb25zZS50b3RhbEVsZW1lbnRzO1xuICAgICAgICB2YXJpYWJsZS5wYWdpbmF0aW9uWydudW1iZXJPZkVsZW1lbnRzJ10gPSB2YXJpYWJsZS5wYWdpbmF0aW9uWydzaXplJ107XG4gICAgICAgIHZhcmlhYmxlLnBhZ2luYXRpb25bJ251bWJlciddID0gIG9wdGlvbnNbJ3BhZ2UnXSA/IG9wdGlvbnNbJ3BhZ2UnXSAtIDEgOiAwO1xuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZHVjZSB0b3RhbFBhZ2VzIGZyb20gdG90YWxFbGVtZW50cyBieSBzaXplLlxuICAgICAgICAgKiBJZiB0aGUgdG90YWwgZWxlbWVudHMgYXJlIGV2ZW5seSBzcGxpdCBhbW9uZyB0aGUgcGFnZXMsIGFzc2lnbiB0aGUgc2FtZSB0byB0b3RhbFBhZ2VzXG4gICAgICAgICAqIEVsc2UgYXNzaWduIHRvdGFsUGFnZXMgKyAxXG4gICAgICAgICAqL1xuICAgICAgICB2YXJpYWJsZS5wYWdpbmF0aW9uWyd0b3RhbFBhZ2VzJ10gPSAgdmFyaWFibGUucGFnaW5hdGlvblsndG90YWxFbGVtZW50cyddIC8gdmFyaWFibGUucGFnaW5hdGlvblsnc2l6ZSddO1xuICAgICAgICBpZiAodmFyaWFibGUucGFnaW5hdGlvblsndG90YWxFbGVtZW50cyddICUgdmFyaWFibGUucGFnaW5hdGlvblsnc2l6ZSddID09PSAwKSB7XG4gICAgICAgICAgICB2YXJpYWJsZS5wYWdpbmF0aW9uWyd0b3RhbFBhZ2VzJ10gPSBwYXJzZUludCh2YXJpYWJsZS5wYWdpbmF0aW9uWyd0b3RhbFBhZ2VzJ10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyaWFibGUucGFnaW5hdGlvblsndG90YWxQYWdlcyddID0gcGFyc2VJbnQodmFyaWFibGUucGFnaW5hdGlvblsndG90YWxQYWdlcyddKSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBwYWdpbmF0aW9uIHR5cGUgaXMgY3Vyc29yLCBmaWxsIG5leHQgJiBwcmV2XG4gICAgICAgIGlmIChyZXNwb25zZS5uZXh0KSB7XG4gICAgICAgICAgICB2YXJpYWJsZS5wYWdpbmF0aW9uWyduZXh0J10gPSByZXNwb25zZS5uZXh0O1xuICAgICAgICAgICAgdmFyaWFibGUucGFnaW5hdGlvblsncHJldiddID0gcmVzcG9uc2UucHJldjtcbiAgICAgICAgICAgIHZhcmlhYmxlLnBhZ2luYXRpb25bJ2xhc3QnXSA9IHJlc3BvbnNlLm5leHQgPyBmYWxzZSA6IHRydWU7XG4gICAgICAgICAgICB2YXJpYWJsZS5wYWdpbmF0aW9uWydmaXJzdCddID0gcmVzcG9uc2UucHJldiA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhcmlhYmxlLnBhZ2luYXRpb25bJ2ZpcnN0J10gPSB2YXJpYWJsZS5wYWdpbmF0aW9uWydwYWdlJ10gPD0gMSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBsYXN0IGJhc2VkIG9uIGN1cnJlbnQgcGFnZSBpbmRleCBhZ2FpbnN0IHRvdGFsIHBhZ2VzXG4gICAgICAgICAgICB2YXJpYWJsZS5wYWdpbmF0aW9uWydsYXN0J10gPSByZXNwb25zZS5oYXNNb3JlSXRlbXMgPT09ICcnID8gISh2YXJpYWJsZS5wYWdpbmF0aW9uWydwYWdlJ10gPCB2YXJpYWJsZS5wYWdpbmF0aW9uWyd0b3RhbFBhZ2VzJ10pIDogIXJlc3BvbnNlLmhhc01vcmVJdGVtcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSBleHByZXNzaW9uIGdpdmVuIGluIHBhZ2luYXRpb24gbWV0YWRhdGEncyBvdXRwdXRcbiAgICAgKiBAcGFyYW0gaXRlbSBoYXMgdmFsdWUgb2YgZWFjaCBrZXkgd2hpY2ggaXMgaW5zaWRlIG91dHB1dCBwYWdpbmF0aW9uIG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHJlc3BvbnNlIGhhcyBkYXRhIG9mIHRoZSBhcGkgY2FsbCdzIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHJlc0hlYWRlcnMgaGFzIGRhdGEgb2YgdGhlIGFwaSBjYWxsJ3MgcmVzcG9uc2UgaGVhZGVyc1xuICAgICAqIEBwYXJhbSByZXMgaG9sZHMgdGhlIGluZm9ybWF0aW9uIG9mIHBhZ2luYXRpb24gd2hpY2ggaGFzIHRvIGJlIHN0b3JlZCBvbiB0aGUgdmFyaWFibGVcbiAgICAgKiBAcGFyYW0ga2V5IGhhcyBrZXkgbmFtZSBhZ2FpbnN0IHdoaWNoIGRhdGEgaGFzIHRvIGJlIHN0b3JlZCBpbiBwYWdpbmF0aW9uIFxuICAgICAqIEByZXR1cm5zIHt2b2lkfSBUaGlzIG1ldGhvZCBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmdcbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0UGFnaW5hdGlvbkl0ZW1zKGl0ZW0sIHJlc3BvbnNlLCByZXMsIGtleSwgcmVzSGVhZGVycykge1xuICAgICAgICAvLyBpZiB0aGUgaXRlbSBoYXMgYm9keSwgcmVzb2x2ZSB0aGUgZXhwcmVzc2lvbiBhZ2FpbnN0IHRoZSByZXNwb25zZVxuICAgICAgICBpZiAoXy5zdGFydHNXaXRoKGl0ZW0sICckYm9keScpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5S2V5ID0gaXRlbS5yZXBsYWNlKCckYm9keS4nLCAnJyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc1trZXldID0gam1lc3BhdGguc2VhcmNoKHJlc3BvbnNlLCBib2R5S2V5KTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtpdGVtfSBleHByZXNzaW9uIG5lZWRzIHRvIGJlIGNvcnJlY3RlZCBhcyBwZXIgSk1FUyBndWlkZWxpbmVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoXy5zdGFydHNXaXRoKGl0ZW0sICckaGVhZGVyJykpIHsgLy8gaWYgdGhlIGl0ZW0gaGFzIGhlYWRlciwgcmVzb2x2ZSB0aGUgZXhwcmVzc2lvbiBhZ2FpbnN0IHRoZSByZXNwb25zZSBoZWFkZXJzIFxuICAgICAgICAgICAgY29uc3QgaGVhZGVyS2V5ID0gaXRlbS5yZXBsYWNlKCckaGVhZGVyLicsICcnKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSAgKDxhbnk+T2JqZWN0KS5mcm9tRW50cmllcyhyZXNIZWFkZXJzLmhlYWRlcnMpO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1zID0gaGVhZGVyS2V5LnNwbGl0KCcuJyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc1trZXldID0gam1lc3BhdGguc2VhcmNoKGhlYWRlcnMsIGhlYWRlclBhcmFtc1swXS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtpdGVtfSBleHByZXNzaW9uIG5lZWRzIHRvIGJlIGNvcnJlY3RlZCBhcyBwZXIgSk1FUyBndWlkZWxpbmVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzW2tleV0/Lmxlbmd0aCkgeyBcbiAgICAgICAgICAgICAgICBsZXQgaGVhZGVyVmFsID0gcmVzW2tleV0uam9pbigpO1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXJQYXJhbXMubGVuZ3RoID09PSAxKSB7IFxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogSWYgdGhlIGhlYWRlclBhcmFtcyBoYXMgb25seSAxIGtleSAod2hpY2ggaXMgbm90IGFuIG9iamVjdCkgbmFtZSBhc3NpbmcgaGVhZGVyVmFsIHRvIHRoZSByZXNba2V5XVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSBoZWFkZXJWYWw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGUgaGVhZGVyUGFyYW1zIGhhcyBtb3JlIHRoYW4gMSBrZXkgKGFuIG9iamVjdCksIHBhcnNlIHRoZSBzdHJpbmdpZmllZCBoZWFkZXJWYWwgd2hpY2ggaXMgYW4gb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAqIFJlc29sdmUgdGhlIGV4cHJlc3Npb24gYWdhaW5zdCBoZWFkZXJWYWwgb2JqZWN0IGFtZCBhc3NpZ24gaXQgdG8gcmVzW2tleV1cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGxldCBrZXlOYW1lID0gaGVhZGVyUGFyYW1zLnNsaWNlKDEpLmpvaW4oJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyUmVzcCA9IEpTT04ucGFyc2UoaGVhZGVyVmFsKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BlY2lhbENoYXIgPSAvWyFAIyQlXiYqKCkrXFw9XFxbXFxde307JzpcIlxcXFx8LDw+XFwvP10rLztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWNpYWxDaGFyLnRlc3Qoa2V5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGtleSBuYW1lIGhhcyBleHByZXNzaW9uIChleDogY29tcGFyaXNzaW9uIGV4cHJlc3Npb24pIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHJvb3Qga2V5IG5hbWUgdG8ga2V5TmFtZSBmb3IgSk1FUyB0byByZXNvbHZlIHRoZSBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlOYW1lID0gJ2hlYWRlclJlc3AuJyArIGtleU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1trZXldID0gam1lc3BhdGguc2VhcmNoKGhlYWRlclJlc3AsIGtleU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtpdGVtfSBleHByZXNzaW9uIG5lZWRzIHRvIGJlIGNvcnJlY3RlZCBhcyBwZXIgSk1FUyBndWlkZWxpbmVzYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHBhZ2luYXRpb24gaW5mb3JtYXRpb24gb2YgdGhlIHNlcnZpY2UgYmFzZWQgb24gaXRzIGV4aXN0ZW5jZSBvbiBzd2FnZ2VyIG9yIG9uIHRoZSB2YXJpYWJsZVxuICAgICAqIEBwYXJhbSB2YXJpYWJsZSB3aXRoaG9sZHMgdmFyaWFibGUgaW5mb3JtYXRpb24gXG4gICAgICogQHBhcmFtIG9wZXJhdGlvbkluZm8gaGFzIG1ldGFkYXRhIG9mIHRoZSB2YXJpYWJsZSBcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGlzIG1ldGhvZCByZXR1cm4gcGFnaW5hdGlvbiBtZXRhZGF0YVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRQYWdpbmF0aW9uSW5mbyhvcGVyYXRpb25JbmZvLCB2YXJpYWJsZSkge1xuICAgICAgICBpZiAob3BlcmF0aW9uSW5mbz8ucGFnaW5hdGlvbkluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb25JbmZvLnBhZ2luYXRpb25JbmZvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhcmlhYmxlLl9wYWdpbmF0aW9uQ29uZmlnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHF1ZXJ5IHBhcmFtcyB3aXRoIHRoZSBwYWdpbmF0aW9uIGluZm8sIGlmIHBhZ2luYXRpb24gbWV0YWRhdGEgaXMgcHJlc2VudCBpbiBxdWVyeSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gdmFyaWFibGUgd2l0aGhvbGRzIHZhcmlhYmxlIGluZm9ybWF0aW9uIFxuICAgICAqIEBwYXJhbSBvcGVyYXRpb25JbmZvIGhhcyBtZXRhZGF0YSBvZiB0aGUgdmFyaWFibGUgXG4gICAgICogQHBhcmFtIG9wdGlvbnMgaGFzIGluZm8gb2YgdGhlIGFwaSdzIHF1ZXJ5IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIHt2b2lkfSBUaGlzIG1ldGhvZCBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmdcbiAgICAgKi9cbiAgICBzdGF0aWMgY2hlY2tQYWdpbmF0aW9uQXRRdWVyeShvcGVyYXRpb25JbmZvLCB2YXJpYWJsZSwgb3B0aW9ucykgeyAgICAgICAgXG4gICAgICAgIGNvbnN0IHBhZ2luYXRpb25JbmZvID0gdGhpcy5nZXRQYWdpbmF0aW9uSW5mbyhvcGVyYXRpb25JbmZvLCB2YXJpYWJsZSk7XG4gICAgICAgIC8vIElmIHBhZ2UgaXMgbm90IGZpcnN0LCBwYWdpbmF0aW9uIGlzIHByZXNlbnQgb24gdGhlIHZhcmlhYmxlIGFuZCBwYWdpbmF0aW9uSW5mbydzIGlucHV0IG1ldGEgaGFzIHNpemUgc2V0IHBhZ2luYXRpb24gaW4gcXVlcnkgcGFyYW1zXG4gICAgICAgIGNvbnN0IGhhc1BhZ2luYXRpb24gPSBvcHRpb25zICYmIG9wdGlvbnNbJ3BhZ2UnXSAmJiBwYWdpbmF0aW9uSW5mbz8uaW5wdXQuc2l6ZSAmJiB2YXJpYWJsZS5wYWdpbmF0aW9uOyAgICBcbiAgICAgICAgaWYgKCFoYXNQYWdpbmF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaW5wdXRQYXJhbTtcbiAgICAgICAgLy8gaWYgcGFnaW5hdGlvbiB0eXBlIGlzIG9mZnNldCwgYXNzc2lnbiBpbnB1dFBhcmFtIHRvIG9mZnNldCBlbHNlIHBhZ2VcbiAgICAgICAgaWYgKHBhZ2luYXRpb25JbmZvLnR5cGUgPT09ICdvZmZzZXQnIHx8IHBhZ2luYXRpb25JbmZvLmlucHV0Lm9mZnNldCkge1xuICAgICAgICAgICAgaW5wdXRQYXJhbSA9ICdvZmZzZXQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRQYXJhbSA9ICdwYWdlJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbU5hbWUgPSBwYWdpbmF0aW9uSW5mby5pbnB1dFtpbnB1dFBhcmFtXS5zcGxpdCgnLicpWzBdOyBcbiAgICAgICAgY29uc3QgcGFyYW1PYmogPSBfLmZpbmQob3BlcmF0aW9uSW5mby5wYXJhbWV0ZXJzLCBmdW5jdGlvbihvYmopIHsgcmV0dXJuIG9iai5uYW1lID09PSBwYXJhbU5hbWUgfSk7ICAgXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSB2YXJpYWJsZSBoYXMgcXVlcnkgcGFyYW1zIGFuZCB0aGV5IGFyZSBub3QgZW1wdHlcbiAgICAgICAgaWYgKCFfLmlzRW1wdHkodmFyaWFibGUuZGF0YUJpbmRpbmcpICYmIHBhcmFtT2JqICYmIHBhcmFtT2JqLnBhcmFtZXRlclR5cGUgPT09ICdxdWVyeScpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRm9yIHBhZ2luYXRpb24gdHlwZSBvdGhlciB0aGFuIG9mZnNldCwgYXNzaWduIHBhZ2Ugd2hpY2ggaXMgcmVjaWV2ZWQgZnJvbSBvcHRpb25zXG4gICAgICAgICAgICAgKiBGb3Igb2Zmc2V0IHR5cGUsIGNhbGN1bGF0ZSBwYWdlIGZyb20gc2l6ZSBhbmQgb3B0aW9uc1twYWdlXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIXBhZ2luYXRpb25JbmZvLm91dHB1dD8ucGFnZSAmJiBwYWdpbmF0aW9uSW5mby50eXBlICE9PSAnb2Zmc2V0Jykge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlLnBhZ2luYXRpb25bJ3BhZ2UnXSA9IG9wdGlvbnNbJ3BhZ2UnXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGUucGFnaW5hdGlvblsncGFnZSddID0gdGhpcy5nZXRPZmZzZXRJbmZvKHZhcmlhYmxlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0UGFnaW5hdGlvblF1ZXJ5UGFyYW1zKHZhcmlhYmxlLCBvcGVyYXRpb25JbmZvLCBwYWdpbmF0aW9uSW5mbyk7ICBcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZHVjZXMgdGhlIG9mZnNldCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBzaXplIGFuZCBwYWdlIHBhcmFtc1xuICAgICAqIEBwYXJhbSB2YXJpYWJsZSB3aXRoaG9sZHMgdmFyaWFibGUgaW5mb3JtYXRpb24gXG4gICAgICogQHBhcmFtIG9wdGlvbnMgaGFzIGluZm8gb2YgdGhlIGFwaSdzIHF1ZXJ5IHBhcmFtc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IFJldHVybnMgdGhlIG5leHQgb2Zmc2V0IG51bWJlclxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRPZmZzZXRJbmZvKHZhcmlhYmxlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB2YXJpYWJsZS5wYWdpbmF0aW9uWydzaXplJ10gKiAob3B0aW9uc1sncGFnZSddID8gKG9wdGlvbnNbJ3BhZ2UnXSAtIDEpIDogMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBQYWdpbmF0aW9uIGRhdGEgb24gdGhlIHJlcXVlc3QgaW5mb3JtYXRpb25cbiAgICAgKiBAcGFyYW0gdmFyaWFibGUgd2l0aGhvbGRzIHZhcmlhYmxlIGluZm9ybWF0aW9uIFxuICAgICAqIEBwYXJhbSBvcGVyYXRpb25JbmZvIGhhcyBtZXRhZGF0YSBvZiB0aGUgdmFyaWFibGUgXG4gICAgICogQHBhcmFtIG9wdGlvbnMgaGFzIGluZm8gb2YgdGhlIGFwaSdzIHF1ZXJ5IHBhcmFtc1xuICAgICAqIEBwYXJhbSBwYWdpbmF0aW9uSW5mbyBoYXMgcGFnaW5hdGlvbiBpbmZvcm1hdGlvbiBvZiB0aGUgdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gaGVhZGVycyBoYXMgcmVxdWVzdCBoZWFkZXJzXG4gICAgICogQHBhcmFtIHJlcXVlc3RCb2R5IGhhcyByZXF1ZXN0IGJvZHlcbiAgICAgKiBAcGFyYW0gdXJsIGhhcyByZXF1ZXN0IHVybFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IFJldHVybnMgdGhlIHJlcXVlc3Qgb2JqZWN0IHdoaWNoIGhhcyBwYWdpbmF0aW9uIGluZm9cbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0UGFnaW5hdGlvbkF0UmVxKHBhZ2luYXRpb25JbmZvLCBvcGVyYXRpb25JbmZvLCB2YXJpYWJsZSwgaGVhZGVycywgcmVxdWVzdEJvZHksIHVybCwgb3B0aW9ucykge1xuICAgICAgICBsZXQgcmVxT2JqID0ge307XG4gICAgICAgIGxldCBpbnB1dFBhcmFtO1xuICAgICAgICBsZXQgcmVzT2JqID0ge307XG4gICAgICAgIC8vIHBhZ2luYXRpb24gaW5wdXQgaW5mb3JtYXRpb24gdmFyaWVzIGJhc2VkIG9uIHRoZSB0eXBlXG4gICAgICAgIGlmIChwYWdpbmF0aW9uSW5mby50eXBlID09PSAnb2Zmc2V0JyB8fCBwYWdpbmF0aW9uSW5mby5pbnB1dC5vZmZzZXQpIHtcbiAgICAgICAgICAgIGlucHV0UGFyYW0gPSAnb2Zmc2V0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0UGFyYW0gPSAncGFnZSc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1OYW1lID0gcGFnaW5hdGlvbkluZm8uaW5wdXRbaW5wdXRQYXJhbV0uc3BsaXQoJy4nKVswXTsgXG4gICAgICAgIC8vIGNoZWNrIGlmIHBhcmFtTmFtZSBpcyBwcmVzZW50IGluIHBhcmFtZXRlcnMgb2Ygb3BlcmF0aW9uIGluZm8gXG4gICAgICAgIGNvbnN0IHBhcmFtT2JqID0gXy5maW5kKG9wZXJhdGlvbkluZm8ucGFyYW1ldGVycywgZnVuY3Rpb24ob2JqKSB7IHJldHVybiBvYmoubmFtZSA9PT0gcGFyYW1OYW1lIH0pOyBcbiAgICAgICAgLy8gc2V0IHBhZ2Uvb2Zmc2V0IGFuZCBzaXplIGZyb20gcGFnaW5hdGlvbiBpZiBtYXRjaGVkIHBhcmFtZXRlcidzIHR5cGUgaXMgaGVhZGVyICBcbiAgICAgICAgaWYgKHBhcmFtT2JqPy5wYXJhbWV0ZXJUeXBlID09PSAnaGVhZGVyJykge1xuICAgICAgICAgICAgXy5zZXQocmVxT2JqLCBwYWdpbmF0aW9uSW5mby5pbnB1dFtpbnB1dFBhcmFtXSwgdmFyaWFibGUucGFnaW5hdGlvblsncGFnZSddKTtcbiAgICAgICAgICAgIF8uc2V0KHJlcU9iaiwgcGFnaW5hdGlvbkluZm8uaW5wdXQuc2l6ZSwgdmFyaWFibGUucGFnaW5hdGlvblsnc2l6ZSddKTtcbiAgICAgICAgICAgIGhlYWRlcnNbcGFyYW1OYW1lXSA9IEpTT04uc3RyaW5naWZ5KHJlcU9ialtwYXJhbU5hbWVdKTtcbiAgICAgICAgICAgIHJlc09ialsnaGVhZGVycyddID0gaGVhZGVycztcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbU9iaj8ucGFyYW1ldGVyVHlwZSA9PT0gJ2JvZHknKSB7IFxuICAgICAgICAgICAgLy8gc2V0IHBhZ2Uvb2Zmc2V0IGFuZCBzaXplIGZyb20gcGFnaW5hdGlvbiBpZiBtYXRjaGVkIHBhcmFtZXRlcidzIHR5cGUgaXMgYm9keSBcbiAgICAgICAgICAgIC8vIGFzc2lnbiBib2R5VmFsIHRvIHVwZGF0ZWQgcGFnaW5hdGlvbiBpbmZvIG9iamVjdFxuICAgICAgICAgICAgY29uc3QgYm9keVZhbCA9IEpTT04ucGFyc2UocGFyYW1PYmouc2FtcGxlVmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgYm9keVBhcmFtID0gcGFnaW5hdGlvbkluZm8uaW5wdXRbaW5wdXRQYXJhbV0uc3BsaXQoJy4nKVsxXVxuICAgICAgICAgICAgaWYgKGJvZHlWYWwgJiYgYm9keVZhbFtib2R5UGFyYW1dKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXRCb2R5UGFyYW0gPSBwYWdpbmF0aW9uSW5mby5pbnB1dFtpbnB1dFBhcmFtXS5zcGxpdCgnLicpLnNwbGljZSgxKS5qb2luKCcuJyk7ICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0UGFyYW0gIT09ICdvZmZzZXQnKSB7IFxuICAgICAgICAgICAgICAgICAgICBfLnNldChyZXFPYmosIGlucHV0Qm9keVBhcmFtLCB2YXJpYWJsZS5wYWdpbmF0aW9uWydwYWdlJ10pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF8uc2V0KHJlcU9iaiwgaW5wdXRCb2R5UGFyYW0sIHRoaXMuZ2V0T2Zmc2V0SW5mbyh2YXJpYWJsZSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfLnNldChyZXFPYmosIHBhZ2luYXRpb25JbmZvLmlucHV0LnNpemUuc3BsaXQoJy4nKS5zcGxpY2UoMSkuam9pbignLicpLCB2YXJpYWJsZS5wYWdpbmF0aW9uWydzaXplJ10pO1xuICAgICAgICAgICAgICAgIGJvZHlWYWxbYm9keVBhcmFtXSA9ICByZXFPYmpbYm9keVBhcmFtXTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHlWYWwpO1xuICAgICAgICAgICAgICAgIHJlc09ialsncmVxdWVzdEJvZHknXSA9IHJlcXVlc3RCb2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHZhcmlhYmxlLnBhZ2luYXRpb24ubmV4dCAmJiBwYXJhbU9iaikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGb3IgY3Vyc29yIHR5cGUgcGFnaW5hdGlvbiwgaWYgcGFnaW5hdGlvbiBpbmZvIGlzIHByZXNlbnQgaW4gdGhlIHBhdGggXG4gICAgICAgICAgICAgKiBCYXNlZCBvbiB3aGV0aGVyIHVzZXIgY2xpY2tzIG9uIHRoZSBuZXh0IG9yIHByZXYgYnV0dG9uIG1vZGlmeSB0aGUgdXJsIFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChwYXJhbU9iai5wYXJhbWV0ZXJUeXBlID09PSAncGF0aCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBvcGVyYXRpb25JbmZvLnJlbGF0aXZlUGF0aC5zcGxpdCgnLycpLFxuICAgICAgICAgICAgICAgIHBhcmFtQ29uZmlnID0gJ3snICsgcGFyYW1PYmoubmFtZSArICd9JyxcbiAgICAgICAgICAgICAgICBwYXJhbUluZGV4ID0gdXJsUGFyYW1zLmluZGV4T2YocGFyYW1Db25maWcpO1xuICAgICAgICAgICAgICAgIGxldCBpbnZva2VVcmw7XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlLnBhZ2luYXRpb24uaXNOZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGludm9rZVVybCA9IHZhcmlhYmxlLnBhZ2luYXRpb24ubmV4dC5zcGxpdCgnLycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGludm9rZVVybCA9IHZhcmlhYmxlLnBhZ2luYXRpb24ucHJldi5zcGxpdCgnLycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCB1cmxQYXRoUGFybWFzO1xuICAgICAgICAgICAgICAgIGxldCB1cmxQYXRoO1xuICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb25JbmZvLmRpcmVjdFBhdGgpIHsgLy8gRm9yIGRpcmVjdCBwYXRoLCBhcyB1cmwgaGFzIGhvc3RuYW1lLCBkZXJpdmF0ZSBwYXRobmFtZSB1c2luZyBVUkwgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIHVybFBhdGggPSBuZXcgVVJMKHVybCk7XG4gICAgICAgICAgICAgICAgICAgIHVybFBhdGhQYXJtYXMgPSB1cmxQYXRoLnBhdGhuYW1lLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgICAgICAgIHVybFBhdGhQYXJtYXNbcGFyYW1JbmRleF0gPSBpbnZva2VVcmxbcGFyYW1JbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHVybFBhdGgucGF0aG5hbWUgPSB1cmxQYXRoUGFybWFzLmpvaW4oJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gdXJsUGF0aC5ocmVmO1xuICAgICAgICAgICAgICAgICAgICByZXNPYmpbJ3VybCddID0gdXJsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIEVsc2UgbW9kaWZ5IHRoZSB1cmwgd2l0aCBpbmRleCBhcyArMSAoZm9sbG93aW5nIHByb3h5IHBhdHRlcm4pXG4gICAgICAgICAgICAgICAgICAgIHVybFBhdGhQYXJtYXMgPSB1cmwuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgdXJsUGF0aFBhcm1hc1twYXJhbUluZGV4ICsgMV0gPSBpbnZva2VVcmxbcGFyYW1JbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IHVybFBhdGhQYXJtYXMuam9pbignLycpO1xuICAgICAgICAgICAgICAgICAgICByZXNPYmpbJ3VybCddID0gdXJsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbU9iai5wYXJhbWV0ZXJUeXBlID09PSAncXVlcnknKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZvciBjdXJzb3IgdHlwZSBwYWdpbmF0aW9uLCBpZiBwYWdpbmF0aW9uIGluZm8gaXMgcHJlc2VudCBpbiB0aGUgcXVlcnkgXG4gICAgICAgICAgICAgKiBCYXNlZCBvbiB3aGV0aGVyIHVzZXIgY2xpY2tzIG9uIHRoZSBuZXh0IG9yIHByZXYgYnV0dG9uIG1vZGlmeSB0aGUgdXJsJ3MgcXVlcnkgcGFyYW1zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSB1cmwuc3BsaXQoJz8nKTtcbiAgICAgICAgICAgICAgICBsZXQgaW52b2tlVXJsO1xuICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZS5wYWdpbmF0aW9uLmlzTmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBpbnZva2VVcmwgPSB2YXJpYWJsZS5wYWdpbmF0aW9uLm5leHQuc3BsaXQoJz8nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnZva2VVcmwgPSB2YXJpYWJsZS5wYWdpbmF0aW9uLnByZXYuc3BsaXQoJz8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zWzFdID0gaW52b2tlVXJsWzFdO1xuICAgICAgICAgICAgICAgIHVybCA9IHVybFBhcmFtcy5qb2luKCc/Jyk7XG4gICAgICAgICAgICAgICAgcmVzT2JqWyd1cmwnXSA9IHVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzT2JqOyAgIFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBhZ2luYXRpb24gaW5mbyByZWNpZXZlZCBmcm9tIGFwaSdzIHJlc3BvbnNlIGluIHRoZSByZXMgb2JqZWN0XG4gICAgICogQHBhcmFtIG9wZXJhdGlvbkluZm8gaGFzIG1ldGFkYXRhIG9mIHRoZSB2YXJpYWJsZVxuICAgICAqIEBwYXJhbSByZXMgaG9sZHMgdGhlIGluZm9ybWF0aW9uIG9mIHBhZ2luYXRpb24gd2hpY2ggaGFzIHRvIGJlIHN0b3JlZCBvbiB0aGUgdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gcGFyYW1OYW1lIGhhcyBrZXkgbmFtZSBhZ2FpbnN0IHdoaWNoIGRhdGEgaGFzIHRvIGJlIHN0b3JlZCBpbiBwYWdpbmF0aW9uXG4gICAgICogQHBhcmFtIHZhcmlhYmxlIHdpdGhob2xkcyB2YXJpYWJsZSBpbmZvcm1hdGlvbiBcbiAgICAgKiBAcmV0dXJucyB7dm9pZH0gVGhpcyBtZXRob2QgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nXG4gICAgICovXG4gICAgc3RhdGljIHNldFBhcmFtZXRlclZhbChwYXJhbU5hbWUsIHJlcywgb3BlcmF0aW9uSW5mbywgdmFyaWFibGUpIHtcbiAgICAgICAgY29uc3QgcGFnaW5hdGlvbkluZm8gPSB0aGlzLmdldFBhZ2luYXRpb25JbmZvKG9wZXJhdGlvbkluZm8sIHZhcmlhYmxlKTtcbiAgICAgICAgY29uc3QgcGFyYW0gPSBwYWdpbmF0aW9uSW5mby5pbnB1dFtwYXJhbU5hbWVdLnNwbGl0KCcuJylbMF07IFxuICAgICAgICBjb25zdCBzaXplT2JqID0gXy5maW5kKG9wZXJhdGlvbkluZm8ucGFyYW1ldGVycywgZnVuY3Rpb24ob2JqKSB7IHJldHVybiBvYmoubmFtZSA9PT0gcGFyYW0gfSk7XG4gICAgICAgIHJlc1twYXJhbU5hbWVdID0gXy5yZXN1bHQoc2l6ZU9iaiwgJ3NhbXBsZVZhbHVlJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyByZXMgb2JqZWN0IGZyb20gdGhlIHJlc3BvbnNlIHJlY2lldmVkIGZyb20gdGhlIGFwaSB0cmlnZ2VyZWRcbiAgICAgKiBAcGFyYW0gdmFyaWFibGUgd2l0aGhvbGRzIHZhcmlhYmxlIGluZm9ybWF0aW9uIFxuICAgICAqIEBwYXJhbSBvcGVyYXRpb25JbmZvIGhhcyBtZXRhZGF0YSBvZiB0aGUgdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gcGFnaW5hdGlvbkluZm8gaGFzIG1ldGFkYXRhIG9mIHRoZSB2YXJpYWJsZSdzIHBhZ2luYXRpb25cbiAgICAgKiBAcGFyYW0gcmVzcG9uc2UgaGFzIGRhdGEgb2YgdGhlIGFwaSBjYWxsJ3MgcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBoYXMgaW5mbyBvZiB0aGUgYXBpJ3MgcXVlcnkgcGFyYW1zXG4gICAgICogQHBhcmFtIHJlc0hlYWRlcnMgaGFzIGRhdGEgb2YgdGhlIGFwaSBjYWxsJ3MgcmVzcG9uc2UgaGVhZGVyc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IEFuIG9iamVjdCB3aGljaCBob2xkcyB0aGUgaW5mb3JtYXRpb24gb2YgcGFnaW5hdGlvbiB3aGljaCBoYXMgdG8gYmUgc3RvcmVkIG9uIHRoZSB2YXJpYWJsZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZW5lcmF0ZVBhZ2luYXRpb25SZXMob3BlcmF0aW9uSW5mbywgcGFnaW5hdGlvbkluZm8sIHJlc3BvbnNlLCByZXNIZWFkZXJzLCBvcHRpb25zLCB2YXJpYWJsZSkge1xuICAgICAgICBsZXQgcmVzID0ge307XG4gICAgICAgIGNvbnN0IHJlc091dHB1dCA9IHBhZ2luYXRpb25JbmZvLm91dHB1dDtcbiAgICAgICAgLy8gSWYgcGFnaW5hdGlvbiB0eXBlIGlzIG5vdCBjdXJzb3IsIGNyZWF0ZSB0aGUgZm9sbG93aW5nIG1ldGFkYXRhIFxuICAgICAgICBpZiAoIXJlc091dHB1dD8ubmV4dCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiBzaXplIGlzIHByZXNlbnQgaW4gdGhlIHBhZ2luYXRpb24ncyBvdXRwdXQgbWV0YWRhdGEgZGVkdWNlIHNpemUgZnJvbSBhcGkncyByZXNwb25zZVxuICAgICAgICAgICAgICogRWxzZSBkZWR1Y2Ugc2l6ZSBmcm9tIHRoZSBwYWdpbmF0aW9uJ3MgaW5wdXQgbWV0YWRhdGEgc2l6ZSBrZXlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHJlc091dHB1dD8uc2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UGFnaW5hdGlvbkl0ZW1zKHJlc091dHB1dC5zaXplLCByZXNwb25zZSwgcmVzLCAnc2l6ZScsIHJlc0hlYWRlcnMpO1xuICAgICAgICAgICAgfSBlbHNlIHsgXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJWYWwoJ3NpemUnLCByZXMsIG9wZXJhdGlvbkluZm8sIHZhcmlhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgcGFnZSBpcyBwcmVzZW50IGluIHRoZSBwYWdpbmF0aW9uJ3Mgb3V0cHV0IG1ldGFkYXRhIGRlZHVjZSBwYWdlIGZyb20gYXBpJ3MgcmVzcG9uc2VcbiAgICAgICAgICAgICAqIEVsc2UgZGVkdWNlIHBhZ2UgZnJvbSB0aGUgcGFnaW5hdGlvbidzIGlucHV0IG1ldGFkYXRhIHBhZ2Uga2V5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChyZXNPdXRwdXQ/LnBhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBhZ2luYXRpb25JdGVtcyhyZXNPdXRwdXQucGFnZSwgcmVzcG9uc2UsIHJlcywgJ3BhZ2UnLCByZXNIZWFkZXJzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFnaW5hdGlvbkluZm8udHlwZSAhPT0gJ29mZnNldCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBhcmFtZXRlclZhbCgncGFnZScsIHJlcywgb3BlcmF0aW9uSW5mbywgdmFyaWFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0b3RhbEVsZW1lbnRzIGhhcyAkbWluVmFsdWUgaW4gaXQsIHNldCB0b3RhbEVsZW1lbnRzIGFzICRtaW5WYWx1ZVxuICAgICAgICAgICAgICogSWYgdGhlIHJlbmRlcmVkIGVsZW1lbnRzIGFyZSBncmVhdGVyIHRoYW4gJG1pblZhbHVlLCBzZXQgdG90YWxFbGVtZW50cyBhcyBOdW1iZXIgb2YgZWxlbWVudHMgcmVuZGVyZWQgKyAxXG4gICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgKiBJZiB0b3RhbEVsZW1lbnRzIGlzIHByZXNlbnQgaW4gdGhlIHBhZ2luYXRpb24ncyBvdXRwdXQgbWV0YWRhdGEgZGVkdWNlIHRvdGFsRWxlbWVudHMgZnJvbSBhcGkncyByZXNwb25zZVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICogSWYgUGFnaW5hdGlvbiB0eXBlIGlzIG9mZnNldCwgZGVkdWNlIHRvdGFsRWxlbWVudHMgZnJvbSBzaXplIGFuZCBvcHRpb25zW3BhZ2VdIGVsc2UgZGVkdWNlIGZyb20gc2l6ZSBhbmQgcmVzW3BhZ2VdXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChfLnN0YXJ0c1dpdGgocmVzT3V0cHV0Py50b3RhbEVsZW1lbnRzLCAnJG1pblZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3RhbEVsID0gcmVzT3V0cHV0LnRvdGFsRWxlbWVudHMucmVwbGFjZSgnJG1pblZhbHVlPScsICcnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlUGFyYW0gPSByZXNbJ3BhZ2UnXSA/IHJlc1sncGFnZSddIDogb3B0aW9uc1sncGFnZSddXG4gICAgICAgICAgICAgICAgY29uc3QgZWxSZW5kZXJlZCA9IHJlc1snc2l6ZSddICogcGFnZVBhcmFtO1xuICAgICAgICAgICAgICAgIGlmICghdmFyaWFibGUucGFnaW5hdGlvbiB8fCB2YXJpYWJsZS5wYWdpbmF0aW9uWyd0b3RhbEVsZW1lbnRzJ10gPiBlbFJlbmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1sndG90YWxFbGVtZW50cyddID0gcGFyc2VJbnQodG90YWxFbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzWyd0b3RhbEVsZW1lbnRzJ10gPSBlbFJlbmRlcmVkICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc091dHB1dD8udG90YWxFbGVtZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UGFnaW5hdGlvbkl0ZW1zKHJlc091dHB1dC50b3RhbEVsZW1lbnRzLCByZXNwb25zZSwgcmVzLCAndG90YWxFbGVtZW50cycsIHJlc0hlYWRlcnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGFnaW5hdGlvbkluZm8udHlwZSA9PT0gJ29mZnNldCcgfHwgcGFnaW5hdGlvbkluZm8uaW5wdXQub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1sndG90YWxFbGVtZW50cyddID0gKHJlc1snc2l6ZSddICogKG9wdGlvbnNbJ3BhZ2UnXSA/IG9wdGlvbnNbJ3BhZ2UnXSA6IDEpKSArIDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzWyd0b3RhbEVsZW1lbnRzJ10gPSAocmVzWydzaXplJ10gKiByZXNbJ3BhZ2UnXSkgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgaGFzTW9yZUl0ZW1zIGlzIHByZXNlbnQgaW4gdGhlIHBhZ2luYXRpb24ncyBvdXRwdXQgbWV0YWRhdGEgZGVkdWNlIGhhc01vcmVJdGVtcyBmcm9tIGFwaSdzIHJlc3BvbnNlXG4gICAgICAgICAgICAgKiBFbHNlIGFzc2lnbiBpdCBhcyBlbXB0eSB3aGljaCB3aWxsIGJlIGNhbGN1bGF0ZWQgYXQgcGFnaW5hdGlvbiBvYmplY3QgZ2VuZXJhdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAocmVzT3V0cHV0Py5oYXNNb3JlSXRlbXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBhZ2luYXRpb25JdGVtcyhyZXNPdXRwdXQuaGFzTW9yZUl0ZW1zLCByZXNwb25zZSwgcmVzLCAnaGFzTW9yZUl0ZW1zJywgcmVzSGVhZGVycyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc1snaGFzTW9yZUl0ZW1zJ10gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZXNPdXRwdXQpIHsgLy8gRm9yIGN1cnNvciB0eXBlIHBhZ2luYXRpb24gc2V0IG5leHQgYW5kIHByZXYga2V5cyBpbiByZXMgb2JqZWN0XG4gICAgICAgICAgICB0aGlzLnNldFBhZ2luYXRpb25JdGVtcyhyZXNPdXRwdXQubmV4dCwgcmVzcG9uc2UsIHJlcywgJ25leHQnLCByZXNIZWFkZXJzKTtcbiAgICAgICAgICAgIHRoaXMuc2V0UGFnaW5hdGlvbkl0ZW1zKHJlc091dHB1dC5wcmV2LCByZXNwb25zZSwgcmVzLCAncHJldicsIHJlc0hlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufSIsImltcG9ydCB7IGV4dHJhY3RUeXBlLCBpc0RlZmluZWQsIGlzRGF0ZVRpbWVUeXBlLCBnZXRCbG9iLCByZXBsYWNlIH0gZnJvbSBcIi4uLy4uL3V0aWwvdXRpbHNcIjtcblxuaW1wb3J0IHsgJHJvb3RTY29wZSwgQ09OU1RBTlRTLCBTV0FHR0VSX0NPTlNUQU5UUywgVkFSSUFCTEVfQ09OU1RBTlRTLCBXU19DT05TVEFOVFMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMvdmFyaWFibGVzLmNvbnN0YW50cyc7XG5pbXBvcnQgeyBpc0ZpbGVVcGxvYWRTdXBwb3J0ZWQgfSBmcm9tICcuL3ZhcmlhYmxlcy51dGlscyc7XG5pbXBvcnQgeyBnZXRBY2Nlc3NUb2tlbiB9IGZyb20gJy4vLi4vb0F1dGgudXRpbHMnO1xuaW1wb3J0IHsgZm9ybWF0RGF0ZX0gZnJvbSBcIi4vdmFyaWFibGVzLnV0aWxzXCI7XG5pbXBvcnQgeyBQYWdpbmF0aW9uVXRpbHMgfSBmcm9tICcuLi8uLi91dGlsL3ZhcmlhYmxlL3BhZ2luYXRpb24udXRpbHMnO1xuXG4vLyBkZWNsYXJlIGNvbnN0IF86IGFueTtcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5cblxuLyoqXG4gKiByZXR1cm5zIHRydWUgaWYgYSBTZXJ2aWNlIHZhcmlhYmxlIGlzOlxuICogIC0gZm9yIGEgcXVlcnkvcHJvY2VkdXJlXG4gKiAgLSBwZXJmb3JtcyBhIFBVVC9QT1NUIG9wZXJhdGlvbiwgaS5lLCB0YWtlcyBhIFJlcXVlc3QgQm9keSBhcyBpbnB1dFxuICogQHBhcmFtIHZhcmlhYmxlXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5jb25zdCBpc0JvZHlUeXBlUXVlcnlPclByb2NlZHVyZSA9ICh2YXJpYWJsZSkgPT4ge1xuICAgIHJldHVybiAoXy5pbmNsdWRlcyhbJ1F1ZXJ5RXhlY3V0aW9uJywgJ1Byb2NlZHVyZUV4ZWN1dGlvbiddLCB2YXJpYWJsZS5jb250cm9sbGVyKSkgJiYgKF8uaW5jbHVkZXMoWydwdXQnLCAncG9zdCddLCB2YXJpYWJsZS5vcGVyYXRpb25UeXBlKSk7XG59O1xuXG4vKipcbiAqIHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFyaWFibGUgaXMgYSBRdWVyeSBzZXJ2aWNlIHZhcmlhYmxlXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udHJvbGxlclxuICogQHBhcmFtIHtzdHJpbmd9IHNlcnZpY2VUeXBlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNRdWVyeVNlcnZpY2VWYXIgPSAoY29udHJvbGxlcjogc3RyaW5nLCBzZXJ2aWNlVHlwZTogc3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuIGNvbnRyb2xsZXIgPT09IFZBUklBQkxFX0NPTlNUQU5UUy5DT05UUk9MTEVSX1RZUEUuUVVFUlkgJiYgc2VydmljZVR5cGUgPT09IFZBUklBQkxFX0NPTlNUQU5UUy5TRVJWSUNFX1RZUEUuREFUQTtcbn07XG5cbi8qKlxuICogQXBwZW5kIGdpdmVuIHZhbHVlIHRvIHRoZSBmb3JtZGF0YVxuICogQHBhcmFtIGZvcm1EYXRhXG4gKiBAcGFyYW0gcGFyYW0gLSBQYXJhbSBmcm9tIHdoaWNoIHZhbHVlIGhhcyB0byBiZSB0YWtlblxuICogQHBhcmFtIHBhcmFtVmFsdWUgLSBWYWx1ZSB3aGljaCBpcyB0byBiZSBhcHBlbmRlZCB0byBmb3JtZGF0YVxuICovXG5jb25zdCBnZXRGb3JtRGF0YSA9IChmb3JtRGF0YSwgcGFyYW0sIHBhcmFtVmFsdWUpID0+IHtcbiAgICBjb25zdCBwYXJhbVR5cGUgPSBfLnRvTG93ZXIoZXh0cmFjdFR5cGUoXy5nZXQocGFyYW0sICdpdGVtcy50eXBlJykgfHwgcGFyYW0udHlwZSkpLFxuICAgICAgICBwYXJhbUNvbnRlbnRUeXBlID0gQ09OU1RBTlRTLmlzU3R1ZGlvTW9kZSA/IHBhcmFtWyd4LVdNLUNPTlRFTlRfVFlQRSddIDogcGFyYW0uY29udGVudFR5cGU7XG4gICAgaWYgKGlzRmlsZVVwbG9hZFN1cHBvcnRlZCgpKSB7XG4gICAgICAgIGlmICgocGFyYW1UeXBlICE9PSAnZmlsZScpICYmIChwYXJhbUNvbnRlbnRUeXBlID09PSAnc3RyaW5nJyB8fCAhcGFyYW1Db250ZW50VHlwZSkpIHtcbiAgICAgICAgICAgIGlmIChfLmlzT2JqZWN0KHBhcmFtVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1WYWx1ZSA9IEpTT04uc3RyaW5naWZ5KHBhcmFtVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKHBhcmFtLm5hbWUsIHBhcmFtVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKF8uaXNBcnJheShwYXJhbVZhbHVlKSAmJiBwYXJhbVR5cGUgPT09ICdmaWxlJykge1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChwYXJhbVZhbHVlLCBmdW5jdGlvbiAoZmlsZU9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQocGFyYW0ubmFtZSwgKGZpbGVPYmplY3QgJiYgZmlsZU9iamVjdC5jb250ZW50KSB8fCBnZXRCbG9iKGZpbGVPYmplY3QpLCBmaWxlT2JqZWN0Lm5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQocGFyYW0ubmFtZSwgZ2V0QmxvYihwYXJhbVZhbHVlLCBwYXJhbUNvbnRlbnRUeXBlKSwgcGFyYW1WYWx1ZSAmJiBwYXJhbVZhbHVlLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtRGF0YTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGZvciBtaXNzaW5nIHJlcXVpcmVkIHBhcmFtcyBhbmQgZm9ybWF0IHRoZSBkYXRlL3RpbWUgcGFyYW0gdmFsdWVzXG4gKiBAcGFyYW0gaW5wdXREYXRhXG4gKiBAcGFyYW0gcGFyYW1zXG4gKiBAcmV0dXJucyB7e3JlcXVlc3RCb2R5OiB7fTsgbWlzc2luZ1BhcmFtczogYW55W119fVxuICovXG5jb25zdCBwcm9jZXNzUmVxdWVzdEJvZHkgPSAoaW5wdXREYXRhLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHt9LFxuICAgICAgICBtaXNzaW5nUGFyYW1zID0gW107XG4gICAgbGV0IHBhcmFtVmFsdWU7XG4gICAgXy5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgIHBhcmFtVmFsdWUgPSBfLmdldChpbnB1dERhdGEsIHBhcmFtLm5hbWUpO1xuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1WYWx1ZSkgJiYgcGFyYW1WYWx1ZSAhPT0gJycgJiYgcGFyYW1WYWx1ZSAhPT0gbnVsbCAmJiAhcGFyYW0ucmVhZE9ubHkpIHtcbiAgICAgICAgICAgIC8vIFRvRG8gLSB2YXJpYWJsZSBzZXBlcmF0aW9uXG4gICAgICAgICAgICBwYXJhbVZhbHVlID0gaXNEYXRlVGltZVR5cGUocGFyYW0udHlwZSkgPyBmb3JtYXREYXRlKHBhcmFtVmFsdWUsIHBhcmFtLnR5cGUpIDogcGFyYW1WYWx1ZTtcbiAgICAgICAgICAgIC8vIENvbnN0cnVjdCAnLCcgc2VwYXJhdGVkIHN0cmluZyBpZiBwYXJhbSBpcyBub3QgYXJyYXkgdHlwZSBidXQgdmFsdWUgaXMgYW4gYXJyYXlcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkocGFyYW1WYWx1ZSkgJiYgXy50b0xvd2VyKGV4dHJhY3RUeXBlKHBhcmFtLnR5cGUpKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwYXJhbVZhbHVlID0gXy5qb2luKHBhcmFtVmFsdWUsICcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0Qm9keVtwYXJhbS5uYW1lXSA9IHBhcmFtVmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW0ucmVxdWlyZWQpIHtcbiAgICAgICAgICAgIG1pc3NpbmdQYXJhbXMucHVzaChwYXJhbS5uYW1lIHx8IHBhcmFtLmlkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgICdyZXF1ZXN0Qm9keSc6IHJlcXVlc3RCb2R5LFxuICAgICAgICAnbWlzc2luZ1BhcmFtcyc6IG1pc3NpbmdQYXJhbXNcbiAgICB9O1xufTtcblxuLyoqXG4gKiBEb25lIG9ubHkgZm9yIEhUVFAgY2FsbHMgbWFkZSB2aWEgdGhlIHByb3h5IHNlcnZlclxuICogR29lcyB0aG91Z2ggcmVxdWVzdCBoZWFkZXJzLCBhcHBlbmRzICdYLScgdG8gY2VydGFpbiBoZWFkZXJzXG4gKiB0aGVzZSBoZWFkZXJzIG5lZWQgbm90IGJlIHByb2Nlc3NlZCBhdCBwcm94eSBzZXJ2ZXIgYW5kIHNob3VsZCBkaXJlY3RseSBiZSBwYXNzZWQgdG8gdGhlIHNlcnZlclxuICogZS5nLiBBdXRob3JpemF0aW9uLCBDb29raWUsIGV0Yy5cbiAqIEBwYXJhbSBoZWFkZXJzXG4gKiBAcmV0dXJucyB7e319XG4gKi9cbmNvbnN0IGNsb2FrSGVhZGVyc0ZvclByb3h5ID0gKGhlYWRlcnMpID0+IHtcbiAgICBjb25zdCBfaGVhZGVycyA9IHt9LFxuICAgICAgICBVTkNMT0FLRURfSEVBREVSUyA9IFZBUklBQkxFX0NPTlNUQU5UUy5SRVNUX1NFUlZJQ0UuVU5DTE9BS0VEX0hFQURFUlMsXG4gICAgICAgIENMT0FLX1BSRUZJWCA9IFZBUklBQkxFX0NPTlNUQU5UUy5SRVNUX1NFUlZJQ0UuUFJFRklYLkNMT0FLX0hFQURFUl9LRVk7XG4gICAgXy5mb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uICh2YWwsIGtleSkge1xuICAgICAgICBpZiAoXy5pbmNsdWRlcyhVTkNMT0FLRURfSEVBREVSUywga2V5LnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICBfaGVhZGVyc1trZXldID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2hlYWRlcnNbQ0xPQUtfUFJFRklYICsga2V5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIF9oZWFkZXJzO1xufTtcblxuZXhwb3J0IGNsYXNzIFNlcnZpY2VWYXJpYWJsZVV0aWxzIHtcbiAgICAvKipcbiAgICAgKiBwcmVwYXJlcyB0aGUgSFRUUCByZXF1ZXN0IGluZm8gZm9yIGEgU2VydmljZSBWYXJpYWJsZVxuICAgICAqIEBwYXJhbSB2YXJpYWJsZVxuICAgICAqIEBwYXJhbSBvcGVyYXRpb25JbmZvXG4gICAgICogQHBhcmFtIGlucHV0RmllbGRzXG4gICAgICogQHJldHVybnMge2FueX1cbiAgICAgKi9cbiAgICBzdGF0aWMgY29uc3RydWN0UmVxdWVzdFBhcmFtcyh2YXJpYWJsZSwgb3BlcmF0aW9uSW5mbywgaW5wdXRGaWVsZHMsIG9wdGlvbnM/KSB7XG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGUgfHwge307XG5cbiAgICAgICAgLy8gb3BlcmF0aW9uSW5mbyBpcyBzcGVjaWZpY2FsbHkgbnVsbCBmb3IgdW5fYXV0aG9yaXplZCBhY2Nlc3NcbiAgICAgICAgaWYgKG9wZXJhdGlvbkluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ2Vycm9yJyA6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiBWQVJJQUJMRV9DT05TVEFOVFMuUkVTVF9TRVJWSUNFLkVSUl9UWVBFLlVTRVJfVU5BVVRIT1JJU0VELFxuICAgICAgICAgICAgICAgICAgICAnbWVzc2FnZSc6IFZBUklBQkxFX0NPTlNUQU5UUy5SRVNUX1NFUlZJQ0UuRVJSX01TRy5VU0VSX1VOQVVUSE9SSVNFRCxcbiAgICAgICAgICAgICAgICAgICAgJ2ZpZWxkJzogJ193bVNlcnZpY2VPcGVyYXRpb25JbmZvJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pc0VtcHR5KG9wZXJhdGlvbkluZm8pKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdlcnJvcicgOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogVkFSSUFCTEVfQ09OU1RBTlRTLlJFU1RfU0VSVklDRS5FUlJfVFlQRS5NRVRBREFUQV9NSVNTSU5HLFxuICAgICAgICAgICAgICAgICAgICAnbWVzc2FnZSc6IFZBUklBQkxFX0NPTlNUQU5UUy5SRVNUX1NFUlZJQ0UuRVJSX01TRy5NRVRBREFUQV9NSVNTSU5HLFxuICAgICAgICAgICAgICAgICAgICAnZmllbGQnOiAnX3dtU2VydmljZU9wZXJhdGlvbkluZm8nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb25JbmZvICYmIG9wZXJhdGlvbkluZm8uaW52YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAnZXJyb3InIDoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6IFZBUklBQkxFX0NPTlNUQU5UUy5SRVNUX1NFUlZJQ0UuRVJSX1RZUEUuQ1JVRF9PUEVSQVRJT05fTUlTU0lORyxcbiAgICAgICAgICAgICAgICAgICAgJ21lc3NhZ2UnOiBWQVJJQUJMRV9DT05TVEFOVFMuUkVTVF9TRVJWSUNFLkVSUl9NU0cuQ1JVRF9PUEVSQVRJT05fTUlTU0lORyxcbiAgICAgICAgICAgICAgICAgICAgJ2ZpZWxkJzogJ193bVNlcnZpY2VPcGVyYXRpb25JbmZvJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkaXJlY3RQYXRoID0gb3BlcmF0aW9uSW5mby5kaXJlY3RQYXRoIHx8ICcnLFxuICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gb3BlcmF0aW9uSW5mby5iYXNlUGF0aCA/IG9wZXJhdGlvbkluZm8uYmFzZVBhdGggKyBvcGVyYXRpb25JbmZvLnJlbGF0aXZlUGF0aCA6IG9wZXJhdGlvbkluZm8ucmVsYXRpdmVQYXRoLFxuICAgICAgICAgICAgaXNCb2R5VHlwZVF1ZXJ5UHJvY2VkdXJlID0gaXNCb2R5VHlwZVF1ZXJ5T3JQcm9jZWR1cmUodmFyaWFibGUpO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSAnJyxcbiAgICAgICAgICAgIGJvZHlJbmZvLFxuICAgICAgICAgICAgaGVhZGVycyA9IHt9LFxuICAgICAgICAgICAgcmVxdWVzdEJvZHksXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICByZXF1aXJlZFBhcmFtTWlzc2luZyA9IFtdLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgcGF0aFBhcmFtUmV4LFxuICAgICAgICAgICAgaW52b2tlUGFyYW1zLFxuICAgICAgICAgICAgYXV0aERldGFpbHMgPSBudWxsLFxuICAgICAgICAgICAgdW5hbWUsXG4gICAgICAgICAgICBwc3dkLFxuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgZm9ybURhdGEsXG4gICAgICAgICAgICBpc1Byb3h5Q2FsbCxcbiAgICAgICAgICAgIHBhcmFtVmFsdWVJbmZvLFxuICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgc2VjdXJpdHlEZWZuT2JqLFxuICAgICAgICAgICAgYWNjZXNzVG9rZW4sXG4gICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM7XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Rm9ybURhdGFPYmooKSB7XG4gICAgICAgICAgICBpZiAoZm9ybURhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybURhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1EYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VjdXJpdHlEZWZuT2JqID0gXy5nZXQob3BlcmF0aW9uSW5mby5zZWN1cml0eURlZmluaXRpb25zLCAnMCcpO1xuXG4gICAgICAgIGlmIChzZWN1cml0eURlZm5PYmopIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2VjdXJpdHlEZWZuT2JqLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFZBUklBQkxFX0NPTlNUQU5UUy5SRVNUX1NFUlZJQ0UuU0VDVVJJVFlfREVGTi5PQVVUSDI6XG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc1Rva2VuID0gZ2V0QWNjZXNzVG9rZW4oc2VjdXJpdHlEZWZuT2JqW1ZBUklBQkxFX0NPTlNUQU5UUy5SRVNUX1NFUlZJQ0UuT0FVVEhfUFJPVklERVJfS0VZXSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1tWQVJJQUJMRV9DT05TVEFOVFMuUkVTVF9TRVJWSUNFLkFVVEhfSERSX0tFWV0gPSBWQVJJQUJMRV9DT05TVEFOVFMuUkVTVF9TRVJWSUNFLlBSRUZJWC5BVVRIX0hEUl9WQUwuT0FVVEggKyAnICcgKyBhY2Nlc3NUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Vycm9yJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZScgOiBWQVJJQUJMRV9DT05TVEFOVFMuUkVTVF9TRVJWSUNFLkVSUl9UWVBFLk5PX0FDQ0VTU1RPS0VOLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWVzc2FnZScgOiBWQVJJQUJMRV9DT05TVEFOVFMuUkVTVF9TRVJWSUNFLkVSUl9NU0cuTk9fQUNDRVNTVE9LRU5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzZWN1cml0eURlZm5PYmonOiBzZWN1cml0eURlZm5PYmpcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBWQVJJQUJMRV9DT05TVEFOVFMuUkVTVF9TRVJWSUNFLlNFQ1VSSVRZX0RFRk4uQkFTSUM6XG4gICAgICAgICAgICAgICAgICAgIHVuYW1lID0gaW5wdXRGaWVsZHNbJ3dtX2F1dGhfdXNlcm5hbWUnXTtcbiAgICAgICAgICAgICAgICAgICAgcHN3ZCA9IGlucHV0RmllbGRzWyd3bV9hdXRoX3Bhc3N3b3JkJ107XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bmFtZSAmJiBwc3dkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPW1ZJQkhVXTogYmFzNjQgZW5jb2RpbmcgYWx0ZXJuYXRpdmUuXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW1ZBUklBQkxFX0NPTlNUQU5UUy5SRVNUX1NFUlZJQ0UuQVVUSF9IRFJfS0VZXSA9IFZBUklBQkxFX0NPTlNUQU5UUy5SRVNUX1NFUlZJQ0UuUFJFRklYLkFVVEhfSERSX1ZBTC5CQVNJQyArICcgJyArIGJ0b2EodW5hbWUgKyAnOicgKyBwc3dkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhEZXRhaWxzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogVkFSSUFCTEVfQ09OU1RBTlRTLlJFU1RfU0VSVklDRS5BVVRIX1RZUEUuQkFTSUNcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnIDogVkFSSUFCTEVfQ09OU1RBTlRTLlJFU1RfU0VSVklDRS5FUlJfVFlQRS5OT19DUkVERU5USUFMUyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21lc3NhZ2UnOiBWQVJJQUJMRV9DT05TVEFOVFMuUkVTVF9TRVJWSUNFLkVSUl9NU0cuTk9fQ1JFREVOVElBTFNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzZWN1cml0eURlZm5PYmonOiBzZWN1cml0eURlZm5PYmpcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHF1ZXJ5IHBhcmFtcywgaWYgcGFnaW5hdGlvbiBpbmZvIGlzIHByZXNlbnQgYW5kIHRoZSBpbmZvIHNob3VsZCBiZSBwcmVzZW50IGluIHF1ZXJ5XG4gICAgICAgIFBhZ2luYXRpb25VdGlscy5jaGVja1BhZ2luYXRpb25BdFF1ZXJ5KG9wZXJhdGlvbkluZm8sIHZhcmlhYmxlLCBvcHRpb25zKTtcblxuICAgICAgICBvcGVyYXRpb25JbmZvLnByb3h5U2V0dGluZ3MgPSBvcGVyYXRpb25JbmZvLnByb3h5U2V0dGluZ3MgfHwge3dlYjogdHJ1ZSwgbW9iaWxlOiBmYWxzZX07XG4gICAgICAgIG1ldGhvZCA9IG9wZXJhdGlvbkluZm8uaHR0cE1ldGhvZCB8fCBvcGVyYXRpb25JbmZvLm1ldGhvZFR5cGU7XG4gICAgICAgIGlzUHJveHlDYWxsID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFRvRG8gLSB2YXJpYWJsZSBzZXBlcmF0aW9uXG4gICAgICAgICAgICAvLyBpZiAoQ09OU1RBTlRTLmhhc0NvcmRvdmEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uSW5mby5wcm94eVNldHRpbmdzLm1vYmlsZTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb25JbmZvLnByb3h5U2V0dGluZ3Mud2ViO1xuICAgICAgICB9KCkpO1xuICAgICAgICB3aXRoQ3JlZGVudGlhbHMgPSBvcGVyYXRpb25JbmZvLnByb3h5U2V0dGluZ3Mud2l0aENyZWRlbnRpYWxzO1xuICAgICAgICB1cmwgPSBpc1Byb3h5Q2FsbCA/IHJlbGF0aXZlUGF0aCA6IGRpcmVjdFBhdGg7XG5cbiAgICAgICAgLyogbG9vcCB0aHJvdWdoIGFsbCB0aGUgcGFyYW1ldGVycyAqL1xuICAgICAgICBfLmZvckVhY2gob3BlcmF0aW9uSW5mby5wYXJhbWV0ZXJzLCBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICAgIC8vIFNldCBwYXJhbXMgYmFzZWQgb24gY3VycmVudCB3b3Jrc3BhY2VcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNldFBhcmFtc09mQ2hpbGROb2RlKCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dEZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBjYXNlIGZvciBib2R5IHR5cGUgcXVlcnkvcHJvY2VkdXJlIHZhcmlhYmxlIHdpdGggcXVlcnkgcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dEZpZWxkc1twYXJhbS5uYW1lXSAmJiBfLmlzT2JqZWN0KGlucHV0RmllbGRzW3BhcmFtLm5hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1WYWx1ZUluZm8gPSBpbnB1dEZpZWxkc1twYXJhbS5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtVmFsdWVJbmZvID0gaW5wdXRGaWVsZHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gXy5nZXQob3BlcmF0aW9uSW5mbywgWydkZWZpbml0aW9ucycsIHBhcmFtLnR5cGVdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgQXBpIERlc2lnbmVyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtVmFsdWVJbmZvID0gcGFyYW1WYWx1ZSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gcGFyYW0uY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcGFyYW1WYWx1ZSA9IHBhcmFtLnNhbXBsZVZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoKGlzRGVmaW5lZChwYXJhbVZhbHVlKSAmJiBwYXJhbVZhbHVlICE9PSBudWxsICYmIHBhcmFtVmFsdWUgIT09ICcnKSB8fCAoaXNCb2R5VHlwZVF1ZXJ5UHJvY2VkdXJlICYmIHBhcmFtLnR5cGUgIT09ICdmaWxlJykpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3JtYXQgZGF0ZVRpbWUgcGFyYW1zIGZvciBkYXRhU2VydmljZSB2YXJpYWJsZXNcbiAgICAgICAgICAgICAgICBpZiAodmFyaWFibGUuc2VydmljZVR5cGUgPT09IFZBUklBQkxFX0NPTlNUQU5UUy5TRVJWSUNFX1RZUEUuREFUQSAmJiBpc0RhdGVUaW1lVHlwZShwYXJhbS50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUb0RvIC0gdmFyaWFibGUgc2VwZXJhdGlvblxuICAgICAgICAgICAgICAgICAgICBwYXJhbVZhbHVlID0gZm9ybWF0RGF0ZShwYXJhbVZhbHVlLCBwYXJhbS50eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0ICcsJyBzZXBhcmF0ZWQgc3RyaW5nIGlmIHBhcmFtIGlzIG5vdCBhcnJheSB0eXBlIGJ1dCB2YWx1ZSBpcyBhbiBhcnJheVxuICAgICAgICAgICAgICAgIGlmIChfLmlzQXJyYXkocGFyYW1WYWx1ZSkgJiYgXy50b0xvd2VyKGV4dHJhY3RUeXBlKHBhcmFtLnR5cGUpKSA9PT0gJ3N0cmluZycgJiYgdmFyaWFibGUuc2VydmljZVR5cGUgPT09IFZBUklBQkxFX0NPTlNUQU5UUy5TRVJWSUNFX1RZUEUuREFUQSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbVZhbHVlID0gXy5qb2luKHBhcmFtVmFsdWUsICcsJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocGFyYW0ucGFyYW1ldGVyVHlwZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1FVRVJZJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBudWxsIHZhbHVlZCBxdWVyeSBwYXJhbXMgZm9yIHF1ZXJ5U2VydmljZSB2YXJpYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF8uaXNOdWxsKHBhcmFtVmFsdWUpICYmIGlzUXVlcnlTZXJ2aWNlVmFyKHZhcmlhYmxlLmNvbnRyb2xsZXIsIHZhcmlhYmxlLnNlcnZpY2VUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFxdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gJz8nICsgcGFyYW0ubmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMgKz0gJyYnICsgcGFyYW0ubmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdQQVRIJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIHJlcGxhY2luZyB0aGUgcGF0aCBwYXJhbSBiYXNlZCBvbiB0aGUgcmVndWxhciBleHByZXNzaW9uIGluIHRoZSByZWxhdGl2ZSBwYXRoICovXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoUGFyYW1SZXggPSBuZXcgUmVnRXhwKCdcXFxccypcXFxce1xcXFxzKicgKyBwYXJhbS5uYW1lICsgJyg6XFxcXC5cXFxcKyk/XFxcXHMqXFxcXH1cXFxccyonKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKHBhdGhQYXJhbVJleCwgcGFyYW1WYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSEVBREVSJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbcGFyYW0ubmFtZV0gPSBwYXJhbVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0JPRFknOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHBvc3QvcHV0IHF1ZXJ5IG1ldGhvZHMgd3JhcCB0aGUgaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0JvZHlUeXBlUXVlcnlQcm9jZWR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRQYXJhbXNPZkNoaWxkTm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlJbmZvID0gcHJvY2Vzc1JlcXVlc3RCb2R5KHBhcmFtVmFsdWVJbmZvLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5ID0gYm9keUluZm8ucmVxdWVzdEJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRQYXJhbU1pc3NpbmcgPSBfLmNvbmNhdChyZXF1aXJlZFBhcmFtTWlzc2luZywgYm9keUluZm8ubWlzc2luZ1BhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5ID0gcGFyYW1WYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdGT1JNREFUQSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNCb2R5VHlwZVF1ZXJ5UHJvY2VkdXJlICYmIHBhcmFtLm5hbWUgPT09IFNXQUdHRVJfQ09OU1RBTlRTLldNX0RBVEFfSlNPTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFBhcmFtc09mQ2hpbGROb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBxdWVyeS9wcm9jZWR1cmUgZm9ybURhdGEgbm9uLWZpbGUgcGFyYW1zIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlJbmZvID0gcHJvY2Vzc1JlcXVlc3RCb2R5KHBhcmFtVmFsdWVJbmZvLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5ID0gZ2V0Rm9ybURhdGEoZ2V0Rm9ybURhdGFPYmooKSwgcGFyYW0sIGJvZHlJbmZvLnJlcXVlc3RCb2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFBhcmFtTWlzc2luZyA9IF8uY29uY2F0KHJlcXVpcmVkUGFyYW1NaXNzaW5nLCBib2R5SW5mby5taXNzaW5nUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHkgPSBnZXRGb3JtRGF0YShnZXRGb3JtRGF0YU9iaigpLCBwYXJhbSwgcGFyYW1WYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZWRQYXJhbU1pc3NpbmcucHVzaChwYXJhbS5uYW1lIHx8IHBhcmFtLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaWYgcmVxdWlyZWQgcGFyYW0gbm90IGZvdW5kLCByZXR1cm4gZXJyb3JcbiAgICAgICAgaWYgKHJlcXVpcmVkUGFyYW1NaXNzaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAnZXJyb3InOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogVkFSSUFCTEVfQ09OU1RBTlRTLlJFU1RfU0VSVklDRS5FUlJfVFlQRS5SRVFVSVJFRF9GSUVMRF9NSVNTSU5HLFxuICAgICAgICAgICAgICAgICAgICAnZmllbGQnOiByZXF1aXJlZFBhcmFtTWlzc2luZy5qb2luKCcsJyksXG4gICAgICAgICAgICAgICAgICAgICdtZXNzYWdlJzogcmVwbGFjZShWQVJJQUJMRV9DT05TVEFOVFMuUkVTVF9TRVJWSUNFLkVSUl9NU0cuUkVRVUlSRURfRklFTERfTUlTU0lORywgW3JlcXVpcmVkUGFyYW1NaXNzaW5nLmpvaW4oJywnKV0pLFxuICAgICAgICAgICAgICAgICAgICAnc2tpcERlZmF1bHROb3RpZmljYXRpb24nOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldHRpbmcgYXBwcm9wcmlhdGUgY29udGVudC1UeXBlIGZvciByZXF1ZXN0IGFjY2VwdGluZyByZXF1ZXN0IGJvZHkgbGlrZSBQT1NULCBQVVQsIGV0Y1xuICAgICAgICBpZiAoIV8uaW5jbHVkZXMoV1NfQ09OU1RBTlRTLk5PTl9CT0RZX0hUVFBfTUVUSE9EUywgXy50b1VwcGVyKG1ldGhvZCkpKSB7XG4gICAgICAgICAgICAvKkJhc2VkIG9uIHRoZSBmb3JtRGF0YSBicm93c2VyIHdpbGwgYXV0b21hdGljYWxseSBzZXQgdGhlIGNvbnRlbnQgdHlwZSB0byAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScgYW5kIHdlYmtpdCBib3VuZGFyeSovXG4gICAgICAgICAgICBpZiAoIShvcGVyYXRpb25JbmZvLmNvbnN1bWVzICYmIChvcGVyYXRpb25JbmZvLmNvbnN1bWVzWzBdID09PSBXU19DT05TVEFOVFMuQ09OVEVOVF9UWVBFUy5NVUxUSVBBUlRfRk9STURBVEEpKSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gKG9wZXJhdGlvbkluZm8uY29uc3VtZXMgJiYgb3BlcmF0aW9uSW5mby5jb25zdW1lc1swXSkgfHwgJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIGNvbnN1bWVzIGhhcyBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQgYW5kXG4gICAgICAgIC8vIGlmIHRoZSBodHRwIHJlcXVlc3Qgb2YgZ2l2ZW4gbWV0aG9kIHR5cGUgY2FuIGhhdmUgYm9keSBzZW5kIHRoZSBxdWVyeVBhcmFtcyBhcyBGb3JtIERhdGFcbiAgICAgICAgaWYgKF8uaW5jbHVkZXMob3BlcmF0aW9uSW5mby5jb25zdW1lcywgV1NfQ09OU1RBTlRTLkNPTlRFTlRfVFlQRVMuRk9STV9VUkxfRU5DT0RFRClcbiAgICAgICAgICAgICYmICFfLmluY2x1ZGVzKFdTX0NPTlNUQU5UUy5OT05fQk9EWV9IVFRQX01FVEhPRFMsIChtZXRob2QgfHwgJycpLnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlICc/JyBhdCB0aGUgc3RhcnQgb2YgdGhlIHF1ZXJ5UGFyYW1zXG4gICAgICAgICAgICBpZiAocXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keSA9IChyZXF1ZXN0Qm9keSA/IHJlcXVlc3RCb2R5ICsgJyYnIDogJycpICsgcXVlcnlQYXJhbXMuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSBXU19DT05TVEFOVFMuQ09OVEVOVF9UWVBFUy5GT1JNX1VSTF9FTkNPREVEO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJsICs9IHF1ZXJ5UGFyYW1zO1xuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgICogZm9yIHByb3h5IGNhbGxzOlxuICAgICAgICAgKiAgLSBjbG9hayB0aGUgcHJvcGVyIGhlYWRlcnMgKHJlcXVpcmVkIG9ubHkgZm9yIFJFU1Qgc2VydmljZXMpXG4gICAgICAgICAqICAtIHByZXBhcmUgY29tcGxldGUgdXJsIGZyb20gcmVsYXRpdmVVcmxcbiAgICAgICAgICovXG4gICAgICAgIGlmIChpc1Byb3h5Q2FsbCkge1xuICAgICAgICAgICAgLy8gYXZvaWRpbmcgY2xvYWtIZWFkZXJzRm9yUHJveHkgd2hlbiB0aGUgbWV0aG9kIGlzIGludm9rZWQgZnJvbSBhcGlkZXNpZ25lci5cbiAgICAgICAgICAgIGhlYWRlcnMgPSAodmFyaWFibGUuc2VydmljZVR5cGUgIT09IFZBUklBQkxFX0NPTlNUQU5UUy5TRVJWSUNFX1RZUEUuUkVTVCAmJiB2YXJpYWJsZS5zZXJ2aWNlVHlwZSAhPT0gVkFSSUFCTEVfQ09OU1RBTlRTLlNFUlZJQ0VfVFlQRS5PUEVOQVBJKSB8fCBvcGVyYXRpb25JbmZvLnNraXBDbG9ha0hlYWRlcnMgPyBoZWFkZXJzIDogY2xvYWtIZWFkZXJzRm9yUHJveHkoaGVhZGVycyk7XG4gICAgICAgICAgICBpZiAodmFyaWFibGUuZ2V0UHJlZmFiTmFtZSgpICYmIFZBUklBQkxFX0NPTlNUQU5UUy5SRVNUX1NVUFBPUlRFRF9TRVJWSUNFUy5pbmRleE9mKHZhcmlhYmxlLnNlcnZpY2VUeXBlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvKiBpZiBpdCBpcyBhIHByZWZhYiB2YXJpYWJsZSAodXNlZCBpbiBhIG5vcm1hbCBwcm9qZWN0KSwgbW9kaWZ5IHRoZSB1cmwgKi9cbiAgICAgICAgICAgICAgICB1cmwgPSAncHJlZmFicy8nICsgdmFyaWFibGUuZ2V0UHJlZmFiTmFtZSgpICsgdXJsO1xuICAgICAgICAgICAgICAgIHRhcmdldCA9ICdpbnZva2VQcmVmYWJSZXN0U2VydmljZSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF2YXJpYWJsZS5nZXRQcmVmYWJOYW1lKCkpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSAnc2VydmljZXMnICsgdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXJsID0gJHJvb3RTY29wZS5wcm9qZWN0LmRlcGxveWVkVXJsICsgdXJsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgcGFnaW5hdGlvbiBpbmZvIGV4aXN0cywgcHJvY2VzcyBpbmZvIGluIHJlcXVlc3QgaGVhZGVycyBvciBib2R5IGJhc2VkIG9uIHRoZSBtZXRhZGF0YVxuICAgICAgICBjb25zdCBwYWdpbmF0aW9uSW5mbyA9IFBhZ2luYXRpb25VdGlscy5nZXRQYWdpbmF0aW9uSW5mbyhvcGVyYXRpb25JbmZvLCB2YXJpYWJsZSk7XG4gICAgICAgIGlmIChwYWdpbmF0aW9uSW5mbyAmJiB2YXJpYWJsZS5wYWdpbmF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwID0gUGFnaW5hdGlvblV0aWxzLnNldFBhZ2luYXRpb25BdFJlcShwYWdpbmF0aW9uSW5mbywgb3BlcmF0aW9uSW5mbywgdmFyaWFibGUsIGhlYWRlcnMsIHJlcXVlc3RCb2R5LCB1cmwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHJlc3ApIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcFsnaGVhZGVycyddKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMgPSByZXNwWydoZWFkZXJzJ107XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNwWydyZXF1ZXN0Qm9keSddKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5ID0gcmVzcFsncmVxdWVzdEJvZHknXVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzcFsndXJsJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gcmVzcFsndXJsJ11cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKmNyZWF0aW5nIHRoZSBwYXJhbXMgbmVlZGVkIHRvIGludm9rZSB0aGUgc2VydmljZS4gdXJsIGlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZWxhdGl2ZSBwYXRoIGZvciB0aGUgb3BlcmF0aW9uKi9cbiAgICAgICAgaW52b2tlUGFyYW1zID0ge1xuICAgICAgICAgICAgJ3Byb2plY3RJRCc6ICRyb290U2NvcGUucHJvamVjdC5pZCxcbiAgICAgICAgICAgICd1cmwnOiB1cmwsXG4gICAgICAgICAgICAndGFyZ2V0JzogdGFyZ2V0LFxuICAgICAgICAgICAgJ21ldGhvZCc6IG1ldGhvZCxcbiAgICAgICAgICAgICdoZWFkZXJzJzogaGVhZGVycyxcbiAgICAgICAgICAgICdkYXRhJzogcmVxdWVzdEJvZHksXG4gICAgICAgICAgICAnYXV0aERldGFpbHMnOiBhdXRoRGV0YWlscyxcbiAgICAgICAgICAgICdpc0RpcmVjdENhbGwnOiAhaXNQcm94eUNhbGwsXG4gICAgICAgICAgICAnaXNFeHRVUkwnOiB2YXJpYWJsZS5zZXJ2aWNlVHlwZSA9PT0gVkFSSUFCTEVfQ09OU1RBTlRTLlNFUlZJQ0VfVFlQRS5SRVNULFxuICAgICAgICAgICAgJ3dpdGhDcmVkZW50aWFscyc6IHdpdGhDcmVkZW50aWFsc1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBpbnZva2VQYXJhbXM7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzRmlsZVVwbG9hZFJlcXVlc3QodmFyaWFibGUpIHtcbiAgICAgICAgLy8gdGVtcG9yYXJ5IGZpeCwgaGF2ZSB0byBmaW5kIHByb3BlciBzb2x1dGlvbiBmb3IgZGVjaWRpbmcgd2VhdGhlciB0byB1cGxvYWQgZmlsZSB0aHJvdWdoIHZhcmlhYmxlXG4gICAgICAgIHJldHVybiB2YXJpYWJsZS5zZXJ2aWNlID09PSAnRmlsZVNlcnZpY2UnICYmIHZhcmlhYmxlLm9wZXJhdGlvbiA9PT0gJ3VwbG9hZEZpbGUnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYXJyYXkgb2YgcXVlcnkgcGFyYW0gbmFtZXMgZm9yIHZhcmlhYmxlIG90aGVyIHRoZW4gcGFnZSxzaXplLHNvcnRcbiAgICAgKiBAcGFyYW1zIHtwYXJhbXN9IHBhcmFtcyBvZiB0aGUgdmFyaWFibGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZXhjbHVkZVBhZ2luYXRpb25QYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfLm1hcChfLnJlamVjdChwYXJhbXMsIChwYXJhbSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF8uaW5jbHVkZXMoVkFSSUFCTEVfQ09OU1RBTlRTLlBBR0lOQVRJT05fUEFSQU1TLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfSksIGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtLm5hbWU7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCB7ZmluZFZhbHVlT2YsIGdldFZhbGlkSlNPTiwgbm9vcCwgZXh0cmFjdFR5cGUsIERhdGFUeXBlLCBERUZBVUxUX0ZPUk1BVFMsIHJlcGxhY2V9IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHsgVkFSSUFCTEVfQ09OU1RBTlRTIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL3ZhcmlhYmxlcy5jb25zdGFudHMnO1xuXG5kZWNsYXJlIGNvbnN0IHdpbmRvdzogYW55LCBtb21lbnQ7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IGhlIGZyb20gJ2hlJztcblxuZXhwb3J0IGxldCBhcHBNYW5hZ2VyOiBhbnk7XG5leHBvcnQgbGV0IGh0dHBTZXJ2aWNlOiBhbnk7XG5leHBvcnQgbGV0IG1ldGFkYXRhU2VydmljZTogYW55O1xuZXhwb3J0IGxldCBuYXZpZ2F0aW9uU2VydmljZTogYW55O1xuZXhwb3J0IGxldCByb3V0ZXJTZXJ2aWNlOiBhbnk7XG5leHBvcnQgbGV0IHRvYXN0ZXJTZXJ2aWNlOiBhbnk7XG5leHBvcnQgbGV0IG9hdXRoU2VydmljZTogYW55O1xuZXhwb3J0IGxldCBzZWN1cml0eVNlcnZpY2U6IGFueTtcbmV4cG9ydCBsZXQgZGlhbG9nU2VydmljZTogYW55O1xuZXhwb3J0IGxldCBpbnRlcm5hbEJvdW5kTm9kZU1hcCA9IG5ldyBNYXAoKTtcbmNvbnN0IHRpbWVycyA9IG5ldyBNYXAoKTtcbmNvbnN0IERPVF9FWFBSX1JFWCA9IC9eXFxbKFwifCcpW1xcd1xcV10qKFxcMSlcXF0kLztcbmNvbnN0IF9pbnZva2UgPSAodmFyaWFibGUsIG9wKSA9PiB7XG4gICAgbGV0IGRlYm91bmNlZEZuLFxuICAgICAgICBjYW5jZWxGbiA9IF8ubm9vcCxcbiAgICAgICAgcmV0VmFsO1xuICAgIGlmICh0aW1lcnMuaGFzKHZhcmlhYmxlKSkge1xuICAgICAgICBjYW5jZWxGbiA9IHRpbWVycy5nZXQodmFyaWFibGUpLmNhbmNlbDtcbiAgICB9XG4gICAgY2FuY2VsRm4oKTtcbiAgICBkZWJvdW5jZWRGbiA9IF8uZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXRWYWwgPSB2YXJpYWJsZVtvcF0oKTtcbiAgICAgICAgLy8gaGFuZGxlIHByb21pc2VzIHRvIGF2b2lkIHVuY2F1Z2h0IHByb21pc2UgZXJyb3JzIGluIGNvbnNvbGVcbiAgICAgICAgaWYgKHJldFZhbCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldFZhbC5jYXRjaChfLm5vb3ApO1xuICAgICAgICB9XG4gICAgfSwgMTAwKTtcbiAgICB0aW1lcnMuc2V0KHZhcmlhYmxlLCBkZWJvdW5jZWRGbik7XG4gICAgZGVib3VuY2VkRm4oKTtcbn07XG5cbmV4cG9ydCBjb25zdCB3bVNldERlcGVuZGVuY3kgPSAodHlwZTogc3RyaW5nLCByZWY6IGFueSkgPT4ge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdhcHBNYW5hZ2VyJzpcbiAgICAgICAgICAgIGFwcE1hbmFnZXIgPSByZWY7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaHR0cCc6XG4gICAgICAgICAgICBodHRwU2VydmljZSA9IHJlZjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtZXRhZGF0YSc6XG4gICAgICAgICAgICBtZXRhZGF0YVNlcnZpY2UgPSByZWY7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbmF2aWdhdGlvblNlcnZpY2UnOlxuICAgICAgICAgICAgbmF2aWdhdGlvblNlcnZpY2UgPSByZWY7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncm91dGVyJzpcbiAgICAgICAgICAgIHJvdXRlclNlcnZpY2UgPSByZWY7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndG9hc3Rlcic6XG4gICAgICAgICAgICB0b2FzdGVyU2VydmljZSA9ICByZWY7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb0F1dGgnOlxuICAgICAgICAgICAgb2F1dGhTZXJ2aWNlID0gIHJlZjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzZWN1cml0eSc6XG4gICAgICAgICAgICBzZWN1cml0eVNlcnZpY2UgPSAgcmVmO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICAgICAgICBkaWFsb2dTZXJ2aWNlID0gcmVmO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBkZWJvdW5jZVZhcmlhYmxlQ2FsbCA9IF9pbnZva2U7XG4vKipcbiAqIHJldHVybnMgdHJ1ZSBpZiBIVE1MNSBGaWxlIEFQSSBpcyBhdmFpbGFibGUgZWxzZSBmYWxzZVxuICogQHJldHVybnMge3twcm90b3R5cGU6IEJsb2I7IG5ldyhibG9iUGFydHM/OiBhbnlbXSwgb3B0aW9ucz86IEJsb2JQcm9wZXJ0eUJhZyk6IEJsb2J9fVxuICovXG5leHBvcnQgY29uc3QgaXNGaWxlVXBsb2FkU3VwcG9ydGVkID0gKCkgPT4ge1xuICAgIC8vIFRvRG8gLSB2YXJpYWJsZSBzZXBlcmF0aW9uXG4gICAgcmV0dXJuICh3aW5kb3cuRmlsZSAmJiB3aW5kb3cuRmlsZVJlYWRlciAmJiB3aW5kb3cuRmlsZUxpc3QgJiYgd2luZG93LkJsb2IpO1xufTtcblxuLyoqXG4gKiBmb3JtYXR0aW5nIHRoZSBleHByZXNzaW9uIGFzIHJlcXVpcmVkIGJ5IGJhY2tlbmQgd2hpY2ggd2FzIGVuY2xvc2VkIGJ5ICR7PGV4cHJlc3Npb24+fS5cbiAqIEBwYXJhbSBmaWVsZERlZnNcbiAqIHJldHVybnMgZmllbGREZWZzXG4gKi9cbmV4cG9ydCBjb25zdCBmb3JtYXRFeHBvcnRFeHByZXNzaW9uID0gKGZpZWxkRGVmczogYW55KSA9PiB7XG4gICAgXy5mb3JFYWNoKGZpZWxkRGVmcywgZnVuY3Rpb24gKGZpZWxkRGVmOiBhbnkpIHtcbiAgICAgICAgaWYgKGZpZWxkRGVmLmV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIGZpZWxkRGVmLmV4cHJlc3Npb24gPSAnJHsnICsgZmllbGREZWYuZXhwcmVzc2lvbiArICd9JztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmaWVsZERlZnM7XG59O1xuLyoqXG4gKiBwcmVwYXJlIGEgYmxvYiBvYmplY3QgYmFzZWQgb24gdGhlIGNvbnRlbnQgYW5kIGNvbnRlbnQgdHlwZSBwcm92aWRlZFxuICogaWYgY29udGVudCBpcyBibG9iIGl0c2VsZiwgc2ltcGx5IHJldHVybnMgaXQgYmFja1xuICogQHBhcmFtIHZhbFxuICogQHBhcmFtIHZhbENvbnRlbnRUeXBlXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEJsb2IgPSAodmFsOiBhbnksIHZhbENvbnRlbnRUeXBlPzogYW55KSA9PiB7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgY29uc3QganNvblZhbCA9IGdldFZhbGlkSlNPTih2YWwpO1xuICAgIGlmIChqc29uVmFsICYmIGpzb25WYWwgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgdmFsID0gbmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KGpzb25WYWwpXSwgeyB0eXBlOiB2YWxDb250ZW50VHlwZSB8fCAnYXBwbGljYXRpb24vanNvbicgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3IEJsb2IoW3ZhbF0sIHsgdHlwZTogdmFsQ29udGVudFR5cGUgfHwgJ3RleHQvcGxhaW4nIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufTtcbi8qKlxuICogc2V0cyB0aGUgdmFsdWUgYWdhaW5zdCBwYXNzZWQga2V5IG9uIHRoZSBcImlucHV0RmllbGRzXCIgb2JqZWN0IGluIHRoZSB2YXJpYWJsZVxuICogQHBhcmFtIHRhcmdldE9iajogdGhlIG9iamVjdCBpbiB3aGljaCB0aGUga2V5LCB2YWx1ZSBpcyB0byBiZSBzZXRcbiAqIEBwYXJhbSB2YXJpYWJsZVxuICogQHBhcmFtIGtleTogY2FuIGJlOlxuICogIC0gYSBzdHJpbmcgZS5nLiBcInVzZXJuYW1lXCJcbiAqICAtIGFuIG9iamVjdCwgZS5nLiB7XCJ1c2VybmFtZVwiOiBcImpvaG5cIiwgXCJzc25cIjogXCIxMTExMVwifVxuICogQHBhcmFtIHZhbFxuICogLSBpZiBrZXkgaXMgc3RyaW5nLCB0aGUgdmFsdWUgYWdhaW5zdCBpdCAoZm9yIHRoYXQgZGF0YSB0eXBlKVxuICogLSBpZiBrZXkgaXMgb2JqZWN0LCBub3QgcmVxdWlyZWRcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5leHBvcnQgY29uc3Qgc2V0SW5wdXQgPSAodGFyZ2V0T2JqOiBhbnksIGtleTogYW55LCB2YWw6IGFueSwgb3B0aW9uczogYW55KSA9PiB7XG4gICAgdGFyZ2V0T2JqID0gdGFyZ2V0T2JqIHx8IHt9O1xuICAgIGxldCBrZXlzLFxuICAgICAgICBsYXN0S2V5LFxuICAgICAgICBwYXJhbU9iaiA9IHt9O1xuXG4gICAgLy8gY29udGVudCB0eXBlIGNoZWNrXG4gICAgaWYgKF8uaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgc3dpdGNoIChvcHRpb25zLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2ZpbGUnOlxuICAgICAgICAgICAgICAgIHZhbCA9IGdldEJsb2IodmFsLCBvcHRpb25zLmNvbnRlbnRUeXBlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgdmFsID0gXy5pc051bWJlcih2YWwpID8gdmFsIDogcGFyc2VJbnQodmFsLCAxMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXy5pc09iamVjdChrZXkpKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBwYXNzZWQgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCBpdHNlbGZcbiAgICAgICAgcGFyYW1PYmogPSBrZXk7XG4gICAgfSBlbHNlIGlmIChrZXkuaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yICcuJyBpbiBrZXkgZS5nLiAnZW1wbG95ZWUuZGVwYXJ0bWVudCdcbiAgICAgICAga2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgICBsYXN0S2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgLy8gRmluZGluZyB0aGUgb2JqZWN0IGJhc2VkIG9uIHRoZSBrZXlcbiAgICAgICAgdGFyZ2V0T2JqID0gZmluZFZhbHVlT2YodGFyZ2V0T2JqLCBrZXlzLmpvaW4oJy4nKSwgdHJ1ZSk7XG4gICAgICAgIGtleSA9IGxhc3RLZXk7XG4gICAgICAgIHBhcmFtT2JqW2tleV0gPSB2YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1PYmpba2V5XSA9IHZhbDtcbiAgICB9XG5cbiAgICBfLmZvckVhY2gocGFyYW1PYmosIGZ1bmN0aW9uIChwYXJhbVZhbDogYW55LCBwYXJhbUtleTogYW55KSB7XG4gICAgICAgIHRhcmdldE9ialtwYXJhbUtleV0gPSBwYXJhbVZhbDtcbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0T2JqO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBkZWNvZGVzIHRoZSB2YXJpYWJsZSBkYXRhIHdoaWNoIGlzIGVuY29kZWQgZnJvbSBiYWNrZW5kIGJlZm9yZSBzaG93aW5nIGluIHRoZSB3aWRnZXRzLlxuICogSXQgdGFrZXMgdmFyaWFibGUgcmVzcG9uc2UgY29udGVudCBhcyBpbnB1dCBhbmQgaXRlcmF0ZXMgcmVjdXJzaXZlbHksXG4gKiBpZiB0aGUgdmFsdWUgaXMgc3RyaW5nIHR5cGUgdGhlbiBpdCB3aWxsIGRlY29kZSB0aGUgZGF0YS5cbiAqIEBwYXJhbSByZXNwb25zZUNvbnRlbnQgKEFycmF5IG9mIG9iamVjdHMpXG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGVEYXRhID0gKHJlc3BvbnNlQ29udGVudDogYW55KSA9PiB7XG4gICAgaWYgKCFyZXNwb25zZUNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlQ29udGVudDtcbiAgICB9XG4gICAgaWYgKF8uaXNBcnJheShyZXNwb25zZUNvbnRlbnQpKSB7XG4gICAgICAgIF8uZm9yRWFjaChyZXNwb25zZUNvbnRlbnQsIChkYXRhOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGlmIChfLmlzU3RyaW5nKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGh0bWxEZWNvZGUoZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goZGF0YSwgKHZhbHVlOiBhbnksIGtleTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiBfLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtrZXldID0gaHRtbERlY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZURhdGEodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChyZXNwb25zZUNvbnRlbnQpKSB7XG4gICAgICAgIF8uZm9yRWFjaChyZXNwb25zZUNvbnRlbnQsICh2YWx1ZTogYW55LCBrZXk6IGFueSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIF8uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VDb250ZW50W2tleV0gPSBodG1sRGVjb2RlKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVEYXRhKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKHJlc3BvbnNlQ29udGVudCkpIHtcbiAgICAgICAgcmVzcG9uc2VDb250ZW50ID0gaHRtbERlY29kZShyZXNwb25zZUNvbnRlbnQpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2VDb250ZW50O1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGh0bWxEZWNvZGUoaW5wdXQ6IGFueSkge1xuICAgIHJldHVybiBoZS51bmVzY2FwZShpbnB1dCk7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB2YXJPcmRlclxuICogQHBhcmFtIG9wdGlvbnNPcmRlclxuICogQHJldHVybnMge2FueX1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEV2YWx1YXRlZE9yZGVyQnkgPSAodmFyT3JkZXI6IGFueSwgb3B0aW9uc09yZGVyOiBhbnkpID0+IHtcbiAgICBsZXQgb3B0aW9uRmllbGRzOiBhbnksXG4gICAgICAgIHZhck9yZGVyQnk7XG4gICAgLy8gSWYgb3B0aW9ucyBvcmRlciBieSBpcyBub3QgZGVmaW5lZCwgcmV0dXJuIHZhcmlhYmxlIG9yZGVyXG4gICAgaWYgKCFvcHRpb25zT3JkZXIgfHwgXy5pc0VtcHR5KG9wdGlvbnNPcmRlcikpIHtcbiAgICAgICAgcmV0dXJuIHZhck9yZGVyO1xuICAgIH1cbiAgICAvLyBJZiB2YXJpYWJsZSBvcmRlciBieSBpcyBub3QgZGVmaW5lZCwgcmV0dXJuIG9wdGlvbnMgb3JkZXJcbiAgICBpZiAoIXZhck9yZGVyKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zT3JkZXI7XG4gICAgfVxuICAgIC8vIElmIGJvdGggYXJlIHByZXNlbnQsIGNvbWJpbmUgdGhlIG9wdGlvbnMgb3JkZXIgYW5kIHZhcmlhYmxlIG9yZGVyLCB3aXRoIG9wdGlvbnMgb3JkZXIgYXMgcHJlY2VkZW5jZVxuICAgIHZhck9yZGVyICAgICA9IF8uc3BsaXQodmFyT3JkZXIsICcsJyk7XG4gICAgb3B0aW9uc09yZGVyID0gXy5zcGxpdChvcHRpb25zT3JkZXIsICcsJyk7XG4gICAgb3B0aW9uRmllbGRzID0gXy5tYXAob3B0aW9uc09yZGVyLCBmdW5jdGlvbiAob3JkZXI6IGFueSkge1xuICAgICAgICByZXR1cm4gXy5zcGxpdChfLnRyaW0ob3JkZXIpLCAnICcpWzBdO1xuICAgIH0pO1xuICAgIC8vIElmIGEgZmllbGQgaXMgcHJlc2VudCBpbiBib3RoIG9wdGlvbnMgYW5kIHZhcmlhYmxlLCByZW1vdmUgdGhlIHZhcmlhYmxlIG9yZGVyYnlcbiAgICBfLnJlbW92ZSh2YXJPcmRlciwgZnVuY3Rpb24gKG9yZGVyQnk6IGFueSkge1xuICAgICAgICByZXR1cm4gXy5pbmNsdWRlcyhvcHRpb25GaWVsZHMsIF8uc3BsaXQoXy50cmltKG9yZGVyQnkpLCAnICcpWzBdKTtcbiAgICB9KTtcbiAgICB2YXJPcmRlckJ5ID0gdmFyT3JkZXIubGVuZ3RoID8gJywnICsgXy5qb2luKHZhck9yZGVyLCAnLCcpIDogJyc7XG4gICAgcmV0dXJuIF8uam9pbihvcHRpb25zT3JkZXIsICcsJykgKyB2YXJPcmRlckJ5O1xufTtcblxuY29uc3QgcHJvY2Vzc1ZhcmlhYmxlUG9zdEJpbmRVcGRhdGUgPSAobm9kZU5hbWUsIG5vZGVWYWwsIG5vZGVUeXBlLCB2YXJpYWJsZSwgbm9VcGRhdGU/KSA9PiB7XG4gICAgc3dpdGNoICh2YXJpYWJsZS5jYXRlZ29yeSkge1xuICAgICAgICBjYXNlIFZBUklBQkxFX0NPTlNUQU5UUy5DQVRFR09SWS5MSVZFOlxuICAgICAgICAgICAgaWYgKHZhcmlhYmxlLm9wZXJhdGlvbiA9PT0gJ3JlYWQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnZGF0YUJpbmRpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChub2RlVmFsLCBmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlLmZpbHRlckZpZWxkc1trZXldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IHZhbFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGUuZmlsdGVyRmllbGRzW25vZGVOYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IG5vZGVWYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHlwZScgOiBub2RlVHlwZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBpZiBhdXRvLXVwZGF0ZSBzZXQgZm9yIHRoZSB2YXJpYWJsZSB3aXRoIHJlYWQgb3BlcmF0aW9uIG9ubHksIGdldCBpdHMgZGF0YSAqL1xuICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZS5hdXRvVXBkYXRlICYmICFfLmlzVW5kZWZpbmVkKG5vZGVWYWwpICYmIF8uaXNGdW5jdGlvbih2YXJpYWJsZS5saXN0UmVjb3JkcykgJiYgIW5vVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9pbnZva2UodmFyaWFibGUsICdsaXN0UmVjb3JkcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnZGF0YUJpbmRpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlLmlucHV0RmllbGRzID0gbm9kZVZhbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZS5pbnB1dEZpZWxkc1tub2RlTmFtZV0gPSBub2RlVmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBpZiBhdXRvLXVwZGF0ZSBzZXQgZm9yIHRoZSB2YXJpYWJsZSB3aXRoIHJlYWQgb3BlcmF0aW9uIG9ubHksIGdldCBpdHMgZGF0YSAqL1xuICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZS5hdXRvVXBkYXRlICYmICFfLmlzVW5kZWZpbmVkKG5vZGVWYWwpICYmIF8uaXNGdW5jdGlvbih2YXJpYWJsZVt2YXJpYWJsZS5vcGVyYXRpb24gKyAnUmVjb3JkJ10pICYmICFub1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBfaW52b2tlKHZhcmlhYmxlLCB2YXJpYWJsZS5vcGVyYXRpb24gKyAnUmVjb3JkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVkFSSUFCTEVfQ09OU1RBTlRTLkNBVEVHT1JZLkNSVUQ6XG4gICAgICAgICAgICBpZiAodmFyaWFibGUub3BlcmF0aW9uVHlwZSA9PT0gJ2xpc3QnICYmIHZhcmlhYmxlLmF1dG9VcGRhdGUgJiYgIV8uaXNVbmRlZmluZWQobm9kZVZhbCkgJiYgXy5pc0Z1bmN0aW9uKHZhcmlhYmxlLmludm9rZSkgJiYgIW5vVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgX2ludm9rZSh2YXJpYWJsZSwgJ2ludm9rZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVkFSSUFCTEVfQ09OU1RBTlRTLkNBVEVHT1JZLlNFUlZJQ0U6XG4gICAgICAgIGNhc2UgVkFSSUFCTEVfQ09OU1RBTlRTLkNBVEVHT1JZLkxPR0lOOlxuICAgICAgICAgICAgaWYgKHZhcmlhYmxlLmF1dG9VcGRhdGUgJiYgIV8uaXNVbmRlZmluZWQobm9kZVZhbCkgJiYgXy5pc0Z1bmN0aW9uKHZhcmlhYmxlLmludm9rZSkgJiYgIW5vVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgX2ludm9rZSh2YXJpYWJsZSwgJ2ludm9rZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVkFSSUFCTEVfQ09OU1RBTlRTLkNBVEVHT1JZLkRFVklDRTpcbiAgICAgICAgICAgIHZhcmlhYmxlW25vZGVOYW1lXSA9IG5vZGVWYWw7XG4gICAgICAgICAgICBpZiAodmFyaWFibGUuYXV0b1VwZGF0ZSAmJiAhXy5pc1VuZGVmaW5lZChub2RlVmFsKSAmJiBfLmlzRnVuY3Rpb24odmFyaWFibGUuaW52b2tlKSAmJiAhbm9VcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBfaW52b2tlKHZhcmlhYmxlLCAnaW52b2tlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG4vKipcbiogUmV0dXJucyB0aGUgb2JqZWN0IG5vZGUgZm9yIGEgYmluZCBvYmplY3QsIHdoZXJlIHRoZSB2YWx1ZSBoYXMgdG8gYmUgdXBkYXRlZFxuKiBvYmoudGFyZ2V0ID0gXCJhXCJcbiAgICAqIEBwYXJhbSBvYmpcbiogQHBhcmFtIHJvb3RcbiogQHBhcmFtIHZhcmlhYmxlXG4qIEByZXR1cm5zIHsqfVxuKi9cbmV4cG9ydCBjb25zdCBnZXRUYXJnZXRPYmogPSAob2JqLCByb290LCB2YXJpYWJsZSkgPT4ge1xuICAgIC8qXG4gICAgICogaWYgdGhlIHRhcmdldCBrZXkgaXMgaW4gdGhlIGZvcm0gYXMgXCJbJ215LnBhcmFtJ11cIlxuICAgICAqIGtlZXAgdGhlIHRhcmdldCBrZXkgYXMgXCJteS5wYXJhbVwiIGFuZCBkbyBub3Qgc3BsaXQgZnVydGhlclxuICAgICAqIHRoaXMgaXMgZG9uZSwgc28gdGhhdCwgdGhlIGNvbXB1dGVkIHZhbHVlIGFnYWluc3QgdGhpcyBiaW5kaW5nIGlzIGFzc2lnbmVkIGFzXG4gICAgICogICAgICB7XCJteS5wYXJhbVwiOiBcInZhbHVlXCJ9XG4gICAgICogYW5kIG5vdCBhc1xuICAgICAqICAgICAge1xuICAgICAqICAgICAgICAgIFwibXlcIjoge1xuICAgICAqICAgICAgICAgICAgICBcInBhcmFtXCI6IFwidmFsdWVcIlxuICAgICAqICAgICAgICAgIH1cbiAgICAgKiAgICAgIH1cbiAgICAgKi9cbiAgICBsZXQgdGFyZ2V0ID0gb2JqLnRhcmdldCxcbiAgICAgICAgdGFyZ2V0T2JqO1xuICAgIGNvbnN0IHJvb3ROb2RlID0gdmFyaWFibGVbcm9vdF07XG4gICAgaWYgKERPVF9FWFBSX1JFWC50ZXN0KHRhcmdldCkpIHtcbiAgICAgICAgdGFyZ2V0T2JqID0gcm9vdE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnN1YnN0cigwLCB0YXJnZXQubGFzdEluZGV4T2YoJy4nKSk7XG4gICAgICAgIGlmIChvYmoudGFyZ2V0ID09PSByb290KSB7XG4gICAgICAgICAgICB0YXJnZXRPYmogPSB2YXJpYWJsZTtcbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHRhcmdldE9iaiA9IGZpbmRWYWx1ZU9mKHJvb3ROb2RlLCB0YXJnZXQsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0T2JqID0gcm9vdE5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldE9iajtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUga2V5IGZvciB0aGUgdGFyZ2V0IG9iamVjdFxuICogdGhlIGNvbXB1dGVkIHZhbHVlIHdpbGwgYmUgdXBkYXRlZCBhZ2FpbnN0IHRoaXMga2V5IGluIHRoZSB0YXJnZXRPYmplY3QoY29tcHV0ZWQgYnkgZ2V0VGFyZ2V0T2JqKCkpXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKiBAcGFyYW0gcmVnZXhcbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnQgY29uc3QgZ2V0VGFyZ2V0Tm9kZUtleSA9ICh0YXJnZXQpID0+IHtcbiAgICAvKlxuICAgICAqIGlmIHRoZSB0YXJnZXQga2V5IGlzIGluIHRoZSBmb3JtIGFzIFwiWydteS5wYXJhbSddXCJcbiAgICAgKiBrZWVwIHRoZSB0YXJnZXQga2V5IGFzIFwibXkucGFyYW1cIiBhbmQgZG8gbm90IHNwbGl0IGZ1cnRoZXJcbiAgICAgKiB0aGlzIGlzIGRvbmUsIHNvIHRoYXQsIHRoZSBjb21wdXRlZCB2YWx1ZSBhZ2FpbnN0IHRoaXMgYmluZGluZyBpcyBhc3NpZ25lZCBhc1xuICAgICAqICAgICAge1wibXkucGFyYW1cIjogXCJ2YWx1ZVwifVxuICAgICAqIGFuZCBub3QgYXNcbiAgICAgKiAgICAgIHtcbiAgICAgKiAgICAgICAgICBcIm15XCI6IHtcbiAgICAgKiAgICAgICAgICAgICAgXCJwYXJhbVwiOiBcInZhbHVlXCJcbiAgICAgKiAgICAgICAgICB9XG4gICAgICogICAgICB9XG4gICAgICovXG4gICAgbGV0IHRhcmdldE5vZGVLZXk7XG4gICAgaWYgKERPVF9FWFBSX1JFWC50ZXN0KHRhcmdldCkpIHtcbiAgICAgICAgdGFyZ2V0Tm9kZUtleSA9IHRhcmdldC5yZXBsYWNlKC9eKFxcW1tcIiddKXwoW1wiJ11cXF0pJC9nLCAnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0Tm9kZUtleSA9IHRhcmdldC5zcGxpdCgnLicpLnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0Tm9kZUtleTtcbn07XG5cbmV4cG9ydCBjb25zdCBzZXRWYWx1ZVRvTm9kZSA9ICh0YXJnZXQsIG9iaiwgcm9vdCwgdmFyaWFibGUsIHZhbHVlLCBub1VwZGF0ZT8pID0+IHtcbiAgICBjb25zdCB0YXJnZXROb2RlS2V5ID0gZ2V0VGFyZ2V0Tm9kZUtleSh0YXJnZXQpLFxuICAgICAgICB0YXJnZXRPYmogPSBnZXRUYXJnZXRPYmoob2JqLCByb290LCB2YXJpYWJsZSk7XG4gICAgdmFsdWUgPSAhXy5pc1VuZGVmaW5lZCh2YWx1ZSkgPyB2YWx1ZSA6IG9iai52YWx1ZTtcbiAgICAvKiBzYW5pdHkgY2hlY2ssIHVzZXIgY2FuIGJpbmQgcGFyZW50IG5vZGVzIHRvIG5vbi1vYmplY3QgdmFsdWVzLCBzbyBjaGlsZCBub2RlIGJpbmRpbmdzIG1heSBmYWlsICovXG4gICAgaWYgKHRhcmdldE9iaikge1xuICAgICAgICB0YXJnZXRPYmpbdGFyZ2V0Tm9kZUtleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcHJvY2Vzc1ZhcmlhYmxlUG9zdEJpbmRVcGRhdGUodGFyZ2V0Tm9kZUtleSwgdmFsdWUsIG9iai50eXBlLCB2YXJpYWJsZSwgbm9VcGRhdGUpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFRhcmdldCA9ICh2YXJpYWJsZSkgPT4ge1xuICAgIGxldCB0YXJnZXQ7XG4gICAgc3dpdGNoKHZhcmlhYmxlLmNhdGVnb3J5KSB7XG4gICAgICAgIGNhc2UgVkFSSUFCTEVfQ09OU1RBTlRTLkNBVEVHT1JZLk1PREVMOlxuICAgICAgICAgICAgdGFyZ2V0ID0gJ2RhdGFTZXQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVkFSSUFCTEVfQ09OU1RBTlRTLkNBVEVHT1JZLkxJVkU6XG4gICAgICAgICAgICB0YXJnZXQgPSB2YXJpYWJsZS5vcGVyYXRpb24gPT09ICdyZWFkJyA/ICdmaWx0ZXJGaWVsZHMnIDogJ2lucHV0RmllbGRzJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGFyZ2V0ID0gJ2RhdGFCaW5kaW5nJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogVGhlIG1vZGVsIGludGVybmFsQm91bmROb2RlTWFwIHN0b3JlcyB0aGUgcmVmZXJlbmNlIHRvIGxhdGVzdCBjb21wdXRlZCB2YWx1ZXMgYWdhaW5zdCBpbnRlcm5hbChuZXN0ZWQpIGJvdW5kIG5vZGVzXG4gKiBUaGlzIGlzIGRvbmUgc28gdGhhdCB0aGUgaW50ZXJuYWwgbm9kZSdzIGNvbXB1dGVkIHZhbHVlIGlzIG5vdCBsb3N0LCBvbmNlIGl0cyBwYXJlbnQgbm9kZSdzIHZhbHVlIGlzIGNvbXB1dGVkIGF0IGEgbGF0ZXIgcG9pbnRcbiAqIEUuZy5cbiAqIFZhcmlhYmxlLmVtcGxveWVlVmFyIGhhcyBmb2xsb3dpbmcgYmluZGluZ3NcbiAqIFwiZGF0YUJpbmRpbmdcIjogW1xuIHtcbiAgICAgICAgIFwidGFyZ2V0XCI6IFwiZGVwYXJ0bWVudC5idWRnZXRcIixcbiAgICAgICAgIFwidmFsdWVcIjogXCJiaW5kOlZhcmlhYmxlcy5idWRnZXRWYXIuZGF0YVNldFwiXG4gICAgIH0sXG4ge1xuICAgICAgICAgXCJ0YXJnZXRcIjogXCJkZXBhcnRtZW50XCIsXG4gICAgICAgICBcInZhbHVlXCI6IFwiYmluZDpWYXJpYWJsZXMuZGVwYXJ0bWVudFZhci5kYXRhU2V0XCJcbiAgICAgfVxuIF1cbiAqIFdoZW4gZGVwYXJ0bWVudC5idWRnZXQgaXMgY29tcHV0ZWQsIGVtcGxveWVlVmFyLmRhdGFTZXQgPSB7XG4gKiAgXCJkZXBhcnRtZW50XCI6IHtcbiAqICAgICAgXCJidWRnZXRcIjoge1wicTFcIjogMTExMX1cbiAqICB9XG4gKiB9XG4gKlxuICogV2hlbiBkZXBhcnRtZW50IGlzIGNvbXB1dGVkXG4gKiAgXCJkZXBhcnRtZW50XCI6IHtcbiAqICAgICAgXCJuYW1lXCI6IFwiSFJcIixcbiAqICAgICAgXCJsb2NhdGlvblwiOiBcIkh5ZGVyYWJhZFwiXG4gKiAgfVxuICogVGhlIGJ1ZGdldCBmaWVsZCAoY29tcHV0ZWQgZWFybGllcikgaXMgTE9TVC5cbiAqXG4gKiBUbyBhdm9pZCB0aGlzLCB0aGUgbGF0ZXN0IHZhbHVlcyBhZ2FpbnN0IGludGVybmFsIG5vZGVzIChpbiB0aGlzIGNhc2UgZGVwYXJ0bWVudC5idWRnZXQpIGFyZSBzdG9yZWQgaW4gYSBtYXBcbiAqIFRoZXNlIHZhbHVlcyBhcmUgYXNzaWduZWQgYmFjayB0byBpbnRlcm5hbCBmaWVsZHMgaWYgdGhlIHBhcmVudCBpcyBjb21wdXRlZCAoaW4gdGhpcyBjYXNlIGRlcGFydG1lbnQpXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKiBAcGFyYW0gcm9vdFxuICogQHBhcmFtIHZhcmlhYmxlXG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVJbnRlcm5hbE5vZGVzID0gKHRhcmdldCwgcm9vdCwgdmFyaWFibGUpID0+IHtcbiAgICBjb25zdCBib3VuZEludGVybmFsTm9kZXMgPSBfLmtleXMoXy5nZXQoaW50ZXJuYWxCb3VuZE5vZGVNYXAuZ2V0KHZhcmlhYmxlKSwgW3ZhcmlhYmxlLm5hbWUsIHJvb3RdKSksXG4gICAgICAgIHRhcmdldE5vZGVLZXkgPSBnZXRUYXJnZXROb2RlS2V5KHRhcmdldCk7XG4gICAgbGV0IGludGVybmFsTm9kZXM7XG4gICAgZnVuY3Rpb24gZmluZEludGVybmFsTm9kZUJvdW5kKCkge1xuICAgICAgICByZXR1cm4gXy5maWx0ZXIoYm91bmRJbnRlcm5hbE5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgLy8gdGhlIGxhdGVyIGNvbmRpdGlvbiBpbiBjaGVjayAodGFyZ2V0Tm9kZUtleSA9PT0gcm9vdCB8fCB0YXJnZXROb2RlS2V5ID09PSAnZGF0YUJpbmRpbmcnKSBpcyBzcGVjaWZpY2FsbHkgZm9yIGxpdmUgdmFyaWFibGUgb2YgaW5zZXJ0L3VwZGF0ZSB0eXBlc1xuICAgICAgICAgICAgcmV0dXJuIChub2RlICE9PSB0YXJnZXROb2RlS2V5ICYmIF8uaW5jbHVkZXMobm9kZSwgdGFyZ2V0Tm9kZUtleSkpIHx8ICgodGFyZ2V0Tm9kZUtleSA9PT0gcm9vdCB8fCB0YXJnZXROb2RlS2V5ID09PSAnZGF0YUJpbmRpbmcnKSAmJiBub2RlICE9PSB0YXJnZXROb2RlS2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGludGVybmFsTm9kZXMgPSBmaW5kSW50ZXJuYWxOb2RlQm91bmQoKTtcbiAgICBpZiAoKGludGVybmFsTm9kZXMubGVuZ3RoKSkge1xuICAgICAgICBfLmZvckVhY2goaW50ZXJuYWxOb2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHNldFZhbHVlVG9Ob2RlKG5vZGUsIHt0YXJnZXQ6IG5vZGV9LCByb290LCB2YXJpYWJsZSwgXy5nZXQoaW50ZXJuYWxCb3VuZE5vZGVNYXAuZ2V0KHZhcmlhYmxlKSwgW3ZhcmlhYmxlLm5hbWUsIHJvb3QsIG5vZGVdKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpbml0aWF0ZUNhbGxiYWNrID0gKHR5cGU6IHN0cmluZywgdmFyaWFibGU6IGFueSwgZGF0YTogYW55LCBvcHRpb25zPzogYW55LCBza2lwRGVmYXVsdE5vdGlmaWNhdGlvbj86IGJvb2xlYW4pID0+IHtcblxuICAgIC8qY2hlY2tpbmcgaWYgZXZlbnQgaXMgYXZhaWxhYmxlIGFuZCB2YXJpYWJsZSBoYXMgZXZlbnQgcHJvcGVydHkgYW5kIHZhcmlhYmxlIGV2ZW50IHByb3BlcnR5IGJvdW5kIHRvIGZ1bmN0aW9uKi9cbiAgICBjb25zdCBldmVudFZhbHVlcyA9IHZhcmlhYmxlW3R5cGVdLFxuICAgICAgICBjYWxsQmFja1Njb3BlID0gdmFyaWFibGUuX2NvbnRleHQ7XG4gICAgbGV0IGVycm9yVmFyaWFibGU7XG4gICAgLyoqXG4gICAgICogRm9yIGVycm9yIGV2ZW50OlxuICAgICAqIHRyaWdnZXIgYXBwIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gICAgICogaWYgbm8gZXZlbnQgaXMgYXNzaWduZWQsIHRyaWdnZXIgZGVmYXVsdCBhcHBOb3RpZmljYXRpb24gdmFyaWFibGUuXG4gICAgICovXG4gICAgaWYgKHR5cGUgPT09IFZBUklBQkxFX0NPTlNUQU5UUy5FVkVOVC5FUlJPUiAmJiAhc2tpcERlZmF1bHROb3RpZmljYXRpb24pIHtcbiAgICAgICAgaWYgKCFldmVudFZhbHVlcykge1xuICAgICAgICAgICAgLyogaW4gY2FzZSBvZiBlcnJvciwgaWYgbm8gZXZlbnQgYXNzaWduZWQsIGhhbmRsZSB0aHJvdWdoIGRlZmF1bHQgbm90aWZpY2F0aW9uIHZhcmlhYmxlICovXG4gICAgICAgICAgICBlcnJvclZhcmlhYmxlID0gY2FsbEJhY2tTY29wZS5BY3Rpb25zW1ZBUklBQkxFX0NPTlNUQU5UUy5ERUZBVUxUX1ZBUi5OT1RJRklDQVRJT05dO1xuICAgICAgICAgICAgaWYgKGVycm9yVmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZXJyb3JWYXJpYWJsZS5nZXRNZXNzYWdlKCkgfHwgZGF0YTtcbiAgICAgICAgICAgICAgICBkYXRhID0gXy5pc1N0cmluZyhkYXRhKSA/IGRhdGEgOiAnQW4gZXJyb3IgaGFzIG9jY3VyZWQuIFBsZWFzZSBjaGVjayB0aGUgYXBwIGxvZ3MuJztcbiAgICAgICAgICAgICAgICBlcnJvclZhcmlhYmxlLmludm9rZSh7ICdtZXNzYWdlJyA6IGRhdGF9LCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgLy8gJHJvb3RTY29wZS4kZXZhbEFzeW5jKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyAkcm9vdFNjb3BlLiRlbWl0KFwiaW52b2tlLXNlcnZpY2VcIiwgVkFSSUFCTEVfQ09OU1RBTlRTLkRFRkFVTFRfVkFSLk5PVElGSUNBVElPTiwge3Njb3BlOiBjYWxsQmFja1Njb3BlLCBtZXNzYWdlOiByZXNwb25zZX0pO1xuICAgICAgICAgICAgICAgIC8vIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRPRE86IFtWaWJodV0sIGNoZWNrIHdoZXRoZXIgdG8gc3VwcG9ydCBsZWdhY3kgZXZlbnQgY2FsbGluZyBtZWNoYW5pc20gKGlkZWFsbHksIGl0IHNob3VsZCBoYXZlIGJlZW4gbWlncmF0ZWQpXG4gICAgLy8gVG9EbyAtIHZhcmlhYmxlIHNlcGVyYXRpb25cbiAgIC8vIGNvbnN0IGZuID0gJHBhcnNlRXZlbnQodmFyaWFibGVbdHlwZV0pO1xuICAgIGNvbnN0IGZuID0gdmFyaWFibGVbdHlwZV0gfHwgbm9vcDtcbiAgICBpZiAodHlwZSA9PT0gVkFSSUFCTEVfQ09OU1RBTlRTLkVWRU5ULkJFRk9SRV9VUERBVEUpIHtcbiAgICAgICAgaWYgKHZhcmlhYmxlLmNhdGVnb3J5ID09PSAnd20uTGl2ZVZhcmlhYmxlJyAmJiB2YXJpYWJsZS5vcGVyYXRpb24gPT09ICdyZWFkJykge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHZhcmlhYmxlLl9jb250ZXh0LCB7dmFyaWFibGU6IHZhcmlhYmxlLCBkYXRhRmlsdGVyOiBkYXRhLCBvcHRpb25zOiBvcHRpb25zfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHJldHVybiBmbih2YXJpYWJsZS5fY29udGV4dCwge3ZhcmlhYmxlOiB2YXJpYWJsZSwgaW5wdXREYXRhOiBkYXRhLCBvcHRpb25zOiBvcHRpb25zfSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZm4odmFyaWFibGUuX2NvbnRleHQsIHt2YXJpYWJsZTogdmFyaWFibGUsIGRhdGE6IGRhdGEsIG9wdGlvbnM6IG9wdGlvbnN9KTtcbiAgICB9XG59O1xuY29uc3QgZ2V0RGF0ZVRpbWVGb3JtYXRGb3JUeXBlID0gKHR5cGUpID0+IHtcbiAgICByZXR1cm4gREVGQVVMVF9GT1JNQVRTW18udG9VcHBlcih0eXBlKV07XG59O1xuXG4vLyBGb3JtYXQgdmFsdWUgZm9yIGRhdGV0aW1lIHR5cGVzXG5jb25zdCBfZm9ybWF0RGF0ZSA9IChkYXRlVmFsdWUsIHR5cGUpID0+IHtcbiAgICBsZXQgZXBvY2g7XG4gICAgaWYgKF8uaXNEYXRlKGRhdGVWYWx1ZSkpIHtcbiAgICAgICAgZXBvY2ggPSBkYXRlVmFsdWUuZ2V0VGltZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaXNOYU4oZGF0ZVZhbHVlKSkge1xuICAgICAgICAgICAgZGF0ZVZhbHVlID0gcGFyc2VJbnQoZGF0ZVZhbHVlLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgZXBvY2ggPSBkYXRlVmFsdWUgJiYgbW9tZW50KGRhdGVWYWx1ZSkudmFsdWVPZigpO1xuICAgIH1cbiAgICBpZiAoaXNOYU4oZXBvY2gpICYmIHR5cGUgIT09IERhdGFUeXBlLlRJTUUpIHtcbiAgICAgICAgcmV0dXJuIGVwb2NoO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gRGF0YVR5cGUuVElNRVNUQU1QKSB7XG4gICAgICAgIHJldHVybiBlcG9jaDtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IERhdGFUeXBlLlRJTUUgJiYgIWVwb2NoKSB7XG4gICAgICAgIGVwb2NoID0gbW9tZW50KG5ldyBEYXRlKCkudG9EYXRlU3RyaW5nKCkgKyAnICcgKyBkYXRlVmFsdWUpLnZhbHVlT2YoKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVWYWx1ZSAmJiBhcHBNYW5hZ2VyLmdldFBpcGUoJ2RhdGUnKS50cmFuc2Zvcm0oZXBvY2gsIGdldERhdGVUaW1lRm9ybWF0Rm9yVHlwZSh0eXBlKSk7XG59O1xuXG4vLyBGdW5jdGlvbiB0byBjb252ZXJ0IHZhbHVlcyBvZiBkYXRlIHRpbWUgdHlwZXMgaW50byBkZWZhdWx0IGZvcm1hdHNcbmV4cG9ydCBjb25zdCBmb3JtYXREYXRlID0gKHZhbHVlLCB0eXBlKSA9PiB7XG4gICAgaWYgKF8uaW5jbHVkZXModHlwZSwgJy4nKSkge1xuICAgICAgICB0eXBlID0gXy50b0xvd2VyKGV4dHJhY3RUeXBlKHR5cGUpKTtcbiAgICB9XG4gICAgaWYgKF8uaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIF8ubWFwKHZhbHVlLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gX2Zvcm1hdERhdGUodmFsLCB0eXBlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBfZm9ybWF0RGF0ZSh2YWx1ZSwgdHlwZSk7XG59O1xuXG5jb25zdCBwYXJzZUVycm9ycyA9IChlcnJvcnMpID0+IHtcbiAgICBsZXQgZXJyTXNnID0gJyc7XG4gICAgaWYgKGVycm9ycyAmJiBlcnJvcnMuZXJyb3IgJiYgZXJyb3JzLmVycm9yLmxlbmd0aCkge1xuICAgICAgICBlcnJvcnMuZXJyb3IuZm9yRWFjaCgoZXJyb3JEZXRhaWxzLCBpKSA9PiB7XG4gICAgICAgICAgICBlcnJNc2cgKz0gcGFyc2VFcnJvcihlcnJvckRldGFpbHMpICsgKGkgPiAwID8gJ1xcbicgOiAnJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXJyTXNnO1xufVxuXG5jb25zdCBwYXJzZUVycm9yID0gKGVycm9yT2JqKSA9PiB7XG4gICAgbGV0IGVyck1zZztcbiAgICBlcnJNc2cgPSBlcnJvck9iai5tZXNzYWdlID8gcmVwbGFjZShlcnJvck9iai5tZXNzYWdlLCBlcnJvck9iai5wYXJhbWV0ZXJzLCB0cnVlKSA6ICgoZXJyb3JPYmoucGFyYW1ldGVycyAmJiBlcnJvck9iai5wYXJhbWV0ZXJzWzBdKSB8fCAnJyk7XG4gICAgcmV0dXJuIGVyck1zZztcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBmaWx0ZXJzIGFuZCByZXR1cm5zIGVycm9yIG1lc3NhZ2UgZnJvbSB0aGUgZmFpbGVkIG5ldHdvcmsgY2FsbCByZXNwb25zZS5cbiAqIEBwYXJhbSBlcnIsIGVycm9yIGZvcm0gbmV0d29yayBjYWxsIGZhaWx1cmVcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEVyck1lc3NhZ2UgPSAoZXJyOiBhbnksIGxvY2FsZU9iamVjdDogYW55KSA9PiAge1xuICAgIGNvbnN0IEhUVFBfU1RBVFVTX01TRyA9IHtcbiAgICAgICAgNDA0OiBsb2NhbGVPYmplY3RbJ01FU1NBR0VfNDA0X0VSUk9SJ10gfHwgJ1JlcXVlc3RlZCByZXNvdXJjZSBub3QgZm91bmQnLFxuICAgICAgICA0MDE6IGxvY2FsZU9iamVjdFsnTUVTU0FHRV80MDFfRVJST1InXSB8fCAnUmVxdWVzdGVkIHJlc291cmNlIHJlcXVpcmVzIGF1dGhlbnRpY2F0aW9uJyxcbiAgICAgICAgNDAzOiBsb2NhbGVPYmplY3RbJ0xBQkVMX0ZPUkJJRERFTl9NRVNTQUdFJ10gfHwgJ1RoZSByZXF1ZXN0ZWQgcmVzb3VyY2UgYWNjZXNzL2FjdGlvbiBpcyBmb3JiaWRkZW4uJ1xuICAgIH07XG5cbiAgICAvLyBjaGVjayBpZiBlcnJvciBtZXNzYWdlIHByZXNlbnQgZm9yIHJlc3BvbmRlZCBodHRwIHN0YXR1c1xuICAgIGxldCBlcnJNc2cgPSBIVFRQX1NUQVRVU19NU0dbZXJyLnN0YXR1c107XG4gICAgbGV0IGVycm9yRGV0YWlscyA9IGVyci5lcnJvcjtcbiAgICBlcnJvckRldGFpbHMgPSBnZXRWYWxpZEpTT04oZXJyb3JEZXRhaWxzKSB8fCBlcnJvckRldGFpbHM7XG5cbiAgICAvLyBXTSBzZXJ2aWNlcyBoYXZlIHRoZSBmb3JtYXQgb2YgZXJyb3IgcmVzcG9uc2UgYXMgZXJyb3JEZXRhaWxzLmVycm9yXG4gICAgaWYgKGVycm9yRGV0YWlscyAmJiBlcnJvckRldGFpbHMuZXJyb3JzKSB7XG4gICAgICAgIGVyck1zZyA9IHBhcnNlRXJyb3JzKGVycm9yRGV0YWlscy5lcnJvcnMpIHx8IGVyck1zZyB8fCAnU2VydmljZSBDYWxsIEZhaWxlZCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZXJyTXNnID0gZXJyTXNnIHx8ICdTZXJ2aWNlIENhbGwgRmFpbGVkJztcbiAgICB9XG4gICAgcmV0dXJuIGVyck1zZztcbn0iLCIvKlxyXG5cdENvcHlyaWdodCAyMDE1IEF4aW5vbVxyXG5cdENvcHlyaWdodCAyMDExLTIwMTMgQWJkdWxsYSBBYmR1cmFraG1hbm92XHJcblx0T3JpZ2luYWwgc291cmNlcyBhcmUgYXZhaWxhYmxlIGF0IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AveDJqcy9cclxuXHJcblx0TGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuXHR5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcblx0WW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG5cdGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuXHRVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcblx0ZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5cdFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5cdFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuXHRsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cclxuXHJcbi8qXHJcblx0U3VwcG9ydGVkIGV4cG9ydCBtZXRob2RzOlxyXG5cdCogQU1EXHJcblx0KiA8c2NyaXB0PiAod2luZG93LlgySlMpXHJcblx0KiBOb2RlLmpzXHJcblxyXG5cdExpbWl0YXRpb25zOlxyXG5cdCogQXR0cmlidXRlIG5hbWVzcGFjZSBwcmVmaXhlcyBhcmUgbm90IHBhcnNlZCBhcyBzdWNoLlxyXG5cdCogT3ZlcmFsbCB0aGUgc2VyaWFsaXphdGlvbi9kZXNlcmlhbGl6YXRvbiBjb2RlIGlzIFwiYmVzdCBlZmZvcnRcIiBhbmQgbm90IGZvb2xwcm9vZi5cclxuKi9cclxuXHJcbi8vIE1vZHVsZSBkZWZpbml0aW9uIHBhdHRlcm4gdXNlZCBpcyByZXR1cm5FeHBvcnRzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3VtZGpzL3VtZFxyXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHJcblx0LyogZ2xvYmFsIGRlZmluZSAqL1xyXG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cclxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XHJcblx0fSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG5cdFx0Ly8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0IG9ubHkgQ29tbW9uSlMtbGlrZVxyXG5cdFx0Ly8gZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cywgbGlrZSBOb2RlLlxyXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJAeG1sZG9tL3htbGRvbVwiKS5ET01QYXJzZXIpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxyXG5cdFx0cm9vdC5YMkpTID0gZmFjdG9yeSgpO1xyXG5cdH1cclxufSkodGhpcywgZnVuY3Rpb24gKEN1c3RvbURPTVBhcnNlcikge1xyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cclxuXHQvLyBXZSByZXR1cm4gYSBjb25zdHJ1Y3RvciB0aGF0IGNhbiBiZSB1c2VkIHRvIG1ha2UgWDJKUyBpbnN0YW5jZXMuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIFgySlMoY29uZmlnKSB7XHJcblx0XHR2YXIgVkVSU0lPTiA9IFwiMy40LjRcIjtcclxuXHJcblx0XHRjb25maWcgPSBjb25maWcgfHwge307XHJcblxyXG5cdFx0ZnVuY3Rpb24gaW5pdENvbmZpZ0RlZmF1bHRzKCkge1xyXG5cdFx0XHQvLyBJZiBzZXQgdG8gXCJwcm9wZXJ0eVwiIHRoZW4gPGVsZW1lbnQ+X2FzQXJyYXkgd2lsbCBiZSBjcmVhdGVkXHJcblx0XHRcdC8vIHRvIGFsbG93IHlvdSB0byBhY2Nlc3MgYW55IGVsZW1lbnQgYXMgYW4gYXJyYXkgKGV2ZW4gaWYgdGhlcmUgaXMgb25seSBvbmUgb2YgaXQpLlxyXG5cdFx0XHRjb25maWcuYXJyYXlBY2Nlc3NGb3JtID0gY29uZmlnLmFycmF5QWNjZXNzRm9ybSB8fCBcIm5vbmVcIjtcclxuXHJcblx0XHRcdC8vIElmIFwidGV4dFwiIHRoZW4gPGVtcHR5PjwvZW1wdHk+IHdpbGwgYmUgdHJhbnNmb3JtZWQgdG8gXCJcIi5cclxuXHRcdFx0Ly8gSWYgXCJvYmplY3RcIiB0aGVuIDxlbXB0eT48L2VtcHR5PiB3aWxsIGJlIHRyYW5zZm9ybWVkIHRvIHt9LlxyXG5cdFx0XHRjb25maWcuZW1wdHlOb2RlRm9ybSA9IGNvbmZpZy5lbXB0eU5vZGVGb3JtIHx8IFwidGV4dFwiO1xyXG5cclxuXHRcdFx0Ly8gRnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBlbGVtZW50cywgaWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgdGhlIGVsZW1lbnQgd2lsbCBiZSBza2lwcGVkXHJcblx0XHRcdC8vIGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7IHJldHVybiB0cnVlOyB9O1xyXG5cdFx0XHRjb25maWcuanNBdHRyaWJ1dGVGaWx0ZXIgPSBjb25maWcuanNBdHRyaWJ1dGVGaWx0ZXI7XHJcblxyXG5cdFx0XHQvLyBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGVsZW1lbnRzLCB0aGUgZWxlbWVudCB2YWx1ZSB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSByZXR1cm5lZCB2YWx1ZVxyXG5cdFx0XHQvLyBmdW5jdGlvbihuYW1lLCB2YWx1ZSkgeyByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7IH07XHJcblx0XHRcdGNvbmZpZy5qc0F0dHJpYnV0ZUNvbnZlcnRlciA9IGNvbmZpZy5qc0F0dHJpYnV0ZUNvbnZlcnRlcjtcclxuXHJcblx0XHRcdC8vIEFsbG93cyBhdHRyaWJ1dGUgdmFsdWVzIHRvIGJlIGNvbnZlcnRlZCBvbiB0aGUgZmx5IGR1cmluZyBwYXJzaW5nIHRvIG9iamVjdHMuXHJcblx0XHRcdC8vIFx0XCJ0ZXN0XCI6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRcdC8vXHRcImNvbnZlcnRcIjogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHsgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpOyB9O1xyXG5cdFx0XHQvLyBjb252ZXJ0KCkgd2lsbCBiZSBjYWxsZWQgZm9yIGV2ZXJ5IGF0dHJpYnV0ZSB3aGVyZSB0ZXN0KCkgcmV0dXJucyB0cnVlXHJcblx0XHRcdC8vIGFuZCB0aGUgcmV0dXJuIHZhbHVlIGZyb20gY29udmVydCgpIHdpbGwgcmVwbGFjZSB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZS5cclxuXHRcdFx0Y29uZmlnLmF0dHJpYnV0ZUNvbnZlcnRlcnMgPSBjb25maWcuYXR0cmlidXRlQ29udmVydGVycyB8fCBbXTtcclxuXHJcblx0XHRcdC8vIEFueSBlbGVtZW50cyB0aGF0IG1hdGNoIHRoZSBwYXRocyBoZXJlIHdpbGwgaGF2ZSB0aGVpciB0ZXh0IHBhcnNlZFxyXG5cdFx0XHQvLyBhcyBhbiBYTUwgZGF0ZXRpbWUgdmFsdWUgKDIwMTEtMTEtMTJUMTM6MDA6MDAtMDc6MDAgc3R5bGUpLlxyXG5cdFx0XHQvLyBUaGUgcGF0aCBjYW4gYmUgYSBwbGFpbiBzdHJpbmcgKHBhcmVudC5jaGlsZDEuY2hpbGQyKSxcclxuXHRcdFx0Ly8gYSByZWdleCAoLy4qXFwuY2hpbGQyLykgb3IgZnVuY3Rpb24oZWxlbWVudFBhdGgpLlxyXG5cdFx0XHRjb25maWcuZGF0ZXRpbWVBY2Nlc3NGb3JtUGF0aHMgPSBjb25maWcuZGF0ZXRpbWVBY2Nlc3NGb3JtUGF0aHMgfHwgW107XHJcblxyXG5cdFx0XHQvLyBBbnkgZWxlbWVudHMgdGhhdCBtYXRjaCB0aGUgcGF0aHMgbGlzdGVkIGhlcmUgd2lsbCBiZSBzdG9yZWQgaW4gSmF2YVNjcmlwdCBvYmplY3RzXHJcblx0XHRcdC8vIGFzIGFycmF5cyBldmVuIGlmIHRoZXJlIGlzIG9ubHkgb25lIG9mIHRoZW0uIFRoZSBwYXRoIGNhbiBiZSBhIHBsYWluIHN0cmluZ1xyXG5cdFx0XHQvLyAocGFyZW50LmNoaWxkMS5jaGlsZDIpLCBhIHJlZ2V4ICgvLipcXC5jaGlsZDIvKSBvciBmdW5jdGlvbihlbGVtZW50TmFtZSwgZWxlbWVudFBhdGgpLlxyXG5cdFx0XHRjb25maWcuYXJyYXlBY2Nlc3NGb3JtUGF0aHMgPSBjb25maWcuYXJyYXlBY2Nlc3NGb3JtUGF0aHMgfHwgW107XHJcblxyXG4gICAgICAgICAgICAvLyB4bWxkb20gY29uc3RydWN0b3IgYXJndW1lbnRzXHJcbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ppbmR3L3htbGRvbSNhcGktcmVmZXJlbmNlXHJcblx0XHRcdGNvbmZpZy54bWxkb21PcHRpb25zID0gY29uZmlnLnhtbGRvbU9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0XHQvLyBJZiB0cnVlLCBhIHRvU3RyaW5nIGZ1bmN0aW9uIGlzIGdlbmVyYXRlZCB0byBwcmludCBub2RlcyBjb250YWluaW5nIHRleHQgb3IgY2RhdGEuXHJcblx0XHRcdC8vIFVzZWZ1bCBpZiB5b3Ugd2FudCB0byBhY2NlcHQgYm90aCBwbGFpbiB0ZXh0IGFuZCBDRGF0YSBhcyBlcXVpdmFsZW50IGlucHV0cy5cclxuXHRcdFx0aWYgKGNvbmZpZy5lbmFibGVUb1N0cmluZ0Z1bmMgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdGNvbmZpZy5lbmFibGVUb1N0cmluZ0Z1bmMgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBJZiB0cnVlLCBlbXB0eSB0ZXh0IHRhZ3MgYXJlIGlnbm9yZWQgZm9yIGVsZW1lbnRzIHdpdGggY2hpbGQgbm9kZXMuXHJcblx0XHRcdGlmIChjb25maWcuc2tpcEVtcHR5VGV4dE5vZGVzRm9yT2JqID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRjb25maWcuc2tpcEVtcHR5VGV4dE5vZGVzRm9yT2JqID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gSWYgdHJ1ZSwgd2hpdGVzcGFjZSBpcyB0cmltbWVkIGZyb20gdGV4dCBub2Rlcy5cclxuXHRcdFx0aWYgKGNvbmZpZy5zdHJpcFdoaXRlc3BhY2VzID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRjb25maWcuc3RyaXBXaGl0ZXNwYWNlcyA9IHRydWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIElmIHRydWUsIGRvdWJsZSBxdW90ZXMgYXJlIHVzZWQgaW4gZ2VuZXJhdGVkIFhNTC5cclxuXHRcdFx0aWYgKGNvbmZpZy51c2VEb3VibGVRdW90ZXMgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdGNvbmZpZy51c2VEb3VibGVRdW90ZXMgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBJZiB0cnVlLCB0aGUgcm9vdCBlbGVtZW50IG9mIHRoZSBYTUwgZG9jdW1lbnQgaXMgaWdub3JlZCB3aGVuIGNvbnZlcnRpbmcgdG8gb2JqZWN0cy5cclxuXHRcdFx0Ly8gVGhlIHJlc3VsdCB3aWxsIGRpcmVjdGx5IGhhdmUgdGhlIHJvb3QgZWxlbWVudCdzIGNoaWxkcmVuIGFzIGl0cyBvd24gcHJvcGVydGllcy5cclxuXHRcdFx0aWYgKGNvbmZpZy5pZ25vcmVSb290ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRjb25maWcuaWdub3JlUm9vdCA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBXaGV0aGVyIFhNTCBjaGFyYWN0ZXJzIGluIHRleHQgYXJlIGVzY2FwZWQgd2hlbiByZWFkaW5nL3dyaXRpbmcgWE1MLlxyXG5cdFx0XHRpZiAoY29uZmlnLmVzY2FwZU1vZGUgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdGNvbmZpZy5lc2NhcGVNb2RlID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gUHJlZml4IHRvIHVzZSBmb3IgcHJvcGVydGllcyB0aGF0IGFyZSBjcmVhdGVkIHRvIHJlcHJlc2VudCBYTUwgYXR0cmlidXRlcy5cclxuXHRcdFx0aWYgKGNvbmZpZy5hdHRyaWJ1dGVQcmVmaXggPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdGNvbmZpZy5hdHRyaWJ1dGVQcmVmaXggPSBcIl9cIjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gSWYgdHJ1ZSwgZW1wdHkgZWxlbWVudHMgd2lsbCBjcmVhdGVkIGFzIHNlbGYgY2xvc2luZyBlbGVtZW50cyAoPGVsZW1lbnQgLz4pXHJcblx0XHRcdC8vIElmIGZhbHNlLCBlbXB0eSBlbGVtZW50cyB3aWxsIGJlIGNyZWF0ZWQgd2l0aCBzdGFydCBhbmQgZW5kIHRhZ3MgKDxlbGVtZW50PjwvZWxlbWVudD4pXHJcblx0XHRcdGlmIChjb25maWcuc2VsZkNsb3NpbmdFbGVtZW50cyA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0Y29uZmlnLnNlbGZDbG9zaW5nRWxlbWVudHMgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBJZiB0aGlzIHByb3BlcnR5IGRlZmluZWQgYXMgZmFsc2UgYW5kIGFuIFhNTCBlbGVtZW50IGhhcyBDRGF0YSBub2RlIE9OTFksIGl0IHdpbGwgYmUgY29udmVydGVkIHRvIHRleHQgd2l0aG91dCBhZGRpdGlvbmFsIHByb3BlcnR5IFwiX19jZGF0YVwiXHJcblx0XHRcdGlmIChjb25maWcua2VlcENEYXRhID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRjb25maWcua2VlcENEYXRhID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIElmIHRoaXMgcHJvcGVydHkgZGVmaW5lZCBhcyB0cnVlLCB1c2UgeyBfX3RleHQ6ICdhYmMnIH0gb3ZlciAnYWJjJ1xyXG5cdFx0XHRpZiAoY29uZmlnLmtlZXBUZXh0ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRjb25maWcua2VlcFRleHQgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gSWYgdHJ1ZSwgd2lsbCBvdXRwdXQgZGF0ZXMgaW4gVVRDXHJcblx0XHRcdGlmIChjb25maWcuanNEYXRlVVRDID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRjb25maWcuanNEYXRlVVRDID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBpbml0UmVxdWlyZWRQb2x5ZmlsbHMoKSB7XHJcblx0XHRcdGZ1bmN0aW9uIHBhZChudW1iZXIpIHtcclxuXHRcdFx0XHR2YXIgciA9IFN0cmluZyhudW1iZXIpO1xyXG5cdFx0XHRcdGlmIChyLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0XHRcdFx0ciA9ICcwJyArIHI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiByO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIEhlbGxvIElFOC1cclxuXHRcdFx0aWYgKHR5cGVvZiBTdHJpbmcucHJvdG90eXBlLnRyaW0gIT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRTdHJpbmcucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbiB0cmltKCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMucmVwbGFjZSgvXlxccyt8Xlxcbit8KFxcc3xcXG4pKyQvZywgJycpO1xyXG5cdFx0XHRcdH07XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdC8vIEltcGxlbWVudGF0aW9uIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNTczNTIxL2hvdy1kby1pLW91dHB1dC1hbi1pc28tODYwMS1mb3JtYXR0ZWQtc3RyaW5nLWluLWphdmFzY3JpcHRcclxuXHRcdFx0XHREYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyA9IGZ1bmN0aW9uIHRvSVNPU3RyaW5nKCkge1xyXG5cdFx0XHRcdFx0dmFyIE1TX0lOX1MgPSAxMDAwO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmdldFVUQ0Z1bGxZZWFyKClcclxuXHRcdFx0XHRcdFx0KyAnLScgKyBwYWQodGhpcy5nZXRVVENNb250aCgpICsgMSlcclxuXHRcdFx0XHRcdFx0KyAnLScgKyBwYWQodGhpcy5nZXRVVENEYXRlKCkpXHJcblx0XHRcdFx0XHRcdCsgJ1QnICsgcGFkKHRoaXMuZ2V0VVRDSG91cnMoKSlcclxuXHRcdFx0XHRcdFx0KyAnOicgKyBwYWQodGhpcy5nZXRVVENNaW51dGVzKCkpXHJcblx0XHRcdFx0XHRcdCsgJzonICsgcGFkKHRoaXMuZ2V0VVRDU2Vjb25kcygpKVxyXG5cdFx0XHRcdFx0XHQrICcuJyArIFN0cmluZygodGhpcy5nZXRVVENNaWxsaXNlY29uZHMoKSAvIE1TX0lOX1MpLnRvRml4ZWQoMykpLnNsaWNlKDIsIDUpXHJcblx0XHRcdFx0XHRcdCsgJ1onO1xyXG5cdFx0XHRcdH07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpbml0Q29uZmlnRGVmYXVsdHMoKTtcclxuXHRcdGluaXRSZXF1aXJlZFBvbHlmaWxscygpO1xyXG5cclxuXHRcdHZhciBET01Ob2RlVHlwZXMgPSB7XHJcblx0XHRcdFwiRUxFTUVOVF9OT0RFXCI6IDEsXHJcblx0XHRcdFwiVEVYVF9OT0RFXCI6IDMsXHJcblx0XHRcdFwiQ0RBVEFfU0VDVElPTl9OT0RFXCI6IDQsXHJcblx0XHRcdFwiQ09NTUVOVF9OT0RFXCI6IDgsXHJcblx0XHRcdFwiRE9DVU1FTlRfTk9ERVwiOiA5XHJcblx0XHR9O1xyXG5cclxuXHRcdGZ1bmN0aW9uIGdldERvbU5vZGVMb2NhbE5hbWUoZG9tTm9kZSkge1xyXG5cdFx0XHR2YXIgbG9jYWxOYW1lID0gZG9tTm9kZS5sb2NhbE5hbWU7XHJcblx0XHRcdGlmIChsb2NhbE5hbWUgPT0gbnVsbCkge1xyXG5cdFx0XHRcdC8vIFllYWgsIHRoaXMgaXMgSUUhIVxyXG5cdFx0XHRcdGxvY2FsTmFtZSA9IGRvbU5vZGUuYmFzZU5hbWU7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGxvY2FsTmFtZSA9PSBudWxsIHx8IGxvY2FsTmFtZSA9PT0gXCJcIikge1xyXG5cdFx0XHRcdC8vID09PVwiXCIgaXMgSUUgdG9vXHJcblx0XHRcdFx0bG9jYWxOYW1lID0gZG9tTm9kZS5ub2RlTmFtZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbG9jYWxOYW1lO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGdldERvbU5vZGVOYW1lc3BhY2VQcmVmaXgobm9kZSkge1xyXG5cdFx0XHRyZXR1cm4gbm9kZS5wcmVmaXg7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZXNjYXBlWG1sQ2hhcnMoc3RyKSB7XHJcblx0XHRcdGlmICh0eXBlb2Ygc3RyID09PSBcInN0cmluZ1wiKVxyXG5cdFx0XHRcdHJldHVybiBzdHIucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKS5yZXBsYWNlKC8nL2csICcmI3gyNzsnKTtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHJldHVybiBzdHI7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gdW5lc2NhcGVYbWxDaGFycyhzdHIpIHtcclxuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC8mbHQ7L2csICc8JykucmVwbGFjZSgvJmd0Oy9nLCAnPicpLnJlcGxhY2UoLyZxdW90Oy9nLCAnXCInKS5yZXBsYWNlKC8mI3gyNzsvZywgXCInXCIpLnJlcGxhY2UoLyZhbXA7L2csICcmJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZW5zdXJlUHJvcGVyQXJyYXlBY2Nlc3NGb3JtKGVsZW1lbnQsIGNoaWxkTmFtZSwgZWxlbWVudFBhdGgpIHtcclxuXHRcdFx0c3dpdGNoIChjb25maWcuYXJyYXlBY2Nlc3NGb3JtKSB7XHJcblx0XHRcdFx0Y2FzZSBcInByb3BlcnR5XCI6XHJcblx0XHRcdFx0XHRpZiAoIShlbGVtZW50W2NoaWxkTmFtZV0gaW5zdGFuY2VvZiBBcnJheSkpXHJcblx0XHRcdFx0XHRcdGVsZW1lbnRbY2hpbGROYW1lICsgXCJfYXNBcnJheVwiXSA9IFtlbGVtZW50W2NoaWxkTmFtZV1dO1xyXG5cdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRlbGVtZW50W2NoaWxkTmFtZSArIFwiX2FzQXJyYXlcIl0gPSBlbGVtZW50W2NoaWxkTmFtZV07XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCEoZWxlbWVudFtjaGlsZE5hbWVdIGluc3RhbmNlb2YgQXJyYXkpICYmIGNvbmZpZy5hcnJheUFjY2Vzc0Zvcm1QYXRocy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0dmFyIG1hdGNoID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY29uZmlnLmFycmF5QWNjZXNzRm9ybVBhdGhzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgYXJyYXlQYXRoID0gY29uZmlnLmFycmF5QWNjZXNzRm9ybVBhdGhzW2ldO1xyXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBhcnJheVBhdGggPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdFx0XHRcdFx0aWYgKGFycmF5UGF0aCA9PT0gZWxlbWVudFBhdGgpIHtcclxuXHRcdFx0XHRcdFx0XHRtYXRjaCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYXJyYXlQYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XHJcblx0XHRcdFx0XHRcdGlmIChhcnJheVBhdGgudGVzdChlbGVtZW50UGF0aCkpIHtcclxuXHRcdFx0XHRcdFx0XHRtYXRjaCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGFycmF5UGF0aCA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRcdFx0XHRcdGlmIChhcnJheVBhdGgoY2hpbGROYW1lLCBlbGVtZW50UGF0aCkpIHtcclxuXHRcdFx0XHRcdFx0XHRtYXRjaCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChtYXRjaClcclxuXHRcdFx0XHRcdGVsZW1lbnRbY2hpbGROYW1lXSA9IFtlbGVtZW50W2NoaWxkTmFtZV1dO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24geG1sRGF0ZVRpbWVUb0RhdGUocHJvcCkge1xyXG5cdFx0XHQvLyBJbXBsZW1lbnRhdGlvbiBiYXNlZCB1cCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzgxNzg1OTgveG1sLWRhdGV0aW1lLXRvLWphdmFzY3JpcHQtZGF0ZS1vYmplY3RcclxuXHRcdFx0Ly8gSW1wcm92ZWQgdG8gc3VwcG9ydCBmdWxsIHNwZWMgYW5kIG9wdGlvbmFsIHBhcnRzXHJcblx0XHRcdHZhciBNSU5VVEVTX1BFUl9IT1VSID0gNjA7XHJcblxyXG5cdFx0XHR2YXIgYml0cyA9IHByb3Auc3BsaXQoL1stVDorWl0vZyk7XHJcblxyXG5cdFx0XHR2YXIgZCA9IG5ldyBEYXRlKGJpdHNbMF0sIGJpdHNbMV0gLSAxLCBiaXRzWzJdKTtcclxuXHRcdFx0dmFyIHNlY29uZEJpdHMgPSBiaXRzWzVdLnNwbGl0KFwiXFwuXCIpO1xyXG5cdFx0XHRkLnNldEhvdXJzKGJpdHNbM10sIGJpdHNbNF0sIHNlY29uZEJpdHNbMF0pO1xyXG5cdFx0XHRpZiAoc2Vjb25kQml0cy5sZW5ndGggPiAxKVxyXG5cdFx0XHRcdGQuc2V0TWlsbGlzZWNvbmRzKHNlY29uZEJpdHNbMV0pO1xyXG5cclxuXHRcdFx0Ly8gR2V0IHN1cHBsaWVkIHRpbWUgem9uZSBvZmZzZXQgaW4gbWludXRlc1xyXG5cdFx0XHRpZiAoYml0c1s2XSAmJiBiaXRzWzddKSB7XHJcblx0XHRcdFx0dmFyIG9mZnNldE1pbnV0ZXMgPSBiaXRzWzZdICogTUlOVVRFU19QRVJfSE9VUiArIE51bWJlcihiaXRzWzddKTtcclxuXHRcdFx0XHR2YXIgc2lnbiA9IC9cXGRcXGQtXFxkXFxkOlxcZFxcZCQvLnRlc3QocHJvcCkgPyAnLScgOiAnKyc7XHJcblxyXG5cdFx0XHRcdC8vIEFwcGx5IHRoZSBzaWduXHJcblx0XHRcdFx0b2Zmc2V0TWludXRlcyA9IDAgKyAoc2lnbiA9PT0gJy0nID8gLTEgKiBvZmZzZXRNaW51dGVzIDogb2Zmc2V0TWludXRlcyk7XHJcblxyXG5cdFx0XHRcdC8vIEFwcGx5IG9mZnNldCBhbmQgbG9jYWwgdGltZXpvbmVcclxuXHRcdFx0XHRkLnNldE1pbnV0ZXMoZC5nZXRNaW51dGVzKCkgLSBvZmZzZXRNaW51dGVzIC0gZC5nZXRUaW1lem9uZU9mZnNldCgpKTtcclxuXHRcdFx0fSBlbHNlIGlmIChwcm9wLmluZGV4T2YoXCJaXCIsIHByb3AubGVuZ3RoIC0gMSkgIT09IC0xKSB7XHJcblx0XHRcdFx0ZCA9IG5ldyBEYXRlKERhdGUuVVRDKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpLCBkLmdldERhdGUoKSwgZC5nZXRIb3VycygpLCBkLmdldE1pbnV0ZXMoKSwgZC5nZXRTZWNvbmRzKCksIGQuZ2V0TWlsbGlzZWNvbmRzKCkpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZCBpcyBub3cgYSBsb2NhbCB0aW1lIGVxdWl2YWxlbnQgdG8gdGhlIHN1cHBsaWVkIHRpbWVcclxuXHRcdFx0cmV0dXJuIGQ7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gY29udmVydFRvRGF0ZUlmUmVxdWlyZWQodmFsdWUsIGNoaWxkTmFtZSwgZnVsbFBhdGgpIHtcclxuXHRcdFx0aWYgKGNvbmZpZy5kYXRldGltZUFjY2Vzc0Zvcm1QYXRocy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0dmFyIHBhdGhXaXRob3V0VGV4dE5vZGUgPSBmdWxsUGF0aC5zcGxpdChcIlxcLiNcIilbMF07XHJcblxyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY29uZmlnLmRhdGV0aW1lQWNjZXNzRm9ybVBhdGhzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgY2FuZGlkYXRlUGF0aCA9IGNvbmZpZy5kYXRldGltZUFjY2Vzc0Zvcm1QYXRoc1tpXTtcclxuXHRcdFx0XHRcdGlmICh0eXBlb2YgY2FuZGlkYXRlUGF0aCA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHRcdFx0XHRpZiAoY2FuZGlkYXRlUGF0aCA9PT0gcGF0aFdpdGhvdXRUZXh0Tm9kZSlcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4geG1sRGF0ZVRpbWVUb0RhdGUodmFsdWUpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjYW5kaWRhdGVQYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XHJcblx0XHRcdFx0XHRcdGlmIChjYW5kaWRhdGVQYXRoLnRlc3QocGF0aFdpdGhvdXRUZXh0Tm9kZSkpXHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHhtbERhdGVUaW1lVG9EYXRlKHZhbHVlKTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGNhbmRpZGF0ZVBhdGggPT09IFwiZnVuY3Rpb25cIikge1xyXG5cdFx0XHRcdFx0XHRpZiAoY2FuZGlkYXRlUGF0aChwYXRoV2l0aG91dFRleHROb2RlKSlcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4geG1sRGF0ZVRpbWVUb0RhdGUodmFsdWUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGRlc2VyaWFsaXplUm9vdEVsZW1lbnRDaGlsZHJlbihyb290RWxlbWVudCkge1xyXG5cdFx0XHR2YXIgcmVzdWx0ID0ge307XHJcblx0XHRcdHZhciBjaGlsZHJlbiA9IHJvb3RFbGVtZW50LmNoaWxkTm9kZXM7XHJcblxyXG5cdFx0XHQvLyBBbHRlcm5hdGl2ZSBmb3IgZmlyc3RFbGVtZW50Q2hpbGQgd2hpY2ggaXMgbm90IHN1cHBvcnRlZCBpbiBzb21lIGVudmlyb25tZW50c1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW4uaXRlbShpKTtcclxuXHRcdFx0XHRpZiAoY2hpbGQubm9kZVR5cGUgPT09IERPTU5vZGVUeXBlcy5FTEVNRU5UX05PREUpIHtcclxuXHRcdFx0XHRcdHZhciBjaGlsZE5hbWUgPSBnZXREb21Ob2RlTG9jYWxOYW1lKGNoaWxkKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoY29uZmlnLmlnbm9yZVJvb3QpXHJcblx0XHRcdFx0XHRcdHJlc3VsdCA9IGRlc2VyaWFsaXplRG9tQ2hpbGRyZW4oY2hpbGQsIGNoaWxkTmFtZSk7XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdHJlc3VsdFtjaGlsZE5hbWVdID0gZGVzZXJpYWxpemVEb21DaGlsZHJlbihjaGlsZCwgY2hpbGROYW1lKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiByZXN1bHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZGVzZXJpYWxpemVFbGVtZW50Q2hpbGRyZW4oZWxlbWVudCwgZWxlbWVudFBhdGgpIHtcclxuXHRcdFx0dmFyIHJlc3VsdCA9IHt9O1xyXG5cdFx0XHRyZXN1bHQuX19jbnQgPSAwO1xyXG5cclxuXHRcdFx0dmFyIG5vZGVDaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGROb2RlcztcclxuXHJcblx0XHRcdC8vIENoaWxkIG5vZGVzLlxyXG5cdFx0XHRmb3IgKHZhciBpQ2hpbGQgPSAwOyBpQ2hpbGQgPCBub2RlQ2hpbGRyZW4ubGVuZ3RoOyBpQ2hpbGQrKykge1xyXG5cdFx0XHRcdHZhciBjaGlsZCA9IG5vZGVDaGlsZHJlbi5pdGVtKGlDaGlsZCk7XHJcblx0XHRcdFx0dmFyIGNoaWxkTmFtZSA9IGdldERvbU5vZGVMb2NhbE5hbWUoY2hpbGQpO1xyXG5cclxuXHRcdFx0XHRpZiAoY2hpbGQubm9kZVR5cGUgPT09IERPTU5vZGVUeXBlcy5DT01NRU5UX05PREUpXHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdFx0cmVzdWx0Ll9fY250Kys7XHJcblxyXG5cdFx0XHRcdC8vIFdlIGRlbGliZXJhdGVseSBkbyBub3QgYWNjZXB0IGV2ZXJ5dGhpbmcgZmFsc2V5IGhlcmUgYmVjYXVzZVxyXG5cdFx0XHRcdC8vIGVsZW1lbnRzIHRoYXQgcmVzb2x2ZSB0byBlbXB0eSBzdHJpbmcgc2hvdWxkIHN0aWxsIGJlIHByZXNlcnZlZC5cclxuXHRcdFx0XHRpZiAocmVzdWx0W2NoaWxkTmFtZV0gPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0cmVzdWx0W2NoaWxkTmFtZV0gPSBkZXNlcmlhbGl6ZURvbUNoaWxkcmVuKGNoaWxkLCBlbGVtZW50UGF0aCArIFwiLlwiICsgY2hpbGROYW1lKTtcclxuXHRcdFx0XHRcdGVuc3VyZVByb3BlckFycmF5QWNjZXNzRm9ybShyZXN1bHQsIGNoaWxkTmFtZSwgZWxlbWVudFBhdGggKyBcIi5cIiArIGNoaWxkTmFtZSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmICghKHJlc3VsdFtjaGlsZE5hbWVdIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcblx0XHRcdFx0XHRcdHJlc3VsdFtjaGlsZE5hbWVdID0gW3Jlc3VsdFtjaGlsZE5hbWVdXTtcclxuXHRcdFx0XHRcdFx0ZW5zdXJlUHJvcGVyQXJyYXlBY2Nlc3NGb3JtKHJlc3VsdCwgY2hpbGROYW1lLCBlbGVtZW50UGF0aCArIFwiLlwiICsgY2hpbGROYW1lKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyZXN1bHRbY2hpbGROYW1lXVtyZXN1bHRbY2hpbGROYW1lXS5sZW5ndGhdID0gZGVzZXJpYWxpemVEb21DaGlsZHJlbihjaGlsZCwgZWxlbWVudFBhdGggKyBcIi5cIiArIGNoaWxkTmFtZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBBdHRyaWJ1dGVzXHJcblx0XHRcdGZvciAodmFyIGlBdHRyaWJ1dGUgPSAwOyBpQXR0cmlidXRlIDwgZWxlbWVudC5hdHRyaWJ1dGVzLmxlbmd0aDsgaUF0dHJpYnV0ZSsrKSB7XHJcblx0XHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGVsZW1lbnQuYXR0cmlidXRlcy5pdGVtKGlBdHRyaWJ1dGUpO1xyXG5cdFx0XHRcdHJlc3VsdC5fX2NudCsrO1xyXG5cclxuXHRcdFx0XHR2YXIgYWRqdXN0ZWRWYWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZTtcclxuXHRcdFx0XHRmb3IgKHZhciBpQ29udmVydGVyID0gMDsgaUNvbnZlcnRlciA8IGNvbmZpZy5hdHRyaWJ1dGVDb252ZXJ0ZXJzLmxlbmd0aDsgaUNvbnZlcnRlcisrKSB7XHJcblx0XHRcdFx0XHR2YXIgY29udmVydGVyID0gY29uZmlnLmF0dHJpYnV0ZUNvbnZlcnRlcnNbaUNvbnZlcnRlcl07XHJcblx0XHRcdFx0XHRpZiAoY29udmVydGVyLnRlc3QuY2FsbChudWxsLCBhdHRyaWJ1dGUubmFtZSwgYXR0cmlidXRlLnZhbHVlKSlcclxuXHRcdFx0XHRcdFx0YWRqdXN0ZWRWYWx1ZSA9IGNvbnZlcnRlci5jb252ZXJ0LmNhbGwobnVsbCwgYXR0cmlidXRlLm5hbWUsIGF0dHJpYnV0ZS52YWx1ZSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXN1bHRbY29uZmlnLmF0dHJpYnV0ZVByZWZpeCArIGF0dHJpYnV0ZS5uYW1lXSA9IGFkanVzdGVkVmFsdWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIE5vZGUgbmFtZXNwYWNlIHByZWZpeFxyXG5cdFx0XHR2YXIgbmFtZXNwYWNlUHJlZml4ID0gZ2V0RG9tTm9kZU5hbWVzcGFjZVByZWZpeChlbGVtZW50KTtcclxuXHRcdFx0aWYgKG5hbWVzcGFjZVByZWZpeCkge1xyXG5cdFx0XHRcdHJlc3VsdC5fX2NudCsrO1xyXG5cdFx0XHRcdHJlc3VsdC5fX3ByZWZpeCA9IG5hbWVzcGFjZVByZWZpeDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHJlc3VsdFtcIiN0ZXh0XCJdKSB7XHJcblx0XHRcdFx0cmVzdWx0Ll9fdGV4dCA9IHJlc3VsdFtcIiN0ZXh0XCJdO1xyXG5cclxuXHRcdFx0XHRpZiAocmVzdWx0Ll9fdGV4dCBpbnN0YW5jZW9mIEFycmF5KSB7XHJcblx0XHRcdFx0XHRyZXN1bHQuX190ZXh0ID0gcmVzdWx0Ll9fdGV4dC5qb2luKFwiXFxuXCIpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKGNvbmZpZy5lc2NhcGVNb2RlKVxyXG5cdFx0XHRcdFx0cmVzdWx0Ll9fdGV4dCA9IHVuZXNjYXBlWG1sQ2hhcnMocmVzdWx0Ll9fdGV4dCk7XHJcblxyXG5cdFx0XHRcdGlmIChjb25maWcuc3RyaXBXaGl0ZXNwYWNlcylcclxuXHRcdFx0XHRcdHJlc3VsdC5fX3RleHQgPSByZXN1bHQuX190ZXh0LnRyaW0oKTtcclxuXHJcblx0XHRcdFx0ZGVsZXRlIHJlc3VsdFtcIiN0ZXh0XCJdO1xyXG5cclxuXHRcdFx0XHRpZiAoY29uZmlnLmFycmF5QWNjZXNzRm9ybSA9PT0gXCJwcm9wZXJ0eVwiKVxyXG5cdFx0XHRcdFx0ZGVsZXRlIHJlc3VsdFtcIiN0ZXh0X2FzQXJyYXlcIl07XHJcblxyXG5cdFx0XHRcdHJlc3VsdC5fX3RleHQgPSBjb252ZXJ0VG9EYXRlSWZSZXF1aXJlZChyZXN1bHQuX190ZXh0LCBcIiN0ZXh0XCIsIGVsZW1lbnRQYXRoICsgXCIuI3RleHRcIik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChyZXN1bHQuaGFzT3duUHJvcGVydHkoJyNjZGF0YS1zZWN0aW9uJykpIHtcclxuXHRcdFx0XHRyZXN1bHQuX19jZGF0YSA9IHJlc3VsdFtcIiNjZGF0YS1zZWN0aW9uXCJdO1xyXG5cdFx0XHRcdGRlbGV0ZSByZXN1bHRbXCIjY2RhdGEtc2VjdGlvblwiXTtcclxuXHJcblx0XHRcdFx0aWYgKGNvbmZpZy5hcnJheUFjY2Vzc0Zvcm0gPT09IFwicHJvcGVydHlcIilcclxuXHRcdFx0XHRcdGRlbGV0ZSByZXN1bHRbXCIjY2RhdGEtc2VjdGlvbl9hc0FycmF5XCJdO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAocmVzdWx0Ll9fY250ID09PSAxICYmIHJlc3VsdC5fX3RleHQgJiYgIWNvbmZpZy5rZWVwVGV4dCkge1xyXG5cdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC5fX3RleHQ7XHJcblx0XHRcdH0gZWxzZSBpZiAocmVzdWx0Ll9fY250ID09PSAwICYmIGNvbmZpZy5lbXB0eU5vZGVGb3JtID09PSBcInRleHRcIikge1xyXG5cdFx0XHRcdHJlc3VsdCA9ICcnO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHJlc3VsdC5fX2NudCA+IDEgJiYgcmVzdWx0Ll9fdGV4dCAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZy5za2lwRW1wdHlUZXh0Tm9kZXNGb3JPYmopIHtcclxuXHRcdFx0XHRpZiAoY29uZmlnLnN0cmlwV2hpdGVzcGFjZXMgJiYgcmVzdWx0Ll9fdGV4dCA9PT0gXCJcIiB8fCByZXN1bHQuX190ZXh0LnRyaW0oKSA9PT0gXCJcIikge1xyXG5cdFx0XHRcdFx0ZGVsZXRlIHJlc3VsdC5fX3RleHQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGRlbGV0ZSByZXN1bHQuX19jbnQ7XHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogV2UgYXJlIGNoZWNraW5nIGlmIHdlIGFyZSBjcmVhdGluZyBhIF9fY2RhdGEgcHJvcGVydHkgb3IgaWYgd2UganVzdCBhZGQgdGhlIGNvbnRlbnQgb2YgY2RhdGEgaW5zaWRlIHJlc3VsdC5cclxuXHRcdFx0ICogQnV0LCBpZiB3ZSBoYXZlIGEgcHJvcGVydHkgaW5zaWRlIHhtbCB0YWcgKDx0YWcgUFJPUEVSVFk9XCIxXCI+PC90YWc+KSwgYW5kIGEgY2RhdGEgaW5zaWRlLCB3ZSBjYW4ndCBpZ25vcmUgaXQuXHJcblx0XHRcdCAqIEluIHRoaXMgY2FzZSB3ZSBhcmUga2VlcGluZyBfX2NkYXRhIHByb3BlcnR5LlxyXG5cdFx0XHQgKi9cclxuXHRcdFx0aWYgKCFjb25maWcua2VlcENEYXRhICYmICghcmVzdWx0Lmhhc093blByb3BlcnR5KCdfX3RleHQnKSAmJiByZXN1bHQuaGFzT3duUHJvcGVydHkoJ19fY2RhdGEnKSAmJiBPYmplY3Qua2V5cyhyZXN1bHQpLmxlbmd0aCA9PT0gMSkpIHtcclxuXHRcdFx0XHRyZXR1cm4gKHJlc3VsdC5fX2NkYXRhID8gcmVzdWx0Ll9fY2RhdGEgOiAnJyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChjb25maWcuZW5hYmxlVG9TdHJpbmdGdW5jICYmIChyZXN1bHQuX190ZXh0IHx8IHJlc3VsdC5fX2NkYXRhKSkge1xyXG5cdFx0XHRcdHJlc3VsdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuICh0aGlzLl9fdGV4dCA/IHRoaXMuX190ZXh0IDogJycpICsgKHRoaXMuX19jZGF0YSA/IHRoaXMuX19jZGF0YSA6ICcnKTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGRlc2VyaWFsaXplRG9tQ2hpbGRyZW4obm9kZSwgcGFyZW50UGF0aCkge1xyXG5cdFx0XHRpZiAobm9kZS5ub2RlVHlwZSA9PT0gRE9NTm9kZVR5cGVzLkRPQ1VNRU5UX05PREUpIHtcclxuXHRcdFx0XHRyZXR1cm4gZGVzZXJpYWxpemVSb290RWxlbWVudENoaWxkcmVuKG5vZGUpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IERPTU5vZGVUeXBlcy5FTEVNRU5UX05PREUpIHtcclxuXHRcdFx0XHRyZXR1cm4gZGVzZXJpYWxpemVFbGVtZW50Q2hpbGRyZW4obm9kZSwgcGFyZW50UGF0aCk7XHJcblx0XHRcdH0gZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gRE9NTm9kZVR5cGVzLlRFWFRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET01Ob2RlVHlwZXMuQ0RBVEFfU0VDVElPTl9OT0RFKSB7XHJcblx0XHRcdFx0cmV0dXJuIG5vZGUubm9kZVZhbHVlO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2VyaWFsaXplU3RhcnRUYWcoanNPYmplY3QsIGVsZW1lbnROYW1lLCBhdHRyaWJ1dGVOYW1lcywgc2VsZkNsb3NpbmcpIHtcclxuXHRcdFx0dmFyIHJlc3VsdFN0ciA9IFwiPFwiICsgKChqc09iamVjdCAmJiBqc09iamVjdC5fX3ByZWZpeCkgPyAoanNPYmplY3QuX19wcmVmaXggKyBcIjpcIikgOiBcIlwiKSArIGVsZW1lbnROYW1lO1xyXG5cclxuXHRcdFx0aWYgKGF0dHJpYnV0ZU5hbWVzKSB7XHJcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIGF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tpXTtcclxuXHRcdFx0XHRcdHZhciBhdHRyaWJ1dGVWYWx1ZSA9IGpzT2JqZWN0W2F0dHJpYnV0ZU5hbWVdO1xyXG5cclxuXHRcdFx0XHRcdGlmIChjb25maWcuZXNjYXBlTW9kZSlcclxuXHRcdFx0XHRcdFx0YXR0cmlidXRlVmFsdWUgPSBlc2NhcGVYbWxDaGFycyhhdHRyaWJ1dGVWYWx1ZSk7XHJcblxyXG5cdFx0XHRcdFx0cmVzdWx0U3RyICs9IFwiIFwiICsgYXR0cmlidXRlTmFtZS5zdWJzdHIoY29uZmlnLmF0dHJpYnV0ZVByZWZpeC5sZW5ndGgpICsgXCI9XCI7XHJcblxyXG5cdFx0XHRcdFx0aWYgKGNvbmZpZy51c2VEb3VibGVRdW90ZXMpXHJcblx0XHRcdFx0XHRcdHJlc3VsdFN0ciArPSAnXCInICsgYXR0cmlidXRlVmFsdWUgKyAnXCInO1xyXG5cdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRyZXN1bHRTdHIgKz0gXCInXCIgKyBhdHRyaWJ1dGVWYWx1ZSArIFwiJ1wiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCFzZWxmQ2xvc2luZylcclxuXHRcdFx0XHRyZXN1bHRTdHIgKz0gXCI+XCI7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRyZXN1bHRTdHIgKz0gXCIgLz5cIjtcclxuXHJcblx0XHRcdHJldHVybiByZXN1bHRTdHI7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2VyaWFsaXplRW5kVGFnKGpzT2JqZWN0LCBlbGVtZW50TmFtZSkge1xyXG5cdFx0XHRyZXR1cm4gXCI8L1wiICsgKChqc09iamVjdCAmJiBqc09iamVjdC5fX3ByZWZpeCkgPyAoanNPYmplY3QuX19wcmVmaXggKyBcIjpcIikgOiBcIlwiKSArIGVsZW1lbnROYW1lICsgXCI+XCI7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzdWZmaXgpIHtcclxuXHRcdFx0cmV0dXJuIHN0ci5pbmRleE9mKHN1ZmZpeCwgc3RyLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpICE9PSAtMTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBpc1NwZWNpYWxQcm9wZXJ0eShqc29uT2JqLCBwcm9wZXJ0eU5hbWUpIHtcclxuXHRcdFx0aWYgKChjb25maWcuYXJyYXlBY2Nlc3NGb3JtID09PSBcInByb3BlcnR5XCIgJiYgZW5kc1dpdGgocHJvcGVydHlOYW1lLnRvU3RyaW5nKCksIChcIl9hc0FycmF5XCIpKSlcclxuXHRcdFx0XHR8fCBwcm9wZXJ0eU5hbWUudG9TdHJpbmcoKS5pbmRleE9mKGNvbmZpZy5hdHRyaWJ1dGVQcmVmaXgpID09PSAwXHJcblx0XHRcdFx0fHwgcHJvcGVydHlOYW1lLnRvU3RyaW5nKCkuaW5kZXhPZihcIl9fXCIpID09PSAwXHJcblx0XHRcdFx0fHwgKGpzb25PYmpbcHJvcGVydHlOYW1lXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSlcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXREYXRhRWxlbWVudENvdW50KGpzT2JqZWN0KSB7XHJcblx0XHRcdHZhciBjb3VudCA9IDA7XHJcblxyXG5cdFx0XHRpZiAoanNPYmplY3QgaW5zdGFuY2VvZiBPYmplY3QpIHtcclxuXHRcdFx0XHRmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4ganNPYmplY3QpIHtcclxuXHRcdFx0XHRcdGlmIChpc1NwZWNpYWxQcm9wZXJ0eShqc09iamVjdCwgcHJvcGVydHlOYW1lKSlcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0Y291bnQrKztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBjb3VudDtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXREYXRhQXR0cmlidXRlTmFtZXMoanNPYmplY3QpIHtcclxuXHRcdFx0dmFyIG5hbWVzID0gW107XHJcblxyXG5cdFx0XHRpZiAoanNPYmplY3QgaW5zdGFuY2VvZiBPYmplY3QpIHtcclxuXHRcdFx0XHRmb3IgKHZhciBhdHRyaWJ1dGVOYW1lIGluIGpzT2JqZWN0KSB7XHJcblx0XHRcdFx0XHRpZiAoYXR0cmlidXRlTmFtZS50b1N0cmluZygpLmluZGV4T2YoXCJfX1wiKSA9PT0gLTFcclxuXHRcdFx0XHRcdFx0JiYgYXR0cmlidXRlTmFtZS50b1N0cmluZygpLmluZGV4T2YoY29uZmlnLmF0dHJpYnV0ZVByZWZpeCkgPT09IDApIHtcclxuXHRcdFx0XHRcdFx0bmFtZXMucHVzaChhdHRyaWJ1dGVOYW1lKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBuYW1lcztcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBzZXJpYWxpemVDb21wbGV4VGV4dE5vZGVDb250ZW50cyh0ZXh0Tm9kZSkge1xyXG5cdFx0XHR2YXIgcmVzdWx0ID0gXCJcIjtcclxuXHJcblx0XHRcdGlmICh0ZXh0Tm9kZS5fX2NkYXRhKSB7XHJcblx0XHRcdFx0cmVzdWx0ICs9IFwiPCFbQ0RBVEFbXCIgKyB0ZXh0Tm9kZS5fX2NkYXRhICsgXCJdXT5cIjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHRleHROb2RlLl9fdGV4dCB8fCB0eXBlb2YgKHRleHROb2RlLl9fdGV4dCkgPT09ICdudW1iZXInIHx8IHR5cGVvZiAodGV4dE5vZGUuX190ZXh0KSA9PT0gJ2Jvb2xlYW4nKSB7XHJcblx0XHRcdFx0aWYgKGNvbmZpZy5lc2NhcGVNb2RlKVxyXG5cdFx0XHRcdFx0cmVzdWx0ICs9IGVzY2FwZVhtbENoYXJzKHRleHROb2RlLl9fdGV4dCk7XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0cmVzdWx0ICs9IHRleHROb2RlLl9fdGV4dDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBzZXJpYWxpemVUZXh0Tm9kZUNvbnRlbnRzKHRleHROb2RlKSB7XHJcblx0XHRcdHZhciByZXN1bHQgPSBcIlwiO1xyXG5cclxuXHRcdFx0aWYgKHRleHROb2RlIGluc3RhbmNlb2YgT2JqZWN0KSB7XHJcblx0XHRcdFx0cmVzdWx0ICs9IHNlcmlhbGl6ZUNvbXBsZXhUZXh0Tm9kZUNvbnRlbnRzKHRleHROb2RlKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0ZXh0Tm9kZSAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdGlmIChjb25maWcuZXNjYXBlTW9kZSlcclxuXHRcdFx0XHRcdHJlc3VsdCArPSBlc2NhcGVYbWxDaGFycyh0ZXh0Tm9kZSk7XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0cmVzdWx0ICs9IHRleHROb2RlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHNlcmlhbGl6ZUFycmF5KGVsZW1lbnRBcnJheSwgZWxlbWVudE5hbWUsIGF0dHJpYnV0ZXMpIHtcclxuXHRcdFx0dmFyIHJlc3VsdCA9IFwiXCI7XHJcblxyXG5cdFx0XHRpZiAoZWxlbWVudEFycmF5Lmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRcdHJlc3VsdCArPSBzZXJpYWxpemVTdGFydFRhZyhlbGVtZW50QXJyYXksIGVsZW1lbnROYW1lLCBhdHRyaWJ1dGVzLCB0cnVlKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRBcnJheS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0cmVzdWx0ICs9IHNlcmlhbGl6ZUphdmFTY3JpcHRPYmplY3QoZWxlbWVudEFycmF5W2ldLCBlbGVtZW50TmFtZSwgZ2V0RGF0YUF0dHJpYnV0ZU5hbWVzKGVsZW1lbnRBcnJheVtpXSkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBzZXJpYWxpemVKYXZhU2NyaXB0T2JqZWN0KGVsZW1lbnQsIGVsZW1lbnROYW1lLCBhdHRyaWJ1dGVzKSB7XHJcblx0XHRcdHZhciByZXN1bHQgPSBcIlwiO1xyXG5cclxuXHRcdFx0Ly8gRmlsdGVyIG91dCBlbGVtZW50c1xyXG5cdFx0XHRpZiAoY29uZmlnLmpzQXR0cmlidXRlRmlsdGVyICYmIGNvbmZpZy5qc0F0dHJpYnV0ZUZpbHRlci5jYWxsKG51bGwsIGVsZW1lbnROYW1lLCBlbGVtZW50KSkge1xyXG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gQ29udmVydCBlbGVtZW50XHJcblx0XHRcdGlmIChjb25maWcuanNBdHRyaWJ1dGVDb252ZXJ0ZXIpIHtcclxuXHRcdFx0XHRlbGVtZW50ID0gY29uZmlnLmpzQXR0cmlidXRlQ29udmVydGVyLmNhbGwobnVsbCwgZWxlbWVudE5hbWUsIGVsZW1lbnQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICgoZWxlbWVudCA9PT0gdW5kZWZpbmVkIHx8IGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gJycpICYmIGNvbmZpZy5zZWxmQ2xvc2luZ0VsZW1lbnRzKSB7XHJcblx0XHRcdFx0cmVzdWx0ICs9IHNlcmlhbGl6ZVN0YXJ0VGFnKGVsZW1lbnQsIGVsZW1lbnROYW1lLCBhdHRyaWJ1dGVzLCB0cnVlKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVsZW1lbnQpID09PSAnW29iamVjdCBBcnJheV0nKSB7XHJcblx0XHRcdFx0XHRyZXN1bHQgKz0gc2VyaWFsaXplQXJyYXkoZWxlbWVudCwgZWxlbWVudE5hbWUsIGF0dHJpYnV0ZXMpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIERhdGUpIHtcclxuXHRcdFx0XHRcdHJlc3VsdCArPSBzZXJpYWxpemVTdGFydFRhZyhlbGVtZW50LCBlbGVtZW50TmFtZSwgYXR0cmlidXRlcywgZmFsc2UpO1xyXG5cdFx0XHRcdFx0Ly8gU2VyaWFsaXplIGRhdGVcclxuXHRcdFx0XHRcdHJlc3VsdCArPSBjb25maWcuanNEYXRlVVRDID8gZWxlbWVudC50b1VUQ1N0cmluZygpIDogZWxlbWVudC50b0lTT1N0cmluZygpO1xyXG5cdFx0XHRcdFx0cmVzdWx0ICs9IHNlcmlhbGl6ZUVuZFRhZyhlbGVtZW50LCBlbGVtZW50TmFtZSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhciBjaGlsZEVsZW1lbnRDb3VudCA9IGdldERhdGFFbGVtZW50Q291bnQoZWxlbWVudCk7XHJcblx0XHRcdFx0XHRpZiAoY2hpbGRFbGVtZW50Q291bnQgPiAwIHx8IHR5cGVvZiAoZWxlbWVudC5fX3RleHQpID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgKGVsZW1lbnQuX190ZXh0KSA9PT0gJ2Jvb2xlYW4nIHx8IGVsZW1lbnQuX190ZXh0IHx8IGVsZW1lbnQuX19jZGF0YSkge1xyXG5cdFx0XHRcdFx0XHRyZXN1bHQgKz0gc2VyaWFsaXplU3RhcnRUYWcoZWxlbWVudCwgZWxlbWVudE5hbWUsIGF0dHJpYnV0ZXMsIGZhbHNlKTtcclxuXHRcdFx0XHRcdFx0cmVzdWx0ICs9IHNlcmlhbGl6ZUphdmFTY3JpcHRPYmplY3RDaGlsZHJlbihlbGVtZW50KTtcclxuXHRcdFx0XHRcdFx0cmVzdWx0ICs9IHNlcmlhbGl6ZUVuZFRhZyhlbGVtZW50LCBlbGVtZW50TmFtZSk7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGNvbmZpZy5zZWxmQ2xvc2luZ0VsZW1lbnRzKSB7XHJcblx0XHRcdFx0XHRcdHJlc3VsdCArPSBzZXJpYWxpemVTdGFydFRhZyhlbGVtZW50LCBlbGVtZW50TmFtZSwgYXR0cmlidXRlcywgdHJ1ZSk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRyZXN1bHQgKz0gc2VyaWFsaXplU3RhcnRUYWcoZWxlbWVudCwgZWxlbWVudE5hbWUsIGF0dHJpYnV0ZXMsIGZhbHNlKTtcclxuXHRcdFx0XHRcdFx0cmVzdWx0ICs9IHNlcmlhbGl6ZUVuZFRhZyhlbGVtZW50LCBlbGVtZW50TmFtZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJlc3VsdCArPSBzZXJpYWxpemVTdGFydFRhZyhlbGVtZW50LCBlbGVtZW50TmFtZSwgYXR0cmlidXRlcywgZmFsc2UpO1xyXG5cdFx0XHRcdHJlc3VsdCArPSBzZXJpYWxpemVUZXh0Tm9kZUNvbnRlbnRzKGVsZW1lbnQpO1xyXG5cdFx0XHRcdHJlc3VsdCArPSBzZXJpYWxpemVFbmRUYWcoZWxlbWVudCwgZWxlbWVudE5hbWUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHNlcmlhbGl6ZUphdmFTY3JpcHRPYmplY3RDaGlsZHJlbihqc09iamVjdCkge1xyXG5cdFx0XHR2YXIgcmVzdWx0ID0gXCJcIjtcclxuXHJcblx0XHRcdHZhciBlbGVtZW50Q291bnQgPSBnZXREYXRhRWxlbWVudENvdW50KGpzT2JqZWN0KTtcclxuXHJcblx0XHRcdGlmIChlbGVtZW50Q291bnQgPiAwKSB7XHJcblx0XHRcdFx0Zm9yICh2YXIgZWxlbWVudE5hbWUgaW4ganNPYmplY3QpIHtcclxuXHRcdFx0XHRcdGlmIChpc1NwZWNpYWxQcm9wZXJ0eShqc09iamVjdCwgZWxlbWVudE5hbWUpKVxyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHR2YXIgZWxlbWVudCA9IGpzT2JqZWN0W2VsZW1lbnROYW1lXTtcclxuXHRcdFx0XHRcdHZhciBhdHRyaWJ1dGVzID0gZ2V0RGF0YUF0dHJpYnV0ZU5hbWVzKGVsZW1lbnQpO1xyXG5cclxuXHRcdFx0XHRcdHJlc3VsdCArPSBzZXJpYWxpemVKYXZhU2NyaXB0T2JqZWN0KGVsZW1lbnQsIGVsZW1lbnROYW1lLCBhdHRyaWJ1dGVzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJlc3VsdCArPSBzZXJpYWxpemVUZXh0Tm9kZUNvbnRlbnRzKGpzT2JqZWN0KTtcclxuXHJcblx0XHRcdHJldHVybiByZXN1bHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcGFyc2VYbWwoeG1sKSB7XHJcblx0XHRcdGlmICh4bWwgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodHlwZW9mIHhtbCAhPT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgcGFyc2VyID0gbnVsbDtcclxuXHRcdFx0dmFyIGRvbU5vZGUgPSBudWxsO1xyXG5cclxuXHRcdFx0aWYgKEN1c3RvbURPTVBhcnNlcikge1xyXG5cdFx0XHRcdC8vIFRoaXMgYnJhbmNoIGlzIHVzZWQgZm9yIG5vZGUuanMsIHdpdGggdGhlIHhtbGRvbSBwYXJzZXIuXHJcblx0XHRcdFx0cGFyc2VyID0gbmV3IEN1c3RvbURPTVBhcnNlcihjb25maWcueG1sZG9tT3B0aW9ucyk7XHJcblxyXG5cdFx0XHRcdGRvbU5vZGUgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbCwgXCJ0ZXh0L3htbFwiKTtcclxuXHRcdFx0fSBlbHNlIGlmICh3aW5kb3cgJiYgd2luZG93LkRPTVBhcnNlcikge1xyXG5cdFx0XHRcdHBhcnNlciA9IG5ldyB3aW5kb3cuRE9NUGFyc2VyKCk7XHJcblx0XHRcdFx0dmFyIHBhcnNlcmVycm9yTlMgPSBudWxsO1xyXG5cclxuXHRcdFx0XHR2YXIgaXNJRVBhcnNlciA9IHdpbmRvdy5BY3RpdmVYT2JqZWN0IHx8IFwiQWN0aXZlWE9iamVjdFwiIGluIHdpbmRvdztcclxuXHJcblx0XHRcdFx0Ly8gSUU5KyBub3cgaXMgaGVyZVxyXG5cdFx0XHRcdGlmICghaXNJRVBhcnNlciAmJiBkb2N1bWVudC5hbGwgJiYgIWRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcclxuXHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdHBhcnNlcmVycm9yTlMgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKFwiSU5WQUxJRFwiLCBcInRleHQveG1sXCIpLmNoaWxkTm9kZXNbMF0ubmFtZXNwYWNlVVJJO1xyXG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRcdFx0XHRcdHBhcnNlcmVycm9yTlMgPSBudWxsO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdGRvbU5vZGUgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbCwgXCJ0ZXh0L3htbFwiKTtcclxuXHRcdFx0XHRcdGlmIChwYXJzZXJlcnJvck5TICE9PSBudWxsICYmIGRvbU5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWVOUyhwYXJzZXJlcnJvck5TLCBcInBhcnNlcmVycm9yXCIpLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRcdFx0ZG9tTm9kZSA9IG51bGw7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRcdFx0XHRkb21Ob2RlID0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gSUUgOihcclxuXHRcdFx0XHRpZiAoeG1sLmluZGV4T2YoXCI8P1wiKSA9PT0gMCkge1xyXG5cdFx0XHRcdFx0eG1sID0geG1sLnN1YnN0cih4bWwuaW5kZXhPZihcIj8+XCIpICsgMik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvKiBnbG9iYWwgQWN0aXZlWE9iamVjdCAqL1xyXG5cdFx0XHRcdGRvbU5vZGUgPSBuZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxET01cIik7XHJcblx0XHRcdFx0ZG9tTm9kZS5hc3luYyA9IFwiZmFsc2VcIjtcclxuXHRcdFx0XHRkb21Ob2RlLmxvYWRYTUwoeG1sKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGRvbU5vZGU7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5hc0FycmF5ID0gZnVuY3Rpb24gYXNBcnJheShwcm9wKSB7XHJcblx0XHRcdGlmIChwcm9wID09PSB1bmRlZmluZWQgfHwgcHJvcCA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdHJldHVybiBbXTtcclxuXHRcdFx0fSBlbHNlIGlmIChwcm9wIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuXHRcdFx0XHRyZXR1cm4gcHJvcDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gW3Byb3BdO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMudG9YbWxEYXRlVGltZSA9IGZ1bmN0aW9uIHRvWG1sRGF0ZVRpbWUoZHQpIHtcclxuXHRcdFx0aWYgKGR0IGluc3RhbmNlb2YgRGF0ZSkge1xyXG5cdFx0XHRcdHJldHVybiBkdC50b0lTT1N0cmluZygpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiAoZHQpID09PSAnbnVtYmVyJykge1xyXG5cdFx0XHRcdHJldHVybiBuZXcgRGF0ZShkdCkudG9JU09TdHJpbmcoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmFzRGF0ZVRpbWUgPSBmdW5jdGlvbiBhc0RhdGVUaW1lKHByb3ApIHtcclxuXHRcdFx0aWYgKHR5cGVvZiAocHJvcCkgPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdFx0XHRyZXR1cm4geG1sRGF0ZVRpbWVUb0RhdGUocHJvcCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmV0dXJuIHByb3A7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0LypcclxuXHRcdFx0SW50ZXJuYWxseSB0aGUgbG9naWMgd29ya3MgaW4gYSBjeWNsZTpcclxuXHRcdFx0RE9NLT5KUyAtIGltcGxlbWVudGVkIGJ5IGN1c3RvbSBsb2dpYyAoZGVzZXJpYWxpemF0aW9uKS5cclxuXHRcdFx0SlMtPlhNTCAtIGltcGxlbWVudGVkIGJ5IGN1c3RvbSBsb2dpYyAoc2VyaWFsaXphdGlvbikuXHJcblx0XHRcdFhNTC0+RE9NIC0gaW1wbGVtZW50ZWQgYnkgYnJvd3Nlci5cclxuXHRcdCovXHJcblxyXG5cdFx0Ly8gVHJhbnNmb3JtbnMgYW4gWE1MIHN0cmluZyBpbnRvIERPTS10cmVlXHJcblx0XHR0aGlzLnhtbDJkb20gPSBmdW5jdGlvbiB4bWwyZG9tKHhtbCkge1xyXG5cdFx0XHRyZXR1cm4gcGFyc2VYbWwoeG1sKTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gVHJhbnNmb3JtcyBhIERPTSB0cmVlIHRvIEphdmFTY3JpcHQgb2JqZWN0cy5cclxuXHRcdHRoaXMuZG9tMmpzID0gZnVuY3Rpb24gZG9tMmpzKGRvbU5vZGUpIHtcclxuXHRcdFx0cmV0dXJuIGRlc2VyaWFsaXplRG9tQ2hpbGRyZW4oZG9tTm9kZSwgbnVsbCk7XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIFRyYW5zZm9ybXMgSmF2YVNjcmlwdCBvYmplY3RzIHRvIGEgRE9NIHRyZWUuXHJcblx0XHR0aGlzLmpzMmRvbSA9IGZ1bmN0aW9uIGpzMmRvbShqc09iamVjdCkge1xyXG5cdFx0XHR2YXIgeG1sID0gdGhpcy5qczJ4bWwoanNPYmplY3QpO1xyXG5cdFx0XHRyZXR1cm4gcGFyc2VYbWwoeG1sKTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gVHJhbnNmb3JtbnMgYW4gWE1MIHN0cmluZyBpbnRvIEphdmFTY3JpcHQgb2JqZWN0cy5cclxuXHRcdHRoaXMueG1sMmpzID0gZnVuY3Rpb24geG1sMmpzKHhtbCkge1xyXG5cdFx0XHR2YXIgZG9tTm9kZSA9IHBhcnNlWG1sKHhtbCk7XHJcblx0XHRcdGlmIChkb21Ob2RlICE9IG51bGwpXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuZG9tMmpzKGRvbU5vZGUpO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIFRyYW5zZm9ybXMgSmF2YVNjcmlwdCBvYmplY3RzIGludG8gYW4gWE1MIHN0cmluZy5cclxuXHRcdHRoaXMuanMyeG1sID0gZnVuY3Rpb24ganMyeG1sKGpzT2JqZWN0KSB7XHJcblx0XHRcdHJldHVybiBzZXJpYWxpemVKYXZhU2NyaXB0T2JqZWN0Q2hpbGRyZW4oanNPYmplY3QpO1xyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmdldFZlcnNpb24gPSBmdW5jdGlvbiBnZXRWZXJzaW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gVkVSU0lPTjtcclxuXHRcdH07XHJcblx0fTtcclxufSk7XHJcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdGxvYWRlZDogZmFsc2UsXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5ubWQgPSAobW9kdWxlKSA9PiB7XG5cdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdHJldHVybiBtb2R1bGU7XG59OyIsImV4cG9ydCAqIGZyb20gJy4vc3JjL2NvbnN0YW50cy92YXJpYWJsZXMuY29uc3RhbnRzJztcbmV4cG9ydCAqIGZyb20gJy4vc3JjL3V0aWwvdmFyaWFibGUvdmFyaWFibGVzLnV0aWxzJztcbmV4cG9ydCAqIGZyb20gJy4vc3JjL21vZGVsL2Jhc2UtYWN0aW9uJztcbmV4cG9ydCAqIGZyb20gJy4vc3JjL21vZGVsL3ZhcmlhYmxlL2FwaS1hd2FyZS12YXJpYWJsZSc7XG5leHBvcnQgKiBmcm9tICcuL3NyYy9tb2RlbC9hY3Rpb24vdGltZXItYWN0aW9uJztcbmV4cG9ydCAqIGZyb20gJy4vc3JjL21vZGVsL3ZhcmlhYmxlL21vZGVsLXZhcmlhYmxlJztcbmV4cG9ydCAqIGZyb20gJy4vc3JjL21vZGVsL3ZhcmlhYmxlL3NlcnZpY2UtdmFyaWFibGUnO1xuZXhwb3J0ICogZnJvbSAnLi9zcmMvbW9kZWwvdmFyaWFibGUvY3J1ZC12YXJpYWJsZSc7XG5leHBvcnQgKiBmcm9tICcuL3NyYy9tb2RlbC92YXJpYWJsZS9saXZlLXZhcmlhYmxlJztcbmV4cG9ydCAqIGZyb20gJy4vc3JjL3R5cGVzL2h0dHAtY2xpZW50LnNlcnZpY2UnO1xuZXhwb3J0ICogZnJvbSAnLi9zcmMvdXRpbC92YXJpYWJsZS9saXZlLXZhcmlhYmxlLmh0dHAudXRpbHMnO1xuZXhwb3J0ICogZnJvbSAnLi9zcmMvdXRpbC92YXJpYWJsZS9saXZlLXZhcmlhYmxlLnV0aWxzJztcblxuZXhwb3J0IGNvbnN0IFRFU1Q6IHN0cmluZyA9ICdoZWxsbyBmcm9tIHZhcmlhYmxlcyc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9
//# sourceMappingURL=index.js.map